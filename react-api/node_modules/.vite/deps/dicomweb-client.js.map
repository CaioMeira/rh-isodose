{
  "version": 3,
  "sources": ["../../dicomweb-client/src/message.js", "../../dicomweb-client/src/api.js", "../../dicomweb-client/src/utils.js", "../../dicomweb-client/src/version.js", "../../dicomweb-client/src/dicomweb-client.js"],
  "sourcesContent": ["/**\n * Converts a Uint8Array to a String.\n * @param {Uint8Array} array that should be converted\n * @param {Number} offset array offset in case only subset of array items should\n                   be extracted (default: 0)\n * @param {Number} limit maximum number of array items that should be extracted\n                   (defaults to length of array)\n * @returns {String}\n */\nfunction uint8ArrayToString(arr, offset = 0, limit) {\n  const itemLimit = limit || arr.length - offset;\n  let str = '';\n  for (let i = offset; i < offset + itemLimit; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n}\n\n/**\n * Converts a String to a Uint8Array.\n * @param {String} str string that should be converted\n * @returns {Uint8Array}\n */\nfunction stringToUint8Array(str) {\n  const arr = new Uint8Array(str.length);\n  for (let i = 0, j = str.length; i < j; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\n/**\n * Identifies the boundary in a multipart/related message header.\n * @param {String} header message header\n * @returns {String} boundary\n */\nfunction identifyBoundary(header) {\n  const parts = header.split('\\r\\n');\n\n  for (let i = 0; i < parts.length; i++) {\n    if (parts[i].substr(0, 2) === '--') {\n      return parts[i];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Checks whether a given token is contained by a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be present\n * @param {Number} offset offset in message content from where search should start\n * @returns {Boolean} whether message contains token at offset\n */\nfunction containsToken(message, token, offset = 0) {\n  if (offset + token.length > message.length) {\n    return false;\n  }\n\n  let index = offset;\n  for (let i = 0; i < token.length; i++) {\n    if (token[i] !== message[index]) {\n      return false;\n    }\n\n    index += 1;\n  }\n  return true;\n}\n\n/**\n * Finds a given token in a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be found\n * @param {String} offset message body offset from where search should start\n * @returns {Boolean} whether message has a part at given offset or not\n */\nfunction findToken(message, token, offset = 0, maxSearchLength) {\n  let searchLength = message.length;\n  if (maxSearchLength) {\n    searchLength = Math.min(offset + maxSearchLength, message.length);\n  }\n\n  for (let i = offset; i < searchLength; i++) {\n    // If the first value of the message matches\n    // the first value of the token, check if\n    // this is the full token.\n    if (message[i] === token[0]) {\n      if (containsToken(message, token, i)) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Create a random GUID\n *\n * @return {string}\n */\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;\n}\n\n/**\n * @typedef {Object} MultipartEncodedData\n * @property {ArrayBuffer} data The encoded Multipart Data\n * @property {String} boundary The boundary used to divide pieces of the encoded data\n */\n\n/**\n * Encode one or more DICOM datasets into a single body so it can be\n * sent using the Multipart Content-Type.\n *\n * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the\n                          multipart body, passed as ArrayBuffers.\n * @param {String} [boundary] Optional string to define a boundary between each part\n                              of the multipart body. If this is not specified, a random\n                              GUID will be generated.\n * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This\n                                  contains both the data itself, and the boundary string\n                                  used to divide it.\n */\nfunction multipartEncode(\n  datasets,\n  boundary = guid(),\n  contentType = 'application/dicom',\n) {\n  const contentTypeString = `Content-Type: ${contentType}`;\n  const header = `\\r\\n--${boundary}\\r\\n${contentTypeString}\\r\\n\\r\\n`;\n  const footer = `\\r\\n--${boundary}--`;\n  const headerArray = stringToUint8Array(header);\n  const footerArray = stringToUint8Array(footer);\n  const headerLength = headerArray.length;\n  const footerLength = footerArray.length;\n\n  let length = 0;\n\n  // Calculate the total length for the final array\n  const contentArrays = datasets.map(datasetBuffer => {\n    const contentArray = new Uint8Array(datasetBuffer);\n    const contentLength = contentArray.length;\n\n    length += headerLength + contentLength + footerLength;\n\n    return contentArray;\n  });\n\n  // Allocate the array\n  const multipartArray = new Uint8Array(length);\n\n  // Set the initial header\n  multipartArray.set(headerArray, 0);\n\n  // Write each dataset into the multipart array\n  let position = 0;\n  contentArrays.forEach(contentArray => {\n    multipartArray.set(headerArray, position);\n    multipartArray.set(contentArray, position + headerLength);\n\n    position += headerLength + contentArray.length;\n  });\n\n  multipartArray.set(footerArray, position);\n\n  return {\n    data: multipartArray.buffer,\n    boundary,\n  };\n}\n\n/**\n * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n *\n * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n * @returns {Array} The content\n */\nfunction multipartDecode(response) {\n  // Use the raw data if it is provided in an appropriate format\n  const message = ArrayBuffer.isView(response) ? response : new Uint8Array(response);\n\n  /* Set a maximum length to search for the header boundaries, otherwise\n       findToken can run for a long time\n    */\n  const maxSearchLength = 1000;\n\n  // First look for the multipart mime header\n  const separator = stringToUint8Array('\\r\\n\\r\\n');\n  const headerIndex = findToken(message, separator, 0, maxSearchLength);\n  if (headerIndex === -1) {\n    throw new Error('Response message has no multipart mime header');\n  }\n\n  const header = uint8ArrayToString(message, 0, headerIndex);\n  const boundaryString = identifyBoundary(header);\n  if (!boundaryString) {\n    throw new Error('Header of response message does not specify boundary');\n  }\n\n  const boundary = stringToUint8Array(boundaryString);\n  const boundaryLength = boundary.length;\n  const components = [];\n\n  let offset = boundaryLength;\n\n  // Loop until we cannot find any more boundaries\n  let boundaryIndex;\n\n  while (boundaryIndex !== -1) {\n    // Search for the next boundary in the message, starting\n    // from the current offset position\n    boundaryIndex = findToken(message, boundary, offset);\n\n    // If no further boundaries are found, stop here.\n    if (boundaryIndex === -1) {\n      break;\n    }\n\n    const headerTokenIndex = findToken(\n      message,\n      separator,\n      offset,\n      maxSearchLength,\n    );\n    if (headerTokenIndex === -1) {\n      throw new Error('Response message part has no mime header');\n    }\n    offset = headerTokenIndex + separator.length;\n\n    // Extract data from response message, excluding \"\\r\\n\"\n    const spacingLength = 2;\n    const data = response.slice(offset, boundaryIndex - spacingLength);\n\n    // Add the data to the array of results\n    components.push(data);\n\n    // Move the offset to the end of the current section,\n    // plus the identified boundary\n    offset = boundaryIndex + boundaryLength;\n  }\n\n  return components;\n}\n\nexport {\n  containsToken,\n  findToken,\n  identifyBoundary,\n  uint8ArrayToString,\n  stringToUint8Array,\n  multipartEncode,\n  multipartDecode,\n  guid,\n};\n", "import { multipartEncode, multipartDecode } from './message.js';\n\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n\nfunction isEmptyObject(obj) {\n  return Object.keys(obj).length === 0 && obj.constructor === Object;\n}\n\nfunction areValidRequestHooks(requestHooks) {\n  const isValid =\n    Array.isArray(requestHooks) &&\n    requestHooks.every(\n      requestHook =>\n        typeof requestHook === 'function' && requestHook.length === 2,\n    );\n\n  if (!isValid) {\n    console.warn(\n      'Request hooks should have the following signature: ' +\n        'function requestHook(request, metadata) { return request; }',\n    );\n  }\n\n  return isValid;\n}\n\nconst getFirstResult = result => result[0];\n\nconst MEDIATYPES = {\n  DICOM: 'application/dicom',\n  DICOM_JSON: 'application/dicom+json',\n  OCTET_STREAM: 'application/octet-stream',\n  PDF: 'application/pdf',\n  JPEG: 'image/jpeg',\n  PNG: 'image/png',\n};\n\n/**\n * debugLog is a function that can be called with console.log arguments, and will\n * be conditionally displayed, only when debug logging is enabled.\n */\nlet debugLog = () => {};\n\n/**\n * @typedef { import(\"../types/types\").InstanceMetadata } InstanceMetadata\n */\n\n/**\n * A callback with the request instance and metadata information\n * of the currently request being executed that should necessarily\n * return the given request optionally modified.\n * @typedef {function} RequestHook\n * @param {XMLHttpRequest} request - The original XMLHttpRequest instance.\n * @param {object} metadata - The metadata used by the request.\n */\n\n/**\n * Class for interacting with DICOMweb RESTful services.\n */\nclass DICOMwebClient {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {String} options.url - URL of the DICOMweb RESTful Service endpoint\n   * @param {String=} options.qidoURLPrefix - URL path prefix for QIDO-RS\n   * @param {String=} options.wadoURLPrefix - URL path prefix for WADO-RS\n   * @param {String=} options.stowURLPrefix - URL path prefix for STOW-RS\n   * @param {String=} options.username - Username\n   * @param {String=} options.password - Password\n   * @param {Object=} options.headers - HTTP headers\n   * @param {Array.<RequestHook>=} options.requestHooks - Request hooks.\n   * @param {Object=} options.verbose - print to console request warnings and errors, default true\n   * @param {Object=} options.debug - print to the console debug level information/status updates.\n   * @param {boolean|String} options.singlepart - retrieve singlepart for the named types.\n   * The available types are:  bulkdata, video, image.  true means all.\n   */\n  constructor(options) {\n    this.baseURL = options.url;\n    if (!this.baseURL) {\n      console.error('no DICOMweb base url provided - calls that require a URL will fail');\n    }\n\n    if ('username' in options) {\n      this.username = options.username;\n      if (!('password' in options)) {\n        console.error(\n          'no password provided to authenticate with DICOMweb service',\n        );\n      }\n      this.password = options.password;\n    }\n\n    if ('qidoURLPrefix' in options) {\n      debugLog(`use URL prefix for QIDO-RS: ${options.qidoURLPrefix}`);\n      this.qidoURL = `${this.baseURL}/${options.qidoURLPrefix}`;\n    } else {\n      this.qidoURL = this.baseURL;\n    }\n\n    if ('wadoURLPrefix' in options) {\n      debugLog(`use URL prefix for WADO-RS: ${options.wadoURLPrefix}`);\n      this.wadoURL = `${this.baseURL}/${options.wadoURLPrefix}`;\n    } else {\n      this.wadoURL = this.baseURL;\n    }\n\n    if ('stowURLPrefix' in options) {\n      debugLog(`use URL prefix for STOW-RS: ${options.stowURLPrefix}`);\n      this.stowURL = `${this.baseURL}/${options.stowURLPrefix}`;\n    } else {\n      this.stowURL = this.baseURL;\n    }\n\n    if (options.singlepart) {\n      debugLog('use singlepart', options.singlepart);\n      this.singlepart = options.singlepart === true ? 'bulkdata,video,image' : options.singlepart;\n    } else {\n      this.singlepart = '';\n    }\n\n    if ('requestHooks' in options) {\n      this.requestHooks = options.requestHooks;\n    }\n\n    // Headers to pass to requests.\n    this.headers = options.headers || {};\n\n    // Optional error interceptor callback to handle any failed request.\n    this.errorInterceptor = options.errorInterceptor || (() => undefined);\n\n    // Verbose - print to console request warnings and errors, default true\n    this.verbose = options.verbose !== false;\n\n    this.setDebug(options.debug);\n \n\n  }\n\n  /**\n   * Allows setting the debug log information. \n   * Note this is different from verbose in that verbose is whether to include warning/error information, defaulting to true\n   * \n   * @param {boolean} debugLevel \n   * @param {function} debugLogFunction to call with the debug output arguments. \n   */\n  setDebug(debugLevel = false, debugLogFunction = null) {\n    this.debugLevel = !!debugLevel;\n    debugLog = debugLogFunction || debugLevel ? console.log : () => {};\n  }\n\n  /**\n   * Gets debug flag\n   * \n   * @returns true if debug logging is enabled\n   */\n  getDebug() {\n    return this.debugLevel;\n  }\n \n  /**\n   * Sets verbose flag.\n   *\n   * @param {Boolean} verbose\n   */\n  setVerbose(verbose) {\n    this.verbose = verbose;\n  }\n\n  /**\n   * Gets verbose flag.\n   *\n   * @return {Boolean} verbose\n   */\n  getVerbose() {\n    return this.verbose;\n  }\n\n  static _parseQueryParameters(params = {}) {\n    let queryString = '?';\n    Object.keys(params).forEach((key, index) => {\n      if (index !== 0) {\n        queryString += '&';\n      }\n      queryString += `${key}=${encodeURIComponent(params[key])}`;\n    });\n    return queryString;\n  }\n\n  /**\n   * Performs an HTTP request.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @param {Object} headers\n   * @param {Object} options\n   * @param {Array.<RequestHook>} options.requestHooks - Request hooks.\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @return {*}\n   * @private\n   */\n  _httpRequest(url, method, headers = {}, options = {}) {\n    const { errorInterceptor, requestHooks } = this;\n\n    return new Promise((resolve, reject) => {\n      let request = options.request ? options.request : new XMLHttpRequest();\n\n      request.open(method, url, true);\n      if ('responseType' in options) {\n        request.responseType = options.responseType;\n      }\n\n      if (typeof headers === 'object') {\n        Object.keys(headers).forEach(key => {\n          request.setRequestHeader(key, headers[key]);\n        });\n      }\n\n      // now add custom headers from the user\n      // (e.g. access tokens)\n      const userHeaders = this.headers;\n      Object.keys(userHeaders).forEach(key => {\n        request.setRequestHeader(key, userHeaders[key]);\n      });\n\n      // Event triggered when upload starts\n      request.onloadstart = function onloadstart() {\n        debugLog('upload started: ', url)\n      };\n\n      // Event triggered when upload ends\n      request.onloadend = function onloadend() {\n        debugLog('upload finished')\n      };\n\n      // Handle response message\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          if (request.status === 200) {\n            const contentType = request.getResponseHeader('Content-Type');\n            // Automatically distinguishes between multipart and singlepart in an array buffer, and\n            // converts them into a consistent type.\n            if (contentType && contentType.indexOf('multipart') !== -1) {\n              resolve(multipartDecode(request.response));\n            } else if (request.responseType === 'arraybuffer') {\n              resolve([request.response]);\n            } else {\n              resolve(request.response);\n            }\n          } else if (request.status === 202) {\n            if (this.verbose) {\n              console.warn('some resources already existed: ', request);\n            }\n            resolve(request.response);\n          } else if (request.status === 204) {\n            if (this.verbose) {\n              console.warn('empty response for request: ', request);\n            }\n            resolve([]);\n          } else {\n            const error = new Error('request failed');\n            error.request = request;\n            error.response = request.response;\n            error.status = request.status;\n            if (this.verbose) {\n              console.error('request failed: ', request);\n              console.error(error);\n              console.error(error.response);\n            }\n\n            errorInterceptor(error);\n\n            reject(error);\n          }\n        }\n      };\n\n      // Event triggered while download progresses\n      if ('progressCallback' in options) {\n        if (typeof options.progressCallback === 'function') {\n          request.onprogress = options.progressCallback;\n        }\n      }\n\n      if (requestHooks && areValidRequestHooks(requestHooks)) {\n        const combinedHeaders = Object.assign({}, headers, this.headers);\n        const metadata = { method, url, headers: combinedHeaders };\n        const pipeRequestHooks = functions => args =>\n          functions.reduce((props, fn) => fn(props, metadata), args);\n        const pipedRequest = pipeRequestHooks(requestHooks);\n        request = pipedRequest(request);\n      }\n\n      // Add withCredentials to request if needed\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          request.withCredentials = true;\n        }\n      }\n\n      if ('data' in options) {\n        request.send(options.data);\n      } else {\n        request.send();\n      }\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request.\n   *\n   * @param {String} url\n   * @param {Object} headers\n   * @param {Object} responseType\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGet(url, headers, responseType, progressCallback, withCredentials) {\n    return this._httpRequest(url, 'get', headers, {\n      responseType,\n      progressCallback,\n      withCredentials,\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/json\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationJson(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.DICOM_JSON };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/pdf\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationPdf(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.PDF };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with an image\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetImage(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'image/',\n      'image/*',\n      'image/jpeg',\n      'image/jp2',\n      'image/gif',\n      'image/png',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a text\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetText(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'text/',\n      'text/*',\n      'text/html',\n      'text/plain',\n      'text/rtf',\n      'text/xml',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a video\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetVideo(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'video/',\n      'video/*',\n      'video/mpeg',\n      'video/mp4',\n      'video/H265',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Asserts that a given media type is valid.\n   *\n   * @params {String} mediaType media type\n   */\n  static _assertMediaTypeIsValid(mediaType) {\n    if (!mediaType) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const sepIndex = mediaType.indexOf('/');\n    if (sepIndex === -1) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const mediaTypeType = mediaType.slice(0, sepIndex);\n    const types = ['application', 'image', 'text', 'video'];\n    if (!types.includes(mediaTypeType)) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    if (mediaType.slice(sepIndex + 1).includes('/')) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with an image media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartImage(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'image/jpeg',\n        'image/gif',\n        'image/png',\n        'image/jp2',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with a video media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartVideo(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'video/',\n        'video/*',\n        'video/mpeg2',\n        'video/mp4',\n        'video/H265',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.4.100': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.101': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.102': ['video/mp4'],\n        '1.2.840.10008.1.2.4.103': ['video/mp4'],\n        '1.2.840.10008.1.2.4.104': ['video/mp4'],\n        '1.2.840.10008.1.2.4.105': ['video/mp4'],\n        '1.2.840.10008.1.2.4.106': ['video/mp4'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/dicom media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationDicom(\n    url,\n    mediaTypes,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/dicom';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [defaultMediaType],\n      '1.2.840.10008.1.2.5': [defaultMediaType],\n      '1.2.840.10008.1.2.4.50': [defaultMediaType],\n      '1.2.840.10008.1.2.4.51': [defaultMediaType],\n      '1.2.840.10008.1.2.4.57': [defaultMediaType],\n      '1.2.840.10008.1.2.4.70': [defaultMediaType],\n      '1.2.840.10008.1.2.4.80': [defaultMediaType],\n      '1.2.840.10008.1.2.4.81': [defaultMediaType],\n      '1.2.840.10008.1.2.4.90': [defaultMediaType],\n      '1.2.840.10008.1.2.4.91': [defaultMediaType],\n      '1.2.840.10008.1.2.4.92': [defaultMediaType],\n      '1.2.840.10008.1.2.4.93': [defaultMediaType],\n      '1.2.840.10008.1.2.4.100': [defaultMediaType],\n      '1.2.840.10008.1.2.4.101': [defaultMediaType],\n      '1.2.840.10008.1.2.4.102': [defaultMediaType],\n      '1.2.840.10008.1.2.4.103': [defaultMediaType],\n      '1.2.840.10008.1.2.4.104': [defaultMediaType],\n      '1.2.840.10008.1.2.4.105': [defaultMediaType],\n      '1.2.840.10008.1.2.4.106': [defaultMediaType],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/octet-stream, OR any of the equivalencies for that (eg\n   * application/pdf etc)\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationOctetStream(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/octet-stream';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [...Object.values(MEDIATYPES)],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    if (byteRange) {\n      headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n  }\n\n  /**\n   * Performs an HTTP POST request.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @param {Function} progressCallback\n   * @param {XMLHttpRequest} request - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPost(url, headers, data, progressCallback, withCredentials, request) {\n    return this._httpRequest(url, 'post', headers, {\n      data,\n      progressCallback,\n      withCredentials,\n      request,\n    });\n  }\n\n  /**\n   * Performs an HTTP POST request with content-type application/dicom+json.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPostApplicationJson(url, data, progressCallback, withCredentials) {\n    const headers = { 'Content-Type': MEDIATYPES.DICOM_JSON };\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Parses media type and extracts its type and subtype.\n   *\n   * @param {String} mediaType - HTTP media type (e.g. image/jpeg)\n   * @private\n   * @returns {String[]} Media type and subtype\n   */\n  static _parseMediaType(mediaType) {\n    DICOMwebClient._assertMediaTypeIsValid(mediaType);\n\n    return mediaType.split('/');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET request messages.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @return {*}\n   * @private\n   */\n  static _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    const fieldValueParts = mediaTypes.map(item => {\n      const { mediaType } = item;\n\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      if (!supportedMediaTypes.includes(mediaType)) {\n        throw new Error(\n          `Media type ${mediaType} is not supported for requested resource`,\n        );\n      }\n\n      return mediaType;\n    });\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET multipart request\n   * messages.  Will throw an exception if no media types are found which are acceptable,\n   * but will only log a verbose level message when types are specified which are\n   * not acceptable.  This allows requesting several types with having to know\n   * whether they are all acceptable or not.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @private\n   */\n  static _buildMultipartAcceptHeaderFieldValue(\n    mediaTypes,\n    supportedMediaTypes,\n  ) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    if (!Array.isArray(supportedMediaTypes) && !isObject(supportedMediaTypes)) {\n      throw new Error(\n        'Supported media types must be provided as an Array or an Object',\n      );\n    }\n\n    const fieldValueParts = [];\n\n    mediaTypes.forEach(item => {\n      const { transferSyntaxUID, mediaType } = item;\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      let fieldValue = `multipart/related; type=\"${mediaType}\"`;\n\n      if (isObject(supportedMediaTypes)) {\n        // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID\n        // to one or more Media Types\n        if (\n          !Object.values(supportedMediaTypes)\n            .flat(1)\n            .includes(mediaType)\n        ) {\n          if (!mediaType.endsWith('/*') || !mediaType.endsWith('/')) {\n            debugLog(\n              `Media type ${mediaType} is not supported for requested resource`,\n            );\n            return;\n          }\n        }\n\n        if (transferSyntaxUID) {\n          if (transferSyntaxUID !== '*') {\n            if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {\n              throw new Error(\n                `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n              );\n            }\n\n            const expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];\n\n            if (!expectedMediaTypes.includes(mediaType)) {\n              const actualType = DICOMwebClient._parseMediaType(mediaType)[0];\n              expectedMediaTypes.map(expectedMediaType => {\n                const expectedType = DICOMwebClient._parseMediaType(\n                  expectedMediaType,\n                )[0];\n                const haveSameType = actualType === expectedType;\n\n                if (\n                  haveSameType &&\n                  (mediaType.endsWith('/*') || mediaType.endsWith('/'))\n                ) {\n                  return;\n                }\n\n                throw new Error(\n                  `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n                );\n              });\n            }\n          }\n\n          fieldValue += `; transfer-syntax=${transferSyntaxUID}`;\n        }\n      } else if (\n        Array.isArray(supportedMediaTypes) &&\n        !supportedMediaTypes.includes(mediaType)\n      ) {\n        if( this.verbose ) {\n          console.warn(\n            `Media type ${mediaType} is not supported for requested resource`,\n          );\n        }\n        return;\n      }\n\n      fieldValueParts.push(fieldValue);\n    });\n\n    if( !fieldValueParts.length ) {\n      throw new Error(`No acceptable media types found among ${JSON.stringify(mediaTypes)}`);\n    }\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds a range header field value for HTTP GET request messages.\n   *\n   * @param {Array} byteRange - Start and end of byte range\n   * @returns {String} Range header field value\n   * @private\n   */\n  static _buildRangeHeaderFieldValue(byteRange = []) {\n    if (byteRange.length === 1) {\n      return `bytes=${byteRange[0]}-`;\n    }\n    if (byteRange.length === 2) {\n      return `bytes=${byteRange[0]}-${byteRange[1]}`;\n    }\n\n    return 'bytes=0-';\n  }\n\n  /**\n   * Gets types that are shared among acceptable media types.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Types that are shared among acceptable media types\n   */\n  static _getSharedMediaTypes(mediaTypes) {\n    const types = new Set();\n\n    if (!mediaTypes || !mediaTypes.length) {\n      return types;\n    }\n\n    mediaTypes.forEach(item => {\n      const { mediaType } = item;\n      const type = DICOMwebClient._parseMediaType(mediaType)[0];\n      types.add(`${type}/`);\n    });\n\n    return Array.from(types);\n  }\n\n  /**\n   * Gets common base type of acceptable media types and asserts that only\n   one type is specified. For example, ``(\"image/jpeg\", \"image/jp2\")``\n   will pass, but ``(\"image/jpeg\", \"video/mpeg2\")`` will raise an\n   exception.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Common media type, eg `image/` for the above example.\n   */\n  static _getCommonMediaType(mediaTypes) {\n    if (!mediaTypes || !mediaTypes.length) {\n      throw new Error('No acceptable media types provided');\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length === 0) {\n      throw new Error('No common acceptable media type could be identified.');\n    } else if (sharedMediaTypes.length > 1) {\n      throw new Error('Acceptable media types must have the same type.');\n    }\n\n    return sharedMediaTypes[0];\n  }\n\n  /**\n   * Searches for DICOM studies.\n   *\n   * @param {Object} options\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @return {Object[]} Study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n   */\n  searchForStudies(options = {}) {\n    debugLog('search for studies');\n    let withCredentials = false;\n    let url = `${this.qidoURL}/studies`;\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the study\n   */\n  retrieveStudyMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of study metadata',\n      );\n    }\n    debugLog(`retrieve metadata of study ${options.studyInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM series.\n   *\n   * @param {Object} options\n   * @param {Object} [options.studyInstanceUID] - Study Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n   */\n  searchForSeries(options = {}) {\n    let url = this.qidoURL;\n    if ('studyInstanceUID' in options) {\n      debugLog(`search series of study ${options.studyInstanceUID}`);\n      url += `/studies/${options.studyInstanceUID}`;\n    }\n    url += '/series';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the series\n   */\n  retrieveSeriesMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of series metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of series metadata',\n      );\n    }\n\n    debugLog(`retrieve metadata of series ${options.seriesInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {String} [options.seriesInstanceUID] - Series Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n   */\n  searchForInstances(options = {}) {\n    let url = this.qidoURL;\n    let withCredentials = false;\n    if ('studyInstanceUID' in options) {\n      url += `/studies/${options.studyInstanceUID}`;\n      if ('seriesInstanceUID' in options) {\n        debugLog(\n          `search for instances of series ${options.seriesInstanceUID}`,\n        );\n        url += `/series/${options.seriesInstanceUID}`;\n      } else {\n        debugLog(\n          `search for instances of study ${options.studyInstanceUID}`,\n        );\n      }\n    } else {\n      debugLog('search for instances');\n    }\n    url += '/instances';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /** Returns a WADO-URI URL for an instance\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {String} WADO-URI URL\n   */\n  buildInstanceWadoURIUrl(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required.');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required.');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required.');\n    }\n\n    const contentType = options.contentType || MEDIATYPES.DICOM;\n    const transferSyntax = options.transferSyntax || '*';\n    const params = [];\n\n    params.push('requestType=WADO');\n    params.push(`studyUID=${options.studyInstanceUID}`);\n    params.push(`seriesUID=${options.seriesInstanceUID}`);\n    params.push(`objectUID=${options.sopInstanceUID}`);\n    params.push(`contentType=${contentType}`);\n    params.push(`transferSyntax=${transferSyntax}`);\n\n    const paramString = params.join('&');\n\n    return `${this.wadoURL}?${paramString}`;\n  }\n\n  /**\n   * Retrieves metadata for a DICOM Instance.\n   *\n   * @param {Object} options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<InstanceMetadata>} metadata elements in DICOM JSON format\n   */\n  retrieveInstanceMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    debugLog(`retrieve metadata of instance ${options.sopInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves frames for a DICOM Instance.\n   * @param {Object} options options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @returns {Array} frame items as byte arrays of the pixel data element\n   */\n  retrieveInstanceFrames(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of instance frames',\n      );\n    }\n    debugLog(\n      `retrieve frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length > 1) {\n      /**\n       * Enable request of frames that are stored either compressed\n       * (image/* media type) or uncompressed (application/octet-stream\n       * media type).\n       */\n      const supportedMediaTypes = {\n        '1.2.840.10008.1.2.1': ['application/octet-stream'],\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n        '1.2.840.10008.1.2.4.201': ['image/jhc'],\n        '1.2.840.10008.1.2.4.202': ['image/jhc'],\n      };\n\n      const headers = {\n        Accept: DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n          mediaTypes,\n          supportedMediaTypes,\n        ),\n      };\n      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n    if (commonMediaType.startsWith('application')) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        mediaTypes,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetMultipartImage(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetMultipartVideo(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of frames.`,\n    );\n  }\n\n /**\n * Element in mediaTypes parameter\n * @typedef {Object} MediaType\n * @param {String} [MediaType.mediaType] - ie 'image/jpeg', 'image/png'...\n */\n\n  /**\n   * Retrieves an individual, server-side rendered DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Promise<ArrayBuffer>} Rendered DICOM Instance\n   */\n  retrieveInstanceRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('text')) {\n      return this._httpGetText(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType === MEDIATYPES.PDF) {\n      return this._httpGetApplicationPdf(\n        url,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves a thumbnail of an DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer} Thumbnail\n   */\n  retrieveInstanceThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves rendered frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    debugLog(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(url, headers, responseType, false, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves thumbnail of frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    console.debug(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<ArrayBuffer>} DICOM Part 10 file as Arraybuffer\n   */\n  retrieveInstance(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required');\n    }\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of instance.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {Function} options.progressCallback\n   * @returns {Promise<ArrayBuffer[]>} DICOM Instances\n   */\n  retrieveSeries(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of series.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {ArrayBuffer[]} DICOM Instances\n   */\n  retrieveStudy(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of study.`,\n    );\n  }\n\n  /**\n   * Retrieves and parses BulkData from a BulkDataURI location.\n   * Decodes the multipart encoded data and returns the resulting data\n   * as an ArrayBuffer.\n   *\n   * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n   *\n   * @param {Object} options\n   * @param {string} options.BulkDataURI to retrieve\n   * @param {Array}  options.mediaTypes to use to fetch the URI\n   * @param {string} options.byteRange to request a sub-range (only valid on single part)\n   * @returns {Promise<Array>} Bulkdata parts\n   */\n  retrieveBulkData(options) {\n    if (!('BulkDataURI' in options)) {\n      throw new Error('BulkDataURI is required.');\n    }\n\n    const url = options.BulkDataURI;\n    const { mediaTypes, byteRange } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (this.singlepart.indexOf('bulkdata') !== -1) {\n      return this._httpGet(url, options.headers, 'arraybuffer', null, withCredentials);\n    }\n\n    if (mediaTypes) {\n      try {\n        const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n        if (commonMediaType==='image/') {\n          return this._httpGetMultipartImage(\n            url,\n            mediaTypes,\n            byteRange,\n            false,\n            false,\n            progressCallback,\n            withCredentials,\n          );\n        }\n      } catch(e) {\n        // No-op - this happens sometimes if trying to fetch the specific desired type but want to fallback to octet-stream\n      }\n    }\n\n    // Just use the media types provided\n    return this._httpGetMultipartApplicationOctetStream(\n      url,\n      mediaTypes,\n      byteRange,\n      false,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Stores DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {ArrayBuffer[]} options.datasets - DICOM Instances in PS3.10 format\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @returns {Promise} Response message\n   */\n  storeInstances(options) {\n    if (!('datasets' in options)) {\n      throw new Error('datasets are required for storing');\n    }\n\n    let url = `${this.stowURL}/studies`;\n    if ('studyInstanceUID' in options) {\n      url += `/${options.studyInstanceUID}`;\n    }\n\n    const { data, boundary } = multipartEncode(options.datasets);\n    const headers = {\n      'Content-Type': `multipart/related; type=\"application/dicom\"; boundary=\"${boundary}\"`,\n    };\n    const { withCredentials = false } = options;\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      options.progressCallback,\n      withCredentials,\n      options.request,\n    );\n  }\n\n  \n}\n\n\nexport { DICOMwebClient };\nexport default DICOMwebClient;\n", "function findSubstring(str, before, after) {\n  const beforeIndex = str.lastIndexOf(before) + before.length;\n  if (beforeIndex < before.length) {\n    return null;\n  }\n  if (after !== undefined) {\n    const afterIndex = str.lastIndexOf(after);\n    if (afterIndex < 0) {\n      return null;\n    }\n    return str.substring(beforeIndex, afterIndex);\n  }\n  return str.substring(beforeIndex);\n}\n\nfunction getStudyInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, 'studies/', '/series');\n  if (!uid) {\n    uid = findSubstring(uri, 'studies/');\n  }\n  if (!uid) {\n    console.debug(\n      `Study Instance UID could not be dertermined from URI \"${uri}\"`,\n    );\n  }\n  return uid;\n}\n\nfunction getSeriesInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, 'series/', '/instances');\n  if (!uid) {\n    uid = findSubstring(uri, 'series/');\n  }\n  if (!uid) {\n    console.debug(\n      `Series Instance UID could not be dertermined from URI \"${uri}\"`,\n    );\n  }\n  return uid;\n}\n\nfunction getSOPInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, '/instances/', '/frames');\n  if (!uid) {\n    uid = findSubstring(uri, '/instances/', '/metadata');\n  }\n  if (!uid) {\n    uid = findSubstring(uri, '/instances/');\n  }\n  if (!uid) {\n    console.debug(`SOP Instance UID could not be dertermined from URI\"${uri}\"`);\n  }\n  return uid;\n}\n\n\nfunction getFrameNumbersFromUri(uri) {\n  let numbers = findSubstring(uri, '/frames/', '/rendered');\n  if (!numbers) {\n    numbers = findSubstring(uri, '/frames/');\n  }\n  if (numbers === undefined) {\n    console.debug(`Frame Numbers could not be dertermined from URI\"${uri}\"`);\n  }\n  return numbers.split(',');\n}\n\nexport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n};\n", "export default '0.5.2';\n", "import { DICOMwebClient } from './api.js';\nimport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n} from './utils.js';\n\nconst api = {\n  DICOMwebClient,\n};\nconst utils = {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n};\n\nexport { default as version } from './version.js';\n\nexport { api, utils };\n"],
  "mappings": "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",
  "names": ["uint8ArrayToString", "arr", "offset", "limit", "itemLimit", "length", "str", "i", "String", "fromCharCode", "stringToUint8Array", "Uint8Array", "j", "charCodeAt", "identifyBoundary", "header", "parts", "split", "substr", "containsToken", "message", "token", "index", "findToken", "maxSearchLength", "searchLength", "Math", "min", "guid", "s4", "floor", "random", "toString", "substring", "multipartEncode", "datasets", "boundary", "contentType", "contentTypeString", "footer", "headerArray", "footerArray", "headerLength", "footerLength", "contentArrays", "map", "datasetBuffer", "contentArray", "contentLength", "multipartArray", "set", "position", "forEach", "data", "buffer", "multipartDecode", "response", "ArrayBuffer", "isView", "separator", "headerIndex", "Error", "boundaryString", "boundaryLength", "components", "boundaryIndex", "headerTokenIndex", "spacingLength", "slice", "push", "isObject", "obj", "isEmptyObject", "Object", "keys", "constructor", "areValidRequestHooks", "requestHooks", "isValid", "Array", "isArray", "every", "requestHook", "console", "warn", "getFirstResult", "result", "MEDIATYPES", "DICOM", "DICOM_JSON", "OCTET_STREAM", "PDF", "JPEG", "PNG", "debugLog", "DICOMwebClient", "options", "baseURL", "url", "error", "username", "password", "qidoURLPrefix", "qidoURL", "wadoURLPrefix", "wadoURL", "stowURLPrefix", "stowURL", "singlepart", "headers", "errorInterceptor", "undefined", "verbose", "setDebug", "debug", "debugLevel", "debugLogFunction", "log", "method", "Promise", "resolve", "reject", "request", "XMLHttpRequest", "open", "responseType", "key", "setRequestHeader", "userHeaders", "onloadstart", "onloadend", "onreadystatechange", "readyState", "status", "getResponseHeader", "indexOf", "progressCallback", "onprogress", "combinedHeaders", "assign", "metadata", "pipeRequestHooks", "functions", "args", "reduce", "props", "fn", "pipedRequest", "withCredentials", "send", "_httpRequest", "params", "urlWithQueryParams", "_parseQueryParameters", "Accept", "_httpGet", "mediaTypes", "supportedMediaTypes", "acceptHeaderFieldValue", "_buildAcceptHeaderFieldValue", "byteRange", "rendered", "Range", "_buildRangeHeaderFieldValue", "_buildMultipartAcceptHeaderFieldValue", "defaultMediaType", "acceptableMediaTypes", "mediaType", "values", "_httpPost", "queryParams", "_httpGetApplicationJson", "studyInstanceUID", "seriesInstanceUID", "transferSyntax", "sopInstanceUID", "paramString", "join", "frameNumbers", "_httpGetMultipartApplicationOctetStream", "sharedMediaTypes", "_getSharedMediaTypes", "commonMediaType", "_getCommonMediaType", "startsWith", "_httpGetMultipartImage", "_httpGetMultipartVideo", "_httpGetImage", "_httpGetVideo", "_httpGetText", "_httpGetApplicationPdf", "_httpGetMultipartApplicationDicom", "then", "BulkDataURI", "e", "queryString", "encodeURIComponent", "sepIndex", "mediaTypeType", "types", "includes", "_assertMediaTypeIsValid", "fieldValueParts", "item", "transferSyntaxUID", "fieldValue", "flat", "endsWith", "expectedMediaTypes", "actualType", "_parseMediaType", "expectedMediaType", "expectedType", "haveSameType", "JSON", "stringify", "Set", "type", "add", "from", "findSubstring", "before", "after", "beforeIndex", "lastIndexOf", "afterIndex", "getStudyInstanceUIDFromUri", "uri", "uid", "getSeriesInstanceUIDFromUri", "getSOPInstanceUIDFromUri", "getFrameNumbersFromUri", "numbers", "api", "utils"]
}
