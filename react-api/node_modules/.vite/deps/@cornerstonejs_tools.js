import {
  BaseVolumeViewport_default,
  DataTypeByteSize,
  DesiredOutputPrecision,
  Settings,
  StackViewport_default,
  VideoViewport_default,
  VolumeViewport_default,
  VtkDataTypes,
  addImageSlicesToViewports_default,
  addVolumesToViewports_default,
  basis_default,
  cache_default,
  common_exports,
  constants_exports,
  convertMapperToNotSharedMapper,
  createVolumeActor_default,
  enums_exports,
  eventTarget_default,
  geometryLoader_exports,
  getEnabledElement,
  getEnabledElementByIds,
  getEnabledElementByViewportId,
  getEnabledElements,
  getRenderingEngine,
  getRenderingEngines,
  getWebWorkerManager,
  imageLoadPoolManager_default,
  imageLoader_exports,
  macro,
  mat4_exports,
  metaData_exports,
  quantize_default,
  quat_exports,
  triggerEvent,
  utilities_exports,
  vec2_exports,
  vec3_exports,
  vec4_exports,
  volumeLoader_exports,
  vtkActor$1,
  vtkCellArray$1,
  vtkColorTransferFunction$1,
  vtkCubeSource$1,
  vtkDataArray$1,
  vtkImageData$1,
  vtkMapper$1,
  vtkMath,
  vtkMatrixBuilder,
  vtkPiecewiseFunction$1,
  vtkPoints$1,
  vtkPolyData$1,
  vtkRenderer$1,
  vtkTexture$1,
  zip
} from "./chunk-RJWO4TE6.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/lodash.get/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.get/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray = Array.isArray;
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get3(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get3;
  }
});

// node_modules/@cornerstonejs/tools/dist/esm/types/index.js
var require_types = __commonJS({
  "node_modules/@cornerstonejs/tools/dist/esm/types/index.js"() {
  }
});

// node_modules/xmlbuilder2/lib/xmlbuilder2.min.js
var require_xmlbuilder2_min = __commonJS({
  "node_modules/xmlbuilder2/lib/xmlbuilder2.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.xmlbuilder2 = t() : e.xmlbuilder2 = t();
    }(exports, function() {
      return function(e) {
        var t = {};
        function r(n) {
          if (t[n]) return t[n].exports;
          var i = t[n] = { i: n, l: false, exports: {} };
          return e[n].call(i.exports, i, i.exports, r), i.l = true, i.exports;
        }
        return r.m = e, r.c = t, r.d = function(e2, t2, n) {
          r.o(e2, t2) || Object.defineProperty(e2, t2, { enumerable: true, get: n });
        }, r.r = function(e2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        }, r.t = function(e2, t2) {
          if (1 & t2 && (e2 = r(e2)), 8 & t2) return e2;
          if (4 & t2 && "object" == typeof e2 && e2 && e2.__esModule) return e2;
          var n = /* @__PURE__ */ Object.create(null);
          if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: e2 }), 2 & t2 && "string" != typeof e2) for (var i in e2) r.d(n, i, (function(t3) {
            return e2[t3];
          }).bind(null, i));
          return n;
        }, r.n = function(e2) {
          var t2 = e2 && e2.__esModule ? function() {
            return e2.default;
          } : function() {
            return e2;
          };
          return r.d(t2, "a", t2), t2;
        }, r.o = function(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }, r.p = "", r(r.s = 184);
      }([function(e, t, r) {
        "use strict";
        function n(e2) {
          for (var r2 in e2) t.hasOwnProperty(r2) || (t[r2] = e2[r2]);
        }
        Object.defineProperty(t, "__esModule", { value: true }), n(r(240)), n(r(251)), n(r(175)), n(r(107)), n(r(29)), n(r(73)), n(r(106)), n(r(30)), n(r(252)), n(r(52)), n(r(97)), n(r(253)), n(r(37)), n(r(51)), n(r(173)), n(r(176)), n(r(172)), n(r(108)), n(r(254)), n(r(255)), n(r(256)), n(r(72)), n(r(177)), n(r(105)), n(r(17)), n(r(257)), n(r(12)), n(r(174));
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(212);
        t.FixedSizeSet = i.FixedSizeSet;
        var o = r(213);
        t.ObjectCache = o.ObjectCache;
        var a = r(214);
        t.CompareCache = a.CompareCache;
        var s = r(215);
        t.Lazy = s.Lazy;
        var u = r(216);
        function l(e2, t2, r2) {
          if (m(e2)) e2.forEach(function(e3, n3) {
            return t2.call(r2, n3, e3);
          });
          else for (var n2 in e2) e2.hasOwnProperty(n2) && t2.call(r2, n2, e2[n2]);
        }
        function c(e2) {
          var t2, r2;
          if (h(e2)) return e2;
          if (f(e2)) {
            var i2 = [];
            try {
              for (var o2 = n(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var s2 = a2.value;
                i2.push(c(s2));
              }
            } catch (e3) {
              t2 = { error: e3 };
            } finally {
              try {
                a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
              } finally {
                if (t2) throw t2.error;
              }
            }
            return i2;
          }
          if (p(e2)) {
            i2 = {};
            for (var u2 in e2) if (e2.hasOwnProperty(u2)) {
              var l2 = e2[u2];
              i2[u2] = c(l2);
            }
            return i2;
          }
          return e2;
        }
        function h(e2) {
          return !!e2 && "[object Function]" === Object.prototype.toString.call(e2);
        }
        function p(e2) {
          var t2 = typeof e2;
          return !!e2 && ("function" === t2 || "object" === t2);
        }
        function f(e2) {
          return Array.isArray(e2);
        }
        function d(e2) {
          return e2 instanceof Set;
        }
        function m(e2) {
          return e2 instanceof Map;
        }
        function y(e2) {
          if (p(e2)) {
            var t2 = Object.getPrototypeOf(e2), r2 = t2.constructor;
            return t2 && r2 && "function" == typeof r2 && r2 instanceof r2 && Function.prototype.toString.call(r2) === Function.prototype.toString.call(Object);
          }
          return false;
        }
        t.StringWalker = u.StringWalker, t.applyMixin = function(e2, t2) {
          for (var r2 = [], n2 = 2; n2 < arguments.length; n2++) r2[n2 - 2] = arguments[n2];
          Object.getOwnPropertyNames(t2.prototype).forEach(function(n3) {
            if ("constructor" !== n3) {
              if (-1 !== r2.indexOf(n3)) {
                var i2 = Object.getOwnPropertyDescriptor(e2.prototype, n3);
                i2 && Object.defineProperty(e2.prototype, "_" + n3, i2);
              }
              var o2 = Object.getOwnPropertyDescriptor(t2.prototype, n3);
              o2 && Object.defineProperty(e2.prototype, n3, o2);
            }
          });
        }, t.applyDefaults = function e2(t2, r2, n2) {
          void 0 === n2 && (n2 = false);
          var i2 = c(t2 || {});
          return l(r2, function(t3, r3) {
            y(r3) ? i2[t3] = e2(i2[t3], r3, n2) : (n2 || void 0 === i2[t3]) && (i2[t3] = r3);
          }), i2;
        }, t.forEachArray = function(e2, t2, r2) {
          e2.forEach(t2, r2);
        }, t.forEachObject = l, t.arrayLength = function(e2) {
          return d(e2) ? e2.size : e2.length;
        }, t.objectLength = function(e2) {
          return m(e2) ? e2.size : Object.keys(e2).length;
        }, t.getObjectValue = function(e2, t2) {
          return m(e2) ? e2.get(t2) : e2[t2];
        }, t.removeObjectValue = function(e2, t2) {
          m(e2) ? e2.delete(t2) : delete e2[t2];
        }, t.clone = c, t.isBoolean = function(e2) {
          return "boolean" == typeof e2;
        }, t.isNumber = function(e2) {
          return "number" == typeof e2;
        }, t.isString = function(e2) {
          return "string" == typeof e2;
        }, t.isFunction = h, t.isObject = p, t.isArray = f, t.isSet = d, t.isMap = m, t.isEmpty = function(e2) {
          if (f(e2)) return !e2.length;
          if (d(e2)) return !e2.size;
          if (m(e2)) return !e2.size;
          if (p(e2)) {
            for (var t2 in e2) if (e2.hasOwnProperty(t2)) return false;
            return true;
          }
          return false;
        }, t.isPlainObject = y, t.isIterable = function(e2) {
          return e2 && "function" == typeof e2[Symbol.iterator];
        }, t.getValue = function(e2) {
          return h(e2.valueOf) ? e2.valueOf() : e2;
        }, t.utf8Encode = function(e2) {
          for (var t2 = new Uint8Array(4 * e2.length), r2 = 0, n2 = 0; n2 < e2.length; n2++) {
            var i2 = e2.charCodeAt(n2);
            if (i2 < 128) t2[r2++] = i2;
            else {
              if (i2 < 2048) t2[r2++] = i2 >> 6 | 192;
              else {
                if (i2 > 55295 && i2 < 56320) {
                  if (++n2 >= e2.length) throw new Error("Incomplete surrogate pair.");
                  var o2 = e2.charCodeAt(n2);
                  if (o2 < 56320 || o2 > 57343) throw new Error("Invalid surrogate character.");
                  i2 = 65536 + ((1023 & i2) << 10) + (1023 & o2), t2[r2++] = i2 >> 18 | 240, t2[r2++] = i2 >> 12 & 63 | 128;
                } else t2[r2++] = i2 >> 12 | 224;
                t2[r2++] = i2 >> 6 & 63 | 128;
              }
              t2[r2++] = 63 & i2 | 128;
            }
          }
          return t2.subarray(0, r2);
        }, t.utf8Decode = function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; ) {
            var n2 = e2[r2++];
            if (n2 > 127) if (n2 > 191 && n2 < 224) {
              if (r2 >= e2.length) throw new Error("Incomplete 2-byte sequence.");
              n2 = (31 & n2) << 6 | 63 & e2[r2++];
            } else if (n2 > 223 && n2 < 240) {
              if (r2 + 1 >= e2.length) throw new Error("Incomplete 3-byte sequence.");
              n2 = (15 & n2) << 12 | (63 & e2[r2++]) << 6 | 63 & e2[r2++];
            } else {
              if (!(n2 > 239 && n2 < 248)) throw new Error("Unknown multi-byte start.");
              if (r2 + 2 >= e2.length) throw new Error("Incomplete 4-byte sequence.");
              n2 = (7 & n2) << 18 | (63 & e2[r2++]) << 12 | (63 & e2[r2++]) << 6 | 63 & e2[r2++];
            }
            if (n2 <= 65535) t2 += String.fromCharCode(n2);
            else {
              if (!(n2 <= 1114111)) throw new Error("Code point exceeds UTF-16 limit.");
              n2 -= 65536, t2 += String.fromCharCode(n2 >> 10 | 55296), t2 += String.fromCharCode(1023 & n2 | 56320);
            }
          }
          return t2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), function(e2) {
          e2[e2.Before = 0] = "Before", e2[e2.Equal = 1] = "Equal", e2[e2.After = 2] = "After";
        }(t.BoundaryPosition || (t.BoundaryPosition = {})), function(e2) {
          e2[e2.None = 0] = "None", e2[e2.Capturing = 1] = "Capturing", e2[e2.AtTarget = 2] = "AtTarget", e2[e2.Bubbling = 3] = "Bubbling";
        }(t.EventPhase || (t.EventPhase = {})), function(e2) {
          e2[e2.Element = 1] = "Element", e2[e2.Attribute = 2] = "Attribute", e2[e2.Text = 3] = "Text", e2[e2.CData = 4] = "CData", e2[e2.EntityReference = 5] = "EntityReference", e2[e2.Entity = 6] = "Entity", e2[e2.ProcessingInstruction = 7] = "ProcessingInstruction", e2[e2.Comment = 8] = "Comment", e2[e2.Document = 9] = "Document", e2[e2.DocumentType = 10] = "DocumentType", e2[e2.DocumentFragment = 11] = "DocumentFragment", e2[e2.Notation = 12] = "Notation";
        }(t.NodeType || (t.NodeType = {})), function(e2) {
          e2[e2.Disconnected = 1] = "Disconnected", e2[e2.Preceding = 2] = "Preceding", e2[e2.Following = 4] = "Following", e2[e2.Contains = 8] = "Contains", e2[e2.ContainedBy = 16] = "ContainedBy", e2[e2.ImplementationSpecific = 32] = "ImplementationSpecific";
        }(t.Position || (t.Position = {})), function(e2) {
          e2[e2.Accept = 1] = "Accept", e2[e2.Reject = 2] = "Reject", e2[e2.Skip = 3] = "Skip";
        }(t.FilterResult || (t.FilterResult = {})), function(e2) {
          e2[e2.All = 4294967295] = "All", e2[e2.Element = 1] = "Element", e2[e2.Attribute = 2] = "Attribute", e2[e2.Text = 4] = "Text", e2[e2.CDataSection = 8] = "CDataSection", e2[e2.EntityReference = 16] = "EntityReference", e2[e2.Entity = 32] = "Entity", e2[e2.ProcessingInstruction = 64] = "ProcessingInstruction", e2[e2.Comment = 128] = "Comment", e2[e2.Document = 256] = "Document", e2[e2.DocumentType = 512] = "DocumentType", e2[e2.DocumentFragment = 1024] = "DocumentFragment", e2[e2.Notation = 2048] = "Notation";
        }(t.WhatToShow || (t.WhatToShow = {})), function(e2) {
          e2[e2.StartToStart = 0] = "StartToStart", e2[e2.StartToEnd = 1] = "StartToEnd", e2[e2.EndToEnd = 2] = "EndToEnd", e2[e2.EndToStart = 3] = "EndToStart";
        }(t.HowToCompare || (t.HowToCompare = {}));
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(241);
        t.Cast = n.Cast;
        var i = r(150);
        t.Guard = i.Guard;
        var o = r(242);
        t.EmptySet = o.EmptySet;
      }, function(e, t, r) {
        var n = r(11), i = r(55).f, o = r(21), a = r(25), s = r(80), u = r(119), l = r(123);
        e.exports = function(e2, t2) {
          var r2, c, h, p, f, d = e2.target, m = e2.global, y = e2.stat;
          if (r2 = m ? n : y ? n[d] || s(d, {}) : (n[d] || {}).prototype) for (c in t2) {
            if (p = t2[c], h = e2.noTargetGet ? (f = i(r2, c)) && f.value : r2[c], !l(m ? c : d + (y ? "." : "#") + c, e2.forced) && void 0 !== h) {
              if (typeof p == typeof h) continue;
              u(p, h);
            }
            (e2.sham || h && h.sham) && o(p, "sham", true), a(r2, c, p, e2);
          }
        };
      }, function(e, t, r) {
        var n = r(11), i = r(81), o = r(14), a = r(58), s = r(86), u = r(124), l = i("wks"), c = n.Symbol, h = u ? c : c && c.withoutSetter || a;
        e.exports = function(e2) {
          return o(l, e2) || (s && o(c, e2) ? l[e2] = c[e2] : l[e2] = h("Symbol." + e2)), l[e2];
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(1), i = r(29), o = function() {
          function e2() {
            this._features = { mutationObservers: true, customElements: true, slots: true, steps: true }, this._window = null, this._compareCache = new n.CompareCache(), this._rangeList = new n.FixedSizeSet();
          }
          return e2.prototype.setFeatures = function(e3) {
            if (void 0 === e3 && (e3 = true), n.isObject(e3)) for (var t2 in e3) this._features[t2] = e3[t2] || false;
            else for (var t2 in this._features) this._features[t2] = e3;
          }, Object.defineProperty(e2.prototype, "features", { get: function() {
            return this._features;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "window", { get: function() {
            return null === this._window && (this._window = i.create_window()), this._window;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "compareCache", { get: function() {
            return this._compareCache;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "rangeList", { get: function() {
            return this._rangeList;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2, "instance", { get: function() {
            return e2._instance || (e2._instance = new e2()), e2._instance;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.dom = o.instance;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var r2 in e2) Object.hasOwnProperty.call(e2, r2) && (t2[r2] = e2[r2]);
          return t2.default = e2, t2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = n(r(228));
        t.base64 = i;
        var o = n(r(146));
        t.byte = o;
        var a = n(r(147));
        t.byteSequence = a;
        var s = n(r(96));
        t.codePoint = s;
        var u = n(r(232));
        t.json = u;
        var l = n(r(233));
        t.list = l;
        var c = n(r(234));
        t.map = c;
        var h = n(r(235));
        t.namespace = h;
        var p = n(r(236));
        t.queue = p;
        var f = n(r(237));
        t.set = f;
        var d = n(r(238));
        t.stack = d;
        var m = n(r(239));
        t.string = m;
      }, function(e, t) {
        e.exports = function(e2) {
          try {
            return !!e2();
          } catch (e3) {
            return true;
          }
        };
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function(e2) {
          function t2(t3, r2) {
            void 0 === r2 && (r2 = "");
            var n2 = e2.call(this, r2) || this;
            return n2.name = t3, n2;
          }
          return i(t2, e2), t2;
        }(Error);
        t.DOMException = o;
        var a = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "DOMStringSizeError", t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.DOMStringSizeError = a;
        var s = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "WrongDocumentError", "The object is in the wrong document. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.WrongDocumentError = s;
        var u = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NoDataAllowedError", t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NoDataAllowedError = u;
        var l = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NoModificationAllowedError", "The object can not be modified. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NoModificationAllowedError = l;
        var c = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NotSupportedError", "The operation is not supported. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NotSupportedError = c;
        var h = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InUseAttributeError", t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InUseAttributeError = h;
        var p = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InvalidStateError", "The object is in an invalid state. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InvalidStateError = p;
        var f = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InvalidModificationError", "The object can not be modified in this way. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InvalidModificationError = f;
        var d = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NamespaceError", "The operation is not allowed by Namespaces in XML. [XMLNS] " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NamespaceError = d;
        var m = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InvalidAccessError", "The object does not support the operation or argument. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InvalidAccessError = m;
        var y = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "ValidationError", t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.ValidationError = y;
        var v = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "TypeMismatchError", t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.TypeMismatchError = v;
        var _ = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "SecurityError", "The operation is insecure. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.SecurityError = _;
        var g = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NetworkError", "A network error occurred. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NetworkError = g;
        var b = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "AbortError", "The operation was aborted. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.AbortError = b;
        var x = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "URLMismatchError", "The given URL does not match another URL. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.URLMismatchError = x;
        var w = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "QuotaExceededError", "The quota has been exceeded. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.QuotaExceededError = w;
        var E = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "TimeoutError", "The operation timed out. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.TimeoutError = E;
        var D = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InvalidNodeTypeError", "The supplied node is incorrect or has an incorrect ancestor for this operation. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InvalidNodeTypeError = D;
        var S = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "DataCloneError", "The object can not be cloned. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.DataCloneError = S;
        var C = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NotImplementedError", "The DOM method is not implemented by this module. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NotImplementedError = C;
        var A = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "HierarchyRequestError", "The operation would yield an incorrect node tree. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.HierarchyRequestError = A;
        var N = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NotFoundError", "The object can not be found here. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NotFoundError = N;
        var T = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "IndexSizeError", "The index is not in the allowed range. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.IndexSizeError = T;
        var O = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "SyntaxError", "The string did not match the expected pattern. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.SyntaxError = O;
        var F = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InvalidCharacterError", "The string contains invalid characters. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InvalidCharacterError = F;
      }, function(e, t, r) {
        "use strict";
        var n = r(53), i = ["kind", "resolve", "construct", "instanceOf", "predicate", "represent", "defaultStyle", "styleAliases"], o = ["scalar", "sequence", "mapping"];
        e.exports = function(e2, t2) {
          var r2, a;
          if (t2 = t2 || {}, Object.keys(t2).forEach(function(t3) {
            if (-1 === i.indexOf(t3)) throw new n('Unknown option "' + t3 + '" is met in definition of "' + e2 + '" YAML type.');
          }), this.tag = e2, this.kind = t2.kind || null, this.resolve = t2.resolve || function() {
            return true;
          }, this.construct = t2.construct || function(e3) {
            return e3;
          }, this.instanceOf = t2.instanceOf || null, this.predicate = t2.predicate || null, this.represent = t2.represent || null, this.defaultStyle = t2.defaultStyle || null, this.styleAliases = (r2 = t2.styleAliases || null, a = {}, null !== r2 && Object.keys(r2).forEach(function(e3) {
            r2[e3].forEach(function(t3) {
              a[String(t3)] = e3;
            });
          }), a), -1 === o.indexOf(this.kind)) throw new n('Unknown kind "' + this.kind + '" is specified for "' + e2 + '" YAML type.');
        };
      }, function(e, t, r) {
        (function(t2) {
          var r2 = function(e2) {
            return e2 && e2.Math == Math && e2;
          };
          e.exports = r2("object" == typeof globalThis && globalThis) || r2("object" == typeof window && window) || r2("object" == typeof self && self) || r2("object" == typeof t2 && t2) || Function("return this")();
        }).call(this, r(78));
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.idl_defineConst = function(e2, t2, r2) {
          Object.defineProperty(e2, t2, { writable: false, enumerable: true, configurable: false, value: r2 });
        };
      }, function(e, t) {
        e.exports = function(e2) {
          return "object" == typeof e2 ? null !== e2 : "function" == typeof e2;
        };
      }, function(e, t) {
        var r = {}.hasOwnProperty;
        e.exports = function(e2, t2) {
          return r.call(e2, t2);
        };
      }, function(e, t, r) {
        var n = r(16), i = r(115), o = r(18), a = r(56), s = Object.defineProperty;
        t.f = n ? s : function(e2, t2, r2) {
          if (o(e2), t2 = a(t2, true), o(r2), i) try {
            return s(e2, t2, r2);
          } catch (e3) {
          }
          if ("get" in r2 || "set" in r2) throw TypeError("Accessors not supported");
          return "value" in r2 && (e2[t2] = r2.value), e2;
        };
      }, function(e, t, r) {
        var n = r(8);
        e.exports = !n(function() {
          return 7 != Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1];
        });
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(3), o = r(2);
        function a(e2, t2, r2) {
          if (void 0 === r2 && (r2 = false), r2 && i.Guard.isElementNode(t2) && i.Guard.isShadowRoot(t2.shadowRoot) && t2.shadowRoot._firstChild) return t2.shadowRoot._firstChild;
          if (t2._firstChild) return t2._firstChild;
          if (t2 === e2) return null;
          if (t2._nextSibling) return t2._nextSibling;
          for (var n2 = t2._parent; n2 && n2 !== e2; ) {
            if (n2._nextSibling) return n2._nextSibling;
            n2 = n2._parent;
          }
          return null;
        }
        function s() {
          var e2;
          return (e2 = {})[Symbol.iterator] = function() {
            return { next: function() {
              return { done: true, value: null };
            } };
          }, e2;
        }
        function u(e2, t2, r2, n2) {
          void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false);
          for (var i2 = t2 ? e2 : a(e2, e2, r2); i2 && n2 && !n2(i2); ) i2 = a(e2, i2, r2);
          return i2;
        }
        function l(e2, t2, r2, n2, i2) {
          void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
          for (var o2 = a(e2, t2, n2); o2 && i2 && !i2(o2); ) o2 = a(e2, o2, n2);
          return o2;
        }
        function c(e2, t2, r2, n2) {
          var i2;
          return void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false), t2 || 0 !== e2._children.size ? ((i2 = {})[Symbol.iterator] = function() {
            var i3 = t2 ? e2 : a(e2, e2, r2);
            return { next: function() {
              for (; i3 && n2 && !n2(i3); ) i3 = a(e2, i3, r2);
              if (null === i3) return { done: true, value: null };
              var t3 = { done: false, value: i3 };
              return i3 = a(e2, i3, r2), t3;
            } };
          }, i2) : s();
        }
        function h(e2, t2, r2) {
          void 0 === t2 && (t2 = false);
          for (var n2 = t2 ? e2 : e2._parent; n2 && r2 && !r2(n2); ) n2 = n2._parent;
          return n2;
        }
        function p(e2, t2, r2, n2) {
          void 0 === r2 && (r2 = false);
          for (var i2 = t2._parent; i2 && n2 && !n2(i2); ) i2 = i2._parent;
          return i2;
        }
        function f(e2) {
          return i.Guard.isDocumentTypeNode(e2) ? 0 : i.Guard.isCharacterDataNode(e2) ? e2._data.length : e2._children.size;
        }
        function d(e2, t2) {
          if (void 0 === t2 && (t2 = false), t2) {
            var r2 = d(e2, false);
            return i.Guard.isShadowRoot(r2) ? d(r2._host, true) : r2;
          }
          return e2._parent ? d(e2._parent) : e2;
        }
        function m(e2, t2, r2, n2) {
          void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
          for (var o2 = r2 ? e2 : n2 && i.Guard.isShadowRoot(e2) ? e2._host : e2._parent; null !== o2; ) {
            if (o2 === t2) return true;
            o2 = n2 && i.Guard.isShadowRoot(o2) ? o2._host : o2._parent;
          }
          return false;
        }
        function y(e2) {
          for (var t2 = d(e2), r2 = 0, n2 = u(t2); null !== n2; ) {
            if (r2++, n2 === e2) return r2;
            n2 = l(t2, n2);
          }
          return -1;
        }
        t.tree_getFirstDescendantNode = u, t.tree_getNextDescendantNode = l, t.tree_getDescendantNodes = c, t.tree_getDescendantElements = function(e2, t2, r2, n2) {
          var o2;
          return void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false), t2 || 0 !== e2._children.size ? ((o2 = {})[Symbol.iterator] = function() {
            var o3 = c(e2, t2, r2, function(e3) {
              return i.Guard.isElementNode(e3);
            })[Symbol.iterator](), a2 = o3.next().value;
            return { next: function() {
              for (; a2 && n2 && !n2(a2); ) a2 = o3.next().value;
              if (null === a2) return { done: true, value: null };
              var e3 = { done: false, value: a2 };
              return a2 = o3.next().value, e3;
            } };
          }, o2) : s();
        }, t.tree_getSiblingNodes = function(e2, t2, r2) {
          var n2;
          return void 0 === t2 && (t2 = false), e2._parent && 0 !== e2._parent._children.size ? ((n2 = {})[Symbol.iterator] = function() {
            var n3 = e2._parent ? e2._parent._firstChild : null;
            return { next: function() {
              for (; n3 && (r2 && !r2(n3) || !t2 && n3 === e2); ) n3 = n3._nextSibling;
              if (null === n3) return { done: true, value: null };
              var i2 = { done: false, value: n3 };
              return n3 = n3._nextSibling, i2;
            } };
          }, n2) : s();
        }, t.tree_getFirstAncestorNode = h, t.tree_getNextAncestorNode = p, t.tree_getAncestorNodes = function(e2, t2, r2) {
          var n2;
          return void 0 === t2 && (t2 = false), t2 || e2._parent ? ((n2 = {})[Symbol.iterator] = function() {
            var n3 = h(e2, t2, r2);
            return { next: function() {
              if (null === n3) return { done: true, value: null };
              var e3 = { done: false, value: n3 };
              return n3 = p(0, n3, t2, r2), e3;
            } };
          }, n2) : s();
        }, t.tree_getCommonAncestor = function(e2, t2) {
          if (e2 === t2) return e2._parent;
          for (var r2 = [], n2 = [], i2 = h(e2, true); null !== i2; ) r2.push(i2), i2 = p(0, i2, true);
          for (var o2 = h(t2, true); null !== o2; ) n2.push(o2), o2 = p(0, o2, true);
          for (var a2 = r2.length, s2 = n2.length, u2 = null, l2 = Math.min(a2, s2); l2 > 0; l2--) {
            var c2 = r2[--a2];
            if (c2 !== n2[--s2]) break;
            u2 = c2;
          }
          return u2;
        }, t.tree_getFollowingNode = function(e2, t2) {
          if (t2._firstChild) return t2._firstChild;
          if (t2._nextSibling) return t2._nextSibling;
          for (; ; ) {
            var r2 = t2._parent;
            if (null === r2 || r2 === e2) return null;
            if (r2._nextSibling) return r2._nextSibling;
            t2 = r2;
          }
        }, t.tree_getPrecedingNode = function(e2, t2) {
          return t2 === e2 ? null : t2._previousSibling ? (t2 = t2._previousSibling)._lastChild ? t2._lastChild : t2 : t2._parent;
        }, t.tree_isConstrained = function e2(t2) {
          var r2, i2, a2, s2, u2, l2;
          switch (t2._nodeType) {
            case o.NodeType.Document:
              var c2 = false, h2 = false;
              try {
                for (var p2 = n(t2._children), f2 = p2.next(); !f2.done; f2 = p2.next()) {
                  switch (f2.value._nodeType) {
                    case o.NodeType.ProcessingInstruction:
                    case o.NodeType.Comment:
                      break;
                    case o.NodeType.DocumentType:
                      if (c2 || h2) return false;
                      c2 = true;
                      break;
                    case o.NodeType.Element:
                      if (h2) return false;
                      h2 = true;
                      break;
                    default:
                      return false;
                  }
                }
              } catch (e3) {
                r2 = { error: e3 };
              } finally {
                try {
                  f2 && !f2.done && (i2 = p2.return) && i2.call(p2);
                } finally {
                  if (r2) throw r2.error;
                }
              }
              break;
            case o.NodeType.DocumentFragment:
            case o.NodeType.Element:
              try {
                for (var d2 = n(t2._children), m2 = d2.next(); !m2.done; m2 = d2.next()) {
                  switch (m2.value._nodeType) {
                    case o.NodeType.Element:
                    case o.NodeType.Text:
                    case o.NodeType.ProcessingInstruction:
                    case o.NodeType.CData:
                    case o.NodeType.Comment:
                      break;
                    default:
                      return false;
                  }
                }
              } catch (e3) {
                a2 = { error: e3 };
              } finally {
                try {
                  m2 && !m2.done && (s2 = d2.return) && s2.call(d2);
                } finally {
                  if (a2) throw a2.error;
                }
              }
              break;
            case o.NodeType.DocumentType:
            case o.NodeType.Text:
            case o.NodeType.ProcessingInstruction:
            case o.NodeType.CData:
            case o.NodeType.Comment:
              return !t2.hasChildNodes();
          }
          try {
            for (var y2 = n(t2._children), v = y2.next(); !v.done; v = y2.next()) {
              if (!e2(v.value)) return false;
            }
          } catch (e3) {
            u2 = { error: e3 };
          } finally {
            try {
              v && !v.done && (l2 = y2.return) && l2.call(y2);
            } finally {
              if (u2) throw u2.error;
            }
          }
          return true;
        }, t.tree_nodeLength = f, t.tree_isEmpty = function(e2) {
          return 0 === f(e2);
        }, t.tree_rootNode = d, t.tree_isDescendantOf = function(e2, t2, r2, n2) {
          void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
          for (var i2 = u(e2, r2, n2); null !== i2; ) {
            if (i2 === t2) return true;
            i2 = l(e2, i2, r2, n2);
          }
          return false;
        }, t.tree_isAncestorOf = m, t.tree_isHostIncludingAncestorOf = function e2(t2, r2, n2) {
          if (void 0 === n2 && (n2 = false), m(t2, r2, n2)) return true;
          var o2 = d(t2);
          return !(!i.Guard.isDocumentFragmentNode(o2) || null === o2._host || !e2(o2._host, r2, n2));
        }, t.tree_isSiblingOf = function(e2, t2, r2) {
          return void 0 === r2 && (r2 = false), e2 !== t2 ? null !== e2._parent && e2._parent === t2._parent : !!r2;
        }, t.tree_isPreceding = function(e2, t2) {
          var r2 = y(e2), n2 = y(t2);
          return -1 !== r2 && -1 !== n2 && (d(e2) === d(t2) && n2 < r2);
        }, t.tree_isFollowing = function(e2, t2) {
          var r2 = y(e2), n2 = y(t2);
          return -1 !== r2 && -1 !== n2 && (d(e2) === d(t2) && n2 > r2);
        }, t.tree_isParentOf = function(e2, t2) {
          return e2._parent === t2;
        }, t.tree_isChildOf = function(e2, t2) {
          return t2._parent === e2;
        }, t.tree_previousSibling = function(e2) {
          return e2._previousSibling;
        }, t.tree_nextSibling = function(e2) {
          return e2._nextSibling;
        }, t.tree_firstChild = function(e2) {
          return e2._firstChild;
        }, t.tree_lastChild = function(e2) {
          return e2._lastChild;
        }, t.tree_treePosition = y, t.tree_index = function(e2) {
          for (var t2 = 0; null !== e2._previousSibling; ) t2++, e2 = e2._previousSibling;
          return t2;
        }, t.tree_retarget = function(e2, t2) {
          for (; ; ) {
            if (!e2 || !i.Guard.isNode(e2)) return e2;
            var r2 = d(e2);
            if (!i.Guard.isShadowRoot(r2)) return e2;
            if (t2 && i.Guard.isNode(t2) && m(r2, t2, true, true)) return e2;
            e2 = r2.host;
          }
        };
      }, function(e, t, r) {
        var n = r(13);
        e.exports = function(e2) {
          if (!n(e2)) throw TypeError(String(e2) + " is not an object");
          return e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(24), i = r(130), o = r(49), a = r(43), s = r(88), u = a.set, l = a.getterFor("Array Iterator");
        e.exports = s(Array, "Array", function(e2, t2) {
          u(this, { type: "Array Iterator", target: n(e2), index: 0, kind: t2 });
        }, function() {
          var e2 = l(this), t2 = e2.target, r2 = e2.kind, n2 = e2.index++;
          return !t2 || n2 >= t2.length ? (e2.target = void 0, { value: void 0, done: true }) : "keys" == r2 ? { value: n2, done: false } : "values" == r2 ? { value: t2[n2], done: false } : { value: [n2, t2[n2]], done: false };
        }, "values"), o.Arguments = o.Array, i("keys"), i("values"), i("entries");
      }, function(e, t, r) {
        var n = r(90), i = r(25), o = r(202);
        n || i(Object.prototype, "toString", o, { unsafe: true });
      }, function(e, t, r) {
        var n = r(16), i = r(15), o = r(40);
        e.exports = n ? function(e2, t2, r2) {
          return i.f(e2, t2, o(1, r2));
        } : function(e2, t2, r2) {
          return e2[t2] = r2, e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(137).charAt, i = r(43), o = r(88), a = i.set, s = i.getterFor("String Iterator");
        o(String, "String", function(e2) {
          a(this, { type: "String Iterator", string: String(e2), index: 0 });
        }, function() {
          var e2, t2 = s(this), r2 = t2.string, i2 = t2.index;
          return i2 >= r2.length ? { value: void 0, done: true } : (e2 = n(r2, i2), t2.index += e2.length, { value: e2, done: false });
        });
      }, function(e, t, r) {
        var n = r(11), i = r(203), o = r(19), a = r(21), s = r(5), u = s("iterator"), l = s("toStringTag"), c = o.values;
        for (var h in i) {
          var p = n[h], f = p && p.prototype;
          if (f) {
            if (f[u] !== c) try {
              a(f, u, c);
            } catch (e2) {
              f[u] = c;
            }
            if (f[l] || a(f, l, h), i[h]) {
              for (var d in o) if (f[d] !== o[d]) try {
                a(f, d, o[d]);
              } catch (e2) {
                f[d] = o[d];
              }
            }
          }
        }
      }, function(e, t, r) {
        var n = r(41), i = r(35);
        e.exports = function(e2) {
          return n(i(e2));
        };
      }, function(e, t, r) {
        var n = r(11), i = r(21), o = r(14), a = r(80), s = r(117), u = r(43), l = u.get, c = u.enforce, h = String(String).split("String");
        (e.exports = function(e2, t2, r2, s2) {
          var u2 = !!s2 && !!s2.unsafe, l2 = !!s2 && !!s2.enumerable, p = !!s2 && !!s2.noTargetGet;
          "function" == typeof r2 && ("string" != typeof t2 || o(r2, "name") || i(r2, "name", t2), c(r2).source = h.join("string" == typeof t2 ? t2 : "")), e2 !== n ? (u2 ? !p && e2[t2] && (l2 = true) : delete e2[t2], l2 ? e2[t2] = r2 : i(e2, t2, r2)) : l2 ? e2[t2] = r2 : a(t2, r2);
        })(Function.prototype, "toString", function() {
          return "function" == typeof this && l(this).source || s(this);
        });
      }, function(e, t, r) {
        var n = r(47), i = Math.min;
        e.exports = function(e2) {
          return e2 > 0 ? i(n(e2), 9007199254740991) : 0;
        };
      }, function(e, t, r) {
        var n = r(35);
        e.exports = function(e2) {
          return Object(n(e2));
        };
      }, function(e, t, r) {
        var n = r(16), i = r(8), o = r(14), a = Object.defineProperty, s = {}, u = function(e2) {
          throw e2;
        };
        e.exports = function(e2, t2) {
          if (o(s, e2)) return s[e2];
          t2 || (t2 = {});
          var r2 = [][e2], l = !!o(t2, "ACCESSORS") && t2.ACCESSORS, c = o(t2, 0) ? t2[0] : u, h = o(t2, 1) ? t2[1] : void 0;
          return s[e2] = !!r2 && !i(function() {
            if (l && !n) return true;
            var e3 = { length: -1 };
            l ? a(e3, 1, { enumerable: true, get: u }) : e3[1] = 1, r2.call(e3, c, h);
          });
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(148), i = r(149), o = r(151), a = r(98), s = r(153), u = r(154), l = r(155), c = r(99), h = r(100), p = r(156), f = r(157), d = r(101), m = r(158), y = r(159), v = r(160), _ = r(161), g = r(162), b = r(163), x = r(164), w = r(165), E = r(166), D = r(167), S = r(168), C = r(169), A = r(170);
        t.create_domImplementation = function(e2) {
          return n.DOMImplementationImpl._create(e2);
        }, t.create_window = function() {
          return i.WindowImpl._create();
        }, t.create_xmlDocument = function() {
          return new o.XMLDocumentImpl();
        }, t.create_document = function() {
          return new a.DocumentImpl();
        }, t.create_abortController = function() {
          return new s.AbortControllerImpl();
        }, t.create_abortSignal = function() {
          return u.AbortSignalImpl._create();
        }, t.create_documentType = function(e2, t2, r2, n2) {
          return l.DocumentTypeImpl._create(e2, t2, r2, n2);
        }, t.create_element = function(e2, t2, r2, n2) {
          return c.ElementImpl._create(e2, t2, r2, n2);
        }, t.create_htmlElement = function(e2, t2, r2, n2) {
          return c.ElementImpl._create(e2, t2, r2, n2);
        }, t.create_htmlUnknownElement = function(e2, t2, r2, n2) {
          return c.ElementImpl._create(e2, t2, r2, n2);
        }, t.create_documentFragment = function(e2) {
          return h.DocumentFragmentImpl._create(e2);
        }, t.create_shadowRoot = function(e2, t2) {
          return p.ShadowRootImpl._create(e2, t2);
        }, t.create_attr = function(e2, t2) {
          return f.AttrImpl._create(e2, t2);
        }, t.create_text = function(e2, t2) {
          return d.TextImpl._create(e2, t2);
        }, t.create_cdataSection = function(e2, t2) {
          return m.CDATASectionImpl._create(e2, t2);
        }, t.create_comment = function(e2, t2) {
          return y.CommentImpl._create(e2, t2);
        }, t.create_processingInstruction = function(e2, t2, r2) {
          return v.ProcessingInstructionImpl._create(e2, t2, r2);
        }, t.create_htmlCollection = function(e2, t2) {
          return void 0 === t2 && (t2 = function() {
            return true;
          }), _.HTMLCollectionImpl._create(e2, t2);
        }, t.create_nodeList = function(e2) {
          return g.NodeListImpl._create(e2);
        }, t.create_nodeListStatic = function(e2, t2) {
          return b.NodeListStaticImpl._create(e2, t2);
        }, t.create_namedNodeMap = function(e2) {
          return x.NamedNodeMapImpl._create(e2);
        }, t.create_range = function(e2, t2) {
          return w.RangeImpl._create(e2, t2);
        }, t.create_nodeIterator = function(e2, t2, r2) {
          return E.NodeIteratorImpl._create(e2, t2, r2);
        }, t.create_treeWalker = function(e2, t2) {
          return D.TreeWalkerImpl._create(e2, t2);
        }, t.create_nodeFilter = function() {
          return S.NodeFilterImpl._create();
        }, t.create_mutationRecord = function(e2, t2, r2, n2, i2, o2, a2, s2, u2) {
          return C.MutationRecordImpl._create(e2, t2, r2, n2, i2, o2, a2, s2, u2);
        }, t.create_domTokenList = function(e2, t2) {
          return A.DOMTokenListImpl._create(e2, t2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(17), a = r(3), s = r(72), u = /* @__PURE__ */ new Map();
        function l(e2, t2) {
          if (t2 !== e2._root && o.tree_isAncestorOf(e2._reference, t2, true)) {
            if (e2._pointerBeforeReference) for (; ; ) {
              var r2 = o.tree_getFollowingNode(e2._root, t2);
              if (null !== r2 && o.tree_isDescendantOf(e2._root, r2, true) && !o.tree_isDescendantOf(t2, r2, true)) return void (e2._reference = r2);
              if (null === r2) return void (e2._pointerBeforeReference = false);
            }
            if (null === t2._previousSibling) null !== t2._parent && (e2._reference = t2._parent);
            else {
              for (var n2 = t2._previousSibling, i2 = o.tree_getFirstDescendantNode(t2._previousSibling, true, false); null !== i2; ) null !== i2 && (n2 = i2), i2 = o.tree_getNextDescendantNode(t2._previousSibling, i2, true, false);
              e2._reference = n2;
            }
          }
        }
        function c(e2, t2, r2, n2, i2) {
          if (a.Guard.isSlot(e2) && "name" === t2 && null === i2) {
            if (n2 === r2) return;
            if (null === n2 && "" === r2) return;
            if ("" === n2 && null === r2) return;
            e2._name = null === n2 || "" === n2 ? "" : n2, s.shadowTree_assignSlotablesForATree(o.tree_rootNode(e2));
          }
        }
        function h(e2, t2, r2, n2, i2) {
          if (a.Guard.isSlotable(e2) && "slot" === t2 && null === i2) {
            if (n2 === r2) return;
            if (null === n2 && "" === r2) return;
            if ("" === n2 && null === r2) return;
            e2._name = null === n2 || "" === n2 ? "" : n2, s.shadowTree_isAssigned(e2) && s.shadowTree_assignSlotables(e2._assignedSlot), s.shadowTree_assignASlot(e2);
          }
        }
        function p(e2, t2, r2, n2) {
          "id" === t2 && null === n2 && (e2._uniqueIdentifier = r2 || void 0);
        }
        t.dom_runRemovingSteps = function(e2, t2) {
        }, t.dom_runCloningSteps = function(e2, t2, r2, n2) {
        }, t.dom_runAdoptingSteps = function(e2, t2) {
        }, t.dom_runAttributeChangeSteps = function(e2, t2, r2, o2, a2) {
          var s2, u2;
          i.dom.features.slots && (h.call(e2, e2, t2, r2, o2, a2), c.call(e2, e2, t2, r2, o2, a2)), p.call(e2, e2, t2, o2, a2);
          try {
            for (var l2 = n(e2._attributeChangeSteps), f = l2.next(); !f.done; f = l2.next()) {
              f.value.call(e2, e2, t2, r2, o2, a2);
            }
          } catch (e3) {
            s2 = { error: e3 };
          } finally {
            try {
              f && !f.done && (u2 = l2.return) && u2.call(l2);
            } finally {
              if (s2) throw s2.error;
            }
          }
        }, t.dom_runInsertionSteps = function(e2) {
        }, t.dom_runNodeIteratorPreRemovingSteps = function(e2, t2) {
          l.call(e2, e2, t2);
        }, t.dom_hasSupportedTokens = function(e2) {
          return u.has(e2);
        }, t.dom_getSupportedTokens = function(e2) {
          return u.get(e2) || /* @__PURE__ */ new Set();
        }, t.dom_runEventConstructingSteps = function(e2) {
        }, t.dom_runChildTextContentChangeSteps = function(e2) {
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(11), o = r(46), a = r(44), s = r(16), u = r(86), l = r(124), c = r(8), h = r(14), p = r(59), f = r(13), d = r(18), m = r(27), y = r(24), v = r(56), _ = r(40), g = r(60), b = r(61), x = r(82), w = r(190), E = r(85), D = r(55), S = r(15), C = r(79), A = r(21), N = r(25), T = r(81), O = r(57), F = r(45), k = r(58), P = r(5), I = r(125), L = r(126), M = r(62), B = r(43), j = r(36).forEach, R = O("hidden"), z = P("toPrimitive"), U = B.set, G = B.getterFor("Symbol"), X = Object.prototype, q = i.Symbol, W = o("JSON", "stringify"), H = D.f, J = S.f, Y = w.f, V = C.f, K = T("symbols"), $ = T("op-symbols"), Q = T("string-to-symbol-registry"), Z = T("symbol-to-string-registry"), ee = T("wks"), te2 = i.QObject, re = !te2 || !te2.prototype || !te2.prototype.findChild, ne = s && c(function() {
          return 7 != g(J({}, "a", { get: function() {
            return J(this, "a", { value: 7 }).a;
          } })).a;
        }) ? function(e2, t2, r2) {
          var n2 = H(X, t2);
          n2 && delete X[t2], J(e2, t2, r2), n2 && e2 !== X && J(X, t2, n2);
        } : J, ie = function(e2, t2) {
          var r2 = K[e2] = g(q.prototype);
          return U(r2, { type: "Symbol", tag: e2, description: t2 }), s || (r2.description = t2), r2;
        }, oe = l ? function(e2) {
          return "symbol" == typeof e2;
        } : function(e2) {
          return Object(e2) instanceof q;
        }, ae = function(e2, t2, r2) {
          e2 === X && ae($, t2, r2), d(e2);
          var n2 = v(t2, true);
          return d(r2), h(K, n2) ? (r2.enumerable ? (h(e2, R) && e2[R][n2] && (e2[R][n2] = false), r2 = g(r2, { enumerable: _(0, false) })) : (h(e2, R) || J(e2, R, _(1, {})), e2[R][n2] = true), ne(e2, n2, r2)) : J(e2, n2, r2);
        }, se = function(e2, t2) {
          d(e2);
          var r2 = y(t2), n2 = b(r2).concat(he(r2));
          return j(n2, function(t3) {
            s && !ue.call(r2, t3) || ae(e2, t3, r2[t3]);
          }), e2;
        }, ue = function(e2) {
          var t2 = v(e2, true), r2 = V.call(this, t2);
          return !(this === X && h(K, t2) && !h($, t2)) && (!(r2 || !h(this, t2) || !h(K, t2) || h(this, R) && this[R][t2]) || r2);
        }, le = function(e2, t2) {
          var r2 = y(e2), n2 = v(t2, true);
          if (r2 !== X || !h(K, n2) || h($, n2)) {
            var i2 = H(r2, n2);
            return !i2 || !h(K, n2) || h(r2, R) && r2[R][n2] || (i2.enumerable = true), i2;
          }
        }, ce = function(e2) {
          var t2 = Y(y(e2)), r2 = [];
          return j(t2, function(e3) {
            h(K, e3) || h(F, e3) || r2.push(e3);
          }), r2;
        }, he = function(e2) {
          var t2 = e2 === X, r2 = Y(t2 ? $ : y(e2)), n2 = [];
          return j(r2, function(e3) {
            !h(K, e3) || t2 && !h(X, e3) || n2.push(K[e3]);
          }), n2;
        };
        (u || (N((q = function() {
          if (this instanceof q) throw TypeError("Symbol is not a constructor");
          var e2 = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0, t2 = k(e2), r2 = function(e3) {
            this === X && r2.call($, e3), h(this, R) && h(this[R], t2) && (this[R][t2] = false), ne(this, t2, _(1, e3));
          };
          return s && re && ne(X, t2, { configurable: true, set: r2 }), ie(t2, e2);
        }).prototype, "toString", function() {
          return G(this).tag;
        }), N(q, "withoutSetter", function(e2) {
          return ie(k(e2), e2);
        }), C.f = ue, S.f = ae, D.f = le, x.f = w.f = ce, E.f = he, I.f = function(e2) {
          return ie(P(e2), e2);
        }, s && (J(q.prototype, "description", { configurable: true, get: function() {
          return G(this).description;
        } }), a || N(X, "propertyIsEnumerable", ue, { unsafe: true }))), n({ global: true, wrap: true, forced: !u, sham: !u }, { Symbol: q }), j(b(ee), function(e2) {
          L(e2);
        }), n({ target: "Symbol", stat: true, forced: !u }, { for: function(e2) {
          var t2 = String(e2);
          if (h(Q, t2)) return Q[t2];
          var r2 = q(t2);
          return Q[t2] = r2, Z[r2] = t2, r2;
        }, keyFor: function(e2) {
          if (!oe(e2)) throw TypeError(e2 + " is not a symbol");
          if (h(Z, e2)) return Z[e2];
        }, useSetter: function() {
          re = true;
        }, useSimple: function() {
          re = false;
        } }), n({ target: "Object", stat: true, forced: !u, sham: !s }, { create: function(e2, t2) {
          return void 0 === t2 ? g(e2) : se(g(e2), t2);
        }, defineProperty: ae, defineProperties: se, getOwnPropertyDescriptor: le }), n({ target: "Object", stat: true, forced: !u }, { getOwnPropertyNames: ce, getOwnPropertySymbols: he }), n({ target: "Object", stat: true, forced: c(function() {
          E.f(1);
        }) }, { getOwnPropertySymbols: function(e2) {
          return E.f(m(e2));
        } }), W) && n({ target: "JSON", stat: true, forced: !u || c(function() {
          var e2 = q();
          return "[null]" != W([e2]) || "{}" != W({ a: e2 }) || "{}" != W(Object(e2));
        }) }, { stringify: function(e2, t2, r2) {
          for (var n2, i2 = [e2], o2 = 1; arguments.length > o2; ) i2.push(arguments[o2++]);
          if (n2 = t2, (f(t2) || void 0 !== e2) && !oe(e2)) return p(t2) || (t2 = function(e3, t3) {
            if ("function" == typeof n2 && (t3 = n2.call(this, e3, t3)), !oe(t3)) return t3;
          }), i2[1] = t2, W.apply(null, i2);
        } });
        q.prototype[z] || A(q.prototype, z, q.prototype.valueOf), M(q, "Symbol"), F[R] = true;
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(16), o = r(11), a = r(14), s = r(13), u = r(15).f, l = r(119), c = o.Symbol;
        if (i && "function" == typeof c && (!("description" in c.prototype) || void 0 !== c().description)) {
          var h = {}, p = function() {
            var e2 = arguments.length < 1 || void 0 === arguments[0] ? void 0 : String(arguments[0]), t2 = this instanceof p ? new c(e2) : void 0 === e2 ? c() : c(e2);
            return "" === e2 && (h[t2] = true), t2;
          };
          l(p, c);
          var f = p.prototype = c.prototype;
          f.constructor = p;
          var d = f.toString, m = "Symbol(test)" == String(c("test")), y = /^Symbol\((.*)\)[^)]+$/;
          u(f, "description", { configurable: true, get: function() {
            var e2 = s(this) ? this.valueOf() : this, t2 = d.call(e2);
            if (a(h, e2)) return "";
            var r2 = m ? t2.slice(7, -1) : t2.replace(y, "$1");
            return "" === r2 ? void 0 : r2;
          } }), n({ global: true, forced: true }, { Symbol: p });
        }
      }, function(e, t, r) {
        r(126)("iterator");
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(6), s = r(2), u = r(70), l = r(3), c = r(9), h = r(0), p = r(152), f = r(12), d = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this;
            return t3._parent = null, t3._firstChild = null, t3._lastChild = null, t3._previousSibling = null, t3._nextSibling = null, t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "_childNodes", { get: function() {
            return this.__childNodes || (this.__childNodes = h.create_nodeList(this));
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "_nodeDocument", { get: function() {
            return this._nodeDocumentOverride || a.dom.window._associatedDocument;
          }, set: function(e3) {
            this._nodeDocumentOverride = e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "_registeredObserverList", { get: function() {
            return this.__registeredObserverList || (this.__registeredObserverList = []);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nodeType", { get: function() {
            return this._nodeType;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nodeName", { get: function() {
            return l.Guard.isElementNode(this) ? this._htmlUppercasedQualifiedName : l.Guard.isAttrNode(this) ? this._qualifiedName : l.Guard.isExclusiveTextNode(this) ? "#text" : l.Guard.isCDATASectionNode(this) ? "#cdata-section" : l.Guard.isProcessingInstructionNode(this) ? this._target : l.Guard.isCommentNode(this) ? "#comment" : l.Guard.isDocumentNode(this) ? "#document" : l.Guard.isDocumentTypeNode(this) ? this._name : l.Guard.isDocumentFragmentNode(this) ? "#document-fragment" : "";
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "baseURI", { get: function() {
            return p.urlSerializer(this._nodeDocument._URL);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "isConnected", { get: function() {
            return l.Guard.isElementNode(this) && h.shadowTree_isConnected(this);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "ownerDocument", { get: function() {
            return this._nodeType === s.NodeType.Document ? null : this._nodeDocument;
          }, enumerable: true, configurable: true }), t2.prototype.getRootNode = function(e3) {
            return h.tree_rootNode(this, !!e3 && e3.composed);
          }, Object.defineProperty(t2.prototype, "parentNode", { get: function() {
            return this._nodeType === s.NodeType.Attribute ? null : this._parent;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "parentElement", { get: function() {
            return this._parent && l.Guard.isElementNode(this._parent) ? this._parent : null;
          }, enumerable: true, configurable: true }), t2.prototype.hasChildNodes = function() {
            return null !== this._firstChild;
          }, Object.defineProperty(t2.prototype, "childNodes", { get: function() {
            return this._childNodes;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "firstChild", { get: function() {
            return this._firstChild;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "lastChild", { get: function() {
            return this._lastChild;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "previousSibling", { get: function() {
            return this._previousSibling;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nextSibling", { get: function() {
            return this._nextSibling;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nodeValue", { get: function() {
            return l.Guard.isAttrNode(this) ? this._value : l.Guard.isCharacterDataNode(this) ? this._data : null;
          }, set: function(e3) {
            null === e3 && (e3 = ""), l.Guard.isAttrNode(this) ? h.attr_setAnExistingAttributeValue(this, e3) : l.Guard.isCharacterDataNode(this) && h.characterData_replaceData(this, 0, this._data.length, e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "textContent", { get: function() {
            return l.Guard.isDocumentFragmentNode(this) || l.Guard.isElementNode(this) ? h.text_descendantTextContent(this) : l.Guard.isAttrNode(this) ? this._value : l.Guard.isCharacterDataNode(this) ? this._data : null;
          }, set: function(e3) {
            null === e3 && (e3 = ""), l.Guard.isDocumentFragmentNode(this) || l.Guard.isElementNode(this) ? h.node_stringReplaceAll(e3, this) : l.Guard.isAttrNode(this) ? h.attr_setAnExistingAttributeValue(this, e3) : l.Guard.isCharacterDataNode(this) && h.characterData_replaceData(this, 0, h.tree_nodeLength(this), e3);
          }, enumerable: true, configurable: true }), t2.prototype.normalize = function() {
            for (var e3, t3, r2, n2, i2 = [], s2 = h.tree_getFirstDescendantNode(this, false, false, function(e4) {
              return l.Guard.isExclusiveTextNode(e4);
            }); null !== s2; ) i2.push(s2), s2 = h.tree_getNextDescendantNode(this, s2, false, false, function(e4) {
              return l.Guard.isExclusiveTextNode(e4);
            });
            for (var u2 = 0; u2 < i2.length; u2++) {
              var c2 = i2[u2];
              if (null !== c2._parent) {
                var p2 = h.tree_nodeLength(c2);
                if (0 !== p2) {
                  var f2 = [], d2 = "";
                  try {
                    for (var m = (e3 = void 0, o(h.text_contiguousExclusiveTextNodes(c2))), y = m.next(); !y.done; y = m.next()) {
                      var v = y.value;
                      f2.push(v), d2 += v._data;
                    }
                  } catch (t4) {
                    e3 = { error: t4 };
                  } finally {
                    try {
                      y && !y.done && (t3 = m.return) && t3.call(m);
                    } finally {
                      if (e3) throw e3.error;
                    }
                  }
                  if (h.characterData_replaceData(c2, p2, 0, d2), 0 !== a.dom.rangeList.size) for (var _ = c2._nextSibling; null !== _ && l.Guard.isExclusiveTextNode(_); ) {
                    var g = _, b = h.tree_index(g);
                    try {
                      for (var x = (r2 = void 0, o(a.dom.rangeList)), w = x.next(); !w.done; w = x.next()) {
                        var E = w.value;
                        E._start[0] === g && (E._start[0] = c2, E._start[1] += p2), E._end[0] === g && (E._end[0] = c2, E._end[1] += p2), E._start[0] === g._parent && E._start[1] === b && (E._start[0] = c2, E._start[1] = p2), E._end[0] === g._parent && E._end[1] === b && (E._end[0] = c2, E._end[1] = p2);
                      }
                    } catch (e4) {
                      r2 = { error: e4 };
                    } finally {
                      try {
                        w && !w.done && (n2 = x.return) && n2.call(x);
                      } finally {
                        if (r2) throw r2.error;
                      }
                    }
                    p2 += h.tree_nodeLength(_), _ = _._nextSibling;
                  }
                  for (var D = 0; D < f2.length; D++) {
                    null !== (v = f2[D])._parent && h.mutation_remove(v, v._parent);
                  }
                } else h.mutation_remove(c2, c2._parent);
              }
            }
          }, t2.prototype.cloneNode = function(e3) {
            if (void 0 === e3 && (e3 = false), l.Guard.isShadowRoot(this)) throw new c.NotSupportedError();
            return h.node_clone(this, null, e3);
          }, t2.prototype.isEqualNode = function(e3) {
            return void 0 === e3 && (e3 = null), null !== e3 && h.node_equals(this, e3);
          }, t2.prototype.isSameNode = function(e3) {
            return void 0 === e3 && (e3 = null), this === e3;
          }, t2.prototype.compareDocumentPosition = function(e3) {
            if (e3 === this) return 0;
            var t3 = e3, r2 = this, n2 = null, i2 = null;
            if (l.Guard.isAttrNode(t3) && (t3 = (n2 = t3)._element), l.Guard.isAttrNode(r2) && (r2 = (i2 = r2)._element, n2 && t3 && t3 === r2)) for (var o2 = 0; o2 < r2._attributeList.length; o2++) {
              var u2 = r2._attributeList[o2];
              if (h.node_equals(u2, n2)) return s.Position.ImplementationSpecific | s.Position.Preceding;
              if (h.node_equals(u2, i2)) return s.Position.ImplementationSpecific | s.Position.Following;
            }
            return null === t3 || null === r2 || h.tree_rootNode(t3) !== h.tree_rootNode(r2) ? s.Position.Disconnected | s.Position.ImplementationSpecific | (a.dom.compareCache.check(this, e3) ? s.Position.Preceding : s.Position.Following) : !n2 && h.tree_isAncestorOf(r2, t3) || i2 && t3 === r2 ? s.Position.Contains | s.Position.Preceding : !i2 && h.tree_isDescendantOf(r2, t3) || n2 && t3 === r2 ? s.Position.ContainedBy | s.Position.Following : h.tree_isPreceding(r2, t3) ? s.Position.Preceding : s.Position.Following;
          }, t2.prototype.contains = function(e3) {
            return null !== e3 && h.tree_isDescendantOf(this, e3, true);
          }, t2.prototype.lookupPrefix = function(e3) {
            return e3 ? l.Guard.isElementNode(this) ? h.node_locateANamespacePrefix(this, e3) : l.Guard.isDocumentNode(this) ? null === this.documentElement ? null : h.node_locateANamespacePrefix(this.documentElement, e3) : l.Guard.isDocumentTypeNode(this) || l.Guard.isDocumentFragmentNode(this) ? null : l.Guard.isAttrNode(this) ? null === this._element ? null : h.node_locateANamespacePrefix(this._element, e3) : null !== this._parent && l.Guard.isElementNode(this._parent) ? h.node_locateANamespacePrefix(this._parent, e3) : null : null;
          }, t2.prototype.lookupNamespaceURI = function(e3) {
            return h.node_locateANamespace(this, e3 || null);
          }, t2.prototype.isDefaultNamespace = function(e3) {
            return e3 || (e3 = null), h.node_locateANamespace(this, null) === e3;
          }, t2.prototype.insertBefore = function(e3, t3) {
            return h.mutation_preInsert(e3, this, t3);
          }, t2.prototype.appendChild = function(e3) {
            return h.mutation_append(e3, this);
          }, t2.prototype.replaceChild = function(e3, t3) {
            return h.mutation_replace(t3, e3, this);
          }, t2.prototype.removeChild = function(e3) {
            return h.mutation_preRemove(e3, this);
          }, t2.prototype._getTheParent = function(e3) {
            return l.Guard.isSlotable(this) && h.shadowTree_isAssigned(this) ? this._assignedSlot : this._parent;
          }, t2.ELEMENT_NODE = 1, t2.ATTRIBUTE_NODE = 2, t2.TEXT_NODE = 3, t2.CDATA_SECTION_NODE = 4, t2.ENTITY_REFERENCE_NODE = 5, t2.ENTITY_NODE = 6, t2.PROCESSING_INSTRUCTION_NODE = 7, t2.COMMENT_NODE = 8, t2.DOCUMENT_NODE = 9, t2.DOCUMENT_TYPE_NODE = 10, t2.DOCUMENT_FRAGMENT_NODE = 11, t2.NOTATION_NODE = 12, t2.DOCUMENT_POSITION_DISCONNECTED = 1, t2.DOCUMENT_POSITION_PRECEDING = 2, t2.DOCUMENT_POSITION_FOLLOWING = 4, t2.DOCUMENT_POSITION_CONTAINS = 8, t2.DOCUMENT_POSITION_CONTAINED_BY = 16, t2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32, t2;
        }(u.EventTargetImpl);
        t.NodeImpl = d, d.prototype._children = new l.EmptySet(), f.idl_defineConst(d.prototype, "ELEMENT_NODE", 1), f.idl_defineConst(d.prototype, "ATTRIBUTE_NODE", 2), f.idl_defineConst(d.prototype, "TEXT_NODE", 3), f.idl_defineConst(d.prototype, "CDATA_SECTION_NODE", 4), f.idl_defineConst(d.prototype, "ENTITY_REFERENCE_NODE", 5), f.idl_defineConst(d.prototype, "ENTITY_NODE", 6), f.idl_defineConst(d.prototype, "PROCESSING_INSTRUCTION_NODE", 7), f.idl_defineConst(d.prototype, "COMMENT_NODE", 8), f.idl_defineConst(d.prototype, "DOCUMENT_NODE", 9), f.idl_defineConst(d.prototype, "DOCUMENT_TYPE_NODE", 10), f.idl_defineConst(d.prototype, "DOCUMENT_FRAGMENT_NODE", 11), f.idl_defineConst(d.prototype, "NOTATION_NODE", 12), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_DISCONNECTED", 1), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_PRECEDING", 2), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_FOLLOWING", 4), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_CONTAINS", 8), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_CONTAINED_BY", 16), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 32);
      }, function(e, t) {
        e.exports = function(e2) {
          if (null == e2) throw TypeError("Can't call method on " + e2);
          return e2;
        };
      }, function(e, t, r) {
        var n = r(87), i = r(41), o = r(27), a = r(26), s = r(128), u = [].push, l = function(e2) {
          var t2 = 1 == e2, r2 = 2 == e2, l2 = 3 == e2, c = 4 == e2, h = 6 == e2, p = 5 == e2 || h;
          return function(f, d, m, y) {
            for (var v, _, g = o(f), b = i(g), x = n(d, m, 3), w = a(b.length), E = 0, D = y || s, S = t2 ? D(f, w) : r2 ? D(f, 0) : void 0; w > E; E++) if ((p || E in b) && (_ = x(v = b[E], E, g), e2)) {
              if (t2) S[E] = _;
              else if (_) switch (e2) {
                case 3:
                  return true;
                case 5:
                  return v;
                case 6:
                  return E;
                case 2:
                  u.call(S, v);
              }
              else if (c) return false;
            }
            return h ? -1 : l2 || c ? c : S;
          };
        };
        e.exports = { forEach: l(0), map: l(1), filter: l(2), some: l(3), every: l(4), find: l(5), findIndex: l(6) };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++) e2 = e2.concat(i(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(6), s = r(9), u = r(2), l = r(3), c = r(1), h = r(7), p = r(73), f = r(17), d = r(172), m = r(72), y = r(51), v = r(30), _ = r(106);
        function g(e2, t2, r2) {
          var i2, o2, a2, l2, c2, h2, p2, d2, m2 = t2._nodeType, y2 = e2._nodeType, v2 = r2 ? r2._nodeType : null;
          if (m2 !== u.NodeType.Document && m2 !== u.NodeType.DocumentFragment && m2 !== u.NodeType.Element) throw new s.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + t2.nodeName + ".");
          if (f.tree_isHostIncludingAncestorOf(t2, e2, true)) throw new s.HierarchyRequestError("The node to be inserted cannot be an inclusive ancestor of parent node. Node is " + e2.nodeName + ", parent node is " + t2.nodeName + ".");
          if (null !== r2 && r2._parent !== t2) throw new s.NotFoundError("The reference child node cannot be found under parent node. Child node is " + r2.nodeName + ", parent node is " + t2.nodeName + ".");
          if (y2 !== u.NodeType.DocumentFragment && y2 !== u.NodeType.DocumentType && y2 !== u.NodeType.Element && y2 !== u.NodeType.Text && y2 !== u.NodeType.ProcessingInstruction && y2 !== u.NodeType.CData && y2 !== u.NodeType.Comment) throw new s.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + e2.nodeName + ".");
          if (y2 === u.NodeType.Text && m2 === u.NodeType.Document) throw new s.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + e2.nodeName + ".");
          if (y2 === u.NodeType.DocumentType && m2 !== u.NodeType.Document) throw new s.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + t2.nodeName + ".");
          if (m2 === u.NodeType.Document) {
            if (y2 === u.NodeType.DocumentFragment) {
              var _2 = 0;
              try {
                for (var g2 = n(e2._children), b3 = g2.next(); !b3.done; b3 = g2.next()) {
                  var x2 = b3.value;
                  if (x2._nodeType === u.NodeType.Element) _2++;
                  else if (x2._nodeType === u.NodeType.Text) throw new s.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + x2.nodeName + ".");
                }
              } catch (e3) {
                i2 = { error: e3 };
              } finally {
                try {
                  b3 && !b3.done && (o2 = g2.return) && o2.call(g2);
                } finally {
                  if (i2) throw i2.error;
                }
              }
              if (_2 > 1) throw new s.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + _2 + " element nodes.");
              if (1 === _2) {
                try {
                  for (var w2 = n(t2._children), E = w2.next(); !E.done; E = w2.next()) {
                    if (E.value._nodeType === u.NodeType.Element) throw new s.HierarchyRequestError("The document node already has a document element node.");
                  }
                } catch (e3) {
                  a2 = { error: e3 };
                } finally {
                  try {
                    E && !E.done && (l2 = w2.return) && l2.call(w2);
                  } finally {
                    if (a2) throw a2.error;
                  }
                }
                if (r2) {
                  if (v2 === u.NodeType.DocumentType) throw new s.HierarchyRequestError("Cannot insert an element node before a document type node.");
                  for (var D = r2._nextSibling; D; ) {
                    if (D._nodeType === u.NodeType.DocumentType) throw new s.HierarchyRequestError("Cannot insert an element node before a document type node.");
                    D = D._nextSibling;
                  }
                }
              }
            } else if (y2 === u.NodeType.Element) {
              try {
                for (var S = n(t2._children), C = S.next(); !C.done; C = S.next()) {
                  if (C.value._nodeType === u.NodeType.Element) throw new s.HierarchyRequestError("Document already has a document element node. Node is " + e2.nodeName + ".");
                }
              } catch (e3) {
                c2 = { error: e3 };
              } finally {
                try {
                  C && !C.done && (h2 = S.return) && h2.call(S);
                } finally {
                  if (c2) throw c2.error;
                }
              }
              if (r2) {
                if (v2 === u.NodeType.DocumentType) throw new s.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + e2.nodeName + ".");
                for (D = r2._nextSibling; D; ) {
                  if (D._nodeType === u.NodeType.DocumentType) throw new s.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + e2.nodeName + ".");
                  D = D._nextSibling;
                }
              }
            } else if (y2 === u.NodeType.DocumentType) {
              try {
                for (var A = n(t2._children), N = A.next(); !N.done; N = A.next()) {
                  if (N.value._nodeType === u.NodeType.DocumentType) throw new s.HierarchyRequestError("Document already has a document type node. Node is " + e2.nodeName + ".");
                }
              } catch (e3) {
                p2 = { error: e3 };
              } finally {
                try {
                  N && !N.done && (d2 = A.return) && d2.call(A);
                } finally {
                  if (p2) throw p2.error;
                }
              }
              if (r2) for (var T = r2._previousSibling; T; ) {
                if (T._nodeType === u.NodeType.Element) throw new s.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + e2.nodeName + ".");
                T = T._previousSibling;
              }
              else for (T = t2._firstChild; T; ) {
                if (T._nodeType === u.NodeType.Element) throw new s.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + e2.nodeName + ".");
                T = T._nextSibling;
              }
            }
          }
        }
        function b(e2, t2, r2) {
          g(e2, t2, r2);
          var n2 = r2;
          return n2 === e2 && (n2 = e2._nextSibling), _.document_adopt(e2, t2._nodeDocument), x(e2, t2, n2), e2;
        }
        function x(e2, t2, r2, i2) {
          var s2, d2;
          if (null !== r2 || e2._nodeType === u.NodeType.DocumentFragment) {
            var _2 = e2._nodeType === u.NodeType.DocumentFragment ? e2._children.size : 1;
            if (null !== r2 && 0 !== a.dom.rangeList.size) {
              var g2 = f.tree_index(r2);
              try {
                for (var b3 = n(a.dom.rangeList), x2 = b3.next(); !x2.done; x2 = b3.next()) {
                  var E = x2.value;
                  E._start[0] === t2 && E._start[1] > g2 && (E._start[1] += _2), E._end[0] === t2 && E._end[1] > g2 && (E._end[1] += _2);
                }
              } catch (e3) {
                s2 = { error: e3 };
              } finally {
                try {
                  x2 && !x2.done && (d2 = b3.return) && d2.call(b3);
                } finally {
                  if (s2) throw s2.error;
                }
              }
            }
            var D = e2._nodeType === u.NodeType.DocumentFragment ? new (Array.bind.apply(Array, o([void 0], e2._children)))() : [e2];
            if (e2._nodeType === u.NodeType.DocumentFragment) for (; e2._firstChild; ) w(e2._firstChild, e2, true);
            a.dom.features.mutationObservers && e2._nodeType === u.NodeType.DocumentFragment && y.observer_queueTreeMutationRecord(e2, [], D, null, null);
            for (var S = r2 ? r2._previousSibling : t2._lastChild, C = null === r2 ? -1 : f.tree_index(r2), A = 0; A < D.length; A++) {
              var N = D[A];
              if (l.Guard.isElementNode(N) && (l.Guard.isDocumentNode(t2) && (t2._documentElement = N), N._nodeDocument._hasNamespaces || null === N._namespace && null === N._namespacePrefix || (N._nodeDocument._hasNamespaces = true)), N._parent = t2, null === r2 ? h.set.append(t2._children, N) : (h.set.insert(t2._children, N, C), C++), null === t2._firstChild) N._previousSibling = null, N._nextSibling = null, t2._firstChild = N, t2._lastChild = N;
              else {
                var T = r2 ? r2._previousSibling : t2._lastChild, O = r2 || null;
                N._previousSibling = T, N._nextSibling = O, T && (T._nextSibling = N), O && (O._previousSibling = N), T || (t2._firstChild = N), O || (t2._lastChild = N);
              }
              a.dom.features.slots && null !== t2._shadowRoot && l.Guard.isSlotable(N) && m.shadowTree_assignASlot(N), a.dom.features.steps && l.Guard.isTextNode(N) && v.dom_runChildTextContentChangeSteps(t2), a.dom.features.slots && l.Guard.isShadowRoot(f.tree_rootNode(t2)) && l.Guard.isSlot(t2) && c.isEmpty(t2._assignedNodes) && m.shadowTree_signalASlotChange(t2), a.dom.features.slots && m.shadowTree_assignSlotablesForATree(f.tree_rootNode(N));
              for (var F = f.tree_getFirstDescendantNode(N, true, true); null !== F; ) a.dom.features.steps && v.dom_runInsertionSteps(F), a.dom.features.customElements && l.Guard.isElementNode(F) && m.shadowTree_isConnected(F) && (l.Guard.isCustomElementNode(F) ? p.customElement_enqueueACustomElementCallbackReaction(F, "connectedCallback", []) : p.customElement_tryToUpgrade(F)), F = f.tree_getNextDescendantNode(N, F, true, true);
            }
            a.dom.features.mutationObservers && (i2 || y.observer_queueTreeMutationRecord(t2, D, [], S, r2));
          } else !function(e3, t3, r3) {
            var n2 = t3._lastChild;
            l.Guard.isElementNode(e3) && (l.Guard.isDocumentNode(t3) && (t3._documentElement = e3), e3._nodeDocument._hasNamespaces || null === e3._namespace && null === e3._namespacePrefix || (e3._nodeDocument._hasNamespaces = true));
            if (e3._parent = t3, t3._children.add(e3), null === t3._firstChild) e3._previousSibling = null, e3._nextSibling = null, t3._firstChild = e3, t3._lastChild = e3;
            else {
              var i3 = t3._lastChild;
              e3._previousSibling = i3, e3._nextSibling = null, i3 && (i3._nextSibling = e3), i3 || (t3._firstChild = e3), t3._lastChild = e3;
            }
            a.dom.features.slots && null !== t3._shadowRoot && l.Guard.isSlotable(e3) && m.shadowTree_assignASlot(e3);
            a.dom.features.steps && l.Guard.isTextNode(e3) && v.dom_runChildTextContentChangeSteps(t3);
            a.dom.features.slots && l.Guard.isShadowRoot(f.tree_rootNode(t3)) && l.Guard.isSlot(t3) && c.isEmpty(t3._assignedNodes) && m.shadowTree_signalASlotChange(t3);
            a.dom.features.slots && m.shadowTree_assignSlotablesForATree(f.tree_rootNode(e3));
            a.dom.features.steps && v.dom_runInsertionSteps(e3);
            a.dom.features.customElements && l.Guard.isElementNode(e3) && m.shadowTree_isConnected(e3) && (l.Guard.isCustomElementNode(e3) ? p.customElement_enqueueACustomElementCallbackReaction(e3, "connectedCallback", []) : p.customElement_tryToUpgrade(e3));
            a.dom.features.mutationObservers && (r3 || y.observer_queueTreeMutationRecord(t3, [e3], [], n2, null));
          }(e2, t2, i2);
        }
        function w(e2, t2, r2) {
          var i2, o2, s2, u2, h2, _2, g2, b3;
          if (0 !== a.dom.rangeList.size) {
            var x2 = f.tree_index(e2);
            try {
              for (var w2 = n(a.dom.rangeList), E = w2.next(); !E.done; E = w2.next()) {
                var D = E.value;
                f.tree_isDescendantOf(e2, D._start[0], true) && (D._start = [t2, x2]), f.tree_isDescendantOf(e2, D._end[0], true) && (D._end = [t2, x2]), D._start[0] === t2 && D._start[1] > x2 && D._start[1]--, D._end[0] === t2 && D._end[1] > x2 && D._end[1]--;
              }
            } catch (e3) {
              i2 = { error: e3 };
            } finally {
              try {
                E && !E.done && (o2 = w2.return) && o2.call(w2);
              } finally {
                if (i2) throw i2.error;
              }
            }
            try {
              for (var S = n(a.dom.rangeList), C = S.next(); !C.done; C = S.next()) {
                (D = C.value)._start[0] === t2 && D._start[1] > x2 && (D._start[1] -= 1), D._end[0] === t2 && D._end[1] > x2 && (D._end[1] -= 1);
              }
            } catch (e3) {
              s2 = { error: e3 };
            } finally {
              try {
                C && !C.done && (u2 = S.return) && u2.call(S);
              } finally {
                if (s2) throw s2.error;
              }
            }
          }
          if (a.dom.features.steps) try {
            for (var A = n(d.nodeIterator_iteratorList()), N = A.next(); !N.done; N = A.next()) {
              var T = N.value;
              T._root._nodeDocument === e2._nodeDocument && v.dom_runNodeIteratorPreRemovingSteps(T, e2);
            }
          } catch (e3) {
            h2 = { error: e3 };
          } finally {
            try {
              N && !N.done && (_2 = A.return) && _2.call(A);
            } finally {
              if (h2) throw h2.error;
            }
          }
          var O = e2._previousSibling, F = e2._nextSibling;
          l.Guard.isDocumentNode(t2) && l.Guard.isElementNode(e2) && (t2._documentElement = null), e2._parent = null, t2._children.delete(e2);
          var k = e2._previousSibling, P = e2._nextSibling;
          (e2._previousSibling = null, e2._nextSibling = null, k && (k._nextSibling = P), P && (P._previousSibling = k), k || (t2._firstChild = P), P || (t2._lastChild = k), a.dom.features.slots && l.Guard.isSlotable(e2) && null !== e2._assignedSlot && m.shadowTree_isAssigned(e2) && m.shadowTree_assignSlotables(e2._assignedSlot), a.dom.features.slots && l.Guard.isShadowRoot(f.tree_rootNode(t2)) && l.Guard.isSlot(t2) && c.isEmpty(t2._assignedNodes) && m.shadowTree_signalASlotChange(t2), a.dom.features.slots) && (null !== f.tree_getFirstDescendantNode(e2, true, false, function(e3) {
            return l.Guard.isSlot(e3);
          }) && (m.shadowTree_assignSlotablesForATree(f.tree_rootNode(t2)), m.shadowTree_assignSlotablesForATree(e2)));
          a.dom.features.steps && v.dom_runRemovingSteps(e2, t2), a.dom.features.customElements && l.Guard.isCustomElementNode(e2) && p.customElement_enqueueACustomElementCallbackReaction(e2, "disconnectedCallback", []);
          for (var I = f.tree_getFirstDescendantNode(e2, false, true); null !== I; ) a.dom.features.steps && v.dom_runRemovingSteps(I, e2), a.dom.features.customElements && l.Guard.isCustomElementNode(I) && p.customElement_enqueueACustomElementCallbackReaction(I, "disconnectedCallback", []), I = f.tree_getNextDescendantNode(e2, I, false, true);
          if (a.dom.features.mutationObservers) for (var L = f.tree_getFirstAncestorNode(t2, true); null !== L; ) {
            try {
              for (var M = (g2 = void 0, n(L._registeredObserverList)), B = M.next(); !B.done; B = M.next()) {
                var j = B.value;
                j.options.subtree && e2._registeredObserverList.push({ observer: j.observer, options: j.options, source: j });
              }
            } catch (e3) {
              g2 = { error: e3 };
            } finally {
              try {
                B && !B.done && (b3 = M.return) && b3.call(M);
              } finally {
                if (g2) throw g2.error;
              }
            }
            L = f.tree_getNextAncestorNode(t2, L, true);
          }
          a.dom.features.mutationObservers && (r2 || y.observer_queueTreeMutationRecord(t2, [], [e2], O, F)), a.dom.features.steps && l.Guard.isTextNode(e2) && v.dom_runChildTextContentChangeSteps(t2);
        }
        t.mutation_ensurePreInsertionValidity = g, t.mutation_preInsert = b, t.mutation_insert = x, t.mutation_append = function(e2, t2) {
          return b(e2, t2, null);
        }, t.mutation_replace = function(e2, t2, r2) {
          var i2, o2, l2, c2, h2, p2, d2, m2;
          if (r2._nodeType !== u.NodeType.Document && r2._nodeType !== u.NodeType.DocumentFragment && r2._nodeType !== u.NodeType.Element) throw new s.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + r2.nodeName + ".");
          if (f.tree_isHostIncludingAncestorOf(r2, t2, true)) throw new s.HierarchyRequestError("The node to be inserted cannot be an ancestor of parent node. Node is " + t2.nodeName + ", parent node is " + r2.nodeName + ".");
          if (e2._parent !== r2) throw new s.NotFoundError("The reference child node cannot be found under parent node. Child node is " + e2.nodeName + ", parent node is " + r2.nodeName + ".");
          if (t2._nodeType !== u.NodeType.DocumentFragment && t2._nodeType !== u.NodeType.DocumentType && t2._nodeType !== u.NodeType.Element && t2._nodeType !== u.NodeType.Text && t2._nodeType !== u.NodeType.ProcessingInstruction && t2._nodeType !== u.NodeType.CData && t2._nodeType !== u.NodeType.Comment) throw new s.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + t2.nodeName + ".");
          if (t2._nodeType === u.NodeType.Text && r2._nodeType === u.NodeType.Document) throw new s.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + t2.nodeName + ".");
          if (t2._nodeType === u.NodeType.DocumentType && r2._nodeType !== u.NodeType.Document) throw new s.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + r2.nodeName + ".");
          if (r2._nodeType === u.NodeType.Document) {
            if (t2._nodeType === u.NodeType.DocumentFragment) {
              var v2 = 0;
              try {
                for (var g2 = n(t2._children), b3 = g2.next(); !b3.done; b3 = g2.next()) {
                  var E = b3.value;
                  if (E._nodeType === u.NodeType.Element) v2++;
                  else if (E._nodeType === u.NodeType.Text) throw new s.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + E.nodeName + ".");
                }
              } catch (e3) {
                i2 = { error: e3 };
              } finally {
                try {
                  b3 && !b3.done && (o2 = g2.return) && o2.call(g2);
                } finally {
                  if (i2) throw i2.error;
                }
              }
              if (v2 > 1) throw new s.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + v2 + " element nodes.");
              if (1 === v2) {
                try {
                  for (var D = n(r2._children), S = D.next(); !S.done; S = D.next()) {
                    if ((F = S.value)._nodeType === u.NodeType.Element && F !== e2) throw new s.HierarchyRequestError("The document node already has a document element node.");
                  }
                } catch (e3) {
                  l2 = { error: e3 };
                } finally {
                  try {
                    S && !S.done && (c2 = D.return) && c2.call(D);
                  } finally {
                    if (l2) throw l2.error;
                  }
                }
                for (var C = e2._nextSibling; C; ) {
                  if (C._nodeType === u.NodeType.DocumentType) throw new s.HierarchyRequestError("Cannot insert an element node before a document type node.");
                  C = C._nextSibling;
                }
              }
            } else if (t2._nodeType === u.NodeType.Element) {
              try {
                for (var A = n(r2._children), N = A.next(); !N.done; N = A.next()) {
                  if ((F = N.value)._nodeType === u.NodeType.Element && F !== e2) throw new s.HierarchyRequestError("Document already has a document element node. Node is " + t2.nodeName + ".");
                }
              } catch (e3) {
                h2 = { error: e3 };
              } finally {
                try {
                  N && !N.done && (p2 = A.return) && p2.call(A);
                } finally {
                  if (h2) throw h2.error;
                }
              }
              for (C = e2._nextSibling; C; ) {
                if (C._nodeType === u.NodeType.DocumentType) throw new s.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + t2.nodeName + ".");
                C = C._nextSibling;
              }
            } else if (t2._nodeType === u.NodeType.DocumentType) {
              try {
                for (var T = n(r2._children), O = T.next(); !O.done; O = T.next()) {
                  var F;
                  if ((F = O.value)._nodeType === u.NodeType.DocumentType && F !== e2) throw new s.HierarchyRequestError("Document already has a document type node. Node is " + t2.nodeName + ".");
                }
              } catch (e3) {
                d2 = { error: e3 };
              } finally {
                try {
                  O && !O.done && (m2 = T.return) && m2.call(T);
                } finally {
                  if (d2) throw d2.error;
                }
              }
              for (var k = e2._previousSibling; k; ) {
                if (k._nodeType === u.NodeType.Element) throw new s.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + t2.nodeName + ".");
                k = k._previousSibling;
              }
            }
          }
          var P = e2._nextSibling;
          P === t2 && (P = t2._nextSibling);
          var I = e2._previousSibling;
          _.document_adopt(t2, r2._nodeDocument);
          var L = [];
          null !== e2._parent && (L.push(e2), w(e2, e2._parent, true));
          var M = [];
          return t2._nodeType === u.NodeType.DocumentFragment ? M = Array.from(t2._children) : M.push(t2), x(t2, r2, P, true), a.dom.features.mutationObservers && y.observer_queueTreeMutationRecord(r2, M, L, I, P), e2;
        }, t.mutation_replaceAll = function(e2, t2) {
          var r2, i2;
          null !== e2 && _.document_adopt(e2, t2._nodeDocument);
          var o2 = Array.from(t2._children), s2 = [];
          e2 && e2._nodeType === u.NodeType.DocumentFragment ? s2 = Array.from(e2._children) : null !== e2 && s2.push(e2);
          try {
            for (var l2 = n(o2), c2 = l2.next(); !c2.done; c2 = l2.next()) {
              w(c2.value, t2, true);
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              c2 && !c2.done && (i2 = l2.return) && i2.call(l2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          null !== e2 && x(e2, t2, null, true), a.dom.features.mutationObservers && y.observer_queueTreeMutationRecord(t2, s2, o2, null, null);
        }, t.mutation_preRemove = function(e2, t2) {
          if (e2._parent !== t2) throw new s.NotFoundError("The child node cannot be found under parent node. Child node is " + e2.nodeName + ", parent node is " + t2.nodeName + ".");
          return w(e2, t2), e2;
        }, t.mutation_remove = w;
      }, function(e, t, r) {
        "use strict";
        function n(e2) {
          return null == e2;
        }
        e.exports.isNothing = n, e.exports.isObject = function(e2) {
          return "object" == typeof e2 && null !== e2;
        }, e.exports.toArray = function(e2) {
          return Array.isArray(e2) ? e2 : n(e2) ? [] : [e2];
        }, e.exports.repeat = function(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2 += 1) n2 += e2;
          return n2;
        }, e.exports.isNegativeZero = function(e2) {
          return 0 === e2 && Number.NEGATIVE_INFINITY === 1 / e2;
        }, e.exports.extend = function(e2, t2) {
          var r2, n2, i, o;
          if (t2) for (r2 = 0, n2 = (o = Object.keys(t2)).length; r2 < n2; r2 += 1) e2[i = o[r2]] = t2[i];
          return e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(38), i = r(53), o = r(10);
        function a(e2, t2, r2) {
          var n2 = [];
          return e2.include.forEach(function(e3) {
            r2 = a(e3, t2, r2);
          }), e2[t2].forEach(function(e3) {
            r2.forEach(function(t3, r3) {
              t3.tag === e3.tag && t3.kind === e3.kind && n2.push(r3);
            }), r2.push(e3);
          }), r2.filter(function(e3, t3) {
            return -1 === n2.indexOf(t3);
          });
        }
        function s(e2) {
          this.include = e2.include || [], this.implicit = e2.implicit || [], this.explicit = e2.explicit || [], this.implicit.forEach(function(e3) {
            if (e3.loadKind && "scalar" !== e3.loadKind) throw new i("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
          }), this.compiledImplicit = a(this, "implicit", []), this.compiledExplicit = a(this, "explicit", []), this.compiledTypeMap = function() {
            var e3, t2, r2 = { scalar: {}, sequence: {}, mapping: {}, fallback: {} };
            function n2(e4) {
              r2[e4.kind][e4.tag] = r2.fallback[e4.tag] = e4;
            }
            for (e3 = 0, t2 = arguments.length; e3 < t2; e3 += 1) arguments[e3].forEach(n2);
            return r2;
          }(this.compiledImplicit, this.compiledExplicit);
        }
        s.DEFAULT = null, s.create = function() {
          var e2, t2;
          switch (arguments.length) {
            case 1:
              e2 = s.DEFAULT, t2 = arguments[0];
              break;
            case 2:
              e2 = arguments[0], t2 = arguments[1];
              break;
            default:
              throw new i("Wrong number of arguments for Schema.create function");
          }
          if (e2 = n.toArray(e2), t2 = n.toArray(t2), !e2.every(function(e3) {
            return e3 instanceof s;
          })) throw new i("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
          if (!t2.every(function(e3) {
            return e3 instanceof o;
          })) throw new i("Specified list of YAML types (or a single Type object) contains a non-Type object.");
          return new s({ include: e2, explicit: t2 });
        }, e.exports = s;
      }, function(e, t) {
        e.exports = function(e2, t2) {
          return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
        };
      }, function(e, t, r) {
        var n = r(8), i = r(42), o = "".split;
        e.exports = n(function() {
          return !Object("z").propertyIsEnumerable(0);
        }) ? function(e2) {
          return "String" == i(e2) ? o.call(e2, "") : Object(e2);
        } : Object;
      }, function(e, t) {
        var r = {}.toString;
        e.exports = function(e2) {
          return r.call(e2).slice(8, -1);
        };
      }, function(e, t, r) {
        var n, i, o, a = r(186), s = r(11), u = r(13), l = r(21), c = r(14), h = r(57), p = r(45), f = s.WeakMap;
        if (a) {
          var d = new f(), m = d.get, y = d.has, v = d.set;
          n = function(e2, t2) {
            return v.call(d, e2, t2), t2;
          }, i = function(e2) {
            return m.call(d, e2) || {};
          }, o = function(e2) {
            return y.call(d, e2);
          };
        } else {
          var _ = h("state");
          p[_] = true, n = function(e2, t2) {
            return l(e2, _, t2), t2;
          }, i = function(e2) {
            return c(e2, _) ? e2[_] : {};
          }, o = function(e2) {
            return c(e2, _);
          };
        }
        e.exports = { set: n, get: i, has: o, enforce: function(e2) {
          return o(e2) ? i(e2) : n(e2, {});
        }, getterFor: function(e2) {
          return function(t2) {
            var r2;
            if (!u(t2) || (r2 = i(t2)).type !== e2) throw TypeError("Incompatible receiver, " + e2 + " required");
            return r2;
          };
        } };
      }, function(e, t) {
        e.exports = false;
      }, function(e, t) {
        e.exports = {};
      }, function(e, t, r) {
        var n = r(120), i = r(11), o = function(e2) {
          return "function" == typeof e2 ? e2 : void 0;
        };
        e.exports = function(e2, t2) {
          return arguments.length < 2 ? o(n[e2]) || o(i[e2]) : n[e2] && n[e2][t2] || i[e2] && i[e2][t2];
        };
      }, function(e, t) {
        var r = Math.ceil, n = Math.floor;
        e.exports = function(e2) {
          return isNaN(e2 = +e2) ? 0 : (e2 > 0 ? n : r)(e2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(8);
        e.exports = function(e2, t2) {
          var r2 = [][e2];
          return !!r2 && n(function() {
            r2.call(null, t2 || function() {
              throw 1;
            }, 1);
          });
        };
      }, function(e, t) {
        e.exports = {};
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(220), r(64), r(19), r(65), r(20), r(68), r(66), r(92), r(144), r(22), r(94), r(23);
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++) e2 = e2.concat(i(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(2), s = r(69), u = r(95), l = r(7), c = r(0), h = function() {
          function e2(e3) {
            this.level = 0, this._builderOptions = e3;
          }
          return e2.prototype.declaration = function(e3, t2, r2) {
          }, e2.prototype.docType = function(e3, t2, r2) {
          }, e2.prototype.comment = function(e3) {
          }, e2.prototype.text = function(e3) {
          }, e2.prototype.instruction = function(e3, t2) {
          }, e2.prototype.cdata = function(e3) {
          }, e2.prototype.openTagBegin = function(e3) {
          }, e2.prototype.openTagEnd = function(e3, t2, r2) {
          }, e2.prototype.closeTag = function(e3) {
          }, e2.prototype.attributes = function(e3) {
            var t2, r2;
            try {
              for (var i2 = n(e3), o2 = i2.next(); !o2.done; o2 = i2.next()) {
                var a2 = o2.value;
                this.attribute(null === a2[1] ? a2[2] : a2[1] + ":" + a2[2], a2[3]);
              }
            } catch (e4) {
              t2 = { error: e4 };
            } finally {
              try {
                o2 && !o2.done && (r2 = i2.return) && r2.call(i2);
              } finally {
                if (t2) throw t2.error;
              }
            }
          }, e2.prototype.attribute = function(e3, t2) {
          }, e2.prototype.beginElement = function(e3) {
          }, e2.prototype.endElement = function(e3) {
          }, e2.prototype.serializeNode = function(e3, t2) {
            var r2 = void 0 !== e3._nodeDocument && e3._nodeDocument._hasNamespaces;
            if (this.level = 0, this.currentNode = e3, r2) {
              var n2 = new u.NamespacePrefixMap();
              n2.set("xml", l.namespace.XML);
              this._serializeNodeNS(e3, null, n2, { value: 1 }, t2);
            } else this._serializeNode(e3, t2);
          }, e2.prototype._serializeNodeNS = function(e3, t2, r2, n2, i2) {
            switch (this.currentNode = e3, e3.nodeType) {
              case a.NodeType.Element:
                this._serializeElementNS(e3, t2, r2, n2, i2);
                break;
              case a.NodeType.Document:
                this._serializeDocumentNS(e3, t2, r2, n2, i2);
                break;
              case a.NodeType.Comment:
                this._serializeComment(e3, i2);
                break;
              case a.NodeType.Text:
                this._serializeText(e3, i2);
                break;
              case a.NodeType.DocumentFragment:
                this._serializeDocumentFragmentNS(e3, t2, r2, n2, i2);
                break;
              case a.NodeType.DocumentType:
                this._serializeDocumentType(e3, i2);
                break;
              case a.NodeType.ProcessingInstruction:
                this._serializeProcessingInstruction(e3, i2);
                break;
              case a.NodeType.CData:
                this._serializeCData(e3, i2);
                break;
              default:
                throw new Error("Unknown node type: " + e3.nodeType);
            }
          }, e2.prototype._serializeNode = function(e3, t2) {
            switch (this.currentNode = e3, e3.nodeType) {
              case a.NodeType.Element:
                this._serializeElement(e3, t2);
                break;
              case a.NodeType.Document:
                this._serializeDocument(e3, t2);
                break;
              case a.NodeType.Comment:
                this._serializeComment(e3, t2);
                break;
              case a.NodeType.Text:
                this._serializeText(e3, t2);
                break;
              case a.NodeType.DocumentFragment:
                this._serializeDocumentFragment(e3, t2);
                break;
              case a.NodeType.DocumentType:
                this._serializeDocumentType(e3, t2);
                break;
              case a.NodeType.ProcessingInstruction:
                this._serializeProcessingInstruction(e3, t2);
                break;
              case a.NodeType.CData:
                this._serializeCData(e3, t2);
                break;
              default:
                throw new Error("Unknown node type: " + e3.nodeType);
            }
          }, e2.prototype._serializeElementNS = function(t2, r2, i2, a2, s2) {
            var u2, h2, p = [];
            if (s2 && (-1 !== t2.localName.indexOf(":") || !c.xml_isName(t2.localName))) throw new Error("Node local name contains invalid characters (well-formed required).");
            var f = "", d = false, m = false, y = i2.copy(), v = {}, _ = this._recordNamespaceInformation(t2, y, v), g = r2, b = t2.namespaceURI;
            if (g === b) null !== _ && (m = true), f = b === l.namespace.XML ? "xml:" + t2.localName : t2.localName, this.beginElement(f), this.openTagBegin(f);
            else {
              var x = t2.prefix, w = null;
              if (null === x && b === _ || (w = y.get(x, b)), "xmlns" === x) {
                if (s2) throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
                w = x;
              }
              null !== w ? (f = w + ":" + t2.localName, null !== _ && _ !== l.namespace.XML && (g = _ || null), this.beginElement(f), this.openTagBegin(f)) : null !== x ? (x in v && (x = this._generatePrefix(b, y, a2)), y.set(x, b), f += x + ":" + t2.localName, this.beginElement(f), this.openTagBegin(f), p.push([null, "xmlns", x, this._serializeAttributeValue(b, s2)]), null !== _ && (g = _ || null)) : null === _ || null !== _ && _ !== b ? (m = true, f += t2.localName, g = b, this.beginElement(f), this.openTagBegin(f), p.push([null, null, "xmlns", this._serializeAttributeValue(b, s2)])) : (f += t2.localName, g = b, this.beginElement(f), this.openTagBegin(f));
            }
            p.push.apply(p, o(this._serializeAttributesNS(t2, y, a2, v, m, s2))), this.attributes(p);
            var E = b === l.namespace.HTML;
            if (E && 0 === t2.childNodes.length && e2._VoidElementNames.has(t2.localName) ? (this.openTagEnd(f, true, true), this.endElement(f), d = true) : E || 0 !== t2.childNodes.length ? this.openTagEnd(f, false, false) : (this.openTagEnd(f, true, false), this.endElement(f), d = true), !d) {
              if (E && "template" === t2.localName) ;
              else try {
                for (var D = n(t2.childNodes), S = D.next(); !S.done; S = D.next()) {
                  var C = S.value;
                  this.level++, this._serializeNodeNS(C, g, y, a2, s2), this.level--;
                }
              } catch (e3) {
                u2 = { error: e3 };
              } finally {
                try {
                  S && !S.done && (h2 = D.return) && h2.call(D);
                } finally {
                  if (u2) throw u2.error;
                }
              }
              this.closeTag(f), this.endElement(f);
            }
          }, e2.prototype._serializeElement = function(e3, t2) {
            var r2, i2;
            if (t2 && (-1 !== e3.localName.indexOf(":") || !c.xml_isName(e3.localName))) throw new Error("Node local name contains invalid characters (well-formed required).");
            var o2 = false, a2 = e3.localName;
            this.beginElement(a2), this.openTagBegin(a2);
            var s2 = this._serializeAttributes(e3, t2);
            if (this.attributes(s2), e3.hasChildNodes() ? this.openTagEnd(a2, false, false) : (this.openTagEnd(a2, true, false), this.endElement(a2), o2 = true), !o2) {
              try {
                for (var u2 = n(e3._children), l2 = u2.next(); !l2.done; l2 = u2.next()) {
                  var h2 = l2.value;
                  this.level++, this._serializeNode(h2, t2), this.level--;
                }
              } catch (e4) {
                r2 = { error: e4 };
              } finally {
                try {
                  l2 && !l2.done && (i2 = u2.return) && i2.call(u2);
                } finally {
                  if (r2) throw r2.error;
                }
              }
              this.closeTag(a2), this.endElement(a2);
            }
          }, e2.prototype._serializeDocumentNS = function(e3, t2, r2, i2, o2) {
            var a2, s2;
            if (o2 && null === e3.documentElement) throw new Error("Missing document element (well-formed required).");
            try {
              for (var u2 = n(e3.childNodes), l2 = u2.next(); !l2.done; l2 = u2.next()) {
                var c2 = l2.value;
                this._serializeNodeNS(c2, t2, r2, i2, o2);
              }
            } catch (e4) {
              a2 = { error: e4 };
            } finally {
              try {
                l2 && !l2.done && (s2 = u2.return) && s2.call(u2);
              } finally {
                if (a2) throw a2.error;
              }
            }
          }, e2.prototype._serializeDocument = function(e3, t2) {
            var r2, i2;
            if (t2 && null === e3.documentElement) throw new Error("Missing document element (well-formed required).");
            try {
              for (var o2 = n(e3._children), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var s2 = a2.value;
                this._serializeNode(s2, t2);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                a2 && !a2.done && (i2 = o2.return) && i2.call(o2);
              } finally {
                if (r2) throw r2.error;
              }
            }
          }, e2.prototype._serializeComment = function(e3, t2) {
            if (t2 && (!c.xml_isLegalChar(e3.data) || -1 !== e3.data.indexOf("--") || e3.data.endsWith("-"))) throw new Error("Comment data contains invalid characters (well-formed required).");
            this.comment(e3.data);
          }, e2.prototype._serializeText = function(e3, t2) {
            if (t2 && !c.xml_isLegalChar(e3.data)) throw new Error("Text data contains invalid characters (well-formed required).");
            var r2 = e3.data.replace(/(?!&([^&;]*);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            this.text(r2);
          }, e2.prototype._serializeDocumentFragmentNS = function(e3, t2, r2, i2, o2) {
            var a2, s2;
            try {
              for (var u2 = n(e3.childNodes), l2 = u2.next(); !l2.done; l2 = u2.next()) {
                var c2 = l2.value;
                this._serializeNodeNS(c2, t2, r2, i2, o2);
              }
            } catch (e4) {
              a2 = { error: e4 };
            } finally {
              try {
                l2 && !l2.done && (s2 = u2.return) && s2.call(u2);
              } finally {
                if (a2) throw a2.error;
              }
            }
          }, e2.prototype._serializeDocumentFragment = function(e3, t2) {
            var r2, i2;
            try {
              for (var o2 = n(e3._children), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var s2 = a2.value;
                this._serializeNode(s2, t2);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                a2 && !a2.done && (i2 = o2.return) && i2.call(o2);
              } finally {
                if (r2) throw r2.error;
              }
            }
          }, e2.prototype._serializeDocumentType = function(e3, t2) {
            if (t2 && !c.xml_isPubidChar(e3.publicId)) throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
            if (t2 && (!c.xml_isLegalChar(e3.systemId) || -1 !== e3.systemId.indexOf('"') && -1 !== e3.systemId.indexOf("'"))) throw new Error("DocType system identifier contains invalid characters (well-formed required).");
            this.docType(e3.name, e3.publicId, e3.systemId);
          }, e2.prototype._serializeProcessingInstruction = function(e3, t2) {
            if (t2 && (-1 !== e3.target.indexOf(":") || /^xml$/i.test(e3.target))) throw new Error("Processing instruction target contains invalid characters (well-formed required).");
            if (t2 && (!c.xml_isLegalChar(e3.data) || -1 !== e3.data.indexOf("?>"))) throw new Error("Processing instruction data contains invalid characters (well-formed required).");
            this.instruction(e3.target, e3.data);
          }, e2.prototype._serializeCData = function(e3, t2) {
            if (t2 && -1 !== e3.data.indexOf("]]>")) throw new Error("CDATA contains invalid characters (well-formed required).");
            this.cdata(e3.data);
          }, e2.prototype._serializeAttributesNS = function(e3, t2, r2, i2, o2, a2) {
            var u2, h2, p = [], f = a2 ? new s.LocalNameSet() : void 0;
            try {
              for (var d = n(e3.attributes), m = d.next(); !m.done; m = d.next()) {
                var y = m.value;
                if (a2 || o2 || null !== y.namespaceURI) {
                  if (a2 && f && f.has(y.namespaceURI, y.localName)) throw new Error("Element contains duplicate attributes (well-formed required).");
                  a2 && f && f.set(y.namespaceURI, y.localName);
                  var v = y.namespaceURI, _ = null;
                  if (null !== v) if (_ = t2.get(y.prefix, v), v === l.namespace.XMLNS) {
                    if (y.value === l.namespace.XML || null === y.prefix && o2 || null !== y.prefix && (!(y.localName in i2) || i2[y.localName] !== y.value) && t2.has(y.localName, y.value)) continue;
                    if (a2 && y.value === l.namespace.XMLNS) throw new Error("XMLNS namespace is reserved (well-formed required).");
                    if (a2 && "" === y.value) throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                    "xmlns" === y.prefix && (_ = "xmlns");
                  } else null === _ && (_ = null === y.prefix || t2.hasPrefix(y.prefix) && !t2.has(y.prefix, v) ? this._generatePrefix(v, t2, r2) : y.prefix, p.push([null, "xmlns", _, this._serializeAttributeValue(v, a2)]));
                  if (null !== _ && _, a2 && (-1 !== y.localName.indexOf(":") || !c.xml_isName(y.localName) || "xmlns" === y.localName && null === v)) throw new Error("Attribute local name contains invalid characters (well-formed required).");
                  p.push([v, _, y.localName, this._serializeAttributeValue(y.value, a2)]);
                } else p.push([null, null, y.localName, this._serializeAttributeValue(y.value, a2)]);
              }
            } catch (e4) {
              u2 = { error: e4 };
            } finally {
              try {
                m && !m.done && (h2 = d.return) && h2.call(d);
              } finally {
                if (u2) throw u2.error;
              }
            }
            return p;
          }, e2.prototype._serializeAttributes = function(e3, t2) {
            var r2, i2, o2 = [], a2 = t2 ? {} : void 0;
            try {
              for (var s2 = n(e3.attributes), u2 = s2.next(); !u2.done; u2 = s2.next()) {
                var l2 = u2.value;
                if (t2) {
                  if (t2 && a2 && l2.localName in a2) throw new Error("Element contains duplicate attributes (well-formed required).");
                  if (t2 && a2 && (a2[l2.localName] = true), t2 && (-1 !== l2.localName.indexOf(":") || !c.xml_isName(l2.localName))) throw new Error("Attribute local name contains invalid characters (well-formed required).");
                  o2.push([null, null, l2.localName, this._serializeAttributeValue(l2.value, t2)]);
                } else o2.push([null, null, l2.localName, this._serializeAttributeValue(l2.value, t2)]);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                u2 && !u2.done && (i2 = s2.return) && i2.call(s2);
              } finally {
                if (r2) throw r2.error;
              }
            }
            return o2;
          }, e2.prototype._recordNamespaceInformation = function(e3, t2, r2) {
            var i2, o2, a2 = null;
            try {
              for (var s2 = n(e3.attributes), u2 = s2.next(); !u2.done; u2 = s2.next()) {
                var c2 = u2.value, h2 = c2.namespaceURI, p = c2.prefix;
                if (h2 === l.namespace.XMLNS) {
                  if (null === p) {
                    a2 = c2.value;
                    continue;
                  }
                  var f = c2.localName, d = c2.value;
                  if (d === l.namespace.XML) continue;
                  if ("" === d && (d = null), t2.has(f, d)) continue;
                  t2.set(f, d), r2[f] = d || "";
                }
              }
            } catch (e4) {
              i2 = { error: e4 };
            } finally {
              try {
                u2 && !u2.done && (o2 = s2.return) && o2.call(s2);
              } finally {
                if (i2) throw i2.error;
              }
            }
            return a2;
          }, e2.prototype._generatePrefix = function(e3, t2, r2) {
            var n2 = "ns" + r2.value.toString();
            return r2.value++, t2.set(n2, e3), n2;
          }, e2.prototype._serializeAttributeValue = function(e3, t2) {
            if (t2 && null !== e3 && !c.xml_isLegalChar(e3)) throw new Error("Invalid characters in attribute value.");
            return null === e3 ? "" : e3.replace(/(?!&([^&;]*);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
          }, e2._VoidElementNames = /* @__PURE__ */ new Set(["area", "base", "basefont", "bgsound", "br", "col", "embed", "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"]), e2;
        }();
        t.BaseWriter = h;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(6), a = r(3), s = r(7), u = r(29), l = r(17), c = r(97);
        function h() {
          var e2 = o.dom.window;
          e2._mutationObserverMicrotaskQueued || (e2._mutationObserverMicrotaskQueued = true, Promise.resolve().then(function() {
            p();
          }));
        }
        function p() {
          var e2, t2, r2, i2, u2 = o.dom.window;
          u2._mutationObserverMicrotaskQueued = false;
          var l2 = s.set.clone(u2._mutationObservers), h2 = s.set.clone(u2._signalSlots);
          s.set.empty(u2._signalSlots);
          var p2 = function(e3) {
            var t3 = s.list.clone(e3._recordQueue);
            s.list.empty(e3._recordQueue);
            for (var r3 = 0; r3 < e3._nodeList.length; r3++) {
              var n2 = e3._nodeList[r3];
              s.list.remove(n2._registeredObserverList, function(t4) {
                return a.Guard.isTransientRegisteredObserver(t4) && t4.observer === e3;
              });
            }
            if (!s.list.isEmpty(t3)) try {
              e3._callback.call(e3, t3, e3);
            } catch (e4) {
            }
          };
          try {
            for (var f2 = n(l2), d = f2.next(); !d.done; d = f2.next()) {
              p2(d.value);
            }
          } catch (t3) {
            e2 = { error: t3 };
          } finally {
            try {
              d && !d.done && (t2 = f2.return) && t2.call(f2);
            } finally {
              if (e2) throw e2.error;
            }
          }
          if (o.dom.features.slots) try {
            for (var m = n(h2), y = m.next(); !y.done; y = m.next()) {
              var v = y.value;
              c.event_fireAnEvent("slotchange", v, void 0, { bubbles: true });
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              y && !y.done && (i2 = m.return) && i2.call(m);
            } finally {
              if (r2) throw r2.error;
            }
          }
        }
        function f(e2, t2, r2, o2, a2, s2, c2, p2, f2) {
          for (var d, m, y = /* @__PURE__ */ new Map(), v = l.tree_getFirstAncestorNode(t2, true); null !== v; ) {
            for (var _ = 0; _ < v._registeredObserverList.length; _++) {
              var g = v._registeredObserverList[_], b = g.options;
              if ((v === t2 || b.subtree) && (("attributes" !== e2 || b.attributes) && ("attributes" !== e2 || !b.attributeFilter || b.attributeFilter.indexOf(r2 || "") && null === o2) && ("characterData" !== e2 || b.characterData) && ("childList" !== e2 || b.childList))) {
                var x = g.observer;
                y.has(x) || y.set(x, null), ("attributes" === e2 && b.attributeOldValue || "characterData" === e2 && b.characterDataOldValue) && y.set(x, a2);
              }
            }
            v = l.tree_getNextAncestorNode(t2, v, true);
          }
          try {
            for (var w = n(y), E = w.next(); !E.done; E = w.next()) {
              var D = i(E.value, 2), S = D[0], C = D[1], A = u.create_mutationRecord(e2, t2, u.create_nodeListStatic(t2, s2), u.create_nodeListStatic(t2, c2), p2, f2, r2, o2, C);
              S._recordQueue.push(A);
            }
          } catch (e3) {
            d = { error: e3 };
          } finally {
            try {
              E && !E.done && (m = w.return) && m.call(w);
            } finally {
              if (d) throw d.error;
            }
          }
          h();
        }
        t.observer_queueAMutationObserverMicrotask = h, t.observer_notifyMutationObservers = p, t.observer_queueMutationRecord = f, t.observer_queueTreeMutationRecord = function(e2, t2, r2, n2, i2) {
          f("childList", e2, null, null, null, t2, r2, n2, i2);
        }, t.observer_queueAttributeMutationRecord = function(e2, t2, r2, n2) {
          f("attributes", e2, t2, r2, n2, [], [], null, null);
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(6), i = r(7), o = r(3), a = r(9), s = r(29), u = r(73), l = r(51), c = r(30), h = r(37), p = r(106);
        function f(e2, t2, r2) {
          n.dom.features.mutationObservers && l.observer_queueAttributeMutationRecord(t2, e2._localName, e2._namespace, e2._value), n.dom.features.customElements && o.Guard.isCustomElementNode(t2) && u.customElement_enqueueACustomElementCallbackReaction(t2, "attributeChangedCallback", [e2._localName, e2._value, r2, e2._namespace]), n.dom.features.steps && c.dom_runAttributeChangeSteps(t2, e2._localName, e2._value, r2, e2._namespace), e2._value = r2;
        }
        function d(e2, t2) {
          n.dom.features.mutationObservers && l.observer_queueAttributeMutationRecord(t2, e2._localName, e2._namespace, null), n.dom.features.customElements && o.Guard.isCustomElementNode(t2) && u.customElement_enqueueACustomElementCallbackReaction(t2, "attributeChangedCallback", [e2._localName, null, e2._value, e2._namespace]), n.dom.features.steps && c.dom_runAttributeChangeSteps(t2, e2._localName, null, e2._value, e2._namespace), t2._attributeList._asArray().push(e2), e2._element = t2, t2._nodeDocument._hasNamespaces || null === e2._namespace && null === e2._namespacePrefix && "xmlns" !== e2._localName || (t2._nodeDocument._hasNamespaces = true);
        }
        function m(e2, t2) {
          n.dom.features.mutationObservers && l.observer_queueAttributeMutationRecord(t2, e2._localName, e2._namespace, e2._value), n.dom.features.customElements && o.Guard.isCustomElementNode(t2) && u.customElement_enqueueACustomElementCallbackReaction(t2, "attributeChangedCallback", [e2._localName, e2._value, null, e2._namespace]), n.dom.features.steps && c.dom_runAttributeChangeSteps(t2, e2._localName, e2._value, null, e2._namespace);
          var r2 = t2._attributeList._asArray().indexOf(e2);
          t2._attributeList._asArray().splice(r2, 1), e2._element = null;
        }
        function y(e2, t2, r2) {
          n.dom.features.mutationObservers && l.observer_queueAttributeMutationRecord(r2, e2._localName, e2._namespace, e2._value), n.dom.features.customElements && o.Guard.isCustomElementNode(r2) && u.customElement_enqueueACustomElementCallbackReaction(r2, "attributeChangedCallback", [e2._localName, e2._value, t2._value, e2._namespace]), n.dom.features.steps && c.dom_runAttributeChangeSteps(r2, e2._localName, e2._value, t2._value, e2._namespace);
          var i2 = r2._attributeList._asArray().indexOf(e2);
          -1 !== i2 && (r2._attributeList._asArray()[i2] = t2), e2._element = null, t2._element = r2, r2._nodeDocument._hasNamespaces || null === t2._namespace && null === t2._namespacePrefix && "xmlns" !== t2._localName || (r2._nodeDocument._hasNamespaces = true);
        }
        function v(e2, t2) {
          return t2._namespace === i.namespace.HTML && "html" === t2._nodeDocument._type && (e2 = e2.toLowerCase()), t2._attributeList._asArray().find(function(t3) {
            return t3._qualifiedName === e2;
          }) || null;
        }
        function _(e2, t2, r2) {
          var n2 = e2 || null;
          return r2._attributeList._asArray().find(function(e3) {
            return e3._namespace === n2 && e3._localName === t2;
          }) || null;
        }
        t.element_has = function(e2, t2) {
          return -1 !== t2._attributeList._asArray().indexOf(e2);
        }, t.element_change = f, t.element_append = d, t.element_remove = m, t.element_replace = y, t.element_getAnAttributeByName = v, t.element_getAnAttributeByNamespaceAndLocalName = _, t.element_getAnAttributeValue = function(e2, t2, r2) {
          void 0 === r2 && (r2 = "");
          var n2 = _(r2, t2, e2);
          return null === n2 ? "" : n2._value;
        }, t.element_setAnAttribute = function(e2, t2) {
          if (null !== e2._element && e2._element !== t2) throw new a.InUseAttributeError("This attribute already exists in the document: " + e2._qualifiedName + " as a child of " + e2._element._qualifiedName + ".");
          var r2 = _(e2._namespace || "", e2._localName, t2);
          return r2 === e2 ? e2 : (null !== r2 ? y(r2, e2, t2) : d(e2, t2), r2);
        }, t.element_setAnAttributeValue = function(e2, t2, r2, n2, i2) {
          void 0 === n2 && (n2 = null), void 0 === i2 && (i2 = null);
          var o2 = _(i2 || "", t2, e2);
          if (null === o2) {
            var a2 = s.create_attr(e2._nodeDocument, t2);
            return a2._namespace = i2, a2._namespacePrefix = n2, a2._value = r2, void d(a2, e2);
          }
          f(o2, e2, r2);
        }, t.element_removeAnAttributeByName = function(e2, t2) {
          var r2 = v(e2, t2);
          return null !== r2 && m(r2, t2), r2;
        }, t.element_removeAnAttributeByNamespaceAndLocalName = function(e2, t2, r2) {
          var n2 = _(e2, t2, r2);
          return null !== n2 && m(n2, r2), n2;
        }, t.element_createAnElement = function(e2, t2, r2, o2, l2, c2) {
          void 0 === o2 && (o2 = null), void 0 === l2 && (l2 = null), void 0 === c2 && (c2 = false);
          var h2 = null;
          if (!n.dom.features.customElements) return (h2 = s.create_element(e2, t2, r2, o2))._customElementState = "uncustomized", h2._customElementDefinition = null, h2._is = l2, h2;
          var f2 = u.customElement_lookUpACustomElementDefinition(e2, r2, t2, l2);
          if (null !== f2 && f2.name !== f2.localName) (h2 = new (p.document_elementInterface(t2, i.namespace.HTML))())._localName = t2, h2._namespace = i.namespace.HTML, h2._namespacePrefix = o2, h2._customElementState = "undefined", h2._customElementDefinition = null, h2._is = l2, h2._nodeDocument = e2, c2 ? u.customElement_upgrade(f2, h2) : u.customElement_enqueueACustomElementUpgradeReaction(h2, f2);
          else if (null !== f2) if (c2) try {
            var d2 = new (0, f2.constructor)();
            if (console.assert(void 0 !== d2._customElementState), console.assert(void 0 !== d2._customElementDefinition), console.assert(d2._namespace === i.namespace.HTML), 0 !== d2._attributeList.length) throw new a.NotSupportedError("Custom element already has attributes.");
            if (0 !== d2._children.size) throw new a.NotSupportedError("Custom element already has child nodes.");
            if (null !== d2._parent) throw new a.NotSupportedError("Custom element already has a parent node.");
            if (d2._nodeDocument !== e2) throw new a.NotSupportedError("Custom element is already in a document.");
            if (d2._localName !== t2) throw new a.NotSupportedError("Custom element has a different local name.");
            d2._namespacePrefix = o2, d2._is = null;
          } catch (r3) {
            (h2 = s.create_htmlUnknownElement(e2, t2, i.namespace.HTML, o2))._customElementState = "failed", h2._customElementDefinition = null, h2._is = null;
          }
          else (h2 = s.create_htmlElement(e2, t2, i.namespace.HTML, o2))._customElementState = "undefined", h2._customElementDefinition = null, h2._is = null, u.customElement_enqueueACustomElementUpgradeReaction(h2, f2);
          else {
            (h2 = new (p.document_elementInterface(t2, r2))())._localName = t2, h2._namespace = r2, h2._namespacePrefix = o2, h2._customElementState = "uncustomized", h2._customElementDefinition = null, h2._is = l2, h2._nodeDocument = e2, r2 !== i.namespace.HTML || null === l2 && !u.customElement_isValidCustomElementName(t2) || (h2._customElementState = "undefined");
          }
          if (null === h2) throw new Error("Unable to create element.");
          return h2;
        }, t.element_insertAdjacent = function(e2, t2, r2) {
          switch (t2.toLowerCase()) {
            case "beforebegin":
              return null === e2._parent ? null : h.mutation_preInsert(r2, e2._parent, e2);
            case "afterbegin":
              return h.mutation_preInsert(r2, e2, e2._firstChild);
            case "beforeend":
              return h.mutation_preInsert(r2, e2, null);
            case "afterend":
              return null === e2._parent ? null : h.mutation_preInsert(r2, e2._parent, e2._nextSibling);
            default:
              throw new a.SyntaxError(`Invalid 'where' argument. "beforebegin", "afterbegin", "beforeend" or "afterend" expected`);
          }
        };
      }, function(e, t, r) {
        "use strict";
        function n(e2, t2) {
          Error.call(this), this.name = "YAMLException", this.reason = e2, this.mark = t2, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
        }
        n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n.prototype.toString = function(e2) {
          var t2 = this.name + ": ";
          return t2 += this.reason || "(unknown reason)", !e2 && this.mark && (t2 += " " + this.mark.toString()), t2;
        }, e.exports = n;
      }, function(e, t, r) {
        "use strict";
        var n = r(39);
        e.exports = new n({ include: [r(181)], implicit: [r(293), r(294)], explicit: [r(295), r(296), r(297), r(298)] });
      }, function(e, t, r) {
        var n = r(16), i = r(79), o = r(40), a = r(24), s = r(56), u = r(14), l = r(115), c = Object.getOwnPropertyDescriptor;
        t.f = n ? c : function(e2, t2) {
          if (e2 = a(e2), t2 = s(t2, true), l) try {
            return c(e2, t2);
          } catch (e3) {
          }
          if (u(e2, t2)) return o(!i.f.call(e2, t2), e2[t2]);
        };
      }, function(e, t, r) {
        var n = r(13);
        e.exports = function(e2, t2) {
          if (!n(e2)) return e2;
          var r2, i;
          if (t2 && "function" == typeof (r2 = e2.toString) && !n(i = r2.call(e2))) return i;
          if ("function" == typeof (r2 = e2.valueOf) && !n(i = r2.call(e2))) return i;
          if (!t2 && "function" == typeof (r2 = e2.toString) && !n(i = r2.call(e2))) return i;
          throw TypeError("Can't convert object to primitive value");
        };
      }, function(e, t, r) {
        var n = r(81), i = r(58), o = n("keys");
        e.exports = function(e2) {
          return o[e2] || (o[e2] = i(e2));
        };
      }, function(e, t) {
        var r = 0, n = Math.random();
        e.exports = function(e2) {
          return "Symbol(" + String(void 0 === e2 ? "" : e2) + ")_" + (++r + n).toString(36);
        };
      }, function(e, t, r) {
        var n = r(42);
        e.exports = Array.isArray || function(e2) {
          return "Array" == n(e2);
        };
      }, function(e, t, r) {
        var n, i = r(18), o = r(188), a = r(84), s = r(45), u = r(189), l = r(116), c = r(57), h = c("IE_PROTO"), p = function() {
        }, f = function(e2) {
          return "<script>" + e2 + "<\/script>";
        }, d = function() {
          try {
            n = document.domain && new ActiveXObject("htmlfile");
          } catch (e3) {
          }
          var e2, t2;
          d = n ? function(e3) {
            e3.write(f("")), e3.close();
            var t3 = e3.parentWindow.Object;
            return e3 = null, t3;
          }(n) : ((t2 = l("iframe")).style.display = "none", u.appendChild(t2), t2.src = String("javascript:"), (e2 = t2.contentWindow.document).open(), e2.write(f("document.F=Object")), e2.close(), e2.F);
          for (var r2 = a.length; r2--; ) delete d.prototype[a[r2]];
          return d();
        };
        s[h] = true, e.exports = Object.create || function(e2, t2) {
          var r2;
          return null !== e2 ? (p.prototype = i(e2), r2 = new p(), p.prototype = null, r2[h] = e2) : r2 = d(), void 0 === t2 ? r2 : o(r2, t2);
        };
      }, function(e, t, r) {
        var n = r(121), i = r(84);
        e.exports = Object.keys || function(e2) {
          return n(e2, i);
        };
      }, function(e, t, r) {
        var n = r(15).f, i = r(14), o = r(5)("toStringTag");
        e.exports = function(e2, t2, r2) {
          e2 && !i(e2 = r2 ? e2 : e2.prototype, o) && n(e2, o, { configurable: true, value: t2 });
        };
      }, function(e, t, r) {
        var n = r(8), i = r(5), o = r(129), a = i("species");
        e.exports = function(e2) {
          return o >= 51 || !n(function() {
            var t2 = [];
            return (t2.constructor = {})[a] = function() {
              return { foo: 1 };
            }, 1 !== t2[e2](Boolean).foo;
          });
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(122).indexOf, o = r(48), a = r(28), s = [].indexOf, u = !!s && 1 / [1].indexOf(1, -0) < 0, l = o("indexOf"), c = a("indexOf", { ACCESSORS: true, 1: 0 });
        n({ target: "Array", proto: true, forced: u || !l || !c }, { indexOf: function(e2) {
          return u ? s.apply(this, arguments) || 0 : i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        var n = r(16), i = r(15).f, o = Function.prototype, a = o.toString, s = /^\s*function ([^ (]*)/;
        n && !("name" in o) && i(o, "name", { configurable: true, get: function() {
          try {
            return a.call(this).match(s)[1];
          } catch (e2) {
            return "";
          }
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(25), i = r(18), o = r(8), a = r(136), s = RegExp.prototype, u = s.toString, l = o(function() {
          return "/a/b" != u.call({ source: "a", flags: "b" });
        }), c = "toString" != u.name;
        (l || c) && n(RegExp.prototype, "toString", function() {
          var e2 = i(this), t2 = String(e2.source), r2 = e2.flags;
          return "/" + t2 + "/" + String(void 0 === r2 && e2 instanceof RegExp && !("flags" in s) ? a.call(e2) : r2);
        }, { unsafe: true });
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(19), r(138), r(20), r(66), r(22), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(1), s = r(2), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            return n2._writerOptions = a.applyDefaults(r2, { format: "object", wellFormed: false, group: false, verbose: false }), n2;
          }
          return i(t2, e2), t2.prototype.serialize = function(e3) {
            return this._currentList = [], this._currentIndex = 0, this._listRegister = [this._currentList], this.serializeNode(e3, this._writerOptions.wellFormed), this._process(this._currentList, this._writerOptions);
          }, t2.prototype._process = function(e3, t3) {
            var r2, n2, i2, o2, u2, l, c;
            if (0 === e3.length) return {};
            for (var h = {}, p = false, f = 0, d = 0, m = 0, y = 0, v = 0; v < e3.length; v++) {
              var _ = e3[v];
              switch (I = Object.keys(_)[0]) {
                case "@":
                  continue;
                case "#":
                  f++;
                  break;
                case "!":
                  d++;
                  break;
                case "?":
                  m++;
                  break;
                case "$":
                  y++;
                  break;
                default:
                  h[I] ? p = true : h[I] = true;
              }
            }
            var g = this._getAttrKey(), b = this._getNodeKey(s.NodeType.Text), x = this._getNodeKey(s.NodeType.Comment), w = this._getNodeKey(s.NodeType.ProcessingInstruction), E = this._getNodeKey(s.NodeType.CData);
            if (1 === f && 1 === e3.length && a.isString(e3[0]["#"])) return e3[0]["#"];
            if (p) {
              var D = {};
              for (v = 0; v < e3.length; v++) {
                _ = e3[v];
                if ("@" === (I = Object.keys(_)[0])) {
                  var S = _["@"];
                  1 === (L = Object.keys(S)).length ? D[g + L[0]] = S[L[0]] : D[g] = _["@"];
                }
              }
              var C = [];
              for (v = 0; v < e3.length; v++) {
                _ = e3[v];
                switch (I = Object.keys(_)[0]) {
                  case "@":
                    break;
                  case "#":
                    C.push(((r2 = {})[b] = _["#"], r2));
                    break;
                  case "!":
                    C.push(((n2 = {})[x] = _["!"], n2));
                    break;
                  case "?":
                    C.push(((i2 = {})[w] = _["?"], i2));
                    break;
                  case "$":
                    C.push(((o2 = {})[E] = _.$, o2));
                    break;
                  default:
                    if (0 !== (B = _)[I].length && a.isArray(B[I][0])) {
                      for (var A = [], N = B[I], T = 0; T < N.length; T++) A.push(this._process(N[T], t3));
                      C.push(((u2 = {})[I] = A, u2));
                    } else t3.verbose ? C.push(((l = {})[I] = [this._process(B[I], t3)], l)) : C.push(((c = {})[I] = this._process(B[I], t3), c));
                }
              }
              return D[b] = C, D;
            }
            var O = 1, F = 1, k = 1, P = 1;
            for (D = {}, v = 0; v < e3.length; v++) {
              var I;
              _ = e3[v];
              switch (I = Object.keys(_)[0]) {
                case "@":
                  S = _["@"];
                  var L = Object.keys(S);
                  if (t3.group && 1 !== L.length) D[g] = S;
                  else for (var M in S) D[g + M] = S[M];
                  break;
                case "#":
                  O = this._processSpecItem(_["#"], D, t3.group, b, f, O);
                  break;
                case "!":
                  F = this._processSpecItem(_["!"], D, t3.group, x, d, F);
                  break;
                case "?":
                  k = this._processSpecItem(_["?"], D, t3.group, w, m, k);
                  break;
                case "$":
                  P = this._processSpecItem(_.$, D, t3.group, E, y, P);
                  break;
                default:
                  var B;
                  if (0 !== (B = _)[I].length && a.isArray(B[I][0])) {
                    A = [], N = B[I];
                    for (var j = 0; j < N.length; j++) A.push(this._process(N[j], t3));
                    D[I] = A;
                  } else t3.verbose ? D[I] = [this._process(B[I], t3)] : D[I] = this._process(B[I], t3);
              }
            }
            return D;
          }, t2.prototype._processSpecItem = function(e3, t3, r2, n2, i2, s2) {
            var u2, l;
            if (!r2 && a.isArray(e3) && i2 + e3.length > 2) try {
              for (var c = o(e3), h = c.next(); !h.done; h = c.next()) {
                var p = h.value;
                t3[n2 + (s2++).toString()] = p;
              }
            } catch (e4) {
              u2 = { error: e4 };
            } finally {
              try {
                h && !h.done && (l = c.return) && l.call(c);
              } finally {
                if (u2) throw u2.error;
              }
            }
            else t3[i2 > 1 ? n2 + (s2++).toString() : n2] = e3;
            return s2;
          }, t2.prototype.beginElement = function(e3) {
            var t3, r2, n2 = [];
            if (0 === this._currentList.length) this._currentList.push(((t3 = {})[e3] = n2, t3));
            else {
              var i2 = this._currentList[this._currentList.length - 1];
              if (this._isElementNode(i2, e3)) if (0 !== i2[e3].length && a.isArray(i2[e3][0])) i2[e3].push(n2);
              else i2[e3] = [i2[e3], n2];
              else this._currentList.push(((r2 = {})[e3] = n2, r2));
            }
            this._currentIndex++, this._listRegister.length > this._currentIndex ? this._listRegister[this._currentIndex] = n2 : this._listRegister.push(n2), this._currentList = n2;
          }, t2.prototype.endElement = function() {
            this._currentList = this._listRegister[--this._currentIndex];
          }, t2.prototype.attribute = function(e3, t3) {
            var r2, n2;
            if (0 === this._currentList.length) this._currentList.push({ "@": (r2 = {}, r2[e3] = t3, r2) });
            else {
              var i2 = this._currentList[this._currentList.length - 1];
              this._isAttrNode(i2) ? i2["@"][e3] = t3 : this._currentList.push({ "@": (n2 = {}, n2[e3] = t3, n2) });
            }
          }, t2.prototype.comment = function(e3) {
            if (0 === this._currentList.length) this._currentList.push({ "!": e3 });
            else {
              var t3 = this._currentList[this._currentList.length - 1];
              this._isCommentNode(t3) ? a.isArray(t3["!"]) ? t3["!"].push(e3) : t3["!"] = [t3["!"], e3] : this._currentList.push({ "!": e3 });
            }
          }, t2.prototype.text = function(e3) {
            if (0 === this._currentList.length) this._currentList.push({ "#": e3 });
            else {
              var t3 = this._currentList[this._currentList.length - 1];
              this._isTextNode(t3) ? a.isArray(t3["#"]) ? t3["#"].push(e3) : t3["#"] = [t3["#"], e3] : this._currentList.push({ "#": e3 });
            }
          }, t2.prototype.instruction = function(e3, t3) {
            var r2 = "" === t3 ? e3 : e3 + " " + t3;
            if (0 === this._currentList.length) this._currentList.push({ "?": r2 });
            else {
              var n2 = this._currentList[this._currentList.length - 1];
              this._isInstructionNode(n2) ? a.isArray(n2["?"]) ? n2["?"].push(r2) : n2["?"] = [n2["?"], r2] : this._currentList.push({ "?": r2 });
            }
          }, t2.prototype.cdata = function(e3) {
            if (0 === this._currentList.length) this._currentList.push({ $: e3 });
            else {
              var t3 = this._currentList[this._currentList.length - 1];
              this._isCDATANode(t3) ? a.isArray(t3.$) ? t3.$.push(e3) : t3.$ = [t3.$, e3] : this._currentList.push({ $: e3 });
            }
          }, t2.prototype._isAttrNode = function(e3) {
            return "@" in e3;
          }, t2.prototype._isTextNode = function(e3) {
            return "#" in e3;
          }, t2.prototype._isCommentNode = function(e3) {
            return "!" in e3;
          }, t2.prototype._isInstructionNode = function(e3) {
            return "?" in e3;
          }, t2.prototype._isCDATANode = function(e3) {
            return "$" in e3;
          }, t2.prototype._isElementNode = function(e3, t3) {
            return t3 in e3;
          }, t2.prototype._getAttrKey = function() {
            return this._builderOptions.convert.att;
          }, t2.prototype._getNodeKey = function(e3) {
            switch (e3) {
              case s.NodeType.Comment:
                return this._builderOptions.convert.comment;
              case s.NodeType.Text:
                return this._builderOptions.convert.text;
              case s.NodeType.ProcessingInstruction:
                return this._builderOptions.convert.ins;
              case s.NodeType.CData:
                return this._builderOptions.convert.cdata;
              default:
                throw new Error("Invalid node type.");
            }
          }, t2;
        }(r(50).BaseWriter);
        t.ObjectWriter = u;
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(93);
        n({ target: "RegExp", proto: true, forced: /./.exec !== i }, { exec: i });
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2() {
            this._items = {}, this._nullItems = {};
          }
          return e2.prototype.set = function(e3, t2) {
            null === e3 ? this._nullItems[t2] = true : (this._items[e3] || (this._items[e3] = {}), this._items[e3][t2] = true);
          }, e2.prototype.has = function(e3, t2) {
            return null === e3 ? true === this._nullItems[t2] : !!this._items[e3] && true === this._items[e3][t2];
          }, e2;
        }();
        t.LocalNameSet = n;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(9), o = r(3), a = r(0), s = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "_eventListenerList", { get: function() {
            return this.__eventListenerList || (this.__eventListenerList = []);
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_eventHandlerMap", { get: function() {
            return this.__eventHandlerMap || (this.__eventHandlerMap = {});
          }, enumerable: true, configurable: true }), e2.prototype.addEventListener = function(e3, t2, r2) {
            void 0 === r2 && (r2 = { passive: false, once: false, capture: false });
            var i2, s2 = n(a.eventTarget_flattenMore(r2), 3), u = s2[0], l = s2[1], c = s2[2];
            t2 && (i2 = o.Guard.isEventListener(t2) ? t2 : { handleEvent: t2 }, a.eventTarget_addEventListener(this, { type: e3, callback: i2, capture: u, passive: l, once: c, removed: false }));
          }, e2.prototype.removeEventListener = function(e3, t2, r2) {
            void 0 === r2 && (r2 = { capture: false });
            var n2 = a.eventTarget_flatten(r2);
            if (t2) for (var i2 = 0; i2 < this._eventListenerList.length; i2++) {
              var s2 = this._eventListenerList[i2];
              if (s2.type === e3 && s2.capture === n2) {
                if (o.Guard.isEventListener(t2) && s2.callback === t2) {
                  a.eventTarget_removeEventListener(this, s2, i2);
                  break;
                }
                if (t2 && s2.callback.handleEvent === t2) {
                  a.eventTarget_removeEventListener(this, s2, i2);
                  break;
                }
              }
            }
          }, e2.prototype.dispatchEvent = function(e3) {
            if (e3._dispatchFlag || !e3._initializedFlag) throw new i.InvalidStateError();
            return e3._isTrusted = false, a.event_dispatch(e3, this);
          }, e2.prototype._getTheParent = function(e3) {
            return null;
          }, e2;
        }();
        t.EventTargetImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(34), a = r(0), s = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this) || this;
            return r2._data = t3, r2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "data", { get: function() {
            return this._data;
          }, set: function(e3) {
            a.characterData_replaceData(this, 0, this._data.length, e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "length", { get: function() {
            return this._data.length;
          }, enumerable: true, configurable: true }), t2.prototype.substringData = function(e3, t3) {
            return a.characterData_substringData(this, e3, t3);
          }, t2.prototype.appendData = function(e3) {
            return a.characterData_replaceData(this, this._data.length, 0, e3);
          }, t2.prototype.insertData = function(e3, t3) {
            a.characterData_replaceData(this, e3, 0, t3);
          }, t2.prototype.deleteData = function(e3, t3) {
            a.characterData_replaceData(this, e3, t3, "");
          }, t2.prototype.replaceData = function(e3, t3, r2) {
            a.characterData_replaceData(this, e3, t3, r2);
          }, Object.defineProperty(t2.prototype, "previousElementSibling", { get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nextElementSibling", { get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
          }, enumerable: true, configurable: true }), t2.prototype.before = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.after = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.replaceWith = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.remove = function() {
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2;
        }(o.NodeImpl);
        t.CharacterDataImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++) e2 = e2.concat(i(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(6), s = r(3), u = r(1), l = r(17), c = r(51);
        function h(e2) {
          a.dom.window._signalSlots.add(e2), c.observer_queueAMutationObserverMicrotask();
        }
        function p(e2, t2) {
          void 0 === t2 && (t2 = false);
          var r2 = s.Cast.asNode(e2)._parent;
          if (null === r2) return null;
          var n2 = r2._shadowRoot || null;
          if (null === n2) return null;
          if (t2 && "open" !== n2._mode) return null;
          for (var i2 = l.tree_getFirstDescendantNode(n2, false, true, function(e3) {
            return s.Guard.isSlot(e3);
          }); null !== i2; ) {
            if (i2._name === e2._name) return i2;
            i2 = l.tree_getNextDescendantNode(n2, i2, false, true, function(e3) {
              return s.Guard.isSlot(e3);
            });
          }
          return null;
        }
        function f(e2) {
          var t2, r2, i2 = [], o2 = l.tree_rootNode(e2);
          if (!s.Guard.isShadowRoot(o2)) return i2;
          var a2 = o2._host;
          try {
            for (var u2 = n(a2._children), c2 = u2.next(); !c2.done; c2 = u2.next()) {
              var h2 = c2.value;
              if (s.Guard.isSlotable(h2)) p(h2) === e2 && i2.push(h2);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              c2 && !c2.done && (r2 = u2.return) && r2.call(u2);
            } finally {
              if (t2) throw t2.error;
            }
          }
          return i2;
        }
        function d(e2) {
          var t2, r2, i2 = f(e2);
          if (i2.length === e2._assignedNodes.length) {
            for (var o2 = true, a2 = 0; a2 < i2.length; a2++) if (i2[a2] !== e2._assignedNodes[a2]) {
              o2 = false;
              break;
            }
            o2 || h(e2);
          }
          e2._assignedNodes = i2;
          try {
            for (var s2 = n(i2), u2 = s2.next(); !u2.done; u2 = s2.next()) {
              u2.value._assignedSlot = e2;
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              u2 && !u2.done && (r2 = s2.return) && r2.call(s2);
            } finally {
              if (t2) throw t2.error;
            }
          }
        }
        t.shadowTree_signalASlotChange = h, t.shadowTree_isConnected = function(e2) {
          return s.Guard.isDocumentNode(l.tree_rootNode(e2, true));
        }, t.shadowTree_isAssigned = function(e2) {
          return null !== e2._assignedSlot;
        }, t.shadowTree_findASlot = p, t.shadowTree_findSlotables = f, t.shadowTree_findFlattenedSlotables = function e2(t2) {
          var r2, i2, a2, c2, h2 = [], p2 = l.tree_rootNode(t2);
          if (!s.Guard.isShadowRoot(p2)) return h2;
          var d2 = f(t2);
          if (u.isEmpty(d2)) try {
            for (var m = n(t2._children), y = m.next(); !y.done; y = m.next()) {
              var v = y.value;
              s.Guard.isSlotable(v) && d2.push(v);
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              y && !y.done && (i2 = m.return) && i2.call(m);
            } finally {
              if (r2) throw r2.error;
            }
          }
          try {
            for (var _ = n(d2), g = _.next(); !g.done; g = _.next()) {
              var b = g.value;
              if (s.Guard.isSlot(b) && s.Guard.isShadowRoot(l.tree_rootNode(b))) {
                var x = e2(b);
                h2.push.apply(h2, o(x));
              } else h2.push(b);
            }
          } catch (e3) {
            a2 = { error: e3 };
          } finally {
            try {
              g && !g.done && (c2 = _.return) && c2.call(_);
            } finally {
              if (a2) throw a2.error;
            }
          }
          return h2;
        }, t.shadowTree_assignSlotables = d, t.shadowTree_assignSlotablesForATree = function(e2) {
          for (var t2 = l.tree_getFirstDescendantNode(e2, true, false, function(e3) {
            return s.Guard.isSlot(e3);
          }); null !== t2; ) d(t2), t2 = l.tree_getNextDescendantNode(e2, t2, true, false, function(e3) {
            return s.Guard.isSlot(e3);
          });
        }, t.shadowTree_assignASlot = function(e2) {
          var t2 = p(e2);
          null !== t2 && d(t2);
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = /[a-z]([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*-([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*/, i = /* @__PURE__ */ new Set(["annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph"]), o = /* @__PURE__ */ new Set(["article", "aside", "blockquote", "body", "div", "footer", "h1", "h2", "h3", "h4", "h5", "h6", "header", "main", "nav", "p", "section", "span"]), a = /* @__PURE__ */ new Set(["area", "base", "basefont", "bgsound", "br", "col", "embed", "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"]), s = /* @__PURE__ */ new Set(["article", "aside", "blockquote", "body", "div", "footer", "h1", "h2", "h3", "h4", "h5", "h6", "header", "main", "nav", "p", "section", "span"]);
        t.customElement_isValidCustomElementName = function(e2) {
          return !!n.test(e2) && !i.has(e2);
        }, t.customElement_isValidElementName = function(e2) {
          return o.has(e2);
        }, t.customElement_isVoidElementName = function(e2) {
          return a.has(e2);
        }, t.customElement_isValidShadowHostName = function(e2) {
          return s.has(e2);
        }, t.customElement_enqueueACustomElementUpgradeReaction = function(e2, t2) {
        }, t.customElement_enqueueACustomElementCallbackReaction = function(e2, t2, r2) {
        }, t.customElement_upgrade = function(e2, t2) {
        }, t.customElement_tryToUpgrade = function(e2) {
        }, t.customElement_lookUpACustomElementDefinition = function(e2, t2, r2, n2) {
          return null;
        };
      }, function(e, t, r) {
        r(4)({ target: "String", proto: true }, { repeat: r(259) });
      }, function(e, t, r) {
        "use strict";
        r(278), r(68), r(179), r(94), Object.defineProperty(t, "__esModule", { value: true });
        var n = r(109), i = function() {
          function e2(e3) {
            this._builderOptions = e3, e3.parser && Object.assign(this, e3.parser);
          }
          return e2.prototype._docType = function(e3, t2, r2, n2) {
            return e3.dtd({ name: t2, pubID: r2, sysID: n2 });
          }, e2.prototype._comment = function(e3, t2) {
            return e3.com(t2);
          }, e2.prototype._text = function(e3, t2) {
            return e3.txt(t2);
          }, e2.prototype._instruction = function(e3, t2, r2) {
            return e3.ins(t2, r2);
          }, e2.prototype._cdata = function(e3, t2) {
            return e3.dat(t2);
          }, e2.prototype._element = function(e3, t2, r2) {
            return void 0 === t2 ? e3.ele(r2) : e3.ele(t2, r2);
          }, e2.prototype._attribute = function(e3, t2, r2, n2) {
            return void 0 === t2 ? e3.att(r2, n2) : e3.att(t2, r2, n2);
          }, e2.prototype._sanitize = function(e3) {
            return n.sanitizeInput(e3, this._builderOptions.invalidCharReplacement);
          }, e2.prototype._decodeText = function(t2) {
            return null == t2 ? t2 : t2.replace(/&(quot|amp|apos|lt|gt);/g, function(t3, r2) {
              return e2._entityTable[r2];
            }).replace(/&#(?:x([a-fA-F0-9]+)|([0-9]+));/g, function(e3, t3, r2) {
              return String.fromCodePoint(parseInt(t3 || r2, t3 ? 16 : 10));
            });
          }, e2.prototype._decodeAttributeValue = function(e3) {
            return this._decodeText(e3);
          }, e2.prototype.parse = function(e3, t2) {
            return this._parse(e3, t2);
          }, e2.prototype.docType = function(e3, t2, r2, n2) {
            return this._docType(e3, t2, r2, n2);
          }, e2.prototype.comment = function(e3, t2) {
            return this._comment(e3, t2);
          }, e2.prototype.text = function(e3, t2) {
            return this._text(e3, t2);
          }, e2.prototype.instruction = function(e3, t2, r2) {
            return this._instruction(e3, t2, r2);
          }, e2.prototype.cdata = function(e3, t2) {
            return this._cdata(e3, t2);
          }, e2.prototype.element = function(e3, t2, r2) {
            return this._element(e3, t2, r2);
          }, e2.prototype.attribute = function(e3, t2, r2, n2) {
            return this._attribute(e3, t2, r2, n2);
          }, e2.prototype.sanitize = function(e3) {
            return this._sanitize(e3);
          }, e2._entityTable = { lt: "<", gt: ">", amp: "&", quot: '"', apos: "'" }, e2;
        }();
        t.BaseReader = i;
      }, function(e, t, r) {
        "use strict";
        var n = r(39);
        e.exports = n.DEFAULT = new n({ include: [r(54)], explicit: [r(299), r(300), r(301)] });
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(185);
        t.XMLBuilderImpl = n.XMLBuilderImpl;
        var i = r(304);
        t.XMLBuilderCBImpl = i.XMLBuilderCBImpl;
        var o = r(183);
        t.builder = o.builder, t.create = o.create, t.fragment = o.fragment, t.convert = o.convert;
        var a = r(309);
        t.createCB = a.createCB, t.fragmentCB = a.fragmentCB;
      }, function(e, t) {
        var r;
        r = /* @__PURE__ */ function() {
          return this;
        }();
        try {
          r = r || new Function("return this")();
        } catch (e2) {
          "object" == typeof window && (r = window);
        }
        e.exports = r;
      }, function(e, t, r) {
        "use strict";
        var n = {}.propertyIsEnumerable, i = Object.getOwnPropertyDescriptor, o = i && !n.call({ 1: 2 }, 1);
        t.f = o ? function(e2) {
          var t2 = i(this, e2);
          return !!t2 && t2.enumerable;
        } : n;
      }, function(e, t, r) {
        var n = r(11), i = r(21);
        e.exports = function(e2, t2) {
          try {
            i(n, e2, t2);
          } catch (r2) {
            n[e2] = t2;
          }
          return t2;
        };
      }, function(e, t, r) {
        var n = r(44), i = r(118);
        (e.exports = function(e2, t2) {
          return i[e2] || (i[e2] = void 0 !== t2 ? t2 : {});
        })("versions", []).push({ version: "3.6.5", mode: n ? "pure" : "global", copyright: " 2020 Denis Pushkarev (zloirock.ru)" });
      }, function(e, t, r) {
        var n = r(121), i = r(84).concat("length", "prototype");
        t.f = Object.getOwnPropertyNames || function(e2) {
          return n(e2, i);
        };
      }, function(e, t, r) {
        var n = r(47), i = Math.max, o = Math.min;
        e.exports = function(e2, t2) {
          var r2 = n(e2);
          return r2 < 0 ? i(r2 + t2, 0) : o(r2, t2);
        };
      }, function(e, t) {
        e.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      }, function(e, t) {
        t.f = Object.getOwnPropertySymbols;
      }, function(e, t, r) {
        var n = r(8);
        e.exports = !!Object.getOwnPropertySymbols && !n(function() {
          return !String(Symbol());
        });
      }, function(e, t, r) {
        var n = r(127);
        e.exports = function(e2, t2, r2) {
          if (n(e2), void 0 === t2) return e2;
          switch (r2) {
            case 0:
              return function() {
                return e2.call(t2);
              };
            case 1:
              return function(r3) {
                return e2.call(t2, r3);
              };
            case 2:
              return function(r3, n2) {
                return e2.call(t2, r3, n2);
              };
            case 3:
              return function(r3, n2, i) {
                return e2.call(t2, r3, n2, i);
              };
          }
          return function() {
            return e2.apply(t2, arguments);
          };
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(195), o = r(132), a = r(133), s = r(62), u = r(21), l = r(25), c = r(5), h = r(44), p = r(49), f = r(131), d = f.IteratorPrototype, m = f.BUGGY_SAFARI_ITERATORS, y = c("iterator"), v = function() {
          return this;
        };
        e.exports = function(e2, t2, r2, c2, f2, _, g) {
          i(r2, t2, c2);
          var b, x, w, E = function(e3) {
            if (e3 === f2 && N) return N;
            if (!m && e3 in C) return C[e3];
            switch (e3) {
              case "keys":
              case "values":
              case "entries":
                return function() {
                  return new r2(this, e3);
                };
            }
            return function() {
              return new r2(this);
            };
          }, D = t2 + " Iterator", S = false, C = e2.prototype, A = C[y] || C["@@iterator"] || f2 && C[f2], N = !m && A || E(f2), T = "Array" == t2 && C.entries || A;
          if (T && (b = o(T.call(new e2())), d !== Object.prototype && b.next && (h || o(b) === d || (a ? a(b, d) : "function" != typeof b[y] && u(b, y, v)), s(b, D, true, true), h && (p[D] = v))), "values" == f2 && A && "values" !== A.name && (S = true, N = function() {
            return A.call(this);
          }), h && !g || C[y] === N || u(C, y, N), p[t2] = N, f2) if (x = { values: E("values"), keys: _ ? N : E("keys"), entries: E("entries") }, g) for (w in x) (m || S || !(w in C)) && l(C, w, x[w]);
          else n({ target: t2, proto: true, forced: m || S }, x);
          return x;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(13), o = r(59), a = r(83), s = r(26), u = r(24), l = r(134), c = r(5), h = r(63), p = r(28), f = h("slice"), d = p("slice", { ACCESSORS: true, 0: 0, 1: 2 }), m = c("species"), y = [].slice, v = Math.max;
        n({ target: "Array", proto: true, forced: !f || !d }, { slice: function(e2, t2) {
          var r2, n2, c2, h2 = u(this), p2 = s(h2.length), f2 = a(e2, p2), d2 = a(void 0 === t2 ? p2 : t2, p2);
          if (o(h2) && ("function" != typeof (r2 = h2.constructor) || r2 !== Array && !o(r2.prototype) ? i(r2) && null === (r2 = r2[m]) && (r2 = void 0) : r2 = void 0, r2 === Array || void 0 === r2)) return y.call(h2, f2, d2);
          for (n2 = new (void 0 === r2 ? Array : r2)(v(d2 - f2, 0)), c2 = 0; f2 < d2; f2++, c2++) f2 in h2 && l(n2, c2, h2[f2]);
          return n2.length = c2, n2;
        } });
      }, function(e, t, r) {
        var n = {};
        n[r(5)("toStringTag")] = "z", e.exports = "[object z]" === String(n);
      }, function(e, t, r) {
        "use strict";
        r(19), r(138), r(20), r(92), r(22), r(23), Object.defineProperty(t, "__esModule", { value: true }), t.DefaultBuilderOptions = { version: "1.0", encoding: void 0, standalone: void 0, keepNullNodes: false, keepNullAttributes: false, ignoreConverters: false, convert: { att: "@", ins: "?", text: "#", cdata: "$", comment: "!" }, defaultNamespace: { ele: void 0, att: void 0 }, namespaceAlias: { html: "http://www.w3.org/1999/xhtml", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg", xlink: "http://www.w3.org/1999/xlink" }, invalidCharReplacement: void 0, parser: void 0 }, t.XMLBuilderOptionKeys = new Set(Object.keys(t.DefaultBuilderOptions)), t.DefaultXMLBuilderCBOptions = { format: "xml", wellFormed: false, prettyPrint: false, indent: "  ", newline: "\n", offset: 0, width: 0, allowEmptyTags: false, spaceBeforeSlash: false, keepNullNodes: false, keepNullAttributes: false, ignoreConverters: false, convert: { att: "@", ins: "?", text: "#", cdata: "$", comment: "!" }, defaultNamespace: { ele: void 0, att: void 0 }, namespaceAlias: { html: "http://www.w3.org/1999/xhtml", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg", xlink: "http://www.w3.org/1999/xlink" } };
      }, function(e, t, r) {
        "use strict";
        var n = r(139), i = r(143);
        e.exports = n("Set", function(e2) {
          return function() {
            return e2(this, arguments.length ? arguments[0] : void 0);
          };
        }, i);
      }, function(e, t, r) {
        "use strict";
        var n, i, o = r(136), a = r(221), s = RegExp.prototype.exec, u = String.prototype.replace, l = s, c = (n = /a/, i = /b*/g, s.call(n, "a"), s.call(i, "a"), 0 !== n.lastIndex || 0 !== i.lastIndex), h = a.UNSUPPORTED_Y || a.BROKEN_CARET, p = void 0 !== /()??/.exec("")[1];
        (c || p || h) && (l = function(e2) {
          var t2, r2, n2, i2, a2 = this, l2 = h && a2.sticky, f = o.call(a2), d = a2.source, m = 0, y = e2;
          return l2 && (-1 === (f = f.replace("y", "")).indexOf("g") && (f += "g"), y = String(e2).slice(a2.lastIndex), a2.lastIndex > 0 && (!a2.multiline || a2.multiline && "\n" !== e2[a2.lastIndex - 1]) && (d = "(?: " + d + ")", y = " " + y, m++), r2 = new RegExp("^(?:" + d + ")", f)), p && (r2 = new RegExp("^" + d + "$(?!\\s)", f)), c && (t2 = a2.lastIndex), n2 = s.call(l2 ? r2 : a2, y), l2 ? n2 ? (n2.input = n2.input.slice(m), n2[0] = n2[0].slice(m), n2.index = a2.lastIndex, a2.lastIndex += n2[0].length) : a2.lastIndex = 0 : c && n2 && (a2.lastIndex = a2.global ? n2.index + n2[0].length : t2), p && n2 && n2.length > 1 && u.call(n2[0], r2, function() {
            for (i2 = 1; i2 < arguments.length - 2; i2++) void 0 === arguments[i2] && (n2[i2] = void 0);
          }), n2;
        }), e.exports = l;
      }, function(e, t, r) {
        "use strict";
        var n = r(225), i = r(18), o = r(27), a = r(26), s = r(47), u = r(35), l = r(226), c = r(227), h = Math.max, p = Math.min, f = Math.floor, d = /\$([$&'`]|\d\d?|<[^>]*>)/g, m = /\$([$&'`]|\d\d?)/g;
        n("replace", 2, function(e2, t2, r2, n2) {
          var y = n2.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, v = n2.REPLACE_KEEPS_$0, _ = y ? "$" : "$0";
          return [function(r3, n3) {
            var i2 = u(this), o2 = null == r3 ? void 0 : r3[e2];
            return void 0 !== o2 ? o2.call(r3, i2, n3) : t2.call(String(i2), r3, n3);
          }, function(e3, n3) {
            if (!y && v || "string" == typeof n3 && -1 === n3.indexOf(_)) {
              var o2 = r2(t2, e3, this, n3);
              if (o2.done) return o2.value;
            }
            var u2 = i(e3), f2 = String(this), d2 = "function" == typeof n3;
            d2 || (n3 = String(n3));
            var m2 = u2.global;
            if (m2) {
              var b = u2.unicode;
              u2.lastIndex = 0;
            }
            for (var x = []; ; ) {
              var w = c(u2, f2);
              if (null === w) break;
              if (x.push(w), !m2) break;
              "" === String(w[0]) && (u2.lastIndex = l(f2, a(u2.lastIndex), b));
            }
            for (var E, D = "", S = 0, C = 0; C < x.length; C++) {
              w = x[C];
              for (var A = String(w[0]), N = h(p(s(w.index), f2.length), 0), T = [], O = 1; O < w.length; O++) T.push(void 0 === (E = w[O]) ? E : String(E));
              var F = w.groups;
              if (d2) {
                var k = [A].concat(T, N, f2);
                void 0 !== F && k.push(F);
                var P = String(n3.apply(void 0, k));
              } else P = g(A, f2, N, T, F, n3);
              N >= S && (D += f2.slice(S, N) + P, S = N + A.length);
            }
            return D + f2.slice(S);
          }];
          function g(e3, r3, n3, i2, a2, s2) {
            var u2 = n3 + e3.length, l2 = i2.length, c2 = m;
            return void 0 !== a2 && (a2 = o(a2), c2 = d), t2.call(s2, c2, function(t3, o2) {
              var s3;
              switch (o2.charAt(0)) {
                case "$":
                  return "$";
                case "&":
                  return e3;
                case "`":
                  return r3.slice(0, n3);
                case "'":
                  return r3.slice(u2);
                case "<":
                  s3 = a2[o2.slice(1, -1)];
                  break;
                default:
                  var c3 = +o2;
                  if (0 === c3) return t3;
                  if (c3 > l2) {
                    var h2 = f(c3 / 10);
                    return 0 === h2 ? t3 : h2 <= l2 ? void 0 === i2[h2 - 1] ? o2.charAt(1) : i2[h2 - 1] + o2.charAt(1) : t3;
                  }
                  s3 = i2[c3 - 1];
              }
              return void 0 === s3 ? "" : s3;
            });
          }
        });
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2() {
            this._items = {}, this._nullItems = [];
          }
          return e2.prototype.copy = function() {
            var t2 = new e2();
            for (var r2 in this._items) t2._items[r2] = this._items[r2].slice(0);
            return t2._nullItems = this._nullItems.slice(0), t2;
          }, e2.prototype.get = function(e3, t2) {
            var r2 = null === t2 ? this._nullItems : this._items[t2] || null;
            if (null === r2) return null;
            for (var n2 = null, i = 0; i < r2.length; i++) if ((n2 = r2[i]) === e3) return n2;
            return n2;
          }, e2.prototype.has = function(e3, t2) {
            var r2 = null === t2 ? this._nullItems : this._items[t2] || null;
            return null !== r2 && -1 !== r2.indexOf(e3);
          }, e2.prototype.hasPrefix = function(e3) {
            if (-1 !== this._nullItems.indexOf(e3)) return true;
            for (var t2 in this._items) if (-1 !== this._items[t2].indexOf(e3)) return true;
            return false;
          }, e2.prototype.set = function(e3, t2) {
            var r2 = null === t2 ? this._nullItems : this._items[t2] || null;
            null !== t2 && null === r2 ? this._items[t2] = [e3] : r2.push(e3);
          }, e2;
        }();
        t.NamespacePrefixMap = n;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Surrogate = /[\uD800-\uDFFF]/, t.ScalarValue = /[\uD800-\uDFFF]/, t.NonCharacter = /[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/, t.ASCIICodePoint = /[\u0000-\u007F]/, t.ASCIITabOrNewLine = /[\t\n\r]/, t.ASCIIWhiteSpace = /[\t\n\f\r ]/, t.C0Control = /[\u0000-\u001F]/, t.C0ControlOrSpace = /[\u0000-\u001F ]/, t.Control = /[\u0000-\u001F\u007F-\u009F]/, t.ASCIIDigit = /[0-9]/, t.ASCIIUpperHexDigit = /[0-9A-F]/, t.ASCIILowerHexDigit = /[0-9a-f]/, t.ASCIIHexDigit = /[0-9A-Fa-f]/, t.ASCIIUpperAlpha = /[A-Z]/, t.ASCIILowerAlpha = /[a-z]/, t.ASCIIAlpha = /[A-Za-z]/, t.ASCIIAlphanumeric = /[0-9A-Za-z]/;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++) e2 = e2.concat(i(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(6), s = r(2), u = r(3), l = r(171), c = r(104), h = r(9), p = r(17), f = r(72), d = r(30);
        function m(e2, t2) {
          void 0 === t2 && (t2 = void 0), void 0 === t2 && (t2 = null);
          var r2 = y(e2, t2, /* @__PURE__ */ new Date(), {});
          return r2._isTrusted = true, r2;
        }
        function y(e2, t2, r2, n2) {
          var i2 = new e2("");
          return i2._initializedFlag = true, i2._timeStamp = r2.getTime(), Object.assign(i2, n2), a.dom.features.steps && d.dom_runEventConstructingSteps(i2), i2;
        }
        function v(e2, t2, r2, i2) {
          var o2, a2, l2, c2;
          void 0 === r2 && (r2 = false), void 0 === i2 && (i2 = { value: false });
          var h2 = false;
          e2._dispatchFlag = true;
          var d2 = t2;
          if (r2) {
            var m2 = t2._associatedDocument;
            u.Guard.isDocumentNode(m2) && (d2 = m2);
          }
          var y2 = null, v2 = p.tree_retarget(e2._relatedTarget, t2);
          if (t2 !== v2 || t2 === e2._relatedTarget) {
            var b3 = [];
            try {
              for (var x2 = n(e2._touchTargetList), w2 = x2.next(); !w2.done; w2 = x2.next()) {
                var E2 = w2.value;
                b3.push(p.tree_retarget(E2, t2));
              }
            } catch (e3) {
              o2 = { error: e3 };
            } finally {
              try {
                w2 && !w2.done && (a2 = x2.return) && a2.call(x2);
              } finally {
                if (o2) throw o2.error;
              }
            }
            _(e2, t2, d2, v2, b3, false);
            var D2 = u.Guard.isMouseEvent(e2) && "click" === e2._type;
            D2 && void 0 !== t2._activationBehavior && (y2 = t2);
            for (var S = u.Guard.isSlotable(t2) && f.shadowTree_isAssigned(t2) ? t2 : null, C = false, A = t2._getTheParent(e2); null !== A && u.Guard.isNode(A); ) {
              if (null !== S) {
                if (!u.Guard.isSlot(A)) throw new Error("Parent node of a slotable should be a slot.");
                S = null;
                var N = p.tree_rootNode(A, true);
                u.Guard.isShadowRoot(N) && "closed" === N._mode && (C = true);
              }
              u.Guard.isSlotable(A) && f.shadowTree_isAssigned(A) && (S = A), v2 = p.tree_retarget(e2._relatedTarget, A), b3 = [];
              try {
                for (var T = (l2 = void 0, n(e2._touchTargetList)), O = T.next(); !O.done; O = T.next()) {
                  E2 = O.value;
                  b3.push(p.tree_retarget(E2, A));
                }
              } catch (e3) {
                l2 = { error: e3 };
              } finally {
                try {
                  O && !O.done && (c2 = T.return) && c2.call(T);
                } finally {
                  if (l2) throw l2.error;
                }
              }
              u.Guard.isWindow(A) || u.Guard.isNode(A) && u.Guard.isNode(t2) && p.tree_isAncestorOf(p.tree_rootNode(t2, true), A, true, true) ? (D2 && e2._bubbles && null === y2 && A._activationBehavior && (y2 = A), _(e2, A, null, v2, b3, C)) : A === v2 ? A = null : (t2 = A, D2 && null === y2 && t2._activationBehavior && (y2 = t2), _(e2, A, t2, v2, b3, C)), null !== A && (A = A._getTheParent(e2)), C = false;
            }
            for (var F = null, k = e2._path, P = k.length - 1; P >= 0; P--) {
              if (null !== (L = k[P]).shadowAdjustedTarget) {
                F = L;
                break;
              }
            }
            if (null !== F) if (u.Guard.isNode(F.shadowAdjustedTarget) && u.Guard.isShadowRoot(p.tree_rootNode(F.shadowAdjustedTarget, true))) h2 = true;
            else if (u.Guard.isNode(F.relatedTarget) && u.Guard.isShadowRoot(p.tree_rootNode(F.relatedTarget, true))) h2 = true;
            else for (var I = 0; I < F.touchTargetList.length; I++) {
              var L = F.touchTargetList[I];
              if (u.Guard.isNode(L) && u.Guard.isShadowRoot(p.tree_rootNode(L, true))) {
                h2 = true;
                break;
              }
            }
            null !== y2 && void 0 !== y2._legacyPreActivationBehavior && y2._legacyPreActivationBehavior(e2);
            for (P = k.length - 1; P >= 0; P--) {
              null !== (L = k[P]).shadowAdjustedTarget ? e2._eventPhase = s.EventPhase.AtTarget : e2._eventPhase = s.EventPhase.Capturing, g(L, e2, "capturing", i2);
            }
            for (P = 0; P < k.length; P++) {
              if (null !== (L = k[P]).shadowAdjustedTarget) e2._eventPhase = s.EventPhase.AtTarget;
              else {
                if (!e2._bubbles) continue;
                e2._eventPhase = s.EventPhase.Bubbling;
              }
              g(L, e2, "bubbling", i2);
            }
          }
          return e2._eventPhase = s.EventPhase.None, e2._currentTarget = null, e2._path = [], e2._dispatchFlag = false, e2._stopPropagationFlag = false, e2._stopImmediatePropagationFlag = false, h2 && (e2._target = null, e2._relatedTarget = null, e2._touchTargetList = []), null !== y2 && (e2._canceledFlag || void 0 === y2._activationBehavior ? void 0 !== y2._legacyCanceledActivationBehavior && y2._legacyCanceledActivationBehavior(e2) : y2._activationBehavior(e2)), !e2._canceledFlag;
        }
        function _(e2, t2, r2, n2, i2, o2) {
          var a2 = false;
          u.Guard.isNode(t2) && u.Guard.isShadowRoot(p.tree_rootNode(t2)) && (a2 = true);
          var s2 = false;
          u.Guard.isShadowRoot(t2) && "closed" === t2._mode && (s2 = true), e2._path.push({ invocationTarget: t2, invocationTargetInShadowTree: a2, shadowAdjustedTarget: r2, relatedTarget: n2, touchTargetList: i2, rootOfClosedTree: s2, slotInClosedTree: o2 });
        }
        function g(e2, t2, r2, n2) {
          void 0 === n2 && (n2 = { value: false });
          for (var i2 = t2._path, a2 = -1, s2 = 0; s2 < i2.length; s2++) if (i2[s2] === e2) {
            a2 = s2;
            break;
          }
          if (-1 !== a2) {
            var u2 = i2[a2];
            (null !== u2.shadowAdjustedTarget || a2 > 0 && null !== (u2 = i2[a2 - 1]).shadowAdjustedTarget) && (t2._target = u2.shadowAdjustedTarget);
          }
          if (t2._relatedTarget = e2.relatedTarget, t2._touchTargetList = e2.touchTargetList, !t2._stopPropagationFlag) {
            t2._currentTarget = e2.invocationTarget;
            var l2 = t2._currentTarget._eventListenerList, c2 = new (Array.bind.apply(Array, o([void 0], l2)))();
            if (!b(t2, c2, r2, e2, n2) && t2._isTrusted) {
              var h2 = t2._type;
              "animationend" === h2 ? t2._type = "webkitAnimationEnd" : "animationiteration" === h2 ? t2._type = "webkitAnimationIteration" : "animationstart" === h2 ? t2._type = "webkitAnimationStart" : "transitionend" === h2 && (t2._type = "webkitTransitionEnd"), b(t2, c2, r2, e2, n2), t2._type = h2;
            }
          }
        }
        function b(e2, t2, r2, n2, i2) {
          void 0 === i2 && (i2 = { value: false });
          for (var o2 = false, a2 = 0; a2 < t2.length; a2++) {
            var s2 = t2[a2];
            if (!s2.removed) {
              if (e2._type !== s2.type) continue;
              if (o2 = true, "capturing" === r2 && !s2.capture) continue;
              if ("bubbling" === r2 && s2.capture) continue;
              if (s2.once && null !== e2._currentTarget) {
                for (var l2 = e2._currentTarget, c2 = -1, h2 = 0; h2 < l2._eventListenerList.length; h2++) if (l2._eventListenerList[h2] === s2) {
                  c2 = h2;
                  break;
                }
                -1 !== c2 && l2._eventListenerList.splice(c2, 1);
              }
              var p2 = void 0, f2 = void 0;
              u.Guard.isWindow(p2) && (f2 = p2._currentEvent, false === n2.invocationTargetInShadowTree && (p2._currentEvent = e2)), s2.passive && (e2._inPassiveListenerFlag = true);
              try {
                s2.callback.handleEvent.call(e2._currentTarget, e2);
              } catch (e3) {
                i2.value = true;
              }
              if (s2.passive && (e2._inPassiveListenerFlag = false), u.Guard.isWindow(p2) && (p2._currentEvent = f2), e2._stopImmediatePropagationFlag) return o2;
            }
          }
          return o2;
        }
        function x(e2, t2) {
          return null;
        }
        function w(e2, t2) {
          return null;
        }
        function E(e2, t2) {
        }
        function D(e2, t2) {
        }
        t.event_setTheCanceledFlag = function(e2) {
          e2._cancelable && !e2._inPassiveListenerFlag && (e2._canceledFlag = true);
        }, t.event_initialize = function(e2, t2, r2, n2) {
          e2._initializedFlag = true, e2._stopPropagationFlag = false, e2._stopImmediatePropagationFlag = false, e2._canceledFlag = false, e2._isTrusted = false, e2._target = null, e2._type = t2, e2._bubbles = r2, e2._cancelable = n2;
        }, t.event_createAnEvent = m, t.event_innerEventCreationSteps = y, t.event_dispatch = v, t.event_appendToAnEventPath = _, t.event_invoke = g, t.event_innerInvoke = b, t.event_fireAnEvent = function(e2, t2, r2, n2, i2) {
          void 0 === r2 && (r2 = c.EventImpl);
          var o2 = m(r2);
          if (o2._type = e2, n2) for (var a2 in n2) {
            o2[a2] = n2[a2];
          }
          return v(o2, t2, i2);
        }, t.event_createLegacyEvent = function(e2) {
          var t2 = null;
          switch (e2.toLowerCase()) {
            case "beforeunloadevent":
            case "compositionevent":
              break;
            case "customevent":
              t2 = l.CustomEventImpl;
              break;
            case "devicemotionevent":
            case "deviceorientationevent":
            case "dragevent":
              break;
            case "event":
            case "events":
              t2 = c.EventImpl;
          }
          if (null === t2) throw new h.NotSupportedError("Event constructor not found for interface " + e2 + ".");
          var r2 = new t2("");
          return r2._type = "", r2._timeStamp = (/* @__PURE__ */ new Date()).getTime(), r2._isTrusted = false, r2._initializedFlag = false, r2;
        }, t.event_getterEventHandlerIDLAttribute = function(e2, t2) {
          return null;
        }, t.event_setterEventHandlerIDLAttribute = function(e2, t2, r2) {
        }, t.event_determineTheTargetOfAnEventHandler = x, t.event_getTheCurrentValueOfAnEventHandler = w, t.event_activateAnEventHandler = E, t.event_deactivateAnEventHandler = D;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, a = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(6), u = r(2), l = r(9), c = r(34), h = r(3), p = r(1), f = r(7), d = r(152), m = r(0), y = r(12), v = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this;
            return t3._children = /* @__PURE__ */ new Set(), t3._encoding = { name: "UTF-8", labels: ["unicode-1-1-utf-8", "utf-8", "utf8"] }, t3._contentType = "application/xml", t3._URL = { scheme: "about", username: "", password: "", host: null, port: null, path: ["blank"], query: null, fragment: null, _cannotBeABaseURLFlag: true, _blobURLEntry: null }, t3._origin = null, t3._type = "xml", t3._mode = "no-quirks", t3._documentElement = null, t3._hasNamespaces = false, t3._nodeDocumentOverwrite = null, t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "_nodeDocument", { get: function() {
            return this._nodeDocumentOverwrite || this;
          }, set: function(e3) {
            this._nodeDocumentOverwrite = e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "implementation", { get: function() {
            return this._implementation || (this._implementation = m.create_domImplementation(this));
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "URL", { get: function() {
            return d.urlSerializer(this._URL);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "documentURI", { get: function() {
            return this.URL;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "origin", { get: function() {
            return "null";
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "compatMode", { get: function() {
            return "quirks" === this._mode ? "BackCompat" : "CSS1Compat";
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "characterSet", { get: function() {
            return this._encoding.name;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "charset", { get: function() {
            return this._encoding.name;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "inputEncoding", { get: function() {
            return this._encoding.name;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "contentType", { get: function() {
            return this._contentType;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "doctype", { get: function() {
            var e3, t3;
            try {
              for (var r2 = o(this._children), n2 = r2.next(); !n2.done; n2 = r2.next()) {
                var i2 = n2.value;
                if (h.Guard.isDocumentTypeNode(i2)) return i2;
              }
            } catch (t4) {
              e3 = { error: t4 };
            } finally {
              try {
                n2 && !n2.done && (t3 = r2.return) && t3.call(r2);
              } finally {
                if (e3) throw e3.error;
              }
            }
            return null;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "documentElement", { get: function() {
            return this._documentElement;
          }, enumerable: true, configurable: true }), t2.prototype.getElementsByTagName = function(e3) {
            return m.node_listOfElementsWithQualifiedName(e3, this);
          }, t2.prototype.getElementsByTagNameNS = function(e3, t3) {
            return m.node_listOfElementsWithNamespace(e3, t3, this);
          }, t2.prototype.getElementsByClassName = function(e3) {
            return m.node_listOfElementsWithClassNames(e3, this);
          }, t2.prototype.createElement = function(e3, t3) {
            if (!m.xml_isName(e3)) throw new l.InvalidCharacterError();
            "html" === this._type && (e3 = e3.toLowerCase());
            var r2 = null;
            void 0 !== t3 && (r2 = p.isString(t3) ? t3 : t3.is);
            var n2 = "html" === this._type || "application/xhtml+xml" === this._contentType ? f.namespace.HTML : null;
            return m.element_createAnElement(this, e3, n2, null, r2, true);
          }, t2.prototype.createElementNS = function(e3, t3, r2) {
            return m.document_internalCreateElementNS(this, e3, t3, r2);
          }, t2.prototype.createDocumentFragment = function() {
            return m.create_documentFragment(this);
          }, t2.prototype.createTextNode = function(e3) {
            return m.create_text(this, e3);
          }, t2.prototype.createCDATASection = function(e3) {
            if ("html" === this._type) throw new l.NotSupportedError();
            if (-1 !== e3.indexOf("]]>")) throw new l.InvalidCharacterError();
            return m.create_cdataSection(this, e3);
          }, t2.prototype.createComment = function(e3) {
            return m.create_comment(this, e3);
          }, t2.prototype.createProcessingInstruction = function(e3, t3) {
            if (!m.xml_isName(e3)) throw new l.InvalidCharacterError();
            if (-1 !== t3.indexOf("?>")) throw new l.InvalidCharacterError();
            return m.create_processingInstruction(this, e3, t3);
          }, t2.prototype.importNode = function(e3, t3) {
            if (void 0 === t3 && (t3 = false), h.Guard.isDocumentNode(e3) || h.Guard.isShadowRoot(e3)) throw new l.NotSupportedError();
            return m.node_clone(e3, this, t3);
          }, t2.prototype.adoptNode = function(e3) {
            if (h.Guard.isDocumentNode(e3)) throw new l.NotSupportedError();
            if (h.Guard.isShadowRoot(e3)) throw new l.HierarchyRequestError();
            return m.document_adopt(e3, this), e3;
          }, t2.prototype.createAttribute = function(e3) {
            if (!m.xml_isName(e3)) throw new l.InvalidCharacterError();
            return "html" === this._type && (e3 = e3.toLowerCase()), m.create_attr(this, e3);
          }, t2.prototype.createAttributeNS = function(e3, t3) {
            var r2 = a(m.namespace_validateAndExtract(e3, t3), 3), n2 = r2[0], i2 = r2[1], o2 = r2[2], s2 = m.create_attr(this, o2);
            return s2._namespace = n2, s2._namespacePrefix = i2, s2;
          }, t2.prototype.createEvent = function(e3) {
            return m.event_createLegacyEvent(e3);
          }, t2.prototype.createRange = function() {
            var e3 = m.create_range();
            return e3._start = [this, 0], e3._end = [this, 0], e3;
          }, t2.prototype.createNodeIterator = function(e3, t3, r2) {
            void 0 === t3 && (t3 = u.WhatToShow.All), void 0 === r2 && (r2 = null);
            var n2 = m.create_nodeIterator(e3, e3, true);
            return n2._whatToShow = t3, n2._iteratorCollection = m.create_nodeList(e3), p.isFunction(r2) ? (n2._filter = m.create_nodeFilter(), n2._filter.acceptNode = r2) : n2._filter = r2, n2;
          }, t2.prototype.createTreeWalker = function(e3, t3, r2) {
            void 0 === t3 && (t3 = u.WhatToShow.All), void 0 === r2 && (r2 = null);
            var n2 = m.create_treeWalker(e3, e3);
            return n2._whatToShow = t3, p.isFunction(r2) ? (n2._filter = m.create_nodeFilter(), n2._filter.acceptNode = r2) : n2._filter = r2, n2;
          }, t2.prototype._getTheParent = function(e3) {
            return "load" === e3._type ? null : s.dom.window;
          }, t2.prototype.getElementById = function(e3) {
            throw new Error("Mixin: NonElementParentNode not implemented.");
          }, Object.defineProperty(t2.prototype, "children", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "firstElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "lastElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "childElementCount", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), t2.prototype.prepend = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.append = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelector = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelectorAll = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2;
        }(c.NodeImpl);
        t.DocumentImpl = v, y.idl_defineConst(v.prototype, "_nodeType", u.NodeType.Document);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, a = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(2), u = r(34), l = r(9), c = r(7), h = r(0), p = r(12), f = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this;
            return t3._children = /* @__PURE__ */ new Set(), t3._namespace = null, t3._namespacePrefix = null, t3._localName = "", t3._customElementState = "undefined", t3._customElementDefinition = null, t3._is = null, t3._shadowRoot = null, t3._attributeList = h.create_namedNodeMap(t3), t3._attributeChangeSteps = [], t3._name = "", t3._assignedSlot = null, t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "namespaceURI", { get: function() {
            return this._namespace;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "prefix", { get: function() {
            return this._namespacePrefix;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "localName", { get: function() {
            return this._localName;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "tagName", { get: function() {
            return this._htmlUppercasedQualifiedName;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "id", { get: function() {
            return h.element_getAnAttributeValue(this, "id");
          }, set: function(e3) {
            h.element_setAnAttributeValue(this, "id", e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "className", { get: function() {
            return h.element_getAnAttributeValue(this, "class");
          }, set: function(e3) {
            h.element_setAnAttributeValue(this, "class", e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "classList", { get: function() {
            var e3 = h.element_getAnAttributeByName("class", this);
            return null === e3 && (e3 = h.create_attr(this._nodeDocument, "class")), h.create_domTokenList(this, e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "slot", { get: function() {
            return h.element_getAnAttributeValue(this, "slot");
          }, set: function(e3) {
            h.element_setAnAttributeValue(this, "slot", e3);
          }, enumerable: true, configurable: true }), t2.prototype.hasAttributes = function() {
            return 0 !== this._attributeList.length;
          }, Object.defineProperty(t2.prototype, "attributes", { get: function() {
            return this._attributeList;
          }, enumerable: true, configurable: true }), t2.prototype.getAttributeNames = function() {
            var e3, t3, r2 = [];
            try {
              for (var n2 = o(this._attributeList), i2 = n2.next(); !i2.done; i2 = n2.next()) {
                var a2 = i2.value;
                r2.push(a2._qualifiedName);
              }
            } catch (t4) {
              e3 = { error: t4 };
            } finally {
              try {
                i2 && !i2.done && (t3 = n2.return) && t3.call(n2);
              } finally {
                if (e3) throw e3.error;
              }
            }
            return r2;
          }, t2.prototype.getAttribute = function(e3) {
            var t3 = h.element_getAnAttributeByName(e3, this);
            return t3 ? t3._value : null;
          }, t2.prototype.getAttributeNS = function(e3, t3) {
            var r2 = h.element_getAnAttributeByNamespaceAndLocalName(e3, t3, this);
            return r2 ? r2._value : null;
          }, t2.prototype.setAttribute = function(e3, t3) {
            if (!h.xml_isName(e3)) throw new l.InvalidCharacterError();
            this._namespace === c.namespace.HTML && "html" === this._nodeDocument._type && (e3 = e3.toLowerCase());
            for (var r2 = null, n2 = 0; n2 < this._attributeList.length; n2++) {
              var i2 = this._attributeList[n2];
              if (i2._qualifiedName === e3) {
                r2 = i2;
                break;
              }
            }
            if (null === r2) return (r2 = h.create_attr(this._nodeDocument, e3))._value = t3, void h.element_append(r2, this);
            h.element_change(r2, this, t3);
          }, t2.prototype.setAttributeNS = function(e3, t3, r2) {
            var n2 = a(h.namespace_validateAndExtract(e3, t3), 3), i2 = n2[0], o2 = n2[1], s2 = n2[2];
            h.element_setAnAttributeValue(this, s2, r2, o2, i2);
          }, t2.prototype.removeAttribute = function(e3) {
            h.element_removeAnAttributeByName(e3, this);
          }, t2.prototype.removeAttributeNS = function(e3, t3) {
            h.element_removeAnAttributeByNamespaceAndLocalName(e3, t3, this);
          }, t2.prototype.hasAttribute = function(e3) {
            this._namespace === c.namespace.HTML && "html" === this._nodeDocument._type && (e3 = e3.toLowerCase());
            for (var t3 = 0; t3 < this._attributeList.length; t3++) {
              if (this._attributeList[t3]._qualifiedName === e3) return true;
            }
            return false;
          }, t2.prototype.toggleAttribute = function(e3, t3) {
            if (!h.xml_isName(e3)) throw new l.InvalidCharacterError();
            this._namespace === c.namespace.HTML && "html" === this._nodeDocument._type && (e3 = e3.toLowerCase());
            for (var r2 = null, n2 = 0; n2 < this._attributeList.length; n2++) {
              var i2 = this._attributeList[n2];
              if (i2._qualifiedName === e3) {
                r2 = i2;
                break;
              }
            }
            return null === r2 ? (void 0 === t3 || true === t3) && ((r2 = h.create_attr(this._nodeDocument, e3))._value = "", h.element_append(r2, this), true) : void 0 !== t3 && false !== t3 || (h.element_removeAnAttributeByName(e3, this), false);
          }, t2.prototype.hasAttributeNS = function(e3, t3) {
            for (var r2 = e3 || null, n2 = 0; n2 < this._attributeList.length; n2++) {
              var i2 = this._attributeList[n2];
              if (i2._namespace === r2 && i2._localName === t3) return true;
            }
            return false;
          }, t2.prototype.getAttributeNode = function(e3) {
            return h.element_getAnAttributeByName(e3, this);
          }, t2.prototype.getAttributeNodeNS = function(e3, t3) {
            return h.element_getAnAttributeByNamespaceAndLocalName(e3, t3, this);
          }, t2.prototype.setAttributeNode = function(e3) {
            return h.element_setAnAttribute(e3, this);
          }, t2.prototype.setAttributeNodeNS = function(e3) {
            return h.element_setAnAttribute(e3, this);
          }, t2.prototype.removeAttributeNode = function(e3) {
            for (var t3 = false, r2 = 0; r2 < this._attributeList.length; r2++) {
              if (this._attributeList[r2] === e3) {
                t3 = true;
                break;
              }
            }
            if (!t3) throw new l.NotFoundError();
            return h.element_remove(e3, this), e3;
          }, t2.prototype.attachShadow = function(e3) {
            if (this._namespace !== c.namespace.HTML) throw new l.NotSupportedError();
            if (!h.customElement_isValidCustomElementName(this._localName) && !h.customElement_isValidShadowHostName(this._localName)) throw new l.NotSupportedError();
            if (h.customElement_isValidCustomElementName(this._localName) || null !== this._is) {
              var t3 = h.customElement_lookUpACustomElementDefinition(this._nodeDocument, this._namespace, this._localName, this._is);
              if (null !== t3 && true === t3.disableShadow) throw new l.NotSupportedError();
            }
            if (null !== this._shadowRoot) throw new l.NotSupportedError();
            var r2 = h.create_shadowRoot(this._nodeDocument, this);
            return r2._mode = e3.mode, this._shadowRoot = r2, r2;
          }, Object.defineProperty(t2.prototype, "shadowRoot", { get: function() {
            var e3 = this._shadowRoot;
            return null === e3 || "closed" === e3.mode ? null : e3;
          }, enumerable: true, configurable: true }), t2.prototype.closest = function(e3) {
            throw new l.NotImplementedError();
          }, t2.prototype.matches = function(e3) {
            throw new l.NotImplementedError();
          }, t2.prototype.webkitMatchesSelector = function(e3) {
            return this.matches(e3);
          }, t2.prototype.getElementsByTagName = function(e3) {
            return h.node_listOfElementsWithQualifiedName(e3, this);
          }, t2.prototype.getElementsByTagNameNS = function(e3, t3) {
            return h.node_listOfElementsWithNamespace(e3, t3, this);
          }, t2.prototype.getElementsByClassName = function(e3) {
            return h.node_listOfElementsWithClassNames(e3, this);
          }, t2.prototype.insertAdjacentElement = function(e3, t3) {
            return h.element_insertAdjacent(this, e3, t3);
          }, t2.prototype.insertAdjacentText = function(e3, t3) {
            var r2 = h.create_text(this._nodeDocument, t3);
            h.element_insertAdjacent(this, e3, r2);
          }, Object.defineProperty(t2.prototype, "_qualifiedName", { get: function() {
            return this._namespacePrefix ? this._namespacePrefix + ":" + this._localName : this._localName;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "_htmlUppercasedQualifiedName", { get: function() {
            var e3 = this._qualifiedName;
            return this._namespace === c.namespace.HTML && "html" === this._nodeDocument._type && (e3 = e3.toUpperCase()), e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "children", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "firstElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "lastElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "childElementCount", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), t2.prototype.prepend = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.append = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelector = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelectorAll = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, Object.defineProperty(t2.prototype, "previousElementSibling", { get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nextElementSibling", { get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
          }, enumerable: true, configurable: true }), t2.prototype.before = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.after = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.replaceWith = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.remove = function() {
            throw new Error("Mixin: ChildNode not implemented.");
          }, Object.defineProperty(t2.prototype, "assignedSlot", { get: function() {
            throw new Error("Mixin: Slotable not implemented.");
          }, enumerable: true, configurable: true }), t2._create = function(e3, r2, n2, i2) {
            void 0 === n2 && (n2 = null), void 0 === i2 && (i2 = null);
            var o2 = new t2();
            return o2._localName = r2, o2._namespace = n2, o2._namespacePrefix = i2, o2._nodeDocument = e3, o2;
          }, t2;
        }(u.NodeImpl);
        t.ElementImpl = f, p.idl_defineConst(f.prototype, "_nodeType", s.NodeType.Element);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(2), a = r(34), s = r(12), u = function(e2) {
          function t2(t3) {
            void 0 === t3 && (t3 = null);
            var r2 = e2.call(this) || this;
            return r2._children = /* @__PURE__ */ new Set(), r2._host = t3, r2;
          }
          return i(t2, e2), t2.prototype.getElementById = function(e3) {
            throw new Error("Mixin: NonElementParentNode not implemented.");
          }, Object.defineProperty(t2.prototype, "children", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "firstElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "lastElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "childElementCount", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), t2.prototype.prepend = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.append = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelector = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelectorAll = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2._create = function(e3, r2) {
            void 0 === r2 && (r2 = null);
            var n2 = new t2(r2);
            return n2._nodeDocument = e3, n2;
          }, t2;
        }(a.NodeImpl);
        t.DocumentFragmentImpl = u, s.idl_defineConst(u.prototype, "_nodeType", o.NodeType.DocumentFragment);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(2), s = r(71), u = r(0), l = r(12), c = function(e2) {
          function t2(t3) {
            void 0 === t3 && (t3 = "");
            var r2 = e2.call(this, t3) || this;
            return r2._name = "", r2._assignedSlot = null, r2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "wholeText", { get: function() {
            var e3, t3, r2 = "";
            try {
              for (var n2 = o(u.text_contiguousTextNodes(this, true)), i2 = n2.next(); !i2.done; i2 = n2.next()) {
                r2 += i2.value._data;
              }
            } catch (t4) {
              e3 = { error: t4 };
            } finally {
              try {
                i2 && !i2.done && (t3 = n2.return) && t3.call(n2);
              } finally {
                if (e3) throw e3.error;
              }
            }
            return r2;
          }, enumerable: true, configurable: true }), t2.prototype.splitText = function(e3) {
            return u.text_split(this, e3);
          }, Object.defineProperty(t2.prototype, "assignedSlot", { get: function() {
            throw new Error("Mixin: Slotable not implemented.");
          }, enumerable: true, configurable: true }), t2._create = function(e3, r2) {
            void 0 === r2 && (r2 = "");
            var n2 = new t2(r2);
            return n2._nodeDocument = e3, n2;
          }, t2;
        }(s.CharacterDataImpl);
        t.TextImpl = c, l.idl_defineConst(c.prototype, "_nodeType", a.NodeType.Text);
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "_startNode", { get: function() {
            return this._start[0];
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_startOffset", { get: function() {
            return this._start[1];
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_endNode", { get: function() {
            return this._end[0];
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_endOffset", { get: function() {
            return this._end[1];
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_collapsed", { get: function() {
            return this._start[0] === this._end[0] && this._start[1] === this._end[1];
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "startContainer", { get: function() {
            return this._startNode;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "startOffset", { get: function() {
            return this._startOffset;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "endContainer", { get: function() {
            return this._endNode;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "endOffset", { get: function() {
            return this._endOffset;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "collapsed", { get: function() {
            return this._collapsed;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.AbstractRangeImpl = n;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(2), i = function() {
          function e2(e3) {
            this._activeFlag = false, this._root = e3, this._whatToShow = n.WhatToShow.All, this._filter = null;
          }
          return Object.defineProperty(e2.prototype, "root", { get: function() {
            return this._root;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "whatToShow", { get: function() {
            return this._whatToShow;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "filter", { get: function() {
            return this._filter;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.TraverserImpl = i;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(2), i = r(0), o = r(12), a = function() {
          function e2(e3, t2) {
            this._target = null, this._relatedTarget = null, this._touchTargetList = [], this._path = [], this._currentTarget = null, this._eventPhase = n.EventPhase.None, this._stopPropagationFlag = false, this._stopImmediatePropagationFlag = false, this._canceledFlag = false, this._inPassiveListenerFlag = false, this._composedFlag = false, this._initializedFlag = false, this._dispatchFlag = false, this._isTrusted = false, this._bubbles = false, this._cancelable = false, this._type = e3, t2 && (this._bubbles = t2.bubbles || false, this._cancelable = t2.cancelable || false, this._composedFlag = t2.composed || false), this._initializedFlag = true, this._timeStamp = (/* @__PURE__ */ new Date()).getTime();
          }
          return Object.defineProperty(e2.prototype, "type", { get: function() {
            return this._type;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "target", { get: function() {
            return this._target;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "srcElement", { get: function() {
            return this._target;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "currentTarget", { get: function() {
            return this._currentTarget;
          }, enumerable: true, configurable: true }), e2.prototype.composedPath = function() {
            var e3 = [], t2 = this._path;
            if (0 === t2.length) return e3;
            var r2 = this._currentTarget;
            if (null === r2) throw new Error("Event currentTarget is null.");
            e3.push(r2);
            for (var n2 = 0, i2 = 0, o2 = t2.length - 1; o2 >= 0; ) {
              if (t2[o2].rootOfClosedTree && i2++, t2[o2].invocationTarget === r2) {
                n2 = o2;
                break;
              }
              t2[o2].slotInClosedTree && i2--, o2--;
            }
            var a2 = i2, s = i2;
            for (o2 = n2 - 1; o2 >= 0; ) t2[o2].rootOfClosedTree && a2++, a2 <= s && e3.unshift(t2[o2].invocationTarget), t2[o2].slotInClosedTree && --a2 < s && (s = a2), o2--;
            for (a2 = i2, s = i2, o2 = n2 + 1; o2 < t2.length; ) t2[o2].slotInClosedTree && a2++, a2 <= s && e3.push(t2[o2].invocationTarget), t2[o2].rootOfClosedTree && --a2 < s && (s = a2), o2++;
            return e3;
          }, Object.defineProperty(e2.prototype, "eventPhase", { get: function() {
            return this._eventPhase;
          }, enumerable: true, configurable: true }), e2.prototype.stopPropagation = function() {
            this._stopPropagationFlag = true;
          }, Object.defineProperty(e2.prototype, "cancelBubble", { get: function() {
            return this._stopPropagationFlag;
          }, set: function(e3) {
            e3 && this.stopPropagation();
          }, enumerable: true, configurable: true }), e2.prototype.stopImmediatePropagation = function() {
            this._stopPropagationFlag = true, this._stopImmediatePropagationFlag = true;
          }, Object.defineProperty(e2.prototype, "bubbles", { get: function() {
            return this._bubbles;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "cancelable", { get: function() {
            return this._cancelable;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "returnValue", { get: function() {
            return !this._canceledFlag;
          }, set: function(e3) {
            e3 || i.event_setTheCanceledFlag(this);
          }, enumerable: true, configurable: true }), e2.prototype.preventDefault = function() {
            i.event_setTheCanceledFlag(this);
          }, Object.defineProperty(e2.prototype, "defaultPrevented", { get: function() {
            return this._canceledFlag;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "composed", { get: function() {
            return this._composedFlag;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "isTrusted", { get: function() {
            return this._isTrusted;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "timeStamp", { get: function() {
            return this._timeStamp;
          }, enumerable: true, configurable: true }), e2.prototype.initEvent = function(e3, t2, r2) {
            void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false), this._dispatchFlag || i.event_initialize(this, e3, t2, r2);
          }, e2.NONE = 0, e2.CAPTURING_PHASE = 1, e2.AT_TARGET = 2, e2.BUBBLING_PHASE = 3, e2;
        }();
        t.EventImpl = a, o.idl_defineConst(a.prototype, "NONE", 0), o.idl_defineConst(a.prototype, "CAPTURING_PHASE", 1), o.idl_defineConst(a.prototype, "AT_TARGET", 2), o.idl_defineConst(a.prototype, "BUBBLING_PHASE", 3);
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(2), i = r(9);
        t.traversal_filter = function(e2, t2) {
          if (e2._activeFlag) throw new i.InvalidStateError();
          var r2 = 1 << t2._nodeType - 1;
          if (0 == (e2.whatToShow & r2)) return n.FilterResult.Skip;
          if (!e2.filter) return n.FilterResult.Accept;
          e2._activeFlag = true;
          var o = n.FilterResult.Reject;
          try {
            o = e2.filter.acceptNode(t2);
          } catch (t3) {
            throw e2._activeFlag = false, t3;
          }
          return e2._activeFlag = false, o;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(6), a = r(3), s = r(1), u = r(99), l = r(73), c = r(17), h = r(173), p = r(30), f = r(52), d = r(37);
        t.document_elementInterface = function(e2, t2) {
          return u.ElementImpl;
        }, t.document_internalCreateElementNS = function(e2, t2, r2, i2) {
          var o2 = n(h.namespace_validateAndExtract(t2, r2), 3), a2 = o2[0], u2 = o2[1], l2 = o2[2], c2 = null;
          return void 0 !== i2 && (c2 = s.isString(i2) ? i2 : i2.is), f.element_createAnElement(e2, l2, a2, u2, c2, true);
        }, t.document_adopt = function(e2, t2) {
          var r2, n2;
          if (e2._nodeDocument !== t2 || null !== e2._parent) {
            var s2 = e2._nodeDocument;
            if (e2._parent && d.mutation_remove(e2, e2._parent), t2 !== s2) for (var u2 = c.tree_getFirstDescendantNode(e2, true, true); null !== u2; ) {
              if (u2._nodeDocument = t2, a.Guard.isElementNode(u2)) try {
                for (var h2 = (r2 = void 0, i(u2._attributeList._asArray())), f2 = h2.next(); !f2.done; f2 = h2.next()) {
                  f2.value._nodeDocument = t2;
                }
              } catch (e3) {
                r2 = { error: e3 };
              } finally {
                try {
                  f2 && !f2.done && (n2 = h2.return) && n2.call(h2);
                } finally {
                  if (r2) throw r2.error;
                }
              }
              o.dom.features.customElements && a.Guard.isElementNode(u2) && "custom" === u2._customElementState && l.customElement_enqueueACustomElementCallbackReaction(u2, "adoptedCallback", [s2, t2]), o.dom.features.steps && p.dom_runAdoptingSteps(u2, s2), u2 = c.tree_getNextDescendantNode(e2, u2, true, true);
            }
          }
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(3), a = r(9), s = r(17), u = r(51), l = r(30);
        t.characterData_replaceData = function(e2, t2, r2, c) {
          var h, p, f = s.tree_nodeLength(e2);
          if (t2 > f) throw new a.IndexSizeError("Offset exceeds character data length. Offset: " + t2 + ", Length: " + f + ", Node is " + e2.nodeName + ".");
          t2 + r2 > f && (r2 = f - t2), i.dom.features.mutationObservers && u.observer_queueMutationRecord("characterData", e2, null, null, e2._data, [], [], null, null);
          var d = e2._data.substring(0, t2) + c + e2._data.substring(t2 + r2);
          e2._data = d;
          try {
            for (var m = n(i.dom.rangeList), y = m.next(); !y.done; y = m.next()) {
              var v = y.value;
              v._start[0] === e2 && v._start[1] > t2 && v._start[1] <= t2 + r2 && (v._start[1] = t2), v._end[0] === e2 && v._end[1] > t2 && v._end[1] <= t2 + r2 && (v._end[1] = t2), v._start[0] === e2 && v._start[1] > t2 + r2 && (v._start[1] += c.length - r2), v._end[0] === e2 && v._end[1] > t2 + r2 && (v._end[1] += c.length - r2);
            }
          } catch (e3) {
            h = { error: e3 };
          } finally {
            try {
              y && !y.done && (p = m.return) && p.call(m);
            } finally {
              if (h) throw h.error;
            }
          }
          i.dom.features.steps && o.Guard.isTextNode(e2) && null !== e2._parent && l.dom_runChildTextContentChangeSteps(e2._parent);
        }, t.characterData_substringData = function(e2, t2, r2) {
          var n2 = s.tree_nodeLength(e2);
          if (t2 > n2) throw new a.IndexSizeError("Offset exceeds character data length. Offset: " + t2 + ", Length: " + n2 + ", Node is " + e2.nodeName + ".");
          return t2 + r2 > n2 ? e2._data.substr(t2) : e2._data.substr(t2, r2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, i = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++) e2 = e2.concat(n(arguments[t2]));
          return e2;
        }, o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(7);
        function s(e2) {
          var t2 = a.string.splitAStringOnASCIIWhitespace(e2);
          return new Set(t2);
        }
        function u(e2) {
          return i(e2).join(" ");
        }
        t.orderedSet_parse = s, t.orderedSet_serialize = u, t.orderedSet_sanitize = function(e2) {
          return u(s(e2));
        }, t.orderedSet_contains = function(e2, t2, r2) {
          var n2, i2, a2, s2;
          try {
            for (var u2 = o(t2), l = u2.next(); !l.done; l = u2.next()) {
              var c = l.value, h = false;
              try {
                for (var p = (a2 = void 0, o(e2)), f = p.next(); !f.done; f = p.next()) {
                  var d = f.value;
                  if (r2) {
                    if (d === c) {
                      h = true;
                      break;
                    }
                  } else if (d.toUpperCase() === c.toUpperCase()) {
                    h = true;
                    break;
                  }
                }
              } catch (e3) {
                a2 = { error: e3 };
              } finally {
                try {
                  f && !f.done && (s2 = p.return) && s2.call(p);
                } finally {
                  if (a2) throw a2.error;
                }
              }
              if (!h) return false;
            }
          } catch (e3) {
            n2 = { error: e3 };
          } finally {
            try {
              l && !l.done && (i2 = u2.return) && i2.call(u2);
            } finally {
              if (n2) throw n2.error;
            }
          }
          return true;
        };
      }, function(e, t, r) {
        "use strict";
        r(179), Object.defineProperty(t, "__esModule", { value: true });
        var n = r(262), i = r(110), o = r(1);
        i.dom.setFeatures(false), t.createDocument = function() {
          var e2 = new n.DOMImplementation().createDocument(null, "root", null);
          return e2.documentElement && e2.removeChild(e2.documentElement), e2;
        }, t.sanitizeInput = function(e2, t2) {
          if (null == e2) return e2;
          if (void 0 === t2) return e2 + "";
          var r2 = "";
          e2 += "";
          for (var n2 = 0; n2 < e2.length; n2++) {
            var i2 = e2.charCodeAt(n2);
            if (9 === i2 || 10 === i2 || 13 === i2 || i2 >= 32 && i2 <= 55295 || i2 >= 57344 && i2 <= 65533) r2 += e2.charAt(n2);
            else if (i2 >= 55296 && i2 <= 56319 && n2 < e2.length - 1) {
              var a = e2.charCodeAt(n2 + 1);
              a >= 56320 && a <= 57343 ? (i2 = 1024 * (i2 - 55296) + a - 56320 + 65536, r2 += String.fromCodePoint(i2), n2++) : r2 += o.isString(t2) ? t2 : t2(e2.charAt(n2), n2, e2);
            } else r2 += o.isString(t2) ? t2 : t2(e2.charAt(n2), n2, e2);
          }
          return r2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(1), i = r(153);
        t.AbortController = i.AbortControllerImpl;
        var o = r(154);
        t.AbortSignal = o.AbortSignalImpl;
        var a = r(102);
        t.AbstractRange = a.AbstractRangeImpl;
        var s = r(157);
        t.Attr = s.AttrImpl;
        var u = r(158);
        t.CDATASection = u.CDATASectionImpl;
        var l = r(71);
        t.CharacterData = l.CharacterDataImpl;
        var c = r(263), h = r(159);
        t.Comment = h.CommentImpl;
        var p = r(171);
        t.CustomEvent = p.CustomEventImpl;
        var f = r(100);
        t.DocumentFragment = f.DocumentFragmentImpl;
        var d = r(98);
        t.Document = d.DocumentImpl;
        var m = r(264), y = r(155);
        t.DocumentType = y.DocumentTypeImpl;
        var v = r(6);
        t.dom = v.dom;
        var _ = r(148);
        t.DOMImplementation = _.DOMImplementationImpl;
        var g = r(170);
        t.DOMTokenList = g.DOMTokenListImpl;
        var b = r(99);
        t.Element = b.ElementImpl;
        var x = r(104);
        t.Event = x.EventImpl;
        var w = r(70);
        t.EventTarget = w.EventTargetImpl;
        var E = r(161);
        t.HTMLCollection = E.HTMLCollectionImpl;
        var D = r(265);
        t.MutationObserver = D.MutationObserverImpl;
        var S = r(169);
        t.MutationRecord = S.MutationRecordImpl;
        var C = r(164);
        t.NamedNodeMap = C.NamedNodeMapImpl;
        var A = r(168);
        t.NodeFilter = A.NodeFilterImpl;
        var N = r(34);
        t.Node = N.NodeImpl;
        var T = r(166);
        t.NodeIterator = T.NodeIteratorImpl;
        var O = r(162);
        t.NodeList = O.NodeListImpl;
        var F = r(163);
        t.NodeListStatic = F.NodeListStaticImpl;
        var k = r(266), P = r(267), I = r(268), L = r(160);
        t.ProcessingInstruction = L.ProcessingInstructionImpl;
        var M = r(165);
        t.Range = M.RangeImpl;
        var B = r(156);
        t.ShadowRoot = B.ShadowRootImpl;
        var j = r(269), R = r(270);
        t.StaticRange = R.StaticRangeImpl;
        var z = r(101);
        t.Text = z.TextImpl;
        var U = r(103);
        t.Traverser = U.TraverserImpl;
        var G = r(167);
        t.TreeWalker = G.TreeWalkerImpl;
        var X = r(149);
        t.Window = X.WindowImpl;
        var q = r(151);
        t.XMLDocument = q.XMLDocumentImpl, n.applyMixin(b.ElementImpl, c.ChildNodeImpl), n.applyMixin(l.CharacterDataImpl, c.ChildNodeImpl), n.applyMixin(y.DocumentTypeImpl, c.ChildNodeImpl), n.applyMixin(d.DocumentImpl, m.DocumentOrShadowRootImpl), n.applyMixin(B.ShadowRootImpl, m.DocumentOrShadowRootImpl), n.applyMixin(b.ElementImpl, k.NonDocumentTypeChildNodeImpl), n.applyMixin(l.CharacterDataImpl, k.NonDocumentTypeChildNodeImpl), n.applyMixin(d.DocumentImpl, P.NonElementParentNodeImpl), n.applyMixin(f.DocumentFragmentImpl, P.NonElementParentNodeImpl), n.applyMixin(d.DocumentImpl, I.ParentNodeImpl), n.applyMixin(f.DocumentFragmentImpl, I.ParentNodeImpl), n.applyMixin(b.ElementImpl, I.ParentNodeImpl), n.applyMixin(z.TextImpl, j.SlotableImpl), n.applyMixin(b.ElementImpl, j.SlotableImpl);
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), function(e2) {
          e2[e2.EOF = 0] = "EOF", e2[e2.Declaration = 1] = "Declaration", e2[e2.DocType = 2] = "DocType", e2[e2.Element = 3] = "Element", e2[e2.Text = 4] = "Text", e2[e2.CDATA = 5] = "CDATA", e2[e2.PI = 6] = "PI", e2[e2.Comment = 7] = "Comment", e2[e2.ClosingTag = 8] = "ClosingTag";
        }(t.TokenType || (t.TokenType = {}));
      }, function(e, t, r) {
        "use strict";
        r(64), r(20), r(66);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(1), a = function(e2) {
          function t2() {
            return null !== e2 && e2.apply(this, arguments) || this;
          }
          return i(t2, e2), t2.prototype._parse = function(e3, t3) {
            var r2 = this, n2 = this._builderOptions, i2 = null;
            return o.isFunction(t3) ? i2 = this.parse(e3, t3.apply(this)) : o.isArray(t3) || o.isSet(t3) ? o.forEachArray(t3, function(t4) {
              return i2 = r2.parse(e3, t4);
            }, this) : o.isMap(t3) || o.isObject(t3) ? o.forEachObject(t3, function(t4, a2) {
              if (o.isFunction(a2) && (a2 = a2.apply(r2)), n2.ignoreConverters || 0 !== t4.indexOf(n2.convert.att)) if (n2.ignoreConverters || 0 !== t4.indexOf(n2.convert.text)) if (n2.ignoreConverters || 0 !== t4.indexOf(n2.convert.cdata)) if (n2.ignoreConverters || 0 !== t4.indexOf(n2.convert.comment)) if (n2.ignoreConverters || 0 !== t4.indexOf(n2.convert.ins)) if ((o.isArray(a2) || o.isSet(a2)) && o.isEmpty(a2)) ;
              else if ((o.isMap(a2) || o.isObject(a2)) && o.isEmpty(a2)) i2 = r2.element(e3, void 0, r2.sanitize(t4)) || i2;
              else if (n2.keepNullNodes || null != a2) if (o.isArray(a2) || o.isSet(a2)) o.forEachArray(a2, function(n3) {
                var o2 = {};
                o2[t4] = n3, i2 = r2.parse(e3, o2);
              }, r2);
              else if (o.isMap(a2) || o.isObject(a2)) {
                (s = r2.element(e3, void 0, r2.sanitize(t4))) && (i2 = s, r2.parse(s, a2));
              } else if (null != a2 && "" !== a2) {
                var s;
                (s = r2.element(e3, void 0, r2.sanitize(t4))) && (i2 = s, r2.text(s, r2._decodeText(r2.sanitize(a2))));
              } else i2 = r2.element(e3, void 0, r2.sanitize(t4)) || i2;
              else ;
              else if (o.isString(a2)) {
                var u = a2.indexOf(" "), l = -1 === u ? a2 : a2.substr(0, u), c = -1 === u ? "" : a2.substr(u + 1);
                i2 = r2.instruction(e3, r2.sanitize(l), r2.sanitize(c)) || i2;
              } else o.isArray(a2) || o.isSet(a2) ? o.forEachArray(a2, function(t5) {
                var n3 = t5.indexOf(" "), o2 = -1 === n3 ? t5 : t5.substr(0, n3), a3 = -1 === n3 ? "" : t5.substr(n3 + 1);
                i2 = r2.instruction(e3, r2.sanitize(o2), r2.sanitize(a3)) || i2;
              }, r2) : o.forEachObject(a2, function(t5, n3) {
                return i2 = r2.instruction(e3, r2.sanitize(t5), r2.sanitize(n3)) || i2;
              }, r2);
              else o.isArray(a2) || o.isSet(a2) ? o.forEachArray(a2, function(t5) {
                return i2 = r2.comment(e3, r2.sanitize(t5)) || i2;
              }, r2) : i2 = r2.comment(e3, r2.sanitize(a2)) || i2;
              else o.isArray(a2) || o.isSet(a2) ? o.forEachArray(a2, function(t5) {
                return i2 = r2.cdata(e3, r2.sanitize(t5)) || i2;
              }, r2) : i2 = r2.cdata(e3, r2.sanitize(a2)) || i2;
              else i2 = o.isMap(a2) || o.isObject(a2) ? r2.parse(e3, a2) : r2.text(e3, r2._decodeText(r2.sanitize(a2))) || i2;
              else if (t4 === n2.convert.att) {
                if (o.isArray(a2) || o.isSet(a2)) throw new Error("Invalid attribute: " + a2.toString() + ". " + e3._debugInfo());
                o.forEachObject(a2, function(t5, n3) {
                  i2 = r2.attribute(e3, void 0, r2.sanitize(t5), r2._decodeAttributeValue(r2.sanitize(n3))) || i2;
                });
              } else i2 = r2.attribute(e3, void 0, r2.sanitize(t4.substr(n2.convert.att.length)), r2._decodeAttributeValue(r2.sanitize(a2))) || i2;
            }, this) : (n2.keepNullNodes || null != t3) && (i2 = this.text(e3, this._decodeText(this.sanitize(t3))) || i2), i2 || e3;
          }, t2;
        }(r(75).BaseReader);
        t.ObjectReader = a;
      }, function(e, t, r) {
        "use strict";
        var n = r(39);
        e.exports = new n({ explicit: [r(286), r(287), r(288)] });
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function(e2) {
          this.level = 0, this._builderOptions = e2, this._writerOptions = e2;
        };
        t.BaseCBWriter = n;
      }, function(e, t, r) {
        var n = r(16), i = r(8), o = r(116);
        e.exports = !n && !i(function() {
          return 7 != Object.defineProperty(o("div"), "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(e, t, r) {
        var n = r(11), i = r(13), o = n.document, a = i(o) && i(o.createElement);
        e.exports = function(e2) {
          return a ? o.createElement(e2) : {};
        };
      }, function(e, t, r) {
        var n = r(118), i = Function.toString;
        "function" != typeof n.inspectSource && (n.inspectSource = function(e2) {
          return i.call(e2);
        }), e.exports = n.inspectSource;
      }, function(e, t, r) {
        var n = r(11), i = r(80), o = n["__core-js_shared__"] || i("__core-js_shared__", {});
        e.exports = o;
      }, function(e, t, r) {
        var n = r(14), i = r(187), o = r(55), a = r(15);
        e.exports = function(e2, t2) {
          for (var r2 = i(t2), s = a.f, u = o.f, l = 0; l < r2.length; l++) {
            var c = r2[l];
            n(e2, c) || s(e2, c, u(t2, c));
          }
        };
      }, function(e, t, r) {
        var n = r(11);
        e.exports = n;
      }, function(e, t, r) {
        var n = r(14), i = r(24), o = r(122).indexOf, a = r(45);
        e.exports = function(e2, t2) {
          var r2, s = i(e2), u = 0, l = [];
          for (r2 in s) !n(a, r2) && n(s, r2) && l.push(r2);
          for (; t2.length > u; ) n(s, r2 = t2[u++]) && (~o(l, r2) || l.push(r2));
          return l;
        };
      }, function(e, t, r) {
        var n = r(24), i = r(26), o = r(83), a = function(e2) {
          return function(t2, r2, a2) {
            var s, u = n(t2), l = i(u.length), c = o(a2, l);
            if (e2 && r2 != r2) {
              for (; l > c; ) if ((s = u[c++]) != s) return true;
            } else for (; l > c; c++) if ((e2 || c in u) && u[c] === r2) return e2 || c || 0;
            return !e2 && -1;
          };
        };
        e.exports = { includes: a(true), indexOf: a(false) };
      }, function(e, t, r) {
        var n = r(8), i = /#|\.prototype\./, o = function(e2, t2) {
          var r2 = s[a(e2)];
          return r2 == l || r2 != u && ("function" == typeof t2 ? n(t2) : !!t2);
        }, a = o.normalize = function(e2) {
          return String(e2).replace(i, ".").toLowerCase();
        }, s = o.data = {}, u = o.NATIVE = "N", l = o.POLYFILL = "P";
        e.exports = o;
      }, function(e, t, r) {
        var n = r(86);
        e.exports = n && !Symbol.sham && "symbol" == typeof Symbol.iterator;
      }, function(e, t, r) {
        var n = r(5);
        t.f = n;
      }, function(e, t, r) {
        var n = r(120), i = r(14), o = r(125), a = r(15).f;
        e.exports = function(e2) {
          var t2 = n.Symbol || (n.Symbol = {});
          i(t2, e2) || a(t2, e2, { value: o.f(e2) });
        };
      }, function(e, t) {
        e.exports = function(e2) {
          if ("function" != typeof e2) throw TypeError(String(e2) + " is not a function");
          return e2;
        };
      }, function(e, t, r) {
        var n = r(13), i = r(59), o = r(5)("species");
        e.exports = function(e2, t2) {
          var r2;
          return i(e2) && ("function" != typeof (r2 = e2.constructor) || r2 !== Array && !i(r2.prototype) ? n(r2) && null === (r2 = r2[o]) && (r2 = void 0) : r2 = void 0), new (void 0 === r2 ? Array : r2)(0 === t2 ? 0 : t2);
        };
      }, function(e, t, r) {
        var n, i, o = r(11), a = r(193), s = o.process, u = s && s.versions, l = u && u.v8;
        l ? i = (n = l.split("."))[0] + n[1] : a && (!(n = a.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = a.match(/Chrome\/(\d+)/)) && (i = n[1]), e.exports = i && +i;
      }, function(e, t, r) {
        var n = r(5), i = r(60), o = r(15), a = n("unscopables"), s = Array.prototype;
        null == s[a] && o.f(s, a, { configurable: true, value: i(null) }), e.exports = function(e2) {
          s[a][e2] = true;
        };
      }, function(e, t, r) {
        "use strict";
        var n, i, o, a = r(132), s = r(21), u = r(14), l = r(5), c = r(44), h = l("iterator"), p = false;
        [].keys && ("next" in (o = [].keys()) ? (i = a(a(o))) !== Object.prototype && (n = i) : p = true), null == n && (n = {}), c || u(n, h) || s(n, h, function() {
          return this;
        }), e.exports = { IteratorPrototype: n, BUGGY_SAFARI_ITERATORS: p };
      }, function(e, t, r) {
        var n = r(14), i = r(27), o = r(57), a = r(196), s = o("IE_PROTO"), u = Object.prototype;
        e.exports = a ? Object.getPrototypeOf : function(e2) {
          return e2 = i(e2), n(e2, s) ? e2[s] : "function" == typeof e2.constructor && e2 instanceof e2.constructor ? e2.constructor.prototype : e2 instanceof Object ? u : null;
        };
      }, function(e, t, r) {
        var n = r(18), i = r(197);
        e.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
          var e2, t2 = false, r2 = {};
          try {
            (e2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(r2, []), t2 = r2 instanceof Array;
          } catch (e3) {
          }
          return function(r3, o) {
            return n(r3), i(o), t2 ? e2.call(r3, o) : r3.__proto__ = o, r3;
          };
        }() : void 0);
      }, function(e, t, r) {
        "use strict";
        var n = r(56), i = r(15), o = r(40);
        e.exports = function(e2, t2, r2) {
          var a = n(t2);
          a in e2 ? i.f(e2, a, o(0, r2)) : e2[a] = r2;
        };
      }, function(e, t, r) {
        var n = r(90), i = r(42), o = r(5)("toStringTag"), a = "Arguments" == i(/* @__PURE__ */ function() {
          return arguments;
        }());
        e.exports = n ? i : function(e2) {
          var t2, r2, n2;
          return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (r2 = function(e3, t3) {
            try {
              return e3[t3];
            } catch (e4) {
            }
          }(t2 = Object(e2), o)) ? r2 : a ? i(t2) : "Object" == (n2 = i(t2)) && "function" == typeof t2.callee ? "Arguments" : n2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(18);
        e.exports = function() {
          var e2 = n(this), t2 = "";
          return e2.global && (t2 += "g"), e2.ignoreCase && (t2 += "i"), e2.multiline && (t2 += "m"), e2.dotAll && (t2 += "s"), e2.unicode && (t2 += "u"), e2.sticky && (t2 += "y"), t2;
        };
      }, function(e, t, r) {
        var n = r(47), i = r(35), o = function(e2) {
          return function(t2, r2) {
            var o2, a, s = String(i(t2)), u = n(r2), l = s.length;
            return u < 0 || u >= l ? e2 ? "" : void 0 : (o2 = s.charCodeAt(u)) < 55296 || o2 > 56319 || u + 1 === l || (a = s.charCodeAt(u + 1)) < 56320 || a > 57343 ? e2 ? s.charAt(u) : o2 : e2 ? s.slice(u, u + 2) : a - 56320 + (o2 - 55296 << 10) + 65536;
          };
        };
        e.exports = { codeAt: o(false), charAt: o(true) };
      }, function(e, t, r) {
        var n = r(4), i = r(27), o = r(61);
        n({ target: "Object", stat: true, forced: r(8)(function() {
          o(1);
        }) }, { keys: function(e2) {
          return o(i(e2));
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(11), o = r(123), a = r(25), s = r(140), u = r(141), l = r(142), c = r(13), h = r(8), p = r(208), f = r(62), d = r(209);
        e.exports = function(e2, t2, r2) {
          var m = -1 !== e2.indexOf("Map"), y = -1 !== e2.indexOf("Weak"), v = m ? "set" : "add", _ = i[e2], g = _ && _.prototype, b = _, x = {}, w = function(e3) {
            var t3 = g[e3];
            a(g, e3, "add" == e3 ? function(e4) {
              return t3.call(this, 0 === e4 ? 0 : e4), this;
            } : "delete" == e3 ? function(e4) {
              return !(y && !c(e4)) && t3.call(this, 0 === e4 ? 0 : e4);
            } : "get" == e3 ? function(e4) {
              return y && !c(e4) ? void 0 : t3.call(this, 0 === e4 ? 0 : e4);
            } : "has" == e3 ? function(e4) {
              return !(y && !c(e4)) && t3.call(this, 0 === e4 ? 0 : e4);
            } : function(e4, r3) {
              return t3.call(this, 0 === e4 ? 0 : e4, r3), this;
            });
          };
          if (o(e2, "function" != typeof _ || !(y || g.forEach && !h(function() {
            new _().entries().next();
          })))) b = r2.getConstructor(t2, e2, m, v), s.REQUIRED = true;
          else if (o(e2, true)) {
            var E = new b(), D = E[v](y ? {} : -0, 1) != E, S = h(function() {
              E.has(1);
            }), C = p(function(e3) {
              new _(e3);
            }), A = !y && h(function() {
              for (var e3 = new _(), t3 = 5; t3--; ) e3[v](t3, t3);
              return !e3.has(-0);
            });
            C || ((b = t2(function(t3, r3) {
              l(t3, b, e2);
              var n2 = d(new _(), t3, b);
              return null != r3 && u(r3, n2[v], n2, m), n2;
            })).prototype = g, g.constructor = b), (S || A) && (w("delete"), w("has"), m && w("get")), (A || D) && w(v), y && g.clear && delete g.clear;
          }
          return x[e2] = b, n({ global: true, forced: b != _ }, x), f(b, e2), y || r2.setStrong(b, e2, m), b;
        };
      }, function(e, t, r) {
        var n = r(45), i = r(13), o = r(14), a = r(15).f, s = r(58), u = r(204), l = s("meta"), c = 0, h = Object.isExtensible || function() {
          return true;
        }, p = function(e2) {
          a(e2, l, { value: { objectID: "O" + ++c, weakData: {} } });
        }, f = e.exports = { REQUIRED: false, fastKey: function(e2, t2) {
          if (!i(e2)) return "symbol" == typeof e2 ? e2 : ("string" == typeof e2 ? "S" : "P") + e2;
          if (!o(e2, l)) {
            if (!h(e2)) return "F";
            if (!t2) return "E";
            p(e2);
          }
          return e2[l].objectID;
        }, getWeakData: function(e2, t2) {
          if (!o(e2, l)) {
            if (!h(e2)) return true;
            if (!t2) return false;
            p(e2);
          }
          return e2[l].weakData;
        }, onFreeze: function(e2) {
          return u && f.REQUIRED && h(e2) && !o(e2, l) && p(e2), e2;
        } };
        n[l] = true;
      }, function(e, t, r) {
        var n = r(18), i = r(205), o = r(26), a = r(87), s = r(206), u = r(207), l = function(e2, t2) {
          this.stopped = e2, this.result = t2;
        };
        (e.exports = function(e2, t2, r2, c, h) {
          var p, f, d, m, y, v, _, g = a(t2, r2, c ? 2 : 1);
          if (h) p = e2;
          else {
            if ("function" != typeof (f = s(e2))) throw TypeError("Target is not iterable");
            if (i(f)) {
              for (d = 0, m = o(e2.length); m > d; d++) if ((y = c ? g(n(_ = e2[d])[0], _[1]) : g(e2[d])) && y instanceof l) return y;
              return new l(false);
            }
            p = f.call(e2);
          }
          for (v = p.next; !(_ = v.call(p)).done; ) if ("object" == typeof (y = u(p, g, _.value, c)) && y && y instanceof l) return y;
          return new l(false);
        }).stop = function(e2) {
          return new l(true, e2);
        };
      }, function(e, t) {
        e.exports = function(e2, t2, r) {
          if (!(e2 instanceof t2)) throw TypeError("Incorrect " + (r ? r + " " : "") + "invocation");
          return e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(15).f, i = r(60), o = r(210), a = r(87), s = r(142), u = r(141), l = r(88), c = r(211), h = r(16), p = r(140).fastKey, f = r(43), d = f.set, m = f.getterFor;
        e.exports = { getConstructor: function(e2, t2, r2, l2) {
          var c2 = e2(function(e3, n2) {
            s(e3, c2, t2), d(e3, { type: t2, index: i(null), first: void 0, last: void 0, size: 0 }), h || (e3.size = 0), null != n2 && u(n2, e3[l2], e3, r2);
          }), f2 = m(t2), y = function(e3, t3, r3) {
            var n2, i2, o2 = f2(e3), a2 = v(e3, t3);
            return a2 ? a2.value = r3 : (o2.last = a2 = { index: i2 = p(t3, true), key: t3, value: r3, previous: n2 = o2.last, next: void 0, removed: false }, o2.first || (o2.first = a2), n2 && (n2.next = a2), h ? o2.size++ : e3.size++, "F" !== i2 && (o2.index[i2] = a2)), e3;
          }, v = function(e3, t3) {
            var r3, n2 = f2(e3), i2 = p(t3);
            if ("F" !== i2) return n2.index[i2];
            for (r3 = n2.first; r3; r3 = r3.next) if (r3.key == t3) return r3;
          };
          return o(c2.prototype, { clear: function() {
            for (var e3 = f2(this), t3 = e3.index, r3 = e3.first; r3; ) r3.removed = true, r3.previous && (r3.previous = r3.previous.next = void 0), delete t3[r3.index], r3 = r3.next;
            e3.first = e3.last = void 0, h ? e3.size = 0 : this.size = 0;
          }, delete: function(e3) {
            var t3 = f2(this), r3 = v(this, e3);
            if (r3) {
              var n2 = r3.next, i2 = r3.previous;
              delete t3.index[r3.index], r3.removed = true, i2 && (i2.next = n2), n2 && (n2.previous = i2), t3.first == r3 && (t3.first = n2), t3.last == r3 && (t3.last = i2), h ? t3.size-- : this.size--;
            }
            return !!r3;
          }, forEach: function(e3) {
            for (var t3, r3 = f2(this), n2 = a(e3, arguments.length > 1 ? arguments[1] : void 0, 3); t3 = t3 ? t3.next : r3.first; ) for (n2(t3.value, t3.key, this); t3 && t3.removed; ) t3 = t3.previous;
          }, has: function(e3) {
            return !!v(this, e3);
          } }), o(c2.prototype, r2 ? { get: function(e3) {
            var t3 = v(this, e3);
            return t3 && t3.value;
          }, set: function(e3, t3) {
            return y(this, 0 === e3 ? 0 : e3, t3);
          } } : { add: function(e3) {
            return y(this, e3 = 0 === e3 ? 0 : e3, e3);
          } }), h && n(c2.prototype, "size", { get: function() {
            return f2(this).size;
          } }), c2;
        }, setStrong: function(e2, t2, r2) {
          var n2 = t2 + " Iterator", i2 = m(t2), o2 = m(n2);
          l(e2, t2, function(e3, t3) {
            d(this, { type: n2, target: e3, state: i2(e3), kind: t3, last: void 0 });
          }, function() {
            for (var e3 = o2(this), t3 = e3.kind, r3 = e3.last; r3 && r3.removed; ) r3 = r3.previous;
            return e3.target && (e3.last = r3 = r3 ? r3.next : e3.state.first) ? "keys" == t3 ? { value: r3.key, done: false } : "values" == t3 ? { value: r3.value, done: false } : { value: [r3.key, r3.value], done: false } : (e3.target = void 0, { value: void 0, done: true });
          }, r2 ? "entries" : "values", !r2, true), c(t2);
        } };
      }, function(e, t, r) {
        "use strict";
        var n, i = r(4), o = r(55).f, a = r(26), s = r(222), u = r(35), l = r(224), c = r(44), h = "".endsWith, p = Math.min, f = l("endsWith");
        i({ target: "String", proto: true, forced: !!(c || f || (n = o(String.prototype, "endsWith"), !n || n.writable)) && !f }, { endsWith: function(e2) {
          var t2 = String(u(this));
          s(e2);
          var r2 = arguments.length > 1 ? arguments[1] : void 0, n2 = a(t2.length), i2 = void 0 === r2 ? n2 : p(a(r2), n2), o2 = String(e2);
          return h ? h.call(t2, o2, i2) : t2.slice(i2 - o2.length, i2) === o2;
        } });
      }, function(e, t, r) {
        "use strict";
        (function(e2) {
          var n = r(229), i = r(230), o = r(231);
          function a() {
            return u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
          }
          function s(e3, t2) {
            if (a() < t2) throw new RangeError("Invalid typed array length");
            return u.TYPED_ARRAY_SUPPORT ? (e3 = new Uint8Array(t2)).__proto__ = u.prototype : (null === e3 && (e3 = new u(t2)), e3.length = t2), e3;
          }
          function u(e3, t2, r2) {
            if (!(u.TYPED_ARRAY_SUPPORT || this instanceof u)) return new u(e3, t2, r2);
            if ("number" == typeof e3) {
              if ("string" == typeof t2) throw new Error("If encoding is specified then the first argument must be a string");
              return h(this, e3);
            }
            return l(this, e3, t2, r2);
          }
          function l(e3, t2, r2, n2) {
            if ("number" == typeof t2) throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && t2 instanceof ArrayBuffer ? function(e4, t3, r3, n3) {
              if (t3.byteLength, r3 < 0 || t3.byteLength < r3) throw new RangeError("'offset' is out of bounds");
              if (t3.byteLength < r3 + (n3 || 0)) throw new RangeError("'length' is out of bounds");
              t3 = void 0 === r3 && void 0 === n3 ? new Uint8Array(t3) : void 0 === n3 ? new Uint8Array(t3, r3) : new Uint8Array(t3, r3, n3);
              u.TYPED_ARRAY_SUPPORT ? (e4 = t3).__proto__ = u.prototype : e4 = p(e4, t3);
              return e4;
            }(e3, t2, r2, n2) : "string" == typeof t2 ? function(e4, t3, r3) {
              "string" == typeof r3 && "" !== r3 || (r3 = "utf8");
              if (!u.isEncoding(r3)) throw new TypeError('"encoding" must be a valid string encoding');
              var n3 = 0 | d(t3, r3), i2 = (e4 = s(e4, n3)).write(t3, r3);
              i2 !== n3 && (e4 = e4.slice(0, i2));
              return e4;
            }(e3, t2, r2) : function(e4, t3) {
              if (u.isBuffer(t3)) {
                var r3 = 0 | f(t3.length);
                return 0 === (e4 = s(e4, r3)).length || t3.copy(e4, 0, 0, r3), e4;
              }
              if (t3) {
                if ("undefined" != typeof ArrayBuffer && t3.buffer instanceof ArrayBuffer || "length" in t3) return "number" != typeof t3.length || (n3 = t3.length) != n3 ? s(e4, 0) : p(e4, t3);
                if ("Buffer" === t3.type && o(t3.data)) return p(e4, t3.data);
              }
              var n3;
              throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
            }(e3, t2);
          }
          function c(e3) {
            if ("number" != typeof e3) throw new TypeError('"size" argument must be a number');
            if (e3 < 0) throw new RangeError('"size" argument must not be negative');
          }
          function h(e3, t2) {
            if (c(t2), e3 = s(e3, t2 < 0 ? 0 : 0 | f(t2)), !u.TYPED_ARRAY_SUPPORT) for (var r2 = 0; r2 < t2; ++r2) e3[r2] = 0;
            return e3;
          }
          function p(e3, t2) {
            var r2 = t2.length < 0 ? 0 : 0 | f(t2.length);
            e3 = s(e3, r2);
            for (var n2 = 0; n2 < r2; n2 += 1) e3[n2] = 255 & t2[n2];
            return e3;
          }
          function f(e3) {
            if (e3 >= a()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a().toString(16) + " bytes");
            return 0 | e3;
          }
          function d(e3, t2) {
            if (u.isBuffer(e3)) return e3.length;
            if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e3) || e3 instanceof ArrayBuffer)) return e3.byteLength;
            "string" != typeof e3 && (e3 = "" + e3);
            var r2 = e3.length;
            if (0 === r2) return 0;
            for (var n2 = false; ; ) switch (t2) {
              case "ascii":
              case "latin1":
              case "binary":
                return r2;
              case "utf8":
              case "utf-8":
              case void 0:
                return z(e3).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * r2;
              case "hex":
                return r2 >>> 1;
              case "base64":
                return U(e3).length;
              default:
                if (n2) return z(e3).length;
                t2 = ("" + t2).toLowerCase(), n2 = true;
            }
          }
          function m(e3, t2, r2) {
            var n2 = false;
            if ((void 0 === t2 || t2 < 0) && (t2 = 0), t2 > this.length) return "";
            if ((void 0 === r2 || r2 > this.length) && (r2 = this.length), r2 <= 0) return "";
            if ((r2 >>>= 0) <= (t2 >>>= 0)) return "";
            for (e3 || (e3 = "utf8"); ; ) switch (e3) {
              case "hex":
                return T(this, t2, r2);
              case "utf8":
              case "utf-8":
                return C(this, t2, r2);
              case "ascii":
                return A(this, t2, r2);
              case "latin1":
              case "binary":
                return N(this, t2, r2);
              case "base64":
                return S(this, t2, r2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return O(this, t2, r2);
              default:
                if (n2) throw new TypeError("Unknown encoding: " + e3);
                e3 = (e3 + "").toLowerCase(), n2 = true;
            }
          }
          function y(e3, t2, r2) {
            var n2 = e3[t2];
            e3[t2] = e3[r2], e3[r2] = n2;
          }
          function v(e3, t2, r2, n2, i2) {
            if (0 === e3.length) return -1;
            if ("string" == typeof r2 ? (n2 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), r2 = +r2, isNaN(r2) && (r2 = i2 ? 0 : e3.length - 1), r2 < 0 && (r2 = e3.length + r2), r2 >= e3.length) {
              if (i2) return -1;
              r2 = e3.length - 1;
            } else if (r2 < 0) {
              if (!i2) return -1;
              r2 = 0;
            }
            if ("string" == typeof t2 && (t2 = u.from(t2, n2)), u.isBuffer(t2)) return 0 === t2.length ? -1 : _(e3, t2, r2, n2, i2);
            if ("number" == typeof t2) return t2 &= 255, u.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(e3, t2, r2) : Uint8Array.prototype.lastIndexOf.call(e3, t2, r2) : _(e3, [t2], r2, n2, i2);
            throw new TypeError("val must be string, number or Buffer");
          }
          function _(e3, t2, r2, n2, i2) {
            var o2, a2 = 1, s2 = e3.length, u2 = t2.length;
            if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
              if (e3.length < 2 || t2.length < 2) return -1;
              a2 = 2, s2 /= 2, u2 /= 2, r2 /= 2;
            }
            function l2(e4, t3) {
              return 1 === a2 ? e4[t3] : e4.readUInt16BE(t3 * a2);
            }
            if (i2) {
              var c2 = -1;
              for (o2 = r2; o2 < s2; o2++) if (l2(e3, o2) === l2(t2, -1 === c2 ? 0 : o2 - c2)) {
                if (-1 === c2 && (c2 = o2), o2 - c2 + 1 === u2) return c2 * a2;
              } else -1 !== c2 && (o2 -= o2 - c2), c2 = -1;
            } else for (r2 + u2 > s2 && (r2 = s2 - u2), o2 = r2; o2 >= 0; o2--) {
              for (var h2 = true, p2 = 0; p2 < u2; p2++) if (l2(e3, o2 + p2) !== l2(t2, p2)) {
                h2 = false;
                break;
              }
              if (h2) return o2;
            }
            return -1;
          }
          function g(e3, t2, r2, n2) {
            r2 = Number(r2) || 0;
            var i2 = e3.length - r2;
            n2 ? (n2 = Number(n2)) > i2 && (n2 = i2) : n2 = i2;
            var o2 = t2.length;
            if (o2 % 2 != 0) throw new TypeError("Invalid hex string");
            n2 > o2 / 2 && (n2 = o2 / 2);
            for (var a2 = 0; a2 < n2; ++a2) {
              var s2 = parseInt(t2.substr(2 * a2, 2), 16);
              if (isNaN(s2)) return a2;
              e3[r2 + a2] = s2;
            }
            return a2;
          }
          function b(e3, t2, r2, n2) {
            return G(z(t2, e3.length - r2), e3, r2, n2);
          }
          function x(e3, t2, r2, n2) {
            return G(function(e4) {
              for (var t3 = [], r3 = 0; r3 < e4.length; ++r3) t3.push(255 & e4.charCodeAt(r3));
              return t3;
            }(t2), e3, r2, n2);
          }
          function w(e3, t2, r2, n2) {
            return x(e3, t2, r2, n2);
          }
          function E(e3, t2, r2, n2) {
            return G(U(t2), e3, r2, n2);
          }
          function D(e3, t2, r2, n2) {
            return G(function(e4, t3) {
              for (var r3, n3, i2, o2 = [], a2 = 0; a2 < e4.length && !((t3 -= 2) < 0); ++a2) r3 = e4.charCodeAt(a2), n3 = r3 >> 8, i2 = r3 % 256, o2.push(i2), o2.push(n3);
              return o2;
            }(t2, e3.length - r2), e3, r2, n2);
          }
          function S(e3, t2, r2) {
            return 0 === t2 && r2 === e3.length ? n.fromByteArray(e3) : n.fromByteArray(e3.slice(t2, r2));
          }
          function C(e3, t2, r2) {
            r2 = Math.min(e3.length, r2);
            for (var n2 = [], i2 = t2; i2 < r2; ) {
              var o2, a2, s2, u2, l2 = e3[i2], c2 = null, h2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
              if (i2 + h2 <= r2) switch (h2) {
                case 1:
                  l2 < 128 && (c2 = l2);
                  break;
                case 2:
                  128 == (192 & (o2 = e3[i2 + 1])) && (u2 = (31 & l2) << 6 | 63 & o2) > 127 && (c2 = u2);
                  break;
                case 3:
                  o2 = e3[i2 + 1], a2 = e3[i2 + 2], 128 == (192 & o2) && 128 == (192 & a2) && (u2 = (15 & l2) << 12 | (63 & o2) << 6 | 63 & a2) > 2047 && (u2 < 55296 || u2 > 57343) && (c2 = u2);
                  break;
                case 4:
                  o2 = e3[i2 + 1], a2 = e3[i2 + 2], s2 = e3[i2 + 3], 128 == (192 & o2) && 128 == (192 & a2) && 128 == (192 & s2) && (u2 = (15 & l2) << 18 | (63 & o2) << 12 | (63 & a2) << 6 | 63 & s2) > 65535 && u2 < 1114112 && (c2 = u2);
              }
              null === c2 ? (c2 = 65533, h2 = 1) : c2 > 65535 && (c2 -= 65536, n2.push(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), n2.push(c2), i2 += h2;
            }
            return function(e4) {
              var t3 = e4.length;
              if (t3 <= 4096) return String.fromCharCode.apply(String, e4);
              var r3 = "", n3 = 0;
              for (; n3 < t3; ) r3 += String.fromCharCode.apply(String, e4.slice(n3, n3 += 4096));
              return r3;
            }(n2);
          }
          t.Buffer = u, t.SlowBuffer = function(e3) {
            +e3 != e3 && (e3 = 0);
            return u.alloc(+e3);
          }, t.INSPECT_MAX_BYTES = 50, u.TYPED_ARRAY_SUPPORT = void 0 !== e2.TYPED_ARRAY_SUPPORT ? e2.TYPED_ARRAY_SUPPORT : function() {
            try {
              var e3 = new Uint8Array(1);
              return e3.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                return 42;
              } }, 42 === e3.foo() && "function" == typeof e3.subarray && 0 === e3.subarray(1, 1).byteLength;
            } catch (e4) {
              return false;
            }
          }(), t.kMaxLength = a(), u.poolSize = 8192, u._augment = function(e3) {
            return e3.__proto__ = u.prototype, e3;
          }, u.from = function(e3, t2, r2) {
            return l(null, e3, t2, r2);
          }, u.TYPED_ARRAY_SUPPORT && (u.prototype.__proto__ = Uint8Array.prototype, u.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && u[Symbol.species] === u && Object.defineProperty(u, Symbol.species, { value: null, configurable: true })), u.alloc = function(e3, t2, r2) {
            return function(e4, t3, r3, n2) {
              return c(t3), t3 <= 0 ? s(e4, t3) : void 0 !== r3 ? "string" == typeof n2 ? s(e4, t3).fill(r3, n2) : s(e4, t3).fill(r3) : s(e4, t3);
            }(null, e3, t2, r2);
          }, u.allocUnsafe = function(e3) {
            return h(null, e3);
          }, u.allocUnsafeSlow = function(e3) {
            return h(null, e3);
          }, u.isBuffer = function(e3) {
            return !(null == e3 || !e3._isBuffer);
          }, u.compare = function(e3, t2) {
            if (!u.isBuffer(e3) || !u.isBuffer(t2)) throw new TypeError("Arguments must be Buffers");
            if (e3 === t2) return 0;
            for (var r2 = e3.length, n2 = t2.length, i2 = 0, o2 = Math.min(r2, n2); i2 < o2; ++i2) if (e3[i2] !== t2[i2]) {
              r2 = e3[i2], n2 = t2[i2];
              break;
            }
            return r2 < n2 ? -1 : n2 < r2 ? 1 : 0;
          }, u.isEncoding = function(e3) {
            switch (String(e3).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, u.concat = function(e3, t2) {
            if (!o(e3)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === e3.length) return u.alloc(0);
            var r2;
            if (void 0 === t2) for (t2 = 0, r2 = 0; r2 < e3.length; ++r2) t2 += e3[r2].length;
            var n2 = u.allocUnsafe(t2), i2 = 0;
            for (r2 = 0; r2 < e3.length; ++r2) {
              var a2 = e3[r2];
              if (!u.isBuffer(a2)) throw new TypeError('"list" argument must be an Array of Buffers');
              a2.copy(n2, i2), i2 += a2.length;
            }
            return n2;
          }, u.byteLength = d, u.prototype._isBuffer = true, u.prototype.swap16 = function() {
            var e3 = this.length;
            if (e3 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var t2 = 0; t2 < e3; t2 += 2) y(this, t2, t2 + 1);
            return this;
          }, u.prototype.swap32 = function() {
            var e3 = this.length;
            if (e3 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var t2 = 0; t2 < e3; t2 += 4) y(this, t2, t2 + 3), y(this, t2 + 1, t2 + 2);
            return this;
          }, u.prototype.swap64 = function() {
            var e3 = this.length;
            if (e3 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var t2 = 0; t2 < e3; t2 += 8) y(this, t2, t2 + 7), y(this, t2 + 1, t2 + 6), y(this, t2 + 2, t2 + 5), y(this, t2 + 3, t2 + 4);
            return this;
          }, u.prototype.toString = function() {
            var e3 = 0 | this.length;
            return 0 === e3 ? "" : 0 === arguments.length ? C(this, 0, e3) : m.apply(this, arguments);
          }, u.prototype.equals = function(e3) {
            if (!u.isBuffer(e3)) throw new TypeError("Argument must be a Buffer");
            return this === e3 || 0 === u.compare(this, e3);
          }, u.prototype.inspect = function() {
            var e3 = "", r2 = t.INSPECT_MAX_BYTES;
            return this.length > 0 && (e3 = this.toString("hex", 0, r2).match(/.{2}/g).join(" "), this.length > r2 && (e3 += " ... ")), "<Buffer " + e3 + ">";
          }, u.prototype.compare = function(e3, t2, r2, n2, i2) {
            if (!u.isBuffer(e3)) throw new TypeError("Argument must be a Buffer");
            if (void 0 === t2 && (t2 = 0), void 0 === r2 && (r2 = e3 ? e3.length : 0), void 0 === n2 && (n2 = 0), void 0 === i2 && (i2 = this.length), t2 < 0 || r2 > e3.length || n2 < 0 || i2 > this.length) throw new RangeError("out of range index");
            if (n2 >= i2 && t2 >= r2) return 0;
            if (n2 >= i2) return -1;
            if (t2 >= r2) return 1;
            if (this === e3) return 0;
            for (var o2 = (i2 >>>= 0) - (n2 >>>= 0), a2 = (r2 >>>= 0) - (t2 >>>= 0), s2 = Math.min(o2, a2), l2 = this.slice(n2, i2), c2 = e3.slice(t2, r2), h2 = 0; h2 < s2; ++h2) if (l2[h2] !== c2[h2]) {
              o2 = l2[h2], a2 = c2[h2];
              break;
            }
            return o2 < a2 ? -1 : a2 < o2 ? 1 : 0;
          }, u.prototype.includes = function(e3, t2, r2) {
            return -1 !== this.indexOf(e3, t2, r2);
          }, u.prototype.indexOf = function(e3, t2, r2) {
            return v(this, e3, t2, r2, true);
          }, u.prototype.lastIndexOf = function(e3, t2, r2) {
            return v(this, e3, t2, r2, false);
          }, u.prototype.write = function(e3, t2, r2, n2) {
            if (void 0 === t2) n2 = "utf8", r2 = this.length, t2 = 0;
            else if (void 0 === r2 && "string" == typeof t2) n2 = t2, r2 = this.length, t2 = 0;
            else {
              if (!isFinite(t2)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              t2 |= 0, isFinite(r2) ? (r2 |= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r2, r2 = void 0);
            }
            var i2 = this.length - t2;
            if ((void 0 === r2 || r2 > i2) && (r2 = i2), e3.length > 0 && (r2 < 0 || t2 < 0) || t2 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            n2 || (n2 = "utf8");
            for (var o2 = false; ; ) switch (n2) {
              case "hex":
                return g(this, e3, t2, r2);
              case "utf8":
              case "utf-8":
                return b(this, e3, t2, r2);
              case "ascii":
                return x(this, e3, t2, r2);
              case "latin1":
              case "binary":
                return w(this, e3, t2, r2);
              case "base64":
                return E(this, e3, t2, r2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return D(this, e3, t2, r2);
              default:
                if (o2) throw new TypeError("Unknown encoding: " + n2);
                n2 = ("" + n2).toLowerCase(), o2 = true;
            }
          }, u.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          function A(e3, t2, r2) {
            var n2 = "";
            r2 = Math.min(e3.length, r2);
            for (var i2 = t2; i2 < r2; ++i2) n2 += String.fromCharCode(127 & e3[i2]);
            return n2;
          }
          function N(e3, t2, r2) {
            var n2 = "";
            r2 = Math.min(e3.length, r2);
            for (var i2 = t2; i2 < r2; ++i2) n2 += String.fromCharCode(e3[i2]);
            return n2;
          }
          function T(e3, t2, r2) {
            var n2 = e3.length;
            (!t2 || t2 < 0) && (t2 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
            for (var i2 = "", o2 = t2; o2 < r2; ++o2) i2 += R(e3[o2]);
            return i2;
          }
          function O(e3, t2, r2) {
            for (var n2 = e3.slice(t2, r2), i2 = "", o2 = 0; o2 < n2.length; o2 += 2) i2 += String.fromCharCode(n2[o2] + 256 * n2[o2 + 1]);
            return i2;
          }
          function F(e3, t2, r2) {
            if (e3 % 1 != 0 || e3 < 0) throw new RangeError("offset is not uint");
            if (e3 + t2 > r2) throw new RangeError("Trying to access beyond buffer length");
          }
          function k(e3, t2, r2, n2, i2, o2) {
            if (!u.isBuffer(e3)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (t2 > i2 || t2 < o2) throw new RangeError('"value" argument is out of bounds');
            if (r2 + n2 > e3.length) throw new RangeError("Index out of range");
          }
          function P(e3, t2, r2, n2) {
            t2 < 0 && (t2 = 65535 + t2 + 1);
            for (var i2 = 0, o2 = Math.min(e3.length - r2, 2); i2 < o2; ++i2) e3[r2 + i2] = (t2 & 255 << 8 * (n2 ? i2 : 1 - i2)) >>> 8 * (n2 ? i2 : 1 - i2);
          }
          function I(e3, t2, r2, n2) {
            t2 < 0 && (t2 = 4294967295 + t2 + 1);
            for (var i2 = 0, o2 = Math.min(e3.length - r2, 4); i2 < o2; ++i2) e3[r2 + i2] = t2 >>> 8 * (n2 ? i2 : 3 - i2) & 255;
          }
          function L(e3, t2, r2, n2, i2, o2) {
            if (r2 + n2 > e3.length) throw new RangeError("Index out of range");
            if (r2 < 0) throw new RangeError("Index out of range");
          }
          function M(e3, t2, r2, n2, o2) {
            return o2 || L(e3, 0, r2, 4), i.write(e3, t2, r2, n2, 23, 4), r2 + 4;
          }
          function B(e3, t2, r2, n2, o2) {
            return o2 || L(e3, 0, r2, 8), i.write(e3, t2, r2, n2, 52, 8), r2 + 8;
          }
          u.prototype.slice = function(e3, t2) {
            var r2, n2 = this.length;
            if ((e3 = ~~e3) < 0 ? (e3 += n2) < 0 && (e3 = 0) : e3 > n2 && (e3 = n2), (t2 = void 0 === t2 ? n2 : ~~t2) < 0 ? (t2 += n2) < 0 && (t2 = 0) : t2 > n2 && (t2 = n2), t2 < e3 && (t2 = e3), u.TYPED_ARRAY_SUPPORT) (r2 = this.subarray(e3, t2)).__proto__ = u.prototype;
            else {
              var i2 = t2 - e3;
              r2 = new u(i2, void 0);
              for (var o2 = 0; o2 < i2; ++o2) r2[o2] = this[o2 + e3];
            }
            return r2;
          }, u.prototype.readUIntLE = function(e3, t2, r2) {
            e3 |= 0, t2 |= 0, r2 || F(e3, t2, this.length);
            for (var n2 = this[e3], i2 = 1, o2 = 0; ++o2 < t2 && (i2 *= 256); ) n2 += this[e3 + o2] * i2;
            return n2;
          }, u.prototype.readUIntBE = function(e3, t2, r2) {
            e3 |= 0, t2 |= 0, r2 || F(e3, t2, this.length);
            for (var n2 = this[e3 + --t2], i2 = 1; t2 > 0 && (i2 *= 256); ) n2 += this[e3 + --t2] * i2;
            return n2;
          }, u.prototype.readUInt8 = function(e3, t2) {
            return t2 || F(e3, 1, this.length), this[e3];
          }, u.prototype.readUInt16LE = function(e3, t2) {
            return t2 || F(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
          }, u.prototype.readUInt16BE = function(e3, t2) {
            return t2 || F(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
          }, u.prototype.readUInt32LE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
          }, u.prototype.readUInt32BE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
          }, u.prototype.readIntLE = function(e3, t2, r2) {
            e3 |= 0, t2 |= 0, r2 || F(e3, t2, this.length);
            for (var n2 = this[e3], i2 = 1, o2 = 0; ++o2 < t2 && (i2 *= 256); ) n2 += this[e3 + o2] * i2;
            return n2 >= (i2 *= 128) && (n2 -= Math.pow(2, 8 * t2)), n2;
          }, u.prototype.readIntBE = function(e3, t2, r2) {
            e3 |= 0, t2 |= 0, r2 || F(e3, t2, this.length);
            for (var n2 = t2, i2 = 1, o2 = this[e3 + --n2]; n2 > 0 && (i2 *= 256); ) o2 += this[e3 + --n2] * i2;
            return o2 >= (i2 *= 128) && (o2 -= Math.pow(2, 8 * t2)), o2;
          }, u.prototype.readInt8 = function(e3, t2) {
            return t2 || F(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
          }, u.prototype.readInt16LE = function(e3, t2) {
            t2 || F(e3, 2, this.length);
            var r2 = this[e3] | this[e3 + 1] << 8;
            return 32768 & r2 ? 4294901760 | r2 : r2;
          }, u.prototype.readInt16BE = function(e3, t2) {
            t2 || F(e3, 2, this.length);
            var r2 = this[e3 + 1] | this[e3] << 8;
            return 32768 & r2 ? 4294901760 | r2 : r2;
          }, u.prototype.readInt32LE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
          }, u.prototype.readInt32BE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
          }, u.prototype.readFloatLE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), i.read(this, e3, true, 23, 4);
          }, u.prototype.readFloatBE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), i.read(this, e3, false, 23, 4);
          }, u.prototype.readDoubleLE = function(e3, t2) {
            return t2 || F(e3, 8, this.length), i.read(this, e3, true, 52, 8);
          }, u.prototype.readDoubleBE = function(e3, t2) {
            return t2 || F(e3, 8, this.length), i.read(this, e3, false, 52, 8);
          }, u.prototype.writeUIntLE = function(e3, t2, r2, n2) {
            (e3 = +e3, t2 |= 0, r2 |= 0, n2) || k(this, e3, t2, r2, Math.pow(2, 8 * r2) - 1, 0);
            var i2 = 1, o2 = 0;
            for (this[t2] = 255 & e3; ++o2 < r2 && (i2 *= 256); ) this[t2 + o2] = e3 / i2 & 255;
            return t2 + r2;
          }, u.prototype.writeUIntBE = function(e3, t2, r2, n2) {
            (e3 = +e3, t2 |= 0, r2 |= 0, n2) || k(this, e3, t2, r2, Math.pow(2, 8 * r2) - 1, 0);
            var i2 = r2 - 1, o2 = 1;
            for (this[t2 + i2] = 255 & e3; --i2 >= 0 && (o2 *= 256); ) this[t2 + i2] = e3 / o2 & 255;
            return t2 + r2;
          }, u.prototype.writeUInt8 = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 1, 255, 0), u.TYPED_ARRAY_SUPPORT || (e3 = Math.floor(e3)), this[t2] = 255 & e3, t2 + 1;
          }, u.prototype.writeUInt16LE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e3, this[t2 + 1] = e3 >>> 8) : P(this, e3, t2, true), t2 + 2;
          }, u.prototype.writeUInt16BE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[t2] = e3 >>> 8, this[t2 + 1] = 255 & e3) : P(this, e3, t2, false), t2 + 2;
          }, u.prototype.writeUInt32LE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[t2 + 3] = e3 >>> 24, this[t2 + 2] = e3 >>> 16, this[t2 + 1] = e3 >>> 8, this[t2] = 255 & e3) : I(this, e3, t2, true), t2 + 4;
          }, u.prototype.writeUInt32BE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[t2] = e3 >>> 24, this[t2 + 1] = e3 >>> 16, this[t2 + 2] = e3 >>> 8, this[t2 + 3] = 255 & e3) : I(this, e3, t2, false), t2 + 4;
          }, u.prototype.writeIntLE = function(e3, t2, r2, n2) {
            if (e3 = +e3, t2 |= 0, !n2) {
              var i2 = Math.pow(2, 8 * r2 - 1);
              k(this, e3, t2, r2, i2 - 1, -i2);
            }
            var o2 = 0, a2 = 1, s2 = 0;
            for (this[t2] = 255 & e3; ++o2 < r2 && (a2 *= 256); ) e3 < 0 && 0 === s2 && 0 !== this[t2 + o2 - 1] && (s2 = 1), this[t2 + o2] = (e3 / a2 >> 0) - s2 & 255;
            return t2 + r2;
          }, u.prototype.writeIntBE = function(e3, t2, r2, n2) {
            if (e3 = +e3, t2 |= 0, !n2) {
              var i2 = Math.pow(2, 8 * r2 - 1);
              k(this, e3, t2, r2, i2 - 1, -i2);
            }
            var o2 = r2 - 1, a2 = 1, s2 = 0;
            for (this[t2 + o2] = 255 & e3; --o2 >= 0 && (a2 *= 256); ) e3 < 0 && 0 === s2 && 0 !== this[t2 + o2 + 1] && (s2 = 1), this[t2 + o2] = (e3 / a2 >> 0) - s2 & 255;
            return t2 + r2;
          }, u.prototype.writeInt8 = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 1, 127, -128), u.TYPED_ARRAY_SUPPORT || (e3 = Math.floor(e3)), e3 < 0 && (e3 = 255 + e3 + 1), this[t2] = 255 & e3, t2 + 1;
          }, u.prototype.writeInt16LE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e3, this[t2 + 1] = e3 >>> 8) : P(this, e3, t2, true), t2 + 2;
          }, u.prototype.writeInt16BE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[t2] = e3 >>> 8, this[t2 + 1] = 255 & e3) : P(this, e3, t2, false), t2 + 2;
          }, u.prototype.writeInt32LE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 4, 2147483647, -2147483648), u.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e3, this[t2 + 1] = e3 >>> 8, this[t2 + 2] = e3 >>> 16, this[t2 + 3] = e3 >>> 24) : I(this, e3, t2, true), t2 + 4;
          }, u.prototype.writeInt32BE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), u.TYPED_ARRAY_SUPPORT ? (this[t2] = e3 >>> 24, this[t2 + 1] = e3 >>> 16, this[t2 + 2] = e3 >>> 8, this[t2 + 3] = 255 & e3) : I(this, e3, t2, false), t2 + 4;
          }, u.prototype.writeFloatLE = function(e3, t2, r2) {
            return M(this, e3, t2, true, r2);
          }, u.prototype.writeFloatBE = function(e3, t2, r2) {
            return M(this, e3, t2, false, r2);
          }, u.prototype.writeDoubleLE = function(e3, t2, r2) {
            return B(this, e3, t2, true, r2);
          }, u.prototype.writeDoubleBE = function(e3, t2, r2) {
            return B(this, e3, t2, false, r2);
          }, u.prototype.copy = function(e3, t2, r2, n2) {
            if (r2 || (r2 = 0), n2 || 0 === n2 || (n2 = this.length), t2 >= e3.length && (t2 = e3.length), t2 || (t2 = 0), n2 > 0 && n2 < r2 && (n2 = r2), n2 === r2) return 0;
            if (0 === e3.length || 0 === this.length) return 0;
            if (t2 < 0) throw new RangeError("targetStart out of bounds");
            if (r2 < 0 || r2 >= this.length) throw new RangeError("sourceStart out of bounds");
            if (n2 < 0) throw new RangeError("sourceEnd out of bounds");
            n2 > this.length && (n2 = this.length), e3.length - t2 < n2 - r2 && (n2 = e3.length - t2 + r2);
            var i2, o2 = n2 - r2;
            if (this === e3 && r2 < t2 && t2 < n2) for (i2 = o2 - 1; i2 >= 0; --i2) e3[i2 + t2] = this[i2 + r2];
            else if (o2 < 1e3 || !u.TYPED_ARRAY_SUPPORT) for (i2 = 0; i2 < o2; ++i2) e3[i2 + t2] = this[i2 + r2];
            else Uint8Array.prototype.set.call(e3, this.subarray(r2, r2 + o2), t2);
            return o2;
          }, u.prototype.fill = function(e3, t2, r2, n2) {
            if ("string" == typeof e3) {
              if ("string" == typeof t2 ? (n2 = t2, t2 = 0, r2 = this.length) : "string" == typeof r2 && (n2 = r2, r2 = this.length), 1 === e3.length) {
                var i2 = e3.charCodeAt(0);
                i2 < 256 && (e3 = i2);
              }
              if (void 0 !== n2 && "string" != typeof n2) throw new TypeError("encoding must be a string");
              if ("string" == typeof n2 && !u.isEncoding(n2)) throw new TypeError("Unknown encoding: " + n2);
            } else "number" == typeof e3 && (e3 &= 255);
            if (t2 < 0 || this.length < t2 || this.length < r2) throw new RangeError("Out of range index");
            if (r2 <= t2) return this;
            var o2;
            if (t2 >>>= 0, r2 = void 0 === r2 ? this.length : r2 >>> 0, e3 || (e3 = 0), "number" == typeof e3) for (o2 = t2; o2 < r2; ++o2) this[o2] = e3;
            else {
              var a2 = u.isBuffer(e3) ? e3 : z(new u(e3, n2).toString()), s2 = a2.length;
              for (o2 = 0; o2 < r2 - t2; ++o2) this[o2 + t2] = a2[o2 % s2];
            }
            return this;
          };
          var j = /[^+\/0-9A-Za-z-_]/g;
          function R(e3) {
            return e3 < 16 ? "0" + e3.toString(16) : e3.toString(16);
          }
          function z(e3, t2) {
            var r2;
            t2 = t2 || 1 / 0;
            for (var n2 = e3.length, i2 = null, o2 = [], a2 = 0; a2 < n2; ++a2) {
              if ((r2 = e3.charCodeAt(a2)) > 55295 && r2 < 57344) {
                if (!i2) {
                  if (r2 > 56319) {
                    (t2 -= 3) > -1 && o2.push(239, 191, 189);
                    continue;
                  }
                  if (a2 + 1 === n2) {
                    (t2 -= 3) > -1 && o2.push(239, 191, 189);
                    continue;
                  }
                  i2 = r2;
                  continue;
                }
                if (r2 < 56320) {
                  (t2 -= 3) > -1 && o2.push(239, 191, 189), i2 = r2;
                  continue;
                }
                r2 = 65536 + (i2 - 55296 << 10 | r2 - 56320);
              } else i2 && (t2 -= 3) > -1 && o2.push(239, 191, 189);
              if (i2 = null, r2 < 128) {
                if ((t2 -= 1) < 0) break;
                o2.push(r2);
              } else if (r2 < 2048) {
                if ((t2 -= 2) < 0) break;
                o2.push(r2 >> 6 | 192, 63 & r2 | 128);
              } else if (r2 < 65536) {
                if ((t2 -= 3) < 0) break;
                o2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
              } else {
                if (!(r2 < 1114112)) throw new Error("Invalid code point");
                if ((t2 -= 4) < 0) break;
                o2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
              }
            }
            return o2;
          }
          function U(e3) {
            return n.toByteArray(function(e4) {
              if ((e4 = function(e5) {
                return e5.trim ? e5.trim() : e5.replace(/^\s+|\s+$/g, "");
              }(e4).replace(j, "")).length < 2) return "";
              for (; e4.length % 4 != 0; ) e4 += "=";
              return e4;
            }(e3));
          }
          function G(e3, t2, r2, n2) {
            for (var i2 = 0; i2 < n2 && !(i2 + r2 >= t2.length || i2 >= e3.length); ++i2) t2[i2 + r2] = e3[i2];
            return i2;
          }
        }).call(this, r(78));
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.isASCIIByte = function(e2) {
          return e2 >= 0 && e2 <= 127;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o = r2.call(e2), a = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o.next()).done; ) a.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o.return) && r2.call(o);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a;
        }, i = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++) e2 = e2.concat(n(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.length = function(e2) {
          return e2.length;
        }, t.byteLowercase = function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) {
            var r2 = e2[t2];
            r2 >= 65 && r2 <= 90 && (e2[t2] = r2 + 32);
          }
        }, t.byteUppercase = function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) {
            var r2 = e2[t2];
            r2 >= 97 && r2 <= 122 && (e2[t2] = r2 - 32);
          }
        }, t.byteCaseInsensitiveMatch = function(e2, t2) {
          if (e2.length !== t2.length) return false;
          for (var r2 = 0; r2 < e2.length; r2++) {
            var n2 = e2[r2], i2 = t2[r2];
            if (n2 >= 65 && n2 <= 90 && (n2 += 32), i2 >= 65 && i2 <= 90 && (i2 += 32), n2 !== i2) return false;
          }
          return true;
        }, t.startsWith = function(e2, t2) {
          for (var r2 = 0; ; ) {
            if (r2 >= e2.length) return false;
            if (r2 >= t2.length) return true;
            if (e2[r2] !== t2[r2]) return false;
            r2++;
          }
        }, t.byteLessThan = function(e2, t2) {
          for (var r2 = 0; ; ) {
            if (r2 >= e2.length) return false;
            if (r2 >= t2.length) return true;
            var n2 = e2[r2], i2 = t2[r2];
            if (n2 < i2) return true;
            if (n2 > i2) return false;
            r2++;
          }
        }, t.isomorphicDecode = function(e2) {
          return String.fromCodePoint.apply(String, i(e2));
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(6), i = r(7), o = r(0), a = r(12), s = function() {
          function e2(e3) {
            this._associatedDocument = e3 || n.dom.window.document;
          }
          return e2.prototype.createDocumentType = function(e3, t2, r2) {
            return o.namespace_validate(e3), o.create_documentType(this._associatedDocument, e3, t2, r2);
          }, e2.prototype.createDocument = function(e3, t2, r2) {
            void 0 === r2 && (r2 = null);
            var n2 = o.create_xmlDocument(), a2 = null;
            return t2 && (a2 = o.document_internalCreateElementNS(n2, e3, t2)), r2 && n2.appendChild(r2), a2 && n2.appendChild(a2), n2._origin = this._associatedDocument._origin, e3 === i.namespace.HTML ? n2._contentType = "application/xhtml+xml" : e3 === i.namespace.SVG ? n2._contentType = "image/svg+xml" : n2._contentType = "application/xml", n2;
          }, e2.prototype.createHTMLDocument = function(e3) {
            var t2 = o.create_document();
            t2._type = "html", t2._contentType = "text/html", t2.appendChild(o.create_documentType(t2, "html", "", ""));
            var r2 = o.element_createAnElement(t2, "html", i.namespace.HTML);
            t2.appendChild(r2);
            var n2 = o.element_createAnElement(t2, "head", i.namespace.HTML);
            if (r2.appendChild(n2), void 0 !== e3) {
              var a2 = o.element_createAnElement(t2, "title", i.namespace.HTML);
              n2.appendChild(a2);
              var s2 = o.create_text(t2, e3);
              a2.appendChild(s2);
            }
            var u = o.element_createAnElement(t2, "body", i.namespace.HTML);
            return r2.appendChild(u), t2._origin = this._associatedDocument._origin, t2;
          }, e2.prototype.hasFeature = function() {
            return true;
          }, e2._create = function(t2) {
            return new e2(t2);
          }, e2;
        }();
        t.DOMImplementationImpl = s, a.idl_defineConst(s.prototype, "_ID", "@oozcitak/dom");
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(70), a = r(1), s = r(0), u = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this;
            return t3._signalSlots = /* @__PURE__ */ new Set(), t3._mutationObserverMicrotaskQueued = false, t3._mutationObservers = /* @__PURE__ */ new Set(), t3._iteratorList = new a.FixedSizeSet(), t3._associatedDocument = s.create_document(), t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "document", { get: function() {
            return this._associatedDocument;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "event", { get: function() {
            return this._currentEvent;
          }, enumerable: true, configurable: true }), t2._create = function() {
            return new t2();
          }, t2;
        }(o.EventTargetImpl);
        t.WindowImpl = u;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(2), i = function() {
          function e2() {
          }
          return e2.isNode = function(e3) {
            return !!e3 && void 0 !== e3._nodeType;
          }, e2.isDocumentNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.Document;
          }, e2.isDocumentTypeNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.DocumentType;
          }, e2.isDocumentFragmentNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.DocumentFragment;
          }, e2.isAttrNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.Attribute;
          }, e2.isCharacterDataNode = function(t2) {
            if (!e2.isNode(t2)) return false;
            var r2 = t2._nodeType;
            return r2 === n.NodeType.Text || r2 === n.NodeType.ProcessingInstruction || r2 === n.NodeType.Comment || r2 === n.NodeType.CData;
          }, e2.isTextNode = function(t2) {
            return e2.isNode(t2) && (t2._nodeType === n.NodeType.Text || t2._nodeType === n.NodeType.CData);
          }, e2.isExclusiveTextNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.Text;
          }, e2.isCDATASectionNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.CData;
          }, e2.isCommentNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.Comment;
          }, e2.isProcessingInstructionNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.ProcessingInstruction;
          }, e2.isElementNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.Element;
          }, e2.isCustomElementNode = function(t2) {
            return e2.isElementNode(t2) && "custom" === t2._customElementState;
          }, e2.isShadowRoot = function(e3) {
            return !!e3 && void 0 !== e3.host;
          }, e2.isMouseEvent = function(e3) {
            return !!e3 && void 0 !== e3.screenX && null != e3.screenY;
          }, e2.isSlotable = function(t2) {
            return !!t2 && void 0 !== t2._name && void 0 !== t2._assignedSlot && (e2.isTextNode(t2) || e2.isElementNode(t2));
          }, e2.isSlot = function(t2) {
            return !!t2 && void 0 !== t2._name && void 0 !== t2._assignedNodes && e2.isElementNode(t2);
          }, e2.isWindow = function(e3) {
            return !!e3 && void 0 !== e3.navigator;
          }, e2.isEventListener = function(e3) {
            return !!e3 && void 0 !== e3.handleEvent;
          }, e2.isRegisteredObserver = function(e3) {
            return !!e3 && void 0 !== e3.observer && void 0 !== e3.options;
          }, e2.isTransientRegisteredObserver = function(t2) {
            return !!t2 && void 0 !== t2.source && e2.isRegisteredObserver(t2);
          }, e2;
        }();
        t.Guard = i;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function(e2) {
          function t2() {
            return e2.call(this) || this;
          }
          return i(t2, e2), t2;
        }(r(98).DocumentImpl);
        t.XMLDocumentImpl = o;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o, a = r(1), s = r(243), u = r(7), l = r(244), c = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, h = /[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, p = /[ "<>`]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, f = /[ "<>`#?{}]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, d = /[ "<>`#?{}/:;=@\[\]\\\^\|]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, m = /[0-9A-Za-z!\$&-\/:;=\?@_~\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uD83E\uD840-\uD87E\uD880-\uD8BE\uD8C0-\uD8FE\uD900-\uD93E\uD940-\uD97E\uD980-\uD9BE\uD9C0-\uD9FE\uDA00-\uDA3E\uDA40-\uDA7E\uDA80-\uDABE\uDAC0-\uDAFE\uDB00-\uDB3E\uDB40-\uDB7E\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDC00-\uDFFD]/, y = /[\0\t\f\r #%/:?@\[\\\]]/;
        function v(e2) {
          void 0 !== o && o.call(null, "Validation Error: " + e2);
        }
        function _() {
          return { scheme: "", username: "", password: "", host: null, port: null, path: [], query: null, fragment: null, _cannotBeABaseURLFlag: false, _blobURLEntry: null };
        }
        function g(e2) {
          return e2 in c;
        }
        function b(e2) {
          return g(e2.scheme);
        }
        function x(e2) {
          return c[e2] || null;
        }
        function w(e2) {
          return "" !== e2.username || "" !== e2.password;
        }
        function E(e2, t2) {
          var r2, i2;
          void 0 === t2 && (t2 = false);
          var o2 = e2.scheme + ":";
          if (null !== e2.host ? (o2 += "//", w(e2) && (o2 += e2.username, "" !== e2.password && (o2 += ":" + e2.password), o2 += "@"), o2 += D(e2.host), null !== e2.port && (o2 += ":" + e2.port)) : null === e2.host && "file" === e2.scheme && (o2 += "//"), e2._cannotBeABaseURLFlag) o2 += e2.path[0];
          else try {
            for (var a2 = n(e2.path), s2 = a2.next(); !s2.done; s2 = a2.next()) {
              o2 += "/" + s2.value;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (i2 = a2.return) && i2.call(a2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          return null !== e2.query && (o2 += "?" + e2.query), t2 || null === e2.fragment || (o2 += "#" + e2.fragment), o2;
        }
        function D(e2) {
          return a.isNumber(e2) ? S(e2) : a.isArray(e2) ? "[" + C(e2) + "]" : e2;
        }
        function S(e2) {
          for (var t2 = "", r2 = e2, n2 = 1; n2 <= 4; n2++) t2 = (r2 % 256).toString() + t2, 4 !== n2 && (t2 = "." + t2), r2 = Math.floor(r2 / 256);
          return t2;
        }
        function C(e2) {
          for (var t2 = "", r2 = null, n2 = -1, i2 = 0, o2 = 0, a2 = 0; a2 < 8; a2++) if (0 === e2[a2]) {
            i2 = 1;
            for (var s2 = a2 + 1; s2 < 8 && 0 === e2[s2]; s2++) i2++;
            i2 > o2 && (o2 = i2, n2 = a2);
          }
          o2 > 1 && (r2 = n2);
          for (var u2 = false, l2 = 0; l2 < 8; l2++) u2 && 0 === e2[l2] || (u2 && (u2 = false), r2 !== l2 ? (t2 += e2[l2].toString(16), 7 !== l2 && (t2 += ":")) : (t2 += 0 === l2 ? "::" : ":", u2 = true));
          return t2;
        }
        function A(e2, t2, r2, i2, o2) {
          var l2, c2, y2, _2;
          if (void 0 === i2) {
            i2 = { scheme: "", username: "", password: "", host: null, port: null, path: [], query: null, fragment: null, _cannotBeABaseURLFlag: false, _blobURLEntry: null };
            var E2 = /^[\u0000-\u001F\u0020]+/, D2 = /[\u0000-\u001F\u0020]+$/;
            (E2.test(e2) || D2.test(e2)) && v("Input string contains leading or trailing control characters or space."), e2 = (e2 = e2.replace(E2, "")).replace(D2, "");
          }
          var S2 = /[\u0009\u000A\u000D]/g;
          S2.test(e2) && v("Input string contains tab or newline characters."), e2 = e2.replace(S2, "");
          var C2 = void 0 === o2 ? s.ParserState.SchemeStart : o2;
          void 0 === t2 && (t2 = null);
          for (var A2 = void 0 === r2 || "replacement" === r2 || "UTF-16BE" === r2 || "UTF-16LE" === r2 ? "UTF-8" : r2, L2 = "", M2 = false, B2 = false, j2 = false, R2 = new a.StringWalker(e2); ; ) {
            switch (C2) {
              case s.ParserState.SchemeStart:
                if (u.codePoint.ASCIIAlpha.test(R2.c())) L2 += R2.c().toLowerCase(), C2 = s.ParserState.Scheme;
                else {
                  if (void 0 !== o2) return v("Invalid scheme start character."), null;
                  C2 = s.ParserState.NoScheme, R2.pointer--;
                }
                break;
              case s.ParserState.Scheme:
                if (u.codePoint.ASCIIAlphanumeric.test(R2.c()) || "+" === R2.c() || "-" === R2.c() || "." === R2.c()) L2 += R2.c().toLowerCase();
                else {
                  if (":" !== R2.c()) {
                    if (void 0 === o2) {
                      L2 = "", C2 = s.ParserState.NoScheme, R2.pointer = 0;
                      continue;
                    }
                    return v("Invalid input string."), null;
                  }
                  if (void 0 !== o2) {
                    if (g(i2.scheme) && !g(L2)) return i2;
                    if (!g(i2.scheme) && g(L2)) return i2;
                    if ((w(i2) || null !== i2.port) && "file" === L2) return i2;
                    if ("file" === i2.scheme && ("" === i2.host || null === i2.host)) return i2;
                  }
                  if (i2.scheme = L2, void 0 !== o2) return i2.port === x(i2.scheme) && (i2.port = null), i2;
                  L2 = "", "file" === i2.scheme ? (R2.remaining().startsWith("//") || v("Invalid file URL scheme, '//' expected."), C2 = s.ParserState.File) : b(i2) && null !== t2 && t2.scheme === i2.scheme ? C2 = s.ParserState.SpecialRelativeOrAuthority : b(i2) ? C2 = s.ParserState.SpecialAuthoritySlashes : R2.remaining().startsWith("/") ? (C2 = s.ParserState.PathOrAuthority, R2.pointer++) : (i2._cannotBeABaseURLFlag = true, i2.path.push(""), C2 = s.ParserState.CannotBeABaseURLPath);
                }
                break;
              case s.ParserState.NoScheme:
                if (null === t2 || t2._cannotBeABaseURLFlag && "#" !== R2.c()) return v("Invalid input string."), null;
                t2._cannotBeABaseURLFlag && "#" === R2.c() ? (i2.scheme = t2.scheme, i2.path = u.list.clone(t2.path), i2.query = t2.query, i2.fragment = "", i2._cannotBeABaseURLFlag = true, C2 = s.ParserState.Fragment) : "file" !== t2.scheme ? (C2 = s.ParserState.Relative, R2.pointer--) : (C2 = s.ParserState.File, R2.pointer--);
                break;
              case s.ParserState.SpecialRelativeOrAuthority:
                "/" === R2.c() && R2.remaining().startsWith("/") ? (C2 = s.ParserState.SpecialAuthorityIgnoreSlashes, R2.pointer++) : (v("Invalid input string."), C2 = s.ParserState.Relative, R2.pointer--);
                break;
              case s.ParserState.PathOrAuthority:
                "/" === R2.c() ? C2 = s.ParserState.Authority : (C2 = s.ParserState.Path, R2.pointer--);
                break;
              case s.ParserState.Relative:
                if (null === t2) throw new Error("Invalid parser state. Base URL is null.");
                switch (i2.scheme = t2.scheme, R2.c()) {
                  case "":
                    i2.username = t2.username, i2.password = t2.password, i2.host = t2.host, i2.port = t2.port, i2.path = u.list.clone(t2.path), i2.query = t2.query;
                    break;
                  case "/":
                    C2 = s.ParserState.RelativeSlash;
                    break;
                  case "?":
                    i2.username = t2.username, i2.password = t2.password, i2.host = t2.host, i2.port = t2.port, i2.path = u.list.clone(t2.path), i2.query = "", C2 = s.ParserState.Query;
                    break;
                  case "#":
                    i2.username = t2.username, i2.password = t2.password, i2.host = t2.host, i2.port = t2.port, i2.path = u.list.clone(t2.path), i2.query = t2.query, i2.fragment = "", C2 = s.ParserState.Fragment;
                    break;
                  default:
                    b(i2) && "\\" === R2.c() ? (v("Invalid input string."), C2 = s.ParserState.RelativeSlash) : (i2.username = t2.username, i2.password = t2.password, i2.host = t2.host, i2.port = t2.port, i2.path = u.list.clone(t2.path), 0 !== i2.path.length && i2.path.splice(i2.path.length - 1, 1), C2 = s.ParserState.Path, R2.pointer--);
                }
                break;
              case s.ParserState.RelativeSlash:
                if (!b(i2) || "/" !== R2.c() && "\\" !== R2.c()) if ("/" === R2.c()) C2 = s.ParserState.Authority;
                else {
                  if (null === t2) throw new Error("Invalid parser state. Base URL is null.");
                  i2.username = t2.username, i2.password = t2.password, i2.host = t2.host, i2.port = t2.port, C2 = s.ParserState.Path, R2.pointer--;
                }
                else "\\" === R2.c() && v("Invalid input string."), C2 = s.ParserState.SpecialAuthorityIgnoreSlashes;
                break;
              case s.ParserState.SpecialAuthoritySlashes:
                "/" === R2.c() && R2.remaining().startsWith("/") ? (C2 = s.ParserState.SpecialAuthorityIgnoreSlashes, R2.pointer++) : (v("Expected '//'."), C2 = s.ParserState.SpecialAuthorityIgnoreSlashes, R2.pointer--);
                break;
              case s.ParserState.SpecialAuthorityIgnoreSlashes:
                "/" !== R2.c() && "\\" !== R2.c() ? (C2 = s.ParserState.Authority, R2.pointer--) : v("Unexpected '/' or '\\'.");
                break;
              case s.ParserState.Authority:
                if ("@" === R2.c()) {
                  v("Unexpected '@'."), M2 && (L2 = "%40" + L2), M2 = true;
                  try {
                    for (var U2 = (l2 = void 0, n(L2)), G2 = U2.next(); !G2.done; G2 = U2.next()) {
                      var q2 = G2.value;
                      if (":" !== q2 || j2) {
                        var W2 = X(q2, d);
                        j2 ? i2.password += W2 : i2.username += W2;
                      } else j2 = true;
                    }
                  } catch (e3) {
                    l2 = { error: e3 };
                  } finally {
                    try {
                      G2 && !G2.done && (c2 = U2.return) && c2.call(U2);
                    } finally {
                      if (l2) throw l2.error;
                    }
                  }
                  L2 = "";
                } else if ("" === R2.c() || "/" === R2.c() || "?" === R2.c() || "#" === R2.c() || b(i2) && "\\" === R2.c()) {
                  if (M2 && "" === L2) return v("Invalid input string."), null;
                  R2.pointer -= L2.length + 1, L2 = "", C2 = s.ParserState.Host;
                } else L2 += R2.c();
                break;
              case s.ParserState.Host:
              case s.ParserState.Hostname:
                if (void 0 !== o2 && "file" === i2.scheme) R2.pointer--, C2 = s.ParserState.FileHost;
                else if (":" !== R2.c() || B2) if ("" === R2.c() || "/" === R2.c() || "?" === R2.c() || "#" === R2.c() || b(i2) && "\\" === R2.c()) {
                  if (R2.pointer--, b(i2) && "" === L2) return v("Invalid input string."), null;
                  if (void 0 !== o2 && "" === L2 && (w(i2) || null !== i2.port)) return v("Invalid input string."), i2;
                  if (null === (J = I(L2, !b(i2)))) return null;
                  if (i2.host = J, L2 = "", C2 = s.ParserState.PathStart, void 0 !== o2) return i2;
                } else "[" === R2.c() && (B2 = true), "]" === R2.c() && (B2 = false), L2 += R2.c();
                else {
                  if ("" === L2) return v("Invalid input string."), null;
                  if (null === (J = I(L2, !b(i2)))) return null;
                  if (i2.host = J, L2 = "", C2 = s.ParserState.Port, o2 === s.ParserState.Hostname) return i2;
                }
                break;
              case s.ParserState.Port:
                if (u.codePoint.ASCIIDigit.test(R2.c())) L2 += R2.c();
                else {
                  if (!("" === R2.c() || "/" === R2.c() || "?" === R2.c() || "#" === R2.c() || b(i2) && "\\" === R2.c() || o2)) return v("Invalid input string."), null;
                  if ("" !== L2 && "" !== L2) {
                    var H2 = parseInt(L2, 10);
                    if (H2 > Math.pow(2, 16) - 1) return v("Invalid port number."), null;
                    i2.port = H2 === x(i2.scheme) ? null : H2, L2 = "";
                  }
                  if (void 0 !== o2) return i2;
                  C2 = s.ParserState.PathStart, R2.pointer--;
                }
                break;
              case s.ParserState.File:
                if (i2.scheme = "file", "/" === R2.c() || "\\" === R2.c()) "\\" === R2.c() && v("Invalid input string."), C2 = s.ParserState.FileSlash;
                else if (null !== t2 && "file" === t2.scheme) switch (R2.c()) {
                  case "":
                    i2.host = t2.host, i2.path = u.list.clone(t2.path), i2.query = t2.query;
                    break;
                  case "?":
                    i2.host = t2.host, i2.path = u.list.clone(t2.path), i2.query = "", C2 = s.ParserState.Query;
                    break;
                  case "#":
                    i2.host = t2.host, i2.path = u.list.clone(t2.path), i2.query = t2.query, i2.fragment = "", C2 = s.ParserState.Fragment;
                    break;
                  default:
                    P(R2.substring()) ? v("Unexpected windows drive letter in input string.") : (i2.host = t2.host, i2.path = u.list.clone(t2.path), O(i2)), C2 = s.ParserState.Path, R2.pointer--;
                }
                else C2 = s.ParserState.Path, R2.pointer--;
                break;
              case s.ParserState.FileSlash:
                "/" === R2.c() || "\\" === R2.c() ? ("\\" === R2.c() && v("Invalid input string."), C2 = s.ParserState.FileHost) : (null === t2 || "file" !== t2.scheme || P(R2.substring()) || (F(t2.path[0]) ? i2.path.push(t2.path[0]) : i2.host = t2.host), C2 = s.ParserState.Path, R2.pointer--);
                break;
              case s.ParserState.FileHost:
                if ("" === R2.c() || "/" === R2.c() || "\\" === R2.c() || "?" === R2.c() || "#" === R2.c()) if (R2.pointer--, void 0 === o2 && k(L2)) v("Unexpected windows drive letter in input string."), C2 = s.ParserState.Path;
                else if ("" === L2) {
                  if (i2.host = "", void 0 !== o2) return i2;
                  C2 = s.ParserState.PathStart;
                } else {
                  var J;
                  if (null === (J = I(L2, !b(i2)))) return null;
                  if ("localhost" === J && (J = ""), i2.host = J, void 0 !== o2) return i2;
                  L2 = "", C2 = s.ParserState.PathStart;
                }
                else L2 += R2.c();
                break;
              case s.ParserState.PathStart:
                b(i2) ? ("\\" === R2.c() && v("Invalid input string."), C2 = s.ParserState.Path, "/" !== R2.c() && "\\" !== R2.c() && R2.pointer--) : void 0 === o2 && "?" === R2.c() ? (i2.query = "", C2 = s.ParserState.Query) : void 0 === o2 && "#" === R2.c() ? (i2.fragment = "", C2 = s.ParserState.Fragment) : "" !== R2.c() && (C2 = s.ParserState.Path, "/" !== R2.c() && R2.pointer--);
                break;
              case s.ParserState.Path:
                if ("" === R2.c() || "/" === R2.c() || b(i2) && "\\" === R2.c() || void 0 === o2 && ("?" === R2.c() || "#" === R2.c())) {
                  if (b(i2) && "\\" === R2.c() && v("Invalid input string."), T(L2)) O(i2), "/" === R2.c() || b(i2) && "\\" === R2.c() || i2.path.push("");
                  else if (!N(L2) || "/" === R2.c() || b(i2) && "\\" === R2.c()) {
                    if (!N(L2)) {
                      if ("file" === i2.scheme && 0 === i2.path.length && k(L2)) {
                        null !== i2.host && "" !== i2.host && (v("Invalid input string."), i2.host = "");
                        var Y = Array.from(L2);
                        L2 = Y.slice(0, 1) + ":" + Y.slice(2);
                      }
                      i2.path.push(L2);
                    }
                  } else i2.path.push("");
                  if (L2 = "", "file" === i2.scheme && ("" === R2.c() || "?" === R2.c() || "#" === R2.c())) for (; i2.path.length > 1 && "" === i2.path[0]; ) v("Invalid input string."), i2.path.splice(0, 1);
                  "?" === R2.c() && (i2.query = "", C2 = s.ParserState.Query), "#" === R2.c() && (i2.fragment = "", C2 = s.ParserState.Fragment);
                } else m.test(R2.c()) || "%" === R2.c() || v("Character is not a URL code point or a percent encoded character."), "%" !== R2.c() || /^[0-9a-fA-F][0-9a-fA-F]/.test(R2.remaining()) || v("Percent encoded character must be followed by two hex digits."), L2 += X(R2.c(), f);
                break;
              case s.ParserState.CannotBeABaseURLPath:
                "?" === R2.c() ? (i2.query = "", C2 = s.ParserState.Query) : "#" === R2.c() ? (i2.fragment = "", C2 = s.ParserState.Fragment) : ("" === R2.c() || m.test(R2.c()) || "%" === R2.c() || v("Character is not a URL code point or a percent encoded character."), "%" !== R2.c() || /^[0-9a-fA-F][0-9a-fA-F]/.test(R2.remaining()) || v("Percent encoded character must be followed by two hex digits."), "" !== R2.c() && (i2.path[0] += X(R2.c(), h)));
                break;
              case s.ParserState.Query:
                if ("UTF-8" === A2 || b(i2) && "ws" !== i2.scheme && "wss" !== i2.scheme || (A2 = "UTF-8"), void 0 === o2 && "#" === R2.c()) i2.fragment = "", C2 = s.ParserState.Fragment;
                else if ("" !== R2.c()) {
                  if (m.test(R2.c()) || "%" === R2.c() || v("Character is not a URL code point or a percent encoded character."), "%" !== R2.c() || /^[0-9a-fA-F][0-9a-fA-F]/.test(R2.remaining()) || v("Percent encoded character must be followed by two hex digits."), "UTF-8" !== A2.toUpperCase()) throw new Error("Only UTF-8 encoding is supported.");
                  var V = a.utf8Encode(R2.c());
                  if (V.length >= 3 && 38 === V[0] && 35 === V[1] && 59 === V[V.length - 1]) V = V.subarray(2, V.length - 1), i2.query += "%26%23" + u.byteSequence.isomorphicDecode(V) + "%3B";
                  else try {
                    for (var K = (y2 = void 0, n(V)), $ = K.next(); !$.done; $ = K.next()) {
                      var Q = $.value;
                      Q < 33 || Q > 126 || 34 === Q || 35 === Q || 60 === Q || 62 === Q || 39 === Q && b(i2) ? i2.query += z(Q) : i2.query += String.fromCharCode(Q);
                    }
                  } catch (e3) {
                    y2 = { error: e3 };
                  } finally {
                    try {
                      $ && !$.done && (_2 = K.return) && _2.call(K);
                    } finally {
                      if (y2) throw y2.error;
                    }
                  }
                }
                break;
              case s.ParserState.Fragment:
                "" === R2.c() || ("\0" === R2.c() ? v("NULL character in input string.") : (m.test(R2.c()) || "%" === R2.c() || v("Unexpected character in fragment string."), "%" !== R2.c() || /^[A-Za-z0-9][A-Za-z0-9]/.test(R2.remaining()) || v("Unexpected character in fragment string."), i2.fragment += X(R2.c(), p)));
            }
            if (R2.eof) break;
            R2.pointer++;
          }
          return i2;
        }
        function N(e2) {
          return "." === e2 || "%2e" === e2.toLowerCase();
        }
        function T(e2) {
          var t2 = e2.toLowerCase();
          return ".." === t2 || ".%2e" === t2 || "%2e." === t2 || "%2e%2e" === t2;
        }
        function O(e2) {
          var t2 = e2.path;
          0 !== t2.length && ("file" === e2.scheme && 1 === t2.length && F(t2[0]) || e2.path.splice(e2.path.length - 1, 1));
        }
        function F(e2) {
          return e2.length >= 2 && u.codePoint.ASCIIAlpha.test(e2[0]) && ":" === e2[1];
        }
        function k(e2) {
          return e2.length >= 2 && u.codePoint.ASCIIAlpha.test(e2[0]) && (":" === e2[1] || "|" === e2[1]);
        }
        function P(e2) {
          return e2.length >= 2 && k(e2) && (2 === e2.length || "/" === e2[2] || "\\" === e2[2] || "?" === e2[2] || "#" === e2[2]);
        }
        function I(e2, t2) {
          if (void 0 === t2 && (t2 = false), e2.startsWith("[")) return e2.endsWith("]") ? B(e2.substring(1, e2.length - 1)) : (v("Expected ']' after '['."), null);
          if (t2) return j(e2);
          var r2 = H(a.utf8Decode(G(e2)));
          if (null === r2) return v("Invalid domain."), null;
          if (y.test(r2)) return v("Invalid domain."), null;
          var n2 = M(r2);
          return null === n2 || a.isNumber(n2) ? n2 : r2;
        }
        function L(e2, t2) {
          void 0 === t2 && (t2 = { value: false });
          var r2 = 10;
          return e2.startsWith("0x") || e2.startsWith("0X") ? (t2.value = true, e2 = e2.substr(2), r2 = 16) : e2.length >= 2 && "0" === e2[0] && (t2.value = true, e2 = e2.substr(1), r2 = 8), "" === e2 ? 0 : (10 === r2 ? /^[0-9]+$/ : 16 === r2 ? /^[0-9A-Fa-f]+$/ : /^[0-7]+$/).test(e2) ? parseInt(e2, r2) : null;
        }
        function M(e2) {
          var t2, r2, i2, o2, a2 = { value: false }, s2 = e2.split(".");
          if ("" === s2[s2.length - 1] && (a2.value = true, s2.length > 1 && s2.pop()), s2.length > 4) return e2;
          var u2 = [];
          try {
            for (var l2 = n(s2), c2 = l2.next(); !c2.done; c2 = l2.next()) {
              var h2 = c2.value;
              if ("" === h2) return e2;
              if (null === (_2 = L(h2, a2))) return e2;
              u2.push(_2);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              c2 && !c2.done && (r2 = l2.return) && r2.call(l2);
            } finally {
              if (t2) throw t2.error;
            }
          }
          a2.value && v("Invalid IP v4 address.");
          for (var p2 = 0; p2 < u2.length; p2++) {
            if (u2[p2] > 255 && (v("Invalid IP v4 address."), p2 < u2.length - 1)) return null;
          }
          if (u2[u2.length - 1] >= Math.pow(256, 5 - u2.length)) return v("Invalid IP v4 address."), null;
          var f2 = u2[u2.length - 1];
          u2.pop();
          var d2 = 0;
          try {
            for (var m2 = n(u2), y2 = m2.next(); !y2.done; y2 = m2.next()) {
              var _2;
              f2 += (_2 = y2.value) * Math.pow(256, 3 - d2), d2++;
            }
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              y2 && !y2.done && (o2 = m2.return) && o2.call(m2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return f2;
        }
        function B(e2) {
          var t2, r2 = [0, 0, 0, 0, 0, 0, 0, 0], n2 = 0, o2 = null, s2 = new a.StringWalker(e2);
          if (":" === s2.c()) {
            if (!s2.remaining().startsWith(":")) return v("Invalid IP v6 address."), null;
            s2.pointer += 2, o2 = n2 += 1;
          }
          for (; "" !== s2.c(); ) {
            if (8 === n2) return v("Invalid IP v6 address."), null;
            if (":" !== s2.c()) {
              for (var l2 = 0, c2 = 0; c2 < 4 && u.codePoint.ASCIIHexDigit.test(s2.c()); ) l2 = 16 * l2 + parseInt(s2.c(), 16), s2.pointer++, c2++;
              if ("." === s2.c()) {
                if (0 === c2) return v("Invalid IP v6 address."), null;
                if (s2.pointer -= c2, n2 > 6) return v("Invalid IP v6 address."), null;
                for (var h2 = 0; "" !== s2.c(); ) {
                  var p2 = null;
                  if (h2 > 0) {
                    if (!("." === s2.c() && h2 < 4)) return v("Invalid IP v6 address."), null;
                    s2.pointer++;
                  }
                  if (!u.codePoint.ASCIIDigit.test(s2.c())) return v("Invalid IP v6 address."), null;
                  for (; u.codePoint.ASCIIDigit.test(s2.c()); ) {
                    var f2 = parseInt(s2.c(), 10);
                    if (null === p2) p2 = f2;
                    else {
                      if (0 === p2) return v("Invalid IP v6 address."), null;
                      p2 = 10 * p2 + f2;
                    }
                    if (p2 > 255) return v("Invalid IP v6 address."), null;
                    s2.pointer++;
                  }
                  if (null === p2) return v("Invalid IP v6 address."), null;
                  r2[n2] = 256 * r2[n2] + p2, 2 !== ++h2 && 4 !== h2 || n2++;
                }
                if (4 !== h2) return v("Invalid IP v6 address."), null;
                break;
              }
              if (":" === s2.c()) {
                if (s2.pointer++, "" === s2.c()) return v("Invalid IP v6 address."), null;
              } else if ("" !== s2.c()) return v("Invalid IP v6 address."), null;
              r2[n2] = l2, n2++;
            } else {
              if (null !== o2) return v("Invalid IP v6 address."), null;
              s2.pointer++, o2 = ++n2;
            }
          }
          if (null !== o2) {
            var d2 = n2 - o2;
            for (n2 = 7; 0 !== n2 && d2 > 0; ) t2 = i([r2[o2 + d2 - 1], r2[n2]], 2), r2[n2] = t2[0], r2[o2 + d2 - 1] = t2[1], n2--, d2--;
          } else if (null === o2 && 8 !== n2) return v("Invalid IP v6 address."), null;
          return r2;
        }
        function j(e2) {
          var t2, r2;
          if (/[\x00\t\f\r #/:?@\[\\\]]/.test(e2)) return v("Invalid host string."), null;
          var i2 = "";
          try {
            for (var o2 = n(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              i2 += X(a2.value, h);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (t2) throw t2.error;
            }
          }
          return i2;
        }
        function R(e2) {
          return null;
        }
        function z(e2) {
          return "%" + ("00" + e2.toString(16).toUpperCase()).slice(-2);
        }
        function U(e2) {
          for (var t2 = function(e3) {
            return e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102;
          }, r2 = new Uint8Array(e2.length), n2 = 0, i2 = 0; i2 < e2.length; i2++) {
            var o2 = e2[i2];
            if (37 !== o2) r2[n2] = o2, n2++;
            else if (37 === o2 && i2 >= e2.length - 2) r2[n2] = o2, n2++;
            else if (37 !== o2 || t2(e2[i2 + 1]) && t2(e2[i2 + 2])) {
              var s2 = parseInt(a.utf8Decode(Uint8Array.of(e2[i2 + 1], e2[i2 + 2])), 16);
              r2[n2] = s2, n2++, i2 += 2;
            } else r2[n2] = o2, n2++;
          }
          return r2.subarray(0, n2);
        }
        function G(e2) {
          return U(a.utf8Encode(e2));
        }
        function X(e2, t2) {
          var r2, i2;
          if (!t2.test(e2)) return e2;
          var o2 = a.utf8Encode(e2), s2 = "";
          try {
            for (var u2 = n(o2), l2 = u2.next(); !l2.done; l2 = u2.next()) {
              s2 += z(l2.value);
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              l2 && !l2.done && (i2 = u2.return) && i2.call(u2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          return s2;
        }
        function q(e2) {
          var t2, r2, i2, o2, s2 = [], u2 = [];
          try {
            for (var l2 = n(e2), c2 = l2.next(); !c2.done; c2 = l2.next()) {
              var h2 = c2.value;
              38 === h2 ? (s2.push(Uint8Array.from(u2)), u2 = []) : u2.push(h2);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              c2 && !c2.done && (r2 = l2.return) && r2.call(l2);
            } finally {
              if (t2) throw t2.error;
            }
          }
          0 !== u2.length && s2.push(Uint8Array.from(u2));
          var p2 = [];
          try {
            for (var f2 = n(s2), d2 = f2.next(); !d2.done; d2 = f2.next()) {
              var m2 = d2.value;
              if (0 !== m2.length) {
                for (var y2 = m2.indexOf(61), v2 = -1 !== y2 ? m2.slice(0, y2) : m2, _2 = -1 !== y2 ? m2.slice(y2 + 1) : new Uint8Array(), g2 = 0; g2 < v2.length; g2++) 43 === v2[g2] && (v2[g2] = 32);
                for (g2 = 0; g2 < _2.length; g2++) 43 === _2[g2] && (_2[g2] = 32);
                var b3 = a.utf8Decode(v2), x2 = a.utf8Decode(_2);
                p2.push([b3, x2]);
              }
            }
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              d2 && !d2.done && (o2 = f2.return) && o2.call(f2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return p2;
        }
        function W(e2) {
          var t2, r2, i2 = "";
          try {
            for (var o2 = n(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              var s2 = a2.value;
              i2 += 32 === s2 ? "+" : 42 === s2 || 45 === s2 || 46 === s2 || s2 >= 48 && s2 <= 57 || s2 >= 65 && s2 <= 90 || 95 === s2 || s2 >= 97 && s2 <= 122 ? String.fromCodePoint(s2) : z(s2);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (t2) throw t2.error;
            }
          }
          return i2;
        }
        function H(e2, t2) {
          void 0 === t2 && (t2 = false);
          var r2 = l.domainToASCII(e2);
          return "" === r2 ? (v("Invalid domain name."), null) : r2;
        }
        t.setValidationErrorCallback = function(e2) {
          o = e2;
        }, t.newURL = _, t.isSpecialScheme = g, t.isSpecial = b, t.defaultPort = x, t.includesCredentials = w, t.cannotHaveAUsernamePasswordPort = function(e2) {
          return null === e2.host || "" === e2.host || e2._cannotBeABaseURLFlag || "file" === e2.scheme;
        }, t.urlSerializer = E, t.hostSerializer = D, t.iPv4Serializer = S, t.iPv6Serializer = C, t.urlParser = function(e2, t2, r2) {
          var n2 = A(e2, t2, r2);
          return null === n2 ? null : ("blob" !== n2.scheme || (n2._blobURLEntry = null), n2);
        }, t.basicURLParser = A, t.setTheUsername = function(e2, t2) {
          var r2, i2, o2 = "";
          try {
            for (var a2 = n(t2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
              o2 += X(s2.value, d);
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (i2 = a2.return) && i2.call(a2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          e2.username = o2;
        }, t.setThePassword = function(e2, t2) {
          var r2, i2, o2 = "";
          try {
            for (var a2 = n(t2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
              o2 += X(s2.value, d);
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (i2 = a2.return) && i2.call(a2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          e2.password = o2;
        }, t.isSingleDotPathSegment = N, t.isDoubleDotPathSegment = T, t.shorten = O, t.isNormalizedWindowsDriveLetter = F, t.isWindowsDriveLetter = k, t.startsWithAWindowsDriveLetter = P, t.hostParser = I, t.iPv4NumberParser = L, t.iPv4Parser = M, t.iPv6Parser = B, t.opaqueHostParser = j, t.resolveABlobURL = R, t.percentEncode = z, t.percentDecode = U, t.stringPercentDecode = G, t.utf8PercentEncode = X, t.hostEquals = function(e2, t2) {
          return e2 === t2;
        }, t.urlEquals = function(e2, t2, r2) {
          return void 0 === r2 && (r2 = false), E(e2, r2) === E(t2, r2);
        }, t.urlEncodedStringParser = function(e2) {
          return q(a.utf8Encode(e2));
        }, t.urlEncodedParser = q, t.urlEncodedByteSerializer = W, t.urlEncodedSerializer = function(e2, t2) {
          var r2, i2;
          if ("UTF-8" !== (void 0 === t2 || "replacement" === t2 || "UTF-16BE" === t2 || "UTF-16LE" === t2 ? "UTF-8" : t2).toUpperCase()) throw new Error("Only UTF-8 encoding is supported.");
          var o2 = "";
          try {
            for (var s2 = n(e2), u2 = s2.next(); !u2.done; u2 = s2.next()) {
              var l2 = u2.value, c2 = W(a.utf8Encode(l2[0])), h2 = l2[1];
              h2 = W(a.utf8Encode(h2)), "" !== o2 && (o2 += "&"), o2 += c2 + "=" + h2;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              u2 && !u2.done && (i2 = s2.return) && i2.call(s2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          return o2;
        }, t.origin = function e2(t2) {
          switch (t2.scheme) {
            case "blob":
              t2._blobURLEntry;
              var r2 = A(t2.path[0]);
              return null === r2 ? s.OpaqueOrigin : e2(r2);
            case "ftp":
            case "http":
            case "https":
            case "ws":
            case "wss":
              return [t2.scheme, null === t2.host ? "" : t2.host, t2.port, null];
            case "file":
            default:
              return s.OpaqueOrigin;
          }
        }, t.domainToASCII = H, t.domainToUnicode = function(e2, t2) {
          void 0 === t2 && (t2 = false);
          var r2 = l.domainToUnicode(e2);
          return "" === r2 && v("Invalid domain name."), r2;
        }, t.asciiSerializationOfAnOrigin = function(e2) {
          if ("" === e2[0] && "" === e2[1] && null === e2[2] && null === e2[3]) return "null";
          var t2 = e2[0] + "://" + D(e2[1]);
          return null !== e2[2] && (t2 += ":" + e2[2].toString()), t2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(0), i = function() {
          function e2() {
            this._signal = n.create_abortSignal();
          }
          return Object.defineProperty(e2.prototype, "signal", { get: function() {
            return this._signal;
          }, enumerable: true, configurable: true }), e2.prototype.abort = function() {
            n.abort_signalAbort(this._signal);
          }, e2;
        }();
        t.AbortControllerImpl = i;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(70), a = r(0), s = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this;
            return t3._abortedFlag = false, t3._abortAlgorithms = /* @__PURE__ */ new Set(), t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "aborted", { get: function() {
            return this._abortedFlag;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "onabort", { get: function() {
            return a.event_getterEventHandlerIDLAttribute(this, "onabort");
          }, set: function(e3) {
            a.event_setterEventHandlerIDLAttribute(this, "onabort", e3);
          }, enumerable: true, configurable: true }), t2._create = function() {
            return new t2();
          }, t2;
        }(o.EventTargetImpl);
        t.AbortSignalImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(2), a = r(34), s = r(12), u = function(e2) {
          function t2(t3, r2, n2) {
            var i2 = e2.call(this) || this;
            return i2._name = "", i2._publicId = "", i2._systemId = "", i2._name = t3, i2._publicId = r2, i2._systemId = n2, i2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "name", { get: function() {
            return this._name;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "publicId", { get: function() {
            return this._publicId;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "systemId", { get: function() {
            return this._systemId;
          }, enumerable: true, configurable: true }), t2.prototype.before = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.after = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.replaceWith = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.remove = function() {
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2._create = function(e3, r2, n2, i2) {
            void 0 === n2 && (n2 = ""), void 0 === i2 && (i2 = "");
            var o2 = new t2(r2, n2, i2);
            return o2._nodeDocument = e3, o2;
          }, t2;
        }(a.NodeImpl);
        t.DocumentTypeImpl = u, s.idl_defineConst(u.prototype, "_nodeType", o.NodeType.DocumentType);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(100), a = r(1), s = r(0), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this) || this;
            return n2._host = t3, n2._mode = r2, n2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "mode", { get: function() {
            return this._mode;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "host", { get: function() {
            return this._host;
          }, enumerable: true, configurable: true }), t2.prototype._getTheParent = function(e3) {
            return e3._composedFlag || a.isEmpty(e3._path) || s.tree_rootNode(e3._path[0].invocationTarget) !== this ? this._host : null;
          }, t2._create = function(e3, r2) {
            return new t2(r2, "closed");
          }, t2;
        }(o.DocumentFragmentImpl);
        t.ShadowRootImpl = u;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(2), a = r(34), s = r(0), u = r(12), l = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this) || this;
            return r2._namespace = null, r2._namespacePrefix = null, r2._element = null, r2._value = "", r2._localName = t3, r2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "ownerElement", { get: function() {
            return this._element;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "namespaceURI", { get: function() {
            return this._namespace;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "prefix", { get: function() {
            return this._namespacePrefix;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "localName", { get: function() {
            return this._localName;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "name", { get: function() {
            return this._qualifiedName;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "value", { get: function() {
            return this._value;
          }, set: function(e3) {
            s.attr_setAnExistingAttributeValue(this, e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "_qualifiedName", { get: function() {
            return null !== this._namespacePrefix ? this._namespacePrefix + ":" + this._localName : this._localName;
          }, enumerable: true, configurable: true }), t2._create = function(e3, r2) {
            var n2 = new t2(r2);
            return n2._nodeDocument = e3, n2;
          }, t2;
        }(a.NodeImpl);
        t.AttrImpl = l, u.idl_defineConst(l.prototype, "_nodeType", o.NodeType.Attribute), u.idl_defineConst(l.prototype, "specified", true);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(101), a = r(2), s = r(12), u = function(e2) {
          function t2(t3) {
            return e2.call(this, t3) || this;
          }
          return i(t2, e2), t2._create = function(e3, r2) {
            void 0 === r2 && (r2 = "");
            var n2 = new t2(r2);
            return n2._nodeDocument = e3, n2;
          }, t2;
        }(o.TextImpl);
        t.CDATASectionImpl = u, s.idl_defineConst(u.prototype, "_nodeType", a.NodeType.CData);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(2), a = r(71), s = r(12), u = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, t3) || this;
          }
          return i(t2, e2), t2._create = function(e3, r2) {
            void 0 === r2 && (r2 = "");
            var n2 = new t2(r2);
            return n2._nodeDocument = e3, n2;
          }, t2;
        }(a.CharacterDataImpl);
        t.CommentImpl = u, s.idl_defineConst(u.prototype, "_nodeType", o.NodeType.Comment);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(2), a = r(71), s = r(12), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, r2) || this;
            return n2._target = t3, n2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "target", { get: function() {
            return this._target;
          }, enumerable: true, configurable: true }), t2._create = function(e3, r2, n2) {
            var i2 = new t2(r2, n2);
            return i2._nodeDocument = e3, i2;
          }, t2;
        }(a.CharacterDataImpl);
        t.ProcessingInstructionImpl = u, s.idl_defineConst(u.prototype, "_nodeType", o.NodeType.ProcessingInstruction);
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(7), i = r(0), o = r(3), a = r(1), s = function() {
          function e2(e3, t2) {
            return this._live = true, this._root = e3, this._filter = t2, new Proxy(this, this);
          }
          return Object.defineProperty(e2.prototype, "length", { get: function() {
            for (var e3 = this, t2 = 0, r2 = i.tree_getFirstDescendantNode(this._root, false, false, function(t3) {
              return o.Guard.isElementNode(t3) && e3._filter(t3);
            }); null !== r2; ) t2++, r2 = i.tree_getNextDescendantNode(this._root, r2, false, false, function(t3) {
              return o.Guard.isElementNode(t3) && e3._filter(t3);
            });
            return t2;
          }, enumerable: true, configurable: true }), e2.prototype.item = function(e3) {
            for (var t2 = this, r2 = 0, n2 = i.tree_getFirstDescendantNode(this._root, false, false, function(e4) {
              return o.Guard.isElementNode(e4) && t2._filter(e4);
            }); null !== n2; ) {
              if (r2 === e3) return n2;
              r2++, n2 = i.tree_getNextDescendantNode(this._root, n2, false, false, function(e4) {
                return o.Guard.isElementNode(e4) && t2._filter(e4);
              });
            }
            return null;
          }, e2.prototype.namedItem = function(e3) {
            var t2 = this;
            if ("" === e3) return null;
            for (var r2 = i.tree_getFirstDescendantNode(this._root, false, false, function(e4) {
              return o.Guard.isElementNode(e4) && t2._filter(e4);
            }); null != r2; ) {
              if (r2._uniqueIdentifier === e3) return r2;
              if (r2._namespace === n.namespace.HTML) for (var a2 = 0; a2 < r2._attributeList.length; a2++) {
                var s2 = r2._attributeList[a2];
                if ("name" === s2._localName && null === s2._namespace && null === s2._namespacePrefix && s2._value === e3) return r2;
              }
              r2 = i.tree_getNextDescendantNode(this._root, r2, false, false, function(e4) {
                return o.Guard.isElementNode(e4) && t2._filter(e4);
              });
            }
            return null;
          }, e2.prototype[Symbol.iterator] = function() {
            var e3 = this._root, t2 = this._filter, r2 = i.tree_getFirstDescendantNode(e3, false, false, function(e4) {
              return o.Guard.isElementNode(e4) && t2(e4);
            });
            return { next: function() {
              if (null === r2) return { done: true, value: null };
              var n2 = { done: false, value: r2 };
              return r2 = i.tree_getNextDescendantNode(e3, r2, false, false, function(e4) {
                return o.Guard.isElementNode(e4) && t2(e4);
              }), n2;
            } };
          }, e2.prototype.get = function(t2, r2, n2) {
            if (!a.isString(r2) || -1 !== e2.reservedNames.indexOf(r2)) return Reflect.get(t2, r2, n2);
            var i2 = Number(r2);
            return isNaN(i2) ? t2.namedItem(r2) || void 0 : t2.item(i2) || void 0;
          }, e2.prototype.set = function(t2, r2, n2, o2) {
            if (!a.isString(r2) || -1 !== e2.reservedNames.indexOf(r2)) return Reflect.set(t2, r2, n2, o2);
            var s2 = Number(r2), u = isNaN(s2) ? t2.namedItem(r2) || void 0 : t2.item(s2) || void 0;
            return !(!u || !u._parent) && (i.mutation_replace(u, n2, u._parent), true);
          }, e2._create = function(t2, r2) {
            return void 0 === r2 && (r2 = function() {
              return true;
            }), new e2(t2, r2);
          }, e2.reservedNames = ["_root", "_live", "_filter", "length", "item", "namedItem", "get", "set"], e2;
        }();
        t.HTMLCollectionImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(1), a = r(0), s = function() {
          function e2(e3) {
            return this._live = true, this._filter = null, this._length = 0, this._root = e3, new Proxy(this, this);
          }
          return Object.defineProperty(e2.prototype, "length", { get: function() {
            return this._root._children.size;
          }, enumerable: true, configurable: true }), e2.prototype.item = function(e3) {
            if (e3 < 0 || e3 > this.length - 1) return null;
            if (e3 < this.length / 2) {
              for (var t2 = 0, r2 = this._root._firstChild; null !== r2 && t2 !== e3; ) r2 = r2._nextSibling, t2++;
              return r2;
            }
            for (t2 = this.length - 1, r2 = this._root._lastChild; null !== r2 && t2 !== e3; ) r2 = r2._previousSibling, t2--;
            return r2;
          }, e2.prototype.keys = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = (function() {
              var e4 = 0;
              return { next: (function() {
                return e4 === this.length ? { done: true, value: null } : { done: false, value: e4++ };
              }).bind(this) };
            }).bind(this), e3;
          }, e2.prototype.values = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = (function() {
              var e4 = this[Symbol.iterator]();
              return { next: function() {
                return e4.next();
              } };
            }).bind(this), e3;
          }, e2.prototype.entries = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = (function() {
              var e4 = this[Symbol.iterator](), t2 = 0;
              return { next: function() {
                var r2 = e4.next();
                return r2.done ? { done: true, value: null } : { done: false, value: [t2++, r2.value] };
              } };
            }).bind(this), e3;
          }, e2.prototype[Symbol.iterator] = function() {
            return this._root._children[Symbol.iterator]();
          }, e2.prototype.forEach = function(e3, t2) {
            var r2, o2;
            void 0 === t2 && (t2 = i.dom.window);
            var a2 = 0;
            try {
              for (var s2 = n(this._root._children), u = s2.next(); !u.done; u = s2.next()) {
                var l = u.value;
                e3.call(t2, l, a2++, this);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                u && !u.done && (o2 = s2.return) && o2.call(s2);
              } finally {
                if (r2) throw r2.error;
              }
            }
          }, e2.prototype.get = function(e3, t2, r2) {
            if (!o.isString(t2)) return Reflect.get(e3, t2, r2);
            var n2 = Number(t2);
            return isNaN(n2) ? Reflect.get(e3, t2, r2) : e3.item(n2) || void 0;
          }, e2.prototype.set = function(e3, t2, r2, n2) {
            if (!o.isString(t2)) return Reflect.set(e3, t2, r2, n2);
            var i2 = Number(t2);
            if (isNaN(i2)) return Reflect.set(e3, t2, r2, n2);
            var s2 = e3.item(i2) || void 0;
            return !!s2 && (!!s2._parent && (a.mutation_replace(s2, r2, s2._parent), true));
          }, e2._create = function(t2) {
            return new e2(t2);
          }, e2;
        }();
        t.NodeListImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(1), a = function() {
          function e2(e3) {
            return this._live = false, this._items = [], this._length = 0, this._root = e3, this._items = [], this._filter = function(e4) {
              return true;
            }, new Proxy(this, this);
          }
          return Object.defineProperty(e2.prototype, "length", { get: function() {
            return this._items.length;
          }, enumerable: true, configurable: true }), e2.prototype.item = function(e3) {
            return e3 < 0 || e3 > this.length - 1 ? null : this._items[e3];
          }, e2.prototype.keys = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = (function() {
              var e4 = 0;
              return { next: (function() {
                return e4 === this.length ? { done: true, value: null } : { done: false, value: e4++ };
              }).bind(this) };
            }).bind(this), e3;
          }, e2.prototype.values = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = (function() {
              var e4 = this[Symbol.iterator]();
              return { next: function() {
                return e4.next();
              } };
            }).bind(this), e3;
          }, e2.prototype.entries = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = (function() {
              var e4 = this[Symbol.iterator](), t2 = 0;
              return { next: function() {
                var r2 = e4.next();
                return r2.done ? { done: true, value: null } : { done: false, value: [t2++, r2.value] };
              } };
            }).bind(this), e3;
          }, e2.prototype[Symbol.iterator] = function() {
            var e3 = this._items[Symbol.iterator]();
            return { next: function() {
              return e3.next();
            } };
          }, e2.prototype.forEach = function(e3, t2) {
            var r2, o2;
            void 0 === t2 && (t2 = i.dom.window);
            var a2 = 0;
            try {
              for (var s = n(this._items), u = s.next(); !u.done; u = s.next()) {
                var l = u.value;
                e3.call(t2, l, a2++, this);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                u && !u.done && (o2 = s.return) && o2.call(s);
              } finally {
                if (r2) throw r2.error;
              }
            }
          }, e2.prototype.get = function(e3, t2, r2) {
            if (!o.isString(t2)) return Reflect.get(e3, t2, r2);
            var n2 = Number(t2);
            return isNaN(n2) ? Reflect.get(e3, t2, r2) : e3._items[n2] || void 0;
          }, e2.prototype.set = function(e3, t2, r2, n2) {
            if (!o.isString(t2)) return Reflect.set(e3, t2, r2, n2);
            var i2 = Number(t2);
            return isNaN(i2) ? Reflect.set(e3, t2, r2, n2) : i2 >= 0 && i2 < e3._items.length && (e3._items[i2] = r2, true);
          }, e2._create = function(t2, r2) {
            var n2 = new e2(t2);
            return n2._items = r2, n2;
          }, e2;
        }();
        t.NodeListStaticImpl = a;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(9), a = r(0), s = function(e2) {
          function t2(r2) {
            var n2 = e2.call(this) || this;
            return n2._element = r2, Object.setPrototypeOf(n2, t2.prototype), n2;
          }
          return i(t2, e2), t2.prototype._asArray = function() {
            return this;
          }, t2.prototype.item = function(e3) {
            return this[e3] || null;
          }, t2.prototype.getNamedItem = function(e3) {
            return a.element_getAnAttributeByName(e3, this._element);
          }, t2.prototype.getNamedItemNS = function(e3, t3) {
            return a.element_getAnAttributeByNamespaceAndLocalName(e3 || "", t3, this._element);
          }, t2.prototype.setNamedItem = function(e3) {
            return a.element_setAnAttribute(e3, this._element);
          }, t2.prototype.setNamedItemNS = function(e3) {
            return a.element_setAnAttribute(e3, this._element);
          }, t2.prototype.removeNamedItem = function(e3) {
            var t3 = a.element_removeAnAttributeByName(e3, this._element);
            if (null === t3) throw new o.NotFoundError();
            return t3;
          }, t2.prototype.removeNamedItemNS = function(e3, t3) {
            var r2 = a.element_removeAnAttributeByNamespaceAndLocalName(e3 || "", t3, this._element);
            if (null === r2) throw new o.NotFoundError();
            return r2;
          }, t2._create = function(e3) {
            return new t2(e3);
          }, t2;
        }(Array);
        t.NamedNodeMapImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(6), s = r(2), u = r(102), l = r(9), c = r(0), h = r(12), p = r(3), f = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this, r2 = a.dom.window._associatedDocument;
            return t3._start = [r2, 0], t3._end = [r2, 0], a.dom.rangeList.add(t3), t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "commonAncestorContainer", { get: function() {
            for (var e3 = this._start[0]; !c.tree_isAncestorOf(this._end[0], e3, true); ) {
              if (null === e3._parent) throw new Error("Parent node  is null.");
              e3 = e3._parent;
            }
            return e3;
          }, enumerable: true, configurable: true }), t2.prototype.setStart = function(e3, t3) {
            c.range_setTheStart(this, e3, t3);
          }, t2.prototype.setEnd = function(e3, t3) {
            c.range_setTheEnd(this, e3, t3);
          }, t2.prototype.setStartBefore = function(e3) {
            var t3 = e3._parent;
            if (null === t3) throw new l.InvalidNodeTypeError();
            c.range_setTheStart(this, t3, c.tree_index(e3));
          }, t2.prototype.setStartAfter = function(e3) {
            var t3 = e3._parent;
            if (null === t3) throw new l.InvalidNodeTypeError();
            c.range_setTheStart(this, t3, c.tree_index(e3) + 1);
          }, t2.prototype.setEndBefore = function(e3) {
            var t3 = e3._parent;
            if (null === t3) throw new l.InvalidNodeTypeError();
            c.range_setTheEnd(this, t3, c.tree_index(e3));
          }, t2.prototype.setEndAfter = function(e3) {
            var t3 = e3._parent;
            if (null === t3) throw new l.InvalidNodeTypeError();
            c.range_setTheEnd(this, t3, c.tree_index(e3) + 1);
          }, t2.prototype.collapse = function(e3) {
            e3 ? this._end = this._start : this._start = this._end;
          }, t2.prototype.selectNode = function(e3) {
            c.range_select(e3, this);
          }, t2.prototype.selectNodeContents = function(e3) {
            if (p.Guard.isDocumentTypeNode(e3)) throw new l.InvalidNodeTypeError();
            var t3 = c.tree_nodeLength(e3);
            this._start = [e3, 0], this._end = [e3, t3];
          }, t2.prototype.compareBoundaryPoints = function(e3, t3) {
            if (e3 !== s.HowToCompare.StartToStart && e3 !== s.HowToCompare.StartToEnd && e3 !== s.HowToCompare.EndToEnd && e3 !== s.HowToCompare.EndToStart) throw new l.NotSupportedError();
            if (c.range_root(this) !== c.range_root(t3)) throw new l.WrongDocumentError();
            var r2, n2;
            switch (e3) {
              case s.HowToCompare.StartToStart:
                r2 = this._start, n2 = t3._start;
                break;
              case s.HowToCompare.StartToEnd:
                r2 = this._end, n2 = t3._start;
                break;
              case s.HowToCompare.EndToEnd:
                r2 = this._end, n2 = t3._end;
                break;
              case s.HowToCompare.EndToStart:
                r2 = this._start, n2 = t3._end;
                break;
              default:
                throw new l.NotSupportedError();
            }
            var i2 = c.boundaryPoint_position(r2, n2);
            return i2 === s.BoundaryPosition.Before ? -1 : i2 === s.BoundaryPosition.After ? 1 : 0;
          }, t2.prototype.deleteContents = function() {
            var e3, t3, r2, n2;
            if (!c.range_collapsed(this)) {
              var i2 = this._startNode, a2 = this._startOffset, s2 = this._endNode, u2 = this._endOffset;
              if (i2 === s2 && p.Guard.isCharacterDataNode(i2)) c.characterData_replaceData(i2, a2, u2 - a2, "");
              else {
                var l2, h2, f2 = [];
                try {
                  for (var d = o(c.range_getContainedNodes(this)), m = d.next(); !m.done; m = d.next()) {
                    var y = (b = m.value)._parent;
                    null !== y && c.range_isContained(y, this) || f2.push(b);
                  }
                } catch (t4) {
                  e3 = { error: t4 };
                } finally {
                  try {
                    m && !m.done && (t3 = d.return) && t3.call(d);
                  } finally {
                    if (e3) throw e3.error;
                  }
                }
                if (c.tree_isAncestorOf(s2, i2, true)) l2 = i2, h2 = a2;
                else {
                  for (var v = i2; null !== v._parent && !c.tree_isAncestorOf(s2, v._parent, true); ) v = v._parent;
                  if (null === v._parent) throw new Error("Parent node is null.");
                  l2 = v._parent, h2 = c.tree_index(v) + 1;
                }
                p.Guard.isCharacterDataNode(i2) && c.characterData_replaceData(i2, a2, c.tree_nodeLength(i2) - a2, "");
                try {
                  for (var _ = o(f2), g = _.next(); !g.done; g = _.next()) {
                    var b;
                    (b = g.value)._parent && c.mutation_remove(b, b._parent);
                  }
                } catch (e4) {
                  r2 = { error: e4 };
                } finally {
                  try {
                    g && !g.done && (n2 = _.return) && n2.call(_);
                  } finally {
                    if (r2) throw r2.error;
                  }
                }
                p.Guard.isCharacterDataNode(s2) && c.characterData_replaceData(s2, 0, u2, ""), this._start = [l2, h2], this._end = [l2, h2];
              }
            }
          }, t2.prototype.extractContents = function() {
            return c.range_extract(this);
          }, t2.prototype.cloneContents = function() {
            return c.range_cloneTheContents(this);
          }, t2.prototype.insertNode = function(e3) {
            return c.range_insert(e3, this);
          }, t2.prototype.surroundContents = function(e3) {
            var t3, r2;
            try {
              for (var n2 = o(c.range_getPartiallyContainedNodes(this)), i2 = n2.next(); !i2.done; i2 = n2.next()) {
                var a2 = i2.value;
                if (!p.Guard.isTextNode(a2)) throw new l.InvalidStateError();
              }
            } catch (e4) {
              t3 = { error: e4 };
            } finally {
              try {
                i2 && !i2.done && (r2 = n2.return) && r2.call(n2);
              } finally {
                if (t3) throw t3.error;
              }
            }
            if (p.Guard.isDocumentNode(e3) || p.Guard.isDocumentTypeNode(e3) || p.Guard.isDocumentFragmentNode(e3)) throw new l.InvalidNodeTypeError();
            var s2 = c.range_extract(this);
            0 !== e3._children.size && c.mutation_replaceAll(null, e3), c.range_insert(e3, this), c.mutation_append(s2, e3), c.range_select(e3, this);
          }, t2.prototype.cloneRange = function() {
            return c.create_range(this._start, this._end);
          }, t2.prototype.detach = function() {
            a.dom.rangeList.delete(this);
          }, t2.prototype.isPointInRange = function(e3, t3) {
            if (c.tree_rootNode(e3) !== c.range_root(this)) return false;
            if (p.Guard.isDocumentTypeNode(e3)) throw new l.InvalidNodeTypeError();
            if (t3 > c.tree_nodeLength(e3)) throw new l.IndexSizeError();
            var r2 = [e3, t3];
            return c.boundaryPoint_position(r2, this._start) !== s.BoundaryPosition.Before && c.boundaryPoint_position(r2, this._end) !== s.BoundaryPosition.After;
          }, t2.prototype.comparePoint = function(e3, t3) {
            if (c.tree_rootNode(e3) !== c.range_root(this)) throw new l.WrongDocumentError();
            if (p.Guard.isDocumentTypeNode(e3)) throw new l.InvalidNodeTypeError();
            if (t3 > c.tree_nodeLength(e3)) throw new l.IndexSizeError();
            var r2 = [e3, t3];
            return c.boundaryPoint_position(r2, this._start) === s.BoundaryPosition.Before ? -1 : c.boundaryPoint_position(r2, this._end) === s.BoundaryPosition.After ? 1 : 0;
          }, t2.prototype.intersectsNode = function(e3) {
            if (c.tree_rootNode(e3) !== c.range_root(this)) return false;
            var t3 = e3._parent;
            if (null === t3) return true;
            var r2 = c.tree_index(e3);
            return c.boundaryPoint_position([t3, r2], this._end) === s.BoundaryPosition.Before && c.boundaryPoint_position([t3, r2 + 1], this._start) === s.BoundaryPosition.After;
          }, t2.prototype.toString = function() {
            var e3, t3, r2 = "";
            if (this._startNode === this._endNode && p.Guard.isTextNode(this._startNode)) return this._startNode._data.substring(this._startOffset, this._endOffset);
            p.Guard.isTextNode(this._startNode) && (r2 += this._startNode._data.substring(this._startOffset));
            try {
              for (var n2 = o(c.range_getContainedNodes(this)), i2 = n2.next(); !i2.done; i2 = n2.next()) {
                var a2 = i2.value;
                p.Guard.isTextNode(a2) && (r2 += a2._data);
              }
            } catch (t4) {
              e3 = { error: t4 };
            } finally {
              try {
                i2 && !i2.done && (t3 = n2.return) && t3.call(n2);
              } finally {
                if (e3) throw e3.error;
              }
            }
            return p.Guard.isTextNode(this._endNode) && (r2 += this._endNode._data.substring(0, this._endOffset)), r2;
          }, t2._create = function(e3, r2) {
            var n2 = new t2();
            return e3 && (n2._start = e3), r2 && (n2._end = r2), n2;
          }, t2.START_TO_START = 0, t2.START_TO_END = 1, t2.END_TO_END = 2, t2.END_TO_START = 3, t2;
        }(u.AbstractRangeImpl);
        t.RangeImpl = f, h.idl_defineConst(f.prototype, "START_TO_START", 0), h.idl_defineConst(f.prototype, "START_TO_END", 1), h.idl_defineConst(f.prototype, "END_TO_END", 2), h.idl_defineConst(f.prototype, "END_TO_START", 3);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(103), a = r(0), s = function(e2) {
          function t2(t3, r2, n2) {
            var i2 = e2.call(this, t3) || this;
            return i2._iteratorCollection = void 0, i2._reference = r2, i2._pointerBeforeReference = n2, a.nodeIterator_iteratorList().add(i2), i2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "referenceNode", { get: function() {
            return this._reference;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "pointerBeforeReferenceNode", { get: function() {
            return this._pointerBeforeReference;
          }, enumerable: true, configurable: true }), t2.prototype.nextNode = function() {
            return a.nodeIterator_traverse(this, true);
          }, t2.prototype.previousNode = function() {
            return a.nodeIterator_traverse(this, false);
          }, t2.prototype.detach = function() {
            a.nodeIterator_iteratorList().delete(this);
          }, t2._create = function(e3, r2, n2) {
            return new t2(e3, r2, n2);
          }, t2;
        }(o.TraverserImpl);
        t.NodeIteratorImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(2), a = r(103), s = r(0), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            return n2._current = r2, n2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "currentNode", { get: function() {
            return this._current;
          }, set: function(e3) {
            this._current = e3;
          }, enumerable: true, configurable: true }), t2.prototype.parentNode = function() {
            for (var e3 = this._current; null !== e3 && e3 !== this._root; ) if (null !== (e3 = e3._parent) && s.traversal_filter(this, e3) === o.FilterResult.Accept) return this._current = e3, e3;
            return null;
          }, t2.prototype.firstChild = function() {
            return s.treeWalker_traverseChildren(this, true);
          }, t2.prototype.lastChild = function() {
            return s.treeWalker_traverseChildren(this, false);
          }, t2.prototype.nextSibling = function() {
            return s.treeWalker_traverseSiblings(this, true);
          }, t2.prototype.previousNode = function() {
            for (var e3 = this._current; e3 !== this._root; ) {
              for (var t3 = e3._previousSibling; t3; ) {
                e3 = t3;
                for (var r2 = s.traversal_filter(this, e3); r2 !== o.FilterResult.Reject && e3._lastChild; ) e3 = e3._lastChild, r2 = s.traversal_filter(this, e3);
                if (r2 === o.FilterResult.Accept) return this._current = e3, e3;
                t3 = e3._previousSibling;
              }
              if (e3 === this._root || null === e3._parent) return null;
              if (e3 = e3._parent, s.traversal_filter(this, e3) === o.FilterResult.Accept) return this._current = e3, e3;
            }
            return null;
          }, t2.prototype.previousSibling = function() {
            return s.treeWalker_traverseSiblings(this, false);
          }, t2.prototype.nextNode = function() {
            for (var e3 = this._current, t3 = o.FilterResult.Accept; ; ) {
              for (; t3 !== o.FilterResult.Reject && e3._firstChild; ) if (e3 = e3._firstChild, (t3 = s.traversal_filter(this, e3)) === o.FilterResult.Accept) return this._current = e3, e3;
              for (var r2 = null, n2 = e3; null !== n2; ) {
                if (n2 === this._root) return null;
                if (null !== (r2 = n2._nextSibling)) {
                  e3 = r2;
                  break;
                }
                n2 = n2._parent;
              }
              if ((t3 = s.traversal_filter(this, e3)) === o.FilterResult.Accept) return this._current = e3, e3;
            }
          }, t2._create = function(e3, r2) {
            return new t2(e3, r2);
          }, t2;
        }(a.TraverserImpl);
        t.TreeWalkerImpl = u;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(2), i = r(12), o = function() {
          function e2() {
          }
          return e2.prototype.acceptNode = function(e3) {
            return n.FilterResult.Accept;
          }, e2._create = function() {
            return new e2();
          }, e2.FILTER_ACCEPT = 1, e2.FILTER_REJECT = 2, e2.FILTER_SKIP = 3, e2.SHOW_ALL = 4294967295, e2.SHOW_ELEMENT = 1, e2.SHOW_ATTRIBUTE = 2, e2.SHOW_TEXT = 4, e2.SHOW_CDATA_SECTION = 8, e2.SHOW_ENTITY_REFERENCE = 16, e2.SHOW_ENTITY = 32, e2.SHOW_PROCESSING_INSTRUCTION = 64, e2.SHOW_COMMENT = 128, e2.SHOW_DOCUMENT = 256, e2.SHOW_DOCUMENT_TYPE = 512, e2.SHOW_DOCUMENT_FRAGMENT = 1024, e2.SHOW_NOTATION = 2048, e2;
        }();
        t.NodeFilterImpl = o, i.idl_defineConst(o.prototype, "FILTER_ACCEPT", 1), i.idl_defineConst(o.prototype, "FILTER_REJECT", 2), i.idl_defineConst(o.prototype, "FILTER_SKIP", 3), i.idl_defineConst(o.prototype, "SHOW_ALL", 4294967295), i.idl_defineConst(o.prototype, "SHOW_ELEMENT", 1), i.idl_defineConst(o.prototype, "SHOW_ATTRIBUTE", 2), i.idl_defineConst(o.prototype, "SHOW_TEXT", 4), i.idl_defineConst(o.prototype, "SHOW_CDATA_SECTION", 8), i.idl_defineConst(o.prototype, "SHOW_ENTITY_REFERENCE", 16), i.idl_defineConst(o.prototype, "SHOW_ENTITY", 32), i.idl_defineConst(o.prototype, "SHOW_PROCESSING_INSTRUCTION", 64), i.idl_defineConst(o.prototype, "SHOW_COMMENT", 128), i.idl_defineConst(o.prototype, "SHOW_DOCUMENT", 256), i.idl_defineConst(o.prototype, "SHOW_DOCUMENT_TYPE", 512), i.idl_defineConst(o.prototype, "SHOW_DOCUMENT_FRAGMENT", 1024), i.idl_defineConst(o.prototype, "SHOW_NOTATION", 2048);
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2(e3, t2, r2, n2, i, o, a, s, u) {
            this._type = e3, this._target = t2, this._addedNodes = r2, this._removedNodes = n2, this._previousSibling = i, this._nextSibling = o, this._attributeName = a, this._attributeNamespace = s, this._oldValue = u;
          }
          return Object.defineProperty(e2.prototype, "type", { get: function() {
            return this._type;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "target", { get: function() {
            return this._target;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "addedNodes", { get: function() {
            return this._addedNodes;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "removedNodes", { get: function() {
            return this._removedNodes;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "previousSibling", { get: function() {
            return this._previousSibling;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "nextSibling", { get: function() {
            return this._nextSibling;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "attributeName", { get: function() {
            return this._attributeName;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "attributeNamespace", { get: function() {
            return this._attributeNamespace;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "oldValue", { get: function() {
            return this._oldValue;
          }, enumerable: true, configurable: true }), e2._create = function(t2, r2, n2, i, o, a, s, u, l) {
            return new e2(t2, r2, n2, i, o, a, s, u, l);
          }, e2;
        }();
        t.MutationRecordImpl = n;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(9), a = r(7), s = r(0), u = function() {
          function e2(e3, t2) {
            this._element = e3, this._attribute = t2, this._tokenSet = /* @__PURE__ */ new Set();
            var r2 = t2._localName, n2 = s.element_getAnAttributeValue(e3, r2), o2 = this;
            this._element._attributeChangeSteps.push(function(e4, t3, r3, n3, i2) {
              t3 === o2._attribute._localName && null === i2 && (n3 ? o2._tokenSet = s.orderedSet_parse(n3) : o2._tokenSet.clear());
            }), i.dom.features.steps && s.dom_runAttributeChangeSteps(e3, r2, n2, n2, null);
          }
          return Object.defineProperty(e2.prototype, "length", { get: function() {
            return this._tokenSet.size;
          }, enumerable: true, configurable: true }), e2.prototype.item = function(e3) {
            var t2, r2, i2 = 0;
            try {
              for (var o2 = n(this._tokenSet), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var s2 = a2.value;
                if (i2 === e3) return s2;
                i2++;
              }
            } catch (e4) {
              t2 = { error: e4 };
            } finally {
              try {
                a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
              } finally {
                if (t2) throw t2.error;
              }
            }
            return null;
          }, e2.prototype.contains = function(e3) {
            return this._tokenSet.has(e3);
          }, e2.prototype.add = function() {
            for (var e3, t2, r2 = [], i2 = 0; i2 < arguments.length; i2++) r2[i2] = arguments[i2];
            try {
              for (var u2 = n(r2), l = u2.next(); !l.done; l = u2.next()) {
                var c = l.value;
                if ("" === c) throw new o.SyntaxError("Cannot add an empty token.");
                if (a.codePoint.ASCIIWhiteSpace.test(c)) throw new o.InvalidCharacterError("Token cannot contain whitespace.");
                this._tokenSet.add(c);
              }
            } catch (t3) {
              e3 = { error: t3 };
            } finally {
              try {
                l && !l.done && (t2 = u2.return) && t2.call(u2);
              } finally {
                if (e3) throw e3.error;
              }
            }
            s.tokenList_updateSteps(this);
          }, e2.prototype.remove = function() {
            for (var e3, t2, r2 = [], i2 = 0; i2 < arguments.length; i2++) r2[i2] = arguments[i2];
            try {
              for (var u2 = n(r2), l = u2.next(); !l.done; l = u2.next()) {
                var c = l.value;
                if ("" === c) throw new o.SyntaxError("Cannot remove an empty token.");
                if (a.codePoint.ASCIIWhiteSpace.test(c)) throw new o.InvalidCharacterError("Token cannot contain whitespace.");
                this._tokenSet.delete(c);
              }
            } catch (t3) {
              e3 = { error: t3 };
            } finally {
              try {
                l && !l.done && (t2 = u2.return) && t2.call(u2);
              } finally {
                if (e3) throw e3.error;
              }
            }
            s.tokenList_updateSteps(this);
          }, e2.prototype.toggle = function(e3, t2) {
            if (void 0 === t2 && (t2 = void 0), "" === e3) throw new o.SyntaxError("Cannot toggle an empty token.");
            if (a.codePoint.ASCIIWhiteSpace.test(e3)) throw new o.InvalidCharacterError("Token cannot contain whitespace.");
            return this._tokenSet.has(e3) ? void 0 !== t2 && false !== t2 || (this._tokenSet.delete(e3), s.tokenList_updateSteps(this), false) : (void 0 === t2 || true === t2) && (this._tokenSet.add(e3), s.tokenList_updateSteps(this), true);
          }, e2.prototype.replace = function(e3, t2) {
            if ("" === e3 || "" === t2) throw new o.SyntaxError("Cannot replace an empty token.");
            if (a.codePoint.ASCIIWhiteSpace.test(e3) || a.codePoint.ASCIIWhiteSpace.test(t2)) throw new o.InvalidCharacterError("Token cannot contain whitespace.");
            return !!this._tokenSet.has(e3) && (a.set.replace(this._tokenSet, e3, t2), s.tokenList_updateSteps(this), true);
          }, e2.prototype.supports = function(e3) {
            return s.tokenList_validationSteps(this, e3);
          }, Object.defineProperty(e2.prototype, "value", { get: function() {
            return s.tokenList_serializeSteps(this);
          }, set: function(e3) {
            s.element_setAnAttributeValue(this._element, this._attribute._localName, e3);
          }, enumerable: true, configurable: true }), e2.prototype[Symbol.iterator] = function() {
            var e3 = this._tokenSet[Symbol.iterator]();
            return { next: function() {
              return e3.next();
            } };
          }, e2._create = function(t2, r2) {
            return new e2(t2, r2);
          }, e2;
        }();
        t.DOMTokenListImpl = u;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(104), a = r(0), s = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3, r2) || this;
            return n2._detail = null, n2._detail = r2 && r2.detail || null, n2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "detail", { get: function() {
            return this._detail;
          }, enumerable: true, configurable: true }), t2.prototype.initCustomEvent = function(e3, t3, r2, n2) {
            void 0 === t3 && (t3 = false), void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = null), this._dispatchFlag || (a.event_initialize(this, e3, t3, r2), this._detail = n2);
          }, t2;
        }(o.EventImpl);
        t.CustomEventImpl = s;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(6), i = r(2), o = r(105), a = r(17);
        t.nodeIterator_traverse = function(e2, t2) {
          for (var r2 = e2._reference, n2 = e2._pointerBeforeReference; ; ) {
            if (t2) if (n2) n2 = false;
            else {
              var s = a.tree_getFollowingNode(e2._root, r2);
              if (!s) return null;
              r2 = s;
            }
            else if (n2) {
              var u = a.tree_getPrecedingNode(e2.root, r2);
              if (!u) return null;
              r2 = u;
            } else n2 = true;
            if (o.traversal_filter(e2, r2) === i.FilterResult.Accept) break;
          }
          return e2._reference = r2, e2._pointerBeforeReference = n2, r2;
        }, t.nodeIterator_iteratorList = function() {
          return n.dom.window._iteratorList;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(9), i = r(7), o = r(174);
        function a(e2) {
          if (!o.xml_isName(e2)) throw new n.InvalidCharacterError("Invalid XML name: " + e2);
          if (!o.xml_isQName(e2)) throw new n.InvalidCharacterError("Invalid XML qualified name: " + e2 + ".");
        }
        t.namespace_validate = a, t.namespace_validateAndExtract = function(e2, t2) {
          e2 || (e2 = null), a(t2);
          var r2 = t2.split(":"), o2 = 2 === r2.length ? r2[0] : null, s = 2 === r2.length ? r2[1] : t2;
          if (o2 && null === e2) throw new n.NamespaceError("Qualified name includes a prefix but the namespace is null.");
          if ("xml" === o2 && e2 !== i.namespace.XML) throw new n.NamespaceError('Qualified name includes the "xml" prefix but the namespace is not the XML namespace.');
          if (e2 !== i.namespace.XMLNS && ("xmlns" === o2 || "xmlns" === t2)) throw new n.NamespaceError('Qualified name includes the "xmlns" prefix but the namespace is not the XMLNS namespace.');
          if (e2 === i.namespace.XMLNS && "xmlns" !== o2 && "xmlns" !== t2) throw new n.NamespaceError('Qualified name does not include the "xmlns" prefix but the namespace is the XMLNS namespace.');
          return [e2, o2, s];
        }, t.namespace_extractQName = function(e2) {
          a(e2);
          var t2 = e2.split(":");
          return [2 === t2.length ? t2[0] : null, 2 === t2.length ? t2[1] : e2];
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.xml_isName = function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) {
            var r2 = e2.charCodeAt(t2);
            if (!(r2 >= 97 && r2 <= 122 || r2 >= 65 && r2 <= 90 || 58 === r2 || 95 === r2 || r2 >= 192 && r2 <= 214 || r2 >= 216 && r2 <= 246 || r2 >= 248 && r2 <= 767 || r2 >= 880 && r2 <= 893 || r2 >= 895 && r2 <= 8191 || r2 >= 8204 && r2 <= 8205 || r2 >= 8304 && r2 <= 8591 || r2 >= 11264 && r2 <= 12271 || r2 >= 12289 && r2 <= 55295 || r2 >= 63744 && r2 <= 64975 || r2 >= 65008 && r2 <= 65533) && (0 === t2 || !(45 === r2 || 46 === r2 || r2 >= 48 && r2 <= 57 || 183 === r2 || r2 >= 768 && r2 <= 879 || r2 >= 8255 && r2 <= 8256))) {
              if (r2 >= 55296 && r2 <= 56319 && t2 < e2.length - 1) {
                var n = e2.charCodeAt(t2 + 1);
                if (n >= 56320 && n <= 57343 && (t2++, (r2 = 1024 * (r2 - 55296) + n - 56320 + 65536) >= 65536 && r2 <= 983039)) continue;
              }
              return false;
            }
          }
          return true;
        }, t.xml_isQName = function(e2) {
          for (var t2 = false, r2 = 0; r2 < e2.length; r2++) {
            var n = e2.charCodeAt(r2);
            if (!(n >= 97 && n <= 122 || n >= 65 && n <= 90 || 95 === n || n >= 192 && n <= 214 || n >= 216 && n <= 246 || n >= 248 && n <= 767 || n >= 880 && n <= 893 || n >= 895 && n <= 8191 || n >= 8204 && n <= 8205 || n >= 8304 && n <= 8591 || n >= 11264 && n <= 12271 || n >= 12289 && n <= 55295 || n >= 63744 && n <= 64975 || n >= 65008 && n <= 65533) && (0 === r2 || !(45 === n || 46 === n || n >= 48 && n <= 57 || 183 === n || n >= 768 && n <= 879 || n >= 8255 && n <= 8256))) {
              if (0 === r2 || 58 !== n) {
                if (n >= 55296 && n <= 56319 && r2 < e2.length - 1) {
                  var i = e2.charCodeAt(r2 + 1);
                  if (i >= 56320 && i <= 57343 && (r2++, (n = 1024 * (n - 55296) + i - 56320 + 65536) >= 65536 && n <= 983039)) continue;
                }
                return false;
              }
              if (t2) return false;
              if (r2 === e2.length - 1) return false;
              t2 = true;
            }
          }
          return true;
        }, t.xml_isLegalChar = function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) {
            var r2 = e2.charCodeAt(t2);
            if (!(9 === r2 || 10 === r2 || 13 === r2 || r2 >= 32 && r2 <= 55295 || r2 >= 57344 && r2 <= 65533)) {
              if (r2 >= 55296 && r2 <= 56319 && t2 < e2.length - 1) {
                var n = e2.charCodeAt(t2 + 1);
                if (n >= 56320 && n <= 57343 && (t2++, (r2 = 1024 * (r2 - 55296) + n - 56320 + 65536) >= 65536 && r2 <= 1114111)) continue;
              }
              return false;
            }
          }
          return true;
        }, t.xml_isPubidChar = function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) {
            var r2 = e2.charCodeAt(t2);
            if (!(r2 >= 97 && r2 <= 122 || r2 >= 65 && r2 <= 90 || r2 >= 39 && r2 <= 59 || 32 === r2 || 13 === r2 || 10 === r2 || r2 >= 35 && r2 <= 37 || 33 === r2 || 61 === r2 || 63 === r2 || 64 === r2 || 95 === r2)) return false;
          }
          return true;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(2), i = r(17);
        t.boundaryPoint_position = function e2(t2, r2) {
          var o = t2[0], a = t2[1], s = r2[0], u = r2[1];
          if (console.assert(i.tree_rootNode(o) === i.tree_rootNode(s), "Boundary points must share the same root node."), o === s) return a === u ? n.BoundaryPosition.Equal : a < u ? n.BoundaryPosition.Before : n.BoundaryPosition.After;
          if (i.tree_isFollowing(s, o)) {
            var l = e2([s, u], [o, a]);
            if (l === n.BoundaryPosition.Before) return n.BoundaryPosition.After;
            if (l === n.BoundaryPosition.After) return n.BoundaryPosition.Before;
          }
          if (i.tree_isAncestorOf(s, o)) {
            for (var c = s; !i.tree_isChildOf(o, c); ) null !== c._parent && (c = c._parent);
            if (i.tree_index(c) < a) return n.BoundaryPosition.After;
          }
          return n.BoundaryPosition.Before;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(3), a = r(7), s = r(29), u = r(108), l = r(30), c = r(37), h = r(52);
        t.node_stringReplaceAll = function(e2, t2) {
          var r2 = null;
          "" !== e2 && (r2 = s.create_text(t2._nodeDocument, e2)), c.mutation_replaceAll(r2, t2);
        }, t.node_clone = function e2(t2, r2, a2) {
          var u2, p, f, d, m;
          if (void 0 === r2 && (r2 = null), void 0 === a2 && (a2 = false), null === r2 && (r2 = t2._nodeDocument), o.Guard.isElementNode(t2)) {
            m = h.element_createAnElement(r2, t2._localName, t2._namespace, t2._namespacePrefix, t2._is, false);
            try {
              for (var y = n(t2._attributeList), v = y.next(); !v.done; v = y.next()) {
                var _ = e2(v.value, r2);
                h.element_append(_, m);
              }
            } catch (e3) {
              u2 = { error: e3 };
            } finally {
              try {
                v && !v.done && (p = y.return) && p.call(y);
              } finally {
                if (u2) throw u2.error;
              }
            }
          } else if (o.Guard.isDocumentNode(t2)) {
            var g = s.create_document();
            g._encoding = t2._encoding, g._contentType = t2._contentType, g._URL = t2._URL, g._origin = t2._origin, g._type = t2._type, g._mode = t2._mode, m = g;
          } else if (o.Guard.isDocumentTypeNode(t2)) {
            m = s.create_documentType(r2, t2._name, t2._publicId, t2._systemId);
          } else if (o.Guard.isAttrNode(t2)) {
            var b = s.create_attr(r2, t2.localName);
            b._namespace = t2._namespace, b._namespacePrefix = t2._namespacePrefix, b._value = t2._value, m = b;
          } else m = o.Guard.isExclusiveTextNode(t2) ? s.create_text(r2, t2._data) : o.Guard.isCDATASectionNode(t2) ? s.create_cdataSection(r2, t2._data) : o.Guard.isCommentNode(t2) ? s.create_comment(r2, t2._data) : o.Guard.isProcessingInstructionNode(t2) ? s.create_processingInstruction(r2, t2._target, t2._data) : o.Guard.isDocumentFragmentNode(t2) ? s.create_documentFragment(r2) : Object.create(t2);
          if (o.Guard.isDocumentNode(m) ? (m._nodeDocument = m, r2 = m) : m._nodeDocument = r2, i.dom.features.steps && l.dom_runCloningSteps(m, t2, r2, a2), a2) try {
            for (var x = n(t2._children), w = x.next(); !w.done; w = x.next()) {
              var E = e2(w.value, r2, true);
              c.mutation_append(E, m);
            }
          } catch (e3) {
            f = { error: e3 };
          } finally {
            try {
              w && !w.done && (d = x.return) && d.call(x);
            } finally {
              if (f) throw f.error;
            }
          }
          return m;
        }, t.node_equals = function e2(t2, r2) {
          var i2, a2, s2, u2;
          if (t2._nodeType !== r2._nodeType) return false;
          if (o.Guard.isDocumentTypeNode(t2) && o.Guard.isDocumentTypeNode(r2)) {
            if (t2._name !== r2._name || t2._publicId !== r2._publicId || t2._systemId !== r2._systemId) return false;
          } else if (o.Guard.isElementNode(t2) && o.Guard.isElementNode(r2)) {
            if (t2._namespace !== r2._namespace || t2._namespacePrefix !== r2._namespacePrefix || t2._localName !== r2._localName || t2._attributeList.length !== r2._attributeList.length) return false;
          } else if (o.Guard.isAttrNode(t2) && o.Guard.isAttrNode(r2)) {
            if (t2._namespace !== r2._namespace || t2._localName !== r2._localName || t2._value !== r2._value) return false;
          } else if (o.Guard.isProcessingInstructionNode(t2) && o.Guard.isProcessingInstructionNode(r2)) {
            if (t2._target !== r2._target || t2._data !== r2._data) return false;
          } else if (o.Guard.isCharacterDataNode(t2) && o.Guard.isCharacterDataNode(r2) && t2._data !== r2._data) return false;
          if (o.Guard.isElementNode(t2) && o.Guard.isElementNode(r2)) {
            var l2 = {};
            try {
              for (var c2 = n(t2._attributeList), h2 = c2.next(); !h2.done; h2 = c2.next()) {
                l2[(d = h2.value)._localName] = d;
              }
            } catch (e3) {
              i2 = { error: e3 };
            } finally {
              try {
                h2 && !h2.done && (a2 = c2.return) && a2.call(c2);
              } finally {
                if (i2) throw i2.error;
              }
            }
            try {
              for (var p = n(r2._attributeList), f = p.next(); !f.done; f = p.next()) {
                var d, m = f.value;
                if (!(d = l2[m._localName])) return false;
                if (!e2(d, m)) return false;
              }
            } catch (e3) {
              s2 = { error: e3 };
            } finally {
              try {
                f && !f.done && (u2 = p.return) && u2.call(p);
              } finally {
                if (s2) throw s2.error;
              }
            }
          }
          if (t2._children.size !== r2._children.size) return false;
          for (var y = t2._children[Symbol.iterator](), v = r2._children[Symbol.iterator](), _ = y.next(), g = v.next(); !_.done && !g.done; ) {
            if (!e2(_.value, g.value)) return false;
            _ = y.next(), g = v.next();
          }
          return true;
        }, t.node_listOfElementsWithQualifiedName = function(e2, t2) {
          return "*" === e2 ? s.create_htmlCollection(t2) : "html" === t2._nodeDocument._type ? s.create_htmlCollection(t2, function(t3) {
            return t3._namespace === a.namespace.HTML && t3._qualifiedName === e2.toLowerCase() || t3._namespace !== a.namespace.HTML && t3._qualifiedName === e2;
          }) : s.create_htmlCollection(t2, function(t3) {
            return t3._qualifiedName === e2;
          });
        }, t.node_listOfElementsWithNamespace = function(e2, t2, r2) {
          return "" === e2 && (e2 = null), "*" === e2 && "*" === t2 ? s.create_htmlCollection(r2) : "*" === e2 ? s.create_htmlCollection(r2, function(e3) {
            return e3._localName === t2;
          }) : "*" === t2 ? s.create_htmlCollection(r2, function(t3) {
            return t3._namespace === e2;
          }) : s.create_htmlCollection(r2, function(r3) {
            return r3._localName === t2 && r3._namespace === e2;
          });
        }, t.node_listOfElementsWithClassNames = function(e2, t2) {
          var r2 = u.orderedSet_parse(e2);
          if (0 === r2.size) return s.create_htmlCollection(t2, function() {
            return false;
          });
          var n2 = "quirks" !== t2._nodeDocument._mode;
          return s.create_htmlCollection(t2, function(e3) {
            var t3 = e3.classList;
            return u.orderedSet_contains(t3._tokenSet, r2, n2);
          });
        }, t.node_locateANamespacePrefix = function e2(t2, r2) {
          if (t2._namespace === r2 && null !== t2._namespacePrefix) return t2._namespacePrefix;
          for (var n2 = 0; n2 < t2._attributeList.length; n2++) {
            var i2 = t2._attributeList[n2];
            if ("xmlns" === i2._namespacePrefix && i2._value === r2) return i2._localName;
          }
          return t2._parent && o.Guard.isElementNode(t2._parent) ? e2(t2._parent, r2) : null;
        }, t.node_locateANamespace = function e2(t2, r2) {
          if (o.Guard.isElementNode(t2)) {
            if (null !== t2._namespace && t2._namespacePrefix === r2) return t2._namespace;
            for (var n2 = 0; n2 < t2._attributeList.length; n2++) {
              var i2 = t2._attributeList[n2];
              if (i2._namespace === a.namespace.XMLNS && "xmlns" === i2._namespacePrefix && i2._localName === r2) return i2._value || null;
              if (null === r2 && i2._namespace === a.namespace.XMLNS && null === i2._namespacePrefix && "xmlns" === i2._localName) return i2._value || null;
            }
            return null === t2.parentElement ? null : e2(t2.parentElement, r2);
          }
          return o.Guard.isDocumentNode(t2) ? null === t2.documentElement ? null : e2(t2.documentElement, r2) : o.Guard.isDocumentTypeNode(t2) || o.Guard.isDocumentFragmentNode(t2) ? null : o.Guard.isAttrNode(t2) ? null === t2._element ? null : e2(t2._element, r2) : t2._parent && o.Guard.isElementNode(t2._parent) ? e2(t2._parent, r2) : null;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(3), a = r(9), s = r(29), u = r(17), l = r(107), c = r(37);
        t.text_contiguousTextNodes = function(e2, t2) {
          var r2;
          return void 0 === t2 && (t2 = false), (r2 = {})[Symbol.iterator] = function() {
            for (var r3 = e2; r3 && o.Guard.isTextNode(r3._previousSibling); ) r3 = r3._previousSibling;
            return { next: function() {
              if (r3 && !t2 && r3 === e2 && (r3 = o.Guard.isTextNode(r3._nextSibling) ? r3._nextSibling : null), null === r3) return { done: true, value: null };
              var n2 = { done: false, value: r3 };
              return r3 = o.Guard.isTextNode(r3._nextSibling) ? r3._nextSibling : null, n2;
            } };
          }, r2;
        }, t.text_contiguousExclusiveTextNodes = function(e2, t2) {
          var r2;
          return void 0 === t2 && (t2 = false), (r2 = {})[Symbol.iterator] = function() {
            for (var r3 = e2; r3 && o.Guard.isExclusiveTextNode(r3._previousSibling); ) r3 = r3._previousSibling;
            return { next: function() {
              if (r3 && !t2 && r3 === e2 && (r3 = o.Guard.isExclusiveTextNode(r3._nextSibling) ? r3._nextSibling : null), null === r3) return { done: true, value: null };
              var n2 = { done: false, value: r3 };
              return r3 = o.Guard.isExclusiveTextNode(r3._nextSibling) ? r3._nextSibling : null, n2;
            } };
          }, r2;
        }, t.text_descendantTextContent = function(e2) {
          for (var t2 = "", r2 = u.tree_getFirstDescendantNode(e2, false, false, function(e3) {
            return o.Guard.isTextNode(e3);
          }); null !== r2; ) t2 += r2._data, r2 = u.tree_getNextDescendantNode(e2, r2, false, false, function(e3) {
            return o.Guard.isTextNode(e3);
          });
          return t2;
        }, t.text_split = function(e2, t2) {
          var r2, o2, h = e2._data.length;
          if (t2 > h) throw new a.IndexSizeError();
          var p = h - t2, f = l.characterData_substringData(e2, t2, p), d = s.create_text(e2._nodeDocument, f), m = e2._parent;
          if (null !== m) {
            c.mutation_insert(d, m, e2._nextSibling);
            try {
              for (var y = n(i.dom.rangeList), v = y.next(); !v.done; v = y.next()) {
                var _ = v.value;
                _._start[0] === e2 && _._start[1] > t2 && (_._start[0] = d, _._start[1] -= t2), _._end[0] === e2 && _._end[1] > t2 && (_._end[0] = d, _._end[1] -= t2);
                var g = u.tree_index(e2);
                _._start[0] === m && _._start[1] === g + 1 && _._start[1]++, _._end[0] === m && _._end[1] === g + 1 && _._end[1]++;
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                v && !v.done && (o2 = y.return) && o2.call(y);
              } finally {
                if (r2) throw r2.error;
              }
            }
          }
          return l.characterData_replaceData(e2, t2, p, ""), d;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(41), o = r(24), a = r(48), s = [].join, u = i != Object, l = a("join", ",");
        n({ target: "Array", proto: true, forced: u || !l }, { join: function(e2) {
          return s.call(o(this), void 0 === e2 ? "," : e2);
        } });
      }, function(e, t, r) {
        var n = r(4), i = r(83), o = String.fromCharCode, a = String.fromCodePoint;
        n({ target: "String", stat: true, forced: !!a && 1 != a.length }, { fromCodePoint: function(e2) {
          for (var t2, r2 = [], n2 = arguments.length, a2 = 0; n2 > a2; ) {
            if (t2 = +arguments[a2++], i(t2, 1114111) !== t2) throw RangeError(t2 + " is not a valid code point");
            r2.push(t2 < 65536 ? o(t2) : o(55296 + ((t2 -= 65536) >> 10), t2 % 1024 + 56320));
          }
          return r2.join("");
        } });
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(111), o = function() {
          function e2(e3, t2) {
            this._options = { skipWhitespaceOnlyText: false }, this.err = { line: -1, col: -1, index: -1, str: "" }, this._str = e3, this._index = 0, this._length = e3.length, t2 && (this._options.skipWhitespaceOnlyText = t2.skipWhitespaceOnlyText || false);
          }
          return e2.prototype.nextToken = function() {
            if (this.eof()) return { type: i.TokenType.EOF };
            var t2 = this.skipIfStartsWith("<") ? this.openBracket() : this.text();
            return this._options.skipWhitespaceOnlyText && t2.type === i.TokenType.Text && e2.isWhiteSpaceToken(t2) && (t2 = this.nextToken()), t2;
          }, e2.prototype.openBracket = function() {
            return this.skipIfStartsWith("?") ? this.skipIfStartsWith("xml") ? e2.isSpace(this._str[this._index]) ? this.declaration() : (this.seek(-3), this.pi()) : this.pi() : this.skipIfStartsWith("!") ? this.skipIfStartsWith("--") ? this.comment() : this.skipIfStartsWith("[CDATA[") ? this.cdata() : this.skipIfStartsWith("DOCTYPE") ? this.doctype() : void this.throwError("Invalid '!' in opening tag.") : this.skipIfStartsWith("/") ? this.closeTag() : this.openTag();
          }, e2.prototype.declaration = function() {
            for (var e3 = "", t2 = "", r2 = ""; !this.eof(); ) {
              if (this.skipSpace(), this.skipIfStartsWith("?>")) return { type: i.TokenType.Declaration, version: e3, encoding: t2, standalone: r2 };
              var o2 = n(this.attribute(), 2), a = o2[0], s = o2[1];
              "version" === a ? e3 = s : "encoding" === a ? t2 = s : "standalone" === a ? r2 = s : this.throwError("Invalid attribute name: " + a);
            }
            this.throwError("Missing declaration end symbol `?>`");
          }, e2.prototype.doctype = function() {
            var e3 = "", t2 = "";
            this.skipSpace();
            var r2 = this.takeUntil2("[", ">", true);
            return this.skipSpace(), this.skipIfStartsWith("PUBLIC") ? (e3 = this.quotedString(), t2 = this.quotedString()) : this.skipIfStartsWith("SYSTEM") && (t2 = this.quotedString()), this.skipSpace(), this.skipIfStartsWith("[") && (this.skipUntil("]"), this.skipIfStartsWith("]") || this.throwError("Missing end bracket of DTD internal subset")), this.skipSpace(), this.skipIfStartsWith(">") || this.throwError("Missing doctype end symbol `>`"), { type: i.TokenType.DocType, name: r2, pubId: e3, sysId: t2 };
          }, e2.prototype.pi = function() {
            var e3 = this.takeUntilStartsWith("?>", true);
            if (this.eof() && this.throwError("Missing processing instruction end symbol `?>`"), this.skipSpace(), this.skipIfStartsWith("?>")) return { type: i.TokenType.PI, target: e3, data: "" };
            var t2 = this.takeUntilStartsWith("?>");
            return this.eof() && this.throwError("Missing processing instruction end symbol `?>`"), this.seek(2), { type: i.TokenType.PI, target: e3, data: t2 };
          }, e2.prototype.text = function() {
            var e3 = this.takeUntil("<");
            return { type: i.TokenType.Text, data: e3 };
          }, e2.prototype.comment = function() {
            var e3 = this.takeUntilStartsWith("-->");
            return this.eof() && this.throwError("Missing comment end symbol `-->`"), this.seek(3), { type: i.TokenType.Comment, data: e3 };
          }, e2.prototype.cdata = function() {
            var e3 = this.takeUntilStartsWith("]]>");
            return this.eof() && this.throwError("Missing CDATA end symbol `]>`"), this.seek(3), { type: i.TokenType.CDATA, data: e3 };
          }, e2.prototype.openTag = function() {
            this.skipSpace();
            var e3 = this.takeUntil2(">", "/", true);
            if (this.skipSpace(), this.skipIfStartsWith(">")) return { type: i.TokenType.Element, name: e3, attributes: [], selfClosing: false };
            if (this.skipIfStartsWith("/>")) return { type: i.TokenType.Element, name: e3, attributes: [], selfClosing: true };
            for (var t2 = []; !this.eof(); ) {
              if (this.skipSpace(), this.skipIfStartsWith(">")) return { type: i.TokenType.Element, name: e3, attributes: t2, selfClosing: false };
              if (this.skipIfStartsWith("/>")) return { type: i.TokenType.Element, name: e3, attributes: t2, selfClosing: true };
              var r2 = this.attribute();
              t2.push(r2);
            }
            this.throwError("Missing opening element tag end symbol `>`");
          }, e2.prototype.closeTag = function() {
            this.skipSpace();
            var e3 = this.takeUntil(">", true);
            return this.skipSpace(), this.skipIfStartsWith(">") || this.throwError("Missing closing element tag end symbol `>`"), { type: i.TokenType.ClosingTag, name: e3 };
          }, e2.prototype.attribute = function() {
            this.skipSpace();
            var e3 = this.takeUntil("=", true);
            return this.skipSpace(), this.skipIfStartsWith("=") || this.throwError("Missing equals sign before attribute value"), [e3, this.quotedString()];
          }, e2.prototype.quotedString = function() {
            this.skipSpace();
            var t2 = this.take(1);
            e2.isQuote(t2) || this.throwError("Missing start quote character before quoted value");
            var r2 = this.takeUntil(t2);
            return this.skipIfStartsWith(t2) || this.throwError("Missing end quote character after quoted value"), r2;
          }, e2.prototype.eof = function() {
            return this._index >= this._length;
          }, e2.prototype.skipIfStartsWith = function(e3) {
            var t2 = e3.length;
            if (1 === t2) return this._str[this._index] === e3 && (this._index++, true);
            for (var r2 = 0; r2 < t2; r2++) if (this._str[this._index + r2] !== e3[r2]) return false;
            return this._index += t2, true;
          }, e2.prototype.seek = function(e3) {
            this._index += e3, this._index < 0 && (this._index = 0), this._index > this._length && (this._index = this._length);
          }, e2.prototype.skipSpace = function() {
            for (; !this.eof() && e2.isSpace(this._str[this._index]); ) this._index++;
          }, e2.prototype.take = function(e3) {
            if (1 === e3) return this._str[this._index++];
            var t2 = this._index;
            return this.seek(e3), this._str.slice(t2, this._index);
          }, e2.prototype.takeUntil = function(t2, r2) {
            void 0 === r2 && (r2 = false);
            for (var n2 = this._index; this._index < this._length; ) {
              var i2 = this._str[this._index];
              if (i2 === t2 || r2 && e2.isSpace(i2)) break;
              this._index++;
            }
            return this._str.slice(n2, this._index);
          }, e2.prototype.takeUntil2 = function(t2, r2, n2) {
            void 0 === n2 && (n2 = false);
            for (var i2 = this._index; this._index < this._length; ) {
              var o2 = this._str[this._index];
              if (o2 === t2 || o2 === r2 || n2 && e2.isSpace(o2)) break;
              this._index++;
            }
            return this._str.slice(i2, this._index);
          }, e2.prototype.takeUntilStartsWith = function(t2, r2) {
            void 0 === r2 && (r2 = false);
            for (var n2 = this._index, i2 = t2.length; this._index < this._length; ) {
              for (var o2 = true, a = 0; a < i2; a++) {
                var s = this._str[this._index + a], u = t2[a];
                if (r2 && e2.isSpace(s)) return this._str.slice(n2, this._index);
                if (s !== u) {
                  this._index++, o2 = false;
                  break;
                }
              }
              if (o2) return this._str.slice(n2, this._index);
            }
            return this._index = this._length, this._str.slice(n2);
          }, e2.prototype.skipUntil = function(e3) {
            for (; this._index < this._length; ) {
              if (this._str[this._index] === e3) break;
              this._index++;
            }
          }, e2.isWhiteSpaceToken = function(e3) {
            for (var t2 = e3.data, r2 = 0; r2 < t2.length; r2++) {
              var n2 = t2[r2];
              if (" " !== n2 && "\n" !== n2 && "\r" !== n2 && "	" !== n2 && "\f" !== n2) return false;
            }
            return true;
          }, e2.isSpace = function(e3) {
            return " " === e3 || "\n" === e3 || "\r" === e3 || "	" === e3;
          }, e2.isQuote = function(e3) {
            return '"' === e3 || "'" === e3;
          }, e2.prototype.throwError = function(e3) {
            for (var t2 = /\r\n|\r|\n/g, r2 = null, n2 = 0, i2 = 0, o2 = this._str.length; null !== (r2 = t2.exec(this._str)) && null !== r2; ) if (n2++, r2.index < this._index && (i2 = t2.lastIndex), r2.index > this._index) {
              o2 = r2.index;
              break;
            }
            throw this.err = { line: n2, col: this._index - i2, index: this._index, str: this._str.substring(i2, o2) }, new Error(e3 + "\nIndex: " + this.err.index + "\nLn: " + this.err.line + ", Col: " + this.err.col + "\nInput: " + this.err.str);
          }, e2.prototype[Symbol.iterator] = function() {
            return this._index = 0, { next: (function() {
              var e3 = this.nextToken();
              return e3.type === i.TokenType.EOF ? { done: true, value: null } : { done: false, value: e3 };
            }).bind(this) };
          }, e2;
        }();
        t.XMLStringLexer = o;
      }, function(e, t, r) {
        "use strict";
        var n = r(39);
        e.exports = new n({ include: [r(182)] });
      }, function(e, t, r) {
        "use strict";
        var n = r(39);
        e.exports = new n({ include: [r(113)], implicit: [r(289), r(290), r(291), r(292)] });
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(91), i = r(1), o = r(3), a = r(77), s = r(109);
        function u(e2, t2) {
          var r2 = c(void 0 === e2 || l(e2) ? e2 : n.DefaultBuilderOptions), i2 = l(e2) ? t2 : e2, o2 = s.createDocument();
          h(o2, r2);
          var u2 = new a.XMLBuilderImpl(o2);
          return void 0 !== i2 && u2.ele(i2), u2;
        }
        function l(e2) {
          if (!i.isPlainObject(e2)) return false;
          for (var t2 in e2) if (e2.hasOwnProperty(t2) && !n.XMLBuilderOptionKeys.has(t2)) return false;
          return true;
        }
        function c(e2) {
          void 0 === e2 && (e2 = {});
          var t2 = i.applyDefaults(e2, n.DefaultBuilderOptions);
          if (0 === t2.convert.att.length || 0 === t2.convert.ins.length || 0 === t2.convert.text.length || 0 === t2.convert.cdata.length || 0 === t2.convert.comment.length) throw new Error("JS object converter strings cannot be zero length.");
          return t2;
        }
        function h(e2, t2, r2) {
          var n2 = e2;
          n2._xmlBuilderOptions = t2, n2._isFragment = r2;
        }
        t.builder = function(e2, t2) {
          var r2 = c(l(e2) ? e2 : n.DefaultBuilderOptions), s2 = o.Guard.isNode(e2) || i.isArray(e2) ? e2 : t2;
          if (void 0 === s2) throw new Error("Invalid arguments.");
          if (i.isArray(s2)) {
            for (var u2 = [], h2 = 0; h2 < s2.length; h2++) {
              var p = new a.XMLBuilderImpl(s2[h2]);
              p.set(r2), u2.push(p);
            }
            return u2;
          }
          var f = new a.XMLBuilderImpl(s2);
          return f.set(r2), f;
        }, t.create = u, t.fragment = function(e2, t2) {
          var r2 = c(void 0 === e2 || l(e2) ? e2 : n.DefaultBuilderOptions), i2 = l(e2) ? t2 : e2, o2 = s.createDocument();
          h(o2, r2, true);
          var u2 = new a.XMLBuilderImpl(o2.createDocumentFragment());
          return void 0 !== i2 && u2.ele(i2), u2;
        }, t.convert = function(e2, t2, r2) {
          var i2, o2, a2;
          return l(e2) && void 0 !== t2 ? (i2 = e2, o2 = t2, a2 = r2) : (i2 = n.DefaultBuilderOptions, o2 = e2, a2 = t2 || void 0), u(i2, o2).end(a2);
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(77);
        t.builder = n.builder, t.create = n.create, t.fragment = n.fragment, t.convert = n.convert, t.createCB = n.createCB, t.fragmentCB = n.fragmentCB;
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(191), r(192), r(194), r(64), r(19), r(198), r(199), r(89), r(201), r(65), r(20), r(66), r(22), r(23);
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(91), a = r(1), s = r(217), u = r(2), l = r(3), c = r(0), h = r(109), p = r(7), f = r(276), d = function() {
          function e2(e3) {
            this._domNode = e3;
          }
          return Object.defineProperty(e2.prototype, "node", { get: function() {
            return this._domNode;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "options", { get: function() {
            return this._options;
          }, enumerable: true, configurable: true }), e2.prototype.set = function(e3) {
            return this._options = a.applyDefaults(a.applyDefaults(this._options, e3, true), o.DefaultBuilderOptions), this;
          }, e2.prototype.ele = function(t2, r2, i2) {
            var o2, s2, u2, l2, p2, d2;
            if (a.isObject(t2)) return new f.ObjectReader(this._options).parse(this, t2);
            if (null !== t2 && /^\s*</.test(t2)) return new f.XMLReader(this._options).parse(this, t2);
            if (null !== t2 && /^\s*[\{\[]/.test(t2)) return new f.JSONReader(this._options).parse(this, t2);
            if (null !== t2 && /^(\s*|(#.*)|(%.*))*---/.test(t2)) return new f.YAMLReader(this._options).parse(this, t2);
            if ((null === t2 || a.isString(t2)) && a.isString(r2)) l2 = (o2 = n([t2, r2, i2], 3))[0], p2 = o2[1], d2 = o2[2];
            else {
              if (null === t2) throw new Error("Element name cannot be null. " + this._debugInfo());
              l2 = (s2 = n([void 0, t2, a.isObject(r2) ? r2 : void 0], 3))[0], p2 = s2[1], d2 = s2[2];
            }
            if (d2 && (d2 = a.getValue(d2)), l2 = (u2 = n(this._extractNamespace(h.sanitizeInput(l2, this._options.invalidCharReplacement), h.sanitizeInput(p2, this._options.invalidCharReplacement), true), 2))[0], p2 = u2[1], void 0 === l2) {
              var m = n(c.namespace_extractQName(p2), 1)[0];
              l2 = this.node.lookupNamespaceURI(m);
            }
            var y = null != l2 ? this._doc.createElementNS(l2, p2) : this._doc.createElement(p2);
            this.node.appendChild(y);
            var v = new e2(y), _ = this._doc.doctype;
            if (y === this._doc.documentElement && null !== _) {
              var g = this._doc.implementation.createDocumentType(this._doc.documentElement.tagName, _.publicId, _.systemId);
              this._doc.replaceChild(g, _);
            }
            return d2 && !a.isEmpty(d2) && v.att(d2), v;
          }, e2.prototype.remove = function() {
            var e3 = this.up();
            return e3.node.removeChild(this.node), e3;
          }, e2.prototype.att = function(e3, t2, r2) {
            var i2, o2, s2, u2, f2, d2, m = this;
            if (a.isMap(e3) || a.isObject(e3)) return a.forEachObject(e3, function(e4, t3) {
              return m.att(e4, t3);
            }, this), this;
            if (null != e3 && (e3 = a.getValue(e3 + "")), null != t2 && (t2 = a.getValue(t2 + "")), null != r2 && (r2 = a.getValue(r2 + "")), null !== e3 && !a.isString(e3) || !a.isString(t2) || null !== r2 && !a.isString(r2)) {
              if (!a.isString(e3) || null != t2 && !a.isString(t2)) throw new Error("Attribute name and value not specified. " + this._debugInfo());
              u2 = (o2 = n([void 0, e3, t2], 3))[0], f2 = o2[1], d2 = o2[2];
            } else u2 = (i2 = n([e3, t2, r2], 3))[0], f2 = i2[1], d2 = i2[2];
            if (this._options.keepNullAttributes && null == d2) d2 = "";
            else if (null == d2) return this;
            if (!l.Guard.isElementNode(this.node)) throw new Error("An attribute can only be assigned to an element node.");
            var y = this.node;
            u2 = (s2 = n(this._extractNamespace(u2, f2, false), 2))[0], f2 = s2[1], f2 = h.sanitizeInput(f2, this._options.invalidCharReplacement), u2 = h.sanitizeInput(u2, this._options.invalidCharReplacement), d2 = h.sanitizeInput(d2, this._options.invalidCharReplacement);
            var v = n(c.namespace_extractQName(f2), 2), _ = v[0], g = v[1], b = n(c.namespace_extractQName(y.prefix ? y.prefix + ":" + y.localName : y.localName), 1)[0], x = null;
            return "xmlns" === _ ? (u2 = p.namespace.XMLNS, null === y.namespaceURI && b === g && (x = d2)) : null === _ && "xmlns" === g && null === b && (u2 = p.namespace.XMLNS, x = d2), null !== x && (this._updateNamespace(x), y = this.node), void 0 !== u2 ? y.setAttributeNS(u2, f2, d2) : y.setAttribute(f2, d2), this;
          }, e2.prototype.removeAtt = function(e3, t2) {
            var r2, n2, i2 = this;
            if (!l.Guard.isElementNode(this.node)) throw new Error("An attribute can only be removed from an element node.");
            if (e3 = a.getValue(e3), void 0 !== t2 && (t2 = a.getValue(t2)), null !== e3 && void 0 === t2) n2 = e3;
            else {
              if (null !== e3 && !a.isString(e3) || void 0 === t2) throw new Error("Attribute namespace must be a string. " + this._debugInfo());
              r2 = e3, n2 = t2;
            }
            return a.isArray(n2) || a.isSet(n2) ? a.forEachArray(n2, function(e4) {
              return void 0 === r2 ? i2.removeAtt(e4) : i2.removeAtt(r2, e4);
            }, this) : void 0 !== r2 ? (n2 = h.sanitizeInput(n2, this._options.invalidCharReplacement), r2 = h.sanitizeInput(r2, this._options.invalidCharReplacement), this.node.removeAttributeNS(r2, n2)) : (n2 = h.sanitizeInput(n2, this._options.invalidCharReplacement), this.node.removeAttribute(n2)), this;
          }, e2.prototype.txt = function(e3) {
            if (null == e3) {
              if (!this._options.keepNullNodes) return this;
              e3 = "";
            }
            var t2 = this._doc.createTextNode(h.sanitizeInput(e3, this._options.invalidCharReplacement));
            return this.node.appendChild(t2), this;
          }, e2.prototype.com = function(e3) {
            if (null == e3) {
              if (!this._options.keepNullNodes) return this;
              e3 = "";
            }
            var t2 = this._doc.createComment(h.sanitizeInput(e3, this._options.invalidCharReplacement));
            return this.node.appendChild(t2), this;
          }, e2.prototype.dat = function(e3) {
            if (null == e3) {
              if (!this._options.keepNullNodes) return this;
              e3 = "";
            }
            var t2 = this._doc.createCDATASection(h.sanitizeInput(e3, this._options.invalidCharReplacement));
            return this.node.appendChild(t2), this;
          }, e2.prototype.ins = function(e3, t2) {
            var r2 = this;
            if (void 0 === t2 && (t2 = ""), null == t2) {
              if (!this._options.keepNullNodes) return this;
              t2 = "";
            }
            if (a.isArray(e3) || a.isSet(e3)) a.forEachArray(e3, function(e4) {
              var t3 = (e4 += "").indexOf(" "), n3 = -1 === t3 ? e4 : e4.substr(0, t3), i2 = -1 === t3 ? "" : e4.substr(t3 + 1);
              r2.ins(n3, i2);
            }, this);
            else if (a.isMap(e3) || a.isObject(e3)) a.forEachObject(e3, function(e4, t3) {
              return r2.ins(e4, t3);
            }, this);
            else {
              var n2 = this._doc.createProcessingInstruction(h.sanitizeInput(e3, this._options.invalidCharReplacement), h.sanitizeInput(t2, this._options.invalidCharReplacement));
              this.node.appendChild(n2);
            }
            return this;
          }, e2.prototype.dec = function(e3) {
            return this._options.version = e3.version || "1.0", this._options.encoding = e3.encoding, this._options.standalone = e3.standalone, this;
          }, e2.prototype.dtd = function(e3) {
            var t2 = h.sanitizeInput(e3 && e3.name || (this._doc.documentElement ? this._doc.documentElement.tagName : "ROOT"), this._options.invalidCharReplacement), r2 = h.sanitizeInput(e3 && e3.pubID || "", this._options.invalidCharReplacement), n2 = h.sanitizeInput(e3 && e3.sysID || "", this._options.invalidCharReplacement);
            if (null !== this._doc.documentElement && t2 !== this._doc.documentElement.tagName) throw new Error("DocType name does not match document element name.");
            var i2 = this._doc.implementation.createDocumentType(t2, r2, n2);
            return null !== this._doc.doctype ? this._doc.replaceChild(i2, this._doc.doctype) : this._doc.insertBefore(i2, this._doc.documentElement), this;
          }, e2.prototype.import = function(t2) {
            var r2, o2, a2 = this._domNode, s2 = this._doc, u2 = t2.node;
            if (l.Guard.isDocumentNode(u2)) {
              var h2 = u2.documentElement;
              if (null === h2) throw new Error("Imported document has no document element node. " + this._debugInfo());
              var p2 = s2.importNode(h2, true);
              a2.appendChild(p2);
              var f2 = n(c.namespace_extractQName(p2.prefix ? p2.prefix + ":" + p2.localName : p2.localName), 1)[0], d2 = a2.lookupNamespaceURI(f2);
              new e2(p2)._updateNamespace(d2);
            } else if (l.Guard.isDocumentFragmentNode(u2)) try {
              for (var m = i(u2.childNodes), y = m.next(); !y.done; y = m.next()) {
                var v = y.value;
                p2 = s2.importNode(v, true);
                if (a2.appendChild(p2), l.Guard.isElementNode(p2)) {
                  f2 = n(c.namespace_extractQName(p2.prefix ? p2.prefix + ":" + p2.localName : p2.localName), 1)[0], d2 = a2.lookupNamespaceURI(f2);
                  new e2(p2)._updateNamespace(d2);
                }
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                y && !y.done && (o2 = m.return) && o2.call(m);
              } finally {
                if (r2) throw r2.error;
              }
            }
            else {
              p2 = s2.importNode(u2, true);
              if (a2.appendChild(p2), l.Guard.isElementNode(p2)) {
                f2 = n(c.namespace_extractQName(p2.prefix ? p2.prefix + ":" + p2.localName : p2.localName), 1)[0], d2 = a2.lookupNamespaceURI(f2);
                new e2(p2)._updateNamespace(d2);
              }
            }
            return this;
          }, e2.prototype.doc = function() {
            if (this._doc._isFragment) {
              for (var t2 = this.node; t2 && t2.nodeType !== u.NodeType.DocumentFragment; ) t2 = t2.parentNode;
              if (null === t2) throw new Error("Node has no parent node while searching for document fragment ancestor. " + this._debugInfo());
              return new e2(t2);
            }
            return new e2(this._doc);
          }, e2.prototype.root = function() {
            var t2 = this._doc.documentElement;
            if (!t2) throw new Error("Document root element is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.up = function() {
            var t2 = this._domNode.parentNode;
            if (!t2) throw new Error("Parent node is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.prev = function() {
            var t2 = this._domNode.previousSibling;
            if (!t2) throw new Error("Previous sibling node is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.next = function() {
            var t2 = this._domNode.nextSibling;
            if (!t2) throw new Error("Next sibling node is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.first = function() {
            var t2 = this._domNode.firstChild;
            if (!t2) throw new Error("First child node is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.last = function() {
            var t2 = this._domNode.lastChild;
            if (!t2) throw new Error("Last child node is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.each = function(t2, r2, n2, i2) {
            void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
            for (var o2 = this._getFirstDescendantNode(this._domNode, r2, n2); o2[0]; ) {
              var a2 = this._getNextDescendantNode(this._domNode, o2[0], n2, o2[1], o2[2]);
              t2.call(i2, new e2(o2[0]), o2[1], o2[2]), o2 = a2;
            }
            return this;
          }, e2.prototype.map = function(e3, t2, r2, n2) {
            void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false);
            var i2 = [];
            return this.each(function(t3, r3, o2) {
              return i2.push(e3.call(n2, t3, r3, o2));
            }, t2, r2), i2;
          }, e2.prototype.reduce = function(e3, t2, r2, n2, i2) {
            void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
            var o2 = t2;
            return this.each(function(t3, r3, n3) {
              return o2 = e3.call(i2, o2, t3, r3, n3);
            }, r2, n2), o2;
          }, e2.prototype.find = function(t2, r2, n2, i2) {
            void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
            for (var o2 = this._getFirstDescendantNode(this._domNode, r2, n2); o2[0]; ) {
              var a2 = new e2(o2[0]);
              if (t2.call(i2, a2, o2[1], o2[2])) return a2;
              o2 = this._getNextDescendantNode(this._domNode, o2[0], n2, o2[1], o2[2]);
            }
          }, e2.prototype.filter = function(e3, t2, r2, n2) {
            void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false);
            var i2 = [];
            return this.each(function(t3, r3, o2) {
              e3.call(n2, t3, r3, o2) && i2.push(t3);
            }, t2, r2), i2;
          }, e2.prototype.every = function(t2, r2, n2, i2) {
            void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
            for (var o2 = this._getFirstDescendantNode(this._domNode, r2, n2); o2[0]; ) {
              var a2 = new e2(o2[0]);
              if (!t2.call(i2, a2, o2[1], o2[2])) return false;
              o2 = this._getNextDescendantNode(this._domNode, o2[0], n2, o2[1], o2[2]);
            }
            return true;
          }, e2.prototype.some = function(t2, r2, n2, i2) {
            void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
            for (var o2 = this._getFirstDescendantNode(this._domNode, r2, n2); o2[0]; ) {
              var a2 = new e2(o2[0]);
              if (t2.call(i2, a2, o2[1], o2[2])) return true;
              o2 = this._getNextDescendantNode(this._domNode, o2[0], n2, o2[1], o2[2]);
            }
            return false;
          }, e2.prototype.toArray = function(e3, t2) {
            void 0 === e3 && (e3 = false), void 0 === t2 && (t2 = false);
            var r2 = [];
            return this.each(function(e4) {
              return r2.push(e4);
            }, e3, t2), r2;
          }, e2.prototype.toString = function(e3) {
            return void 0 === (e3 = e3 || {}).format && (e3.format = "xml"), this._serialize(e3);
          }, e2.prototype.toObject = function(e3) {
            return void 0 === (e3 = e3 || {}).format && (e3.format = "object"), this._serialize(e3);
          }, e2.prototype.end = function(e3) {
            return void 0 === (e3 = e3 || {}).format && (e3.format = "xml"), this.doc()._serialize(e3);
          }, e2.prototype._getFirstDescendantNode = function(e3, t2, r2) {
            return t2 ? [this._domNode, 0, 0] : r2 ? this._getNextDescendantNode(e3, e3, r2, 0, 0) : [this._domNode.firstChild, 0, 1];
          }, e2.prototype._getNextDescendantNode = function(e3, t2, r2, n2, i2) {
            if (!r2) return e3 === t2 ? [t2.firstChild, 0, i2 + 1] : [t2.nextSibling, n2 + 1, i2];
            if (t2.firstChild) return [t2.firstChild, 0, i2 + 1];
            if (t2 === e3) return [null, -1, -1];
            if (t2.nextSibling) return [t2.nextSibling, n2 + 1, i2];
            for (var o2 = t2.parentNode; o2 && o2 !== e3; ) {
              if (o2.nextSibling) return [o2.nextSibling, c.tree_index(o2.nextSibling), i2 - 1];
              o2 = o2.parentNode, i2--;
            }
            return [null, -1, -1];
          }, e2.prototype._serialize = function(e3) {
            if ("xml" === e3.format) return new s.XMLWriter(this._options, e3).serialize(this.node);
            if ("map" === e3.format) return new s.MapWriter(this._options, e3).serialize(this.node);
            if ("object" === e3.format) return new s.ObjectWriter(this._options, e3).serialize(this.node);
            if ("json" === e3.format) return new s.JSONWriter(this._options, e3).serialize(this.node);
            if ("yaml" === e3.format) return new s.YAMLWriter(this._options, e3).serialize(this.node);
            throw new Error("Invalid writer format: " + e3.format + ". " + this._debugInfo());
          }, e2.prototype._extractNamespace = function(e3, t2, r2) {
            var n2 = t2.indexOf("@");
            if (n2 > 0 && (void 0 === e3 && (e3 = t2.slice(n2 + 1)), t2 = t2.slice(0, n2)), void 0 === e3) e3 = r2 ? this._options.defaultNamespace.ele : this._options.defaultNamespace.att;
            else if (null !== e3 && "@" === e3[0]) {
              var i2 = e3.slice(1);
              if (void 0 === (e3 = this._options.namespaceAlias[i2])) throw new Error("Namespace alias `" + i2 + "` is not defined. " + this._debugInfo());
            }
            return [e3, t2];
          }, e2.prototype._updateNamespace = function(t2) {
            var r2, o2, a2, s2, u2 = this._domNode;
            if (l.Guard.isElementNode(u2) && null !== t2 && u2.namespaceURI !== t2) {
              var h2 = n(c.namespace_extractQName(u2.prefix ? u2.prefix + ":" + u2.localName : u2.localName), 2), p2 = h2[0], f2 = h2[1], d2 = c.create_element(this._doc, f2, t2, p2);
              try {
                for (var m = i(u2.attributes), y = m.next(); !y.done; y = m.next()) {
                  var v = y.value, _ = v.prefix ? v.prefix + ":" + v.localName : v.localName, g = n(c.namespace_extractQName(_), 1)[0], b = v.namespaceURI;
                  null === b && null !== g && (b = u2.lookupNamespaceURI(g)), null === b ? d2.setAttribute(_, v.value) : d2.setAttributeNS(b, _, v.value);
                }
              } catch (e3) {
                r2 = { error: e3 };
              } finally {
                try {
                  y && !y.done && (o2 = m.return) && o2.call(m);
                } finally {
                  if (r2) throw r2.error;
                }
              }
              var x = u2.parentNode;
              if (null === x) throw new Error("Parent node is null." + this._debugInfo());
              x.replaceChild(d2, u2), this._domNode = d2;
              try {
                for (var w = i(u2.childNodes), E = w.next(); !E.done; E = w.next()) {
                  var D = E.value.cloneNode(true);
                  if (d2.appendChild(D), l.Guard.isElementNode(D)) {
                    var S = n(c.namespace_extractQName(D.prefix ? D.prefix + ":" + D.localName : D.localName), 1)[0], C = d2.lookupNamespaceURI(S);
                    new e2(D)._updateNamespace(C);
                  }
                }
              } catch (e3) {
                a2 = { error: e3 };
              } finally {
                try {
                  E && !E.done && (s2 = w.return) && s2.call(w);
                } finally {
                  if (a2) throw a2.error;
                }
              }
            }
          }, Object.defineProperty(e2.prototype, "_doc", { get: function() {
            var e3 = this.node;
            if (l.Guard.isDocumentNode(e3)) return e3;
            var t2 = e3.ownerDocument;
            if (!t2) throw new Error("Owner document is null. " + this._debugInfo());
            return t2;
          }, enumerable: true, configurable: true }), e2.prototype._debugInfo = function(e3) {
            var t2 = this.node, r2 = t2.parentNode;
            e3 = e3 || t2.nodeName;
            var n2 = r2 ? r2.nodeName : "";
            return n2 ? "node: <" + e3 + ">, parent: <" + n2 + ">" : "node: <" + e3 + ">";
          }, Object.defineProperty(e2.prototype, "_options", { get: function() {
            var e3 = this._doc;
            if (void 0 === e3._xmlBuilderOptions) throw new Error("Builder options is not set.");
            return e3._xmlBuilderOptions;
          }, set: function(e3) {
            this._doc._xmlBuilderOptions = e3;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.XMLBuilderImpl = d;
      }, function(e, t, r) {
        var n = r(11), i = r(117), o = n.WeakMap;
        e.exports = "function" == typeof o && /native code/.test(i(o));
      }, function(e, t, r) {
        var n = r(46), i = r(82), o = r(85), a = r(18);
        e.exports = n("Reflect", "ownKeys") || function(e2) {
          var t2 = i.f(a(e2)), r2 = o.f;
          return r2 ? t2.concat(r2(e2)) : t2;
        };
      }, function(e, t, r) {
        var n = r(16), i = r(15), o = r(18), a = r(61);
        e.exports = n ? Object.defineProperties : function(e2, t2) {
          o(e2);
          for (var r2, n2 = a(t2), s = n2.length, u = 0; s > u; ) i.f(e2, r2 = n2[u++], t2[r2]);
          return e2;
        };
      }, function(e, t, r) {
        var n = r(46);
        e.exports = n("document", "documentElement");
      }, function(e, t, r) {
        var n = r(24), i = r(82).f, o = {}.toString, a = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        e.exports.f = function(e2) {
          return a && "[object Window]" == o.call(e2) ? function(e3) {
            try {
              return i(e3);
            } catch (e4) {
              return a.slice();
            }
          }(e2) : i(n(e2));
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(36).every, o = r(48), a = r(28), s = o("every"), u = a("every");
        n({ target: "Array", proto: true, forced: !s || !u }, { every: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(36).filter, o = r(63), a = r(28), s = o("filter"), u = a("filter");
        n({ target: "Array", proto: true, forced: !s || !u }, { filter: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        var n = r(46);
        e.exports = n("navigator", "userAgent") || "";
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(36).find, o = r(130), a = r(28), s = true, u = a("find");
        "find" in [] && Array(1).find(function() {
          s = false;
        }), n({ target: "Array", proto: true, forced: s || !u }, { find: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } }), o("find");
      }, function(e, t, r) {
        "use strict";
        var n = r(131).IteratorPrototype, i = r(60), o = r(40), a = r(62), s = r(49), u = function() {
          return this;
        };
        e.exports = function(e2, t2, r2) {
          var l = t2 + " Iterator";
          return e2.prototype = i(n, { next: o(1, r2) }), a(e2, l, false, true), s[l] = u, e2;
        };
      }, function(e, t, r) {
        var n = r(8);
        e.exports = !n(function() {
          function e2() {
          }
          return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
        });
      }, function(e, t, r) {
        var n = r(13);
        e.exports = function(e2) {
          if (!n(e2) && null !== e2) throw TypeError("Can't set " + String(e2) + " as a prototype");
          return e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(36).map, o = r(63), a = r(28), s = o("map"), u = a("map");
        n({ target: "Array", proto: true, forced: !s || !u }, { map: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(200).left, o = r(48), a = r(28), s = o("reduce"), u = a("reduce", { 1: 0 });
        n({ target: "Array", proto: true, forced: !s || !u }, { reduce: function(e2) {
          return i(this, e2, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        var n = r(127), i = r(27), o = r(41), a = r(26), s = function(e2) {
          return function(t2, r2, s2, u) {
            n(r2);
            var l = i(t2), c = o(l), h = a(l.length), p = e2 ? h - 1 : 0, f = e2 ? -1 : 1;
            if (s2 < 2) for (; ; ) {
              if (p in c) {
                u = c[p], p += f;
                break;
              }
              if (p += f, e2 ? p < 0 : h <= p) throw TypeError("Reduce of empty array with no initial value");
            }
            for (; e2 ? p >= 0 : h > p; p += f) p in c && (u = r2(u, c[p], p, l));
            return u;
          };
        };
        e.exports = { left: s(false), right: s(true) };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(36).some, o = r(48), a = r(28), s = o("some"), u = a("some");
        n({ target: "Array", proto: true, forced: !s || !u }, { some: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(90), i = r(135);
        e.exports = n ? {}.toString : function() {
          return "[object " + i(this) + "]";
        };
      }, function(e, t) {
        e.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
      }, function(e, t, r) {
        var n = r(8);
        e.exports = !n(function() {
          return Object.isExtensible(Object.preventExtensions({}));
        });
      }, function(e, t, r) {
        var n = r(5), i = r(49), o = n("iterator"), a = Array.prototype;
        e.exports = function(e2) {
          return void 0 !== e2 && (i.Array === e2 || a[o] === e2);
        };
      }, function(e, t, r) {
        var n = r(135), i = r(49), o = r(5)("iterator");
        e.exports = function(e2) {
          if (null != e2) return e2[o] || e2["@@iterator"] || i[n(e2)];
        };
      }, function(e, t, r) {
        var n = r(18);
        e.exports = function(e2, t2, r2, i) {
          try {
            return i ? t2(n(r2)[0], r2[1]) : t2(r2);
          } catch (t3) {
            var o = e2.return;
            throw void 0 !== o && n(o.call(e2)), t3;
          }
        };
      }, function(e, t, r) {
        var n = r(5)("iterator"), i = false;
        try {
          var o = 0, a = { next: function() {
            return { done: !!o++ };
          }, return: function() {
            i = true;
          } };
          a[n] = function() {
            return this;
          }, Array.from(a, function() {
            throw 2;
          });
        } catch (e2) {
        }
        e.exports = function(e2, t2) {
          if (!t2 && !i) return false;
          var r2 = false;
          try {
            var o2 = {};
            o2[n] = function() {
              return { next: function() {
                return { done: r2 = true };
              } };
            }, e2(o2);
          } catch (e3) {
          }
          return r2;
        };
      }, function(e, t, r) {
        var n = r(13), i = r(133);
        e.exports = function(e2, t2, r2) {
          var o, a;
          return i && "function" == typeof (o = t2.constructor) && o !== r2 && n(a = o.prototype) && a !== r2.prototype && i(e2, a), e2;
        };
      }, function(e, t, r) {
        var n = r(25);
        e.exports = function(e2, t2, r2) {
          for (var i in t2) n(e2, i, t2[i], r2);
          return e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(46), i = r(15), o = r(5), a = r(16), s = o("species");
        e.exports = function(e2) {
          var t2 = n(e2), r2 = i.f;
          a && t2 && !t2[s] && r2(t2, s, { configurable: true, get: function() {
            return this;
          } });
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, a = { label: 0, sent: function() {
            if (1 & i2[0]) throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: s(0), throw: s(1), return: s(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function s(o3) {
            return function(s2) {
              return function(o4) {
                if (r2) throw new TypeError("Generator is already executing.");
                for (; a; ) try {
                  if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done) return i2;
                  switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                    case 0:
                    case 1:
                      i2 = o4;
                      break;
                    case 4:
                      return a.label++, { value: o4[1], done: false };
                    case 5:
                      a.label++, n2 = o4[1], o4 = [0];
                      continue;
                    case 7:
                      o4 = a.ops.pop(), a.trys.pop();
                      continue;
                    default:
                      if (!(i2 = a.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                        a = 0;
                        continue;
                      }
                      if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                        a.label = o4[1];
                        break;
                      }
                      if (6 === o4[0] && a.label < i2[1]) {
                        a.label = i2[1], i2 = o4;
                        break;
                      }
                      if (i2 && a.label < i2[2]) {
                        a.label = i2[2], a.ops.push(o4);
                        break;
                      }
                      i2[2] && a.ops.pop(), a.trys.pop();
                      continue;
                  }
                  o4 = t2.call(e2, a);
                } catch (e3) {
                  o4 = [6, e3], n2 = 0;
                } finally {
                  r2 = i2 = 0;
                }
                if (5 & o4[0]) throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, s2]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function() {
          function e2(e3) {
            void 0 === e3 && (e3 = 1e3), this._items = /* @__PURE__ */ new Set(), this._limit = e3;
          }
          return e2.prototype.add = function(e3) {
            if (this._items.add(e3), this._items.size > this._limit) {
              var t2 = this._items.values().next();
              t2.done || this._items.delete(t2.value);
            }
            return this;
          }, e2.prototype.delete = function(e3) {
            return this._items.delete(e3);
          }, e2.prototype.has = function(e3) {
            return this._items.has(e3);
          }, e2.prototype.clear = function() {
            this._items.clear();
          }, Object.defineProperty(e2.prototype, "size", { get: function() {
            return this._items.size;
          }, enumerable: true, configurable: true }), e2.prototype.forEach = function(e3, t2) {
            var r2 = this;
            this._items.forEach(function(n2) {
              return e3.call(t2, n2, n2, r2);
            });
          }, e2.prototype.keys = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.keys())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype.values = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.values())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype.entries = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.entries())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype[Symbol.iterator] = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items)];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, Object.defineProperty(e2.prototype, Symbol.toStringTag, { get: function() {
            return "FixedSizeSet";
          }, enumerable: true, configurable: true }), e2;
        }();
        t.FixedSizeSet = o;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, a = { label: 0, sent: function() {
            if (1 & i2[0]) throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: s(0), throw: s(1), return: s(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function s(o3) {
            return function(s2) {
              return function(o4) {
                if (r2) throw new TypeError("Generator is already executing.");
                for (; a; ) try {
                  if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done) return i2;
                  switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                    case 0:
                    case 1:
                      i2 = o4;
                      break;
                    case 4:
                      return a.label++, { value: o4[1], done: false };
                    case 5:
                      a.label++, n2 = o4[1], o4 = [0];
                      continue;
                    case 7:
                      o4 = a.ops.pop(), a.trys.pop();
                      continue;
                    default:
                      if (!(i2 = a.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                        a = 0;
                        continue;
                      }
                      if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                        a.label = o4[1];
                        break;
                      }
                      if (6 === o4[0] && a.label < i2[1]) {
                        a.label = i2[1], i2 = o4;
                        break;
                      }
                      if (i2 && a.label < i2[2]) {
                        a.label = i2[2], a.ops.push(o4);
                        break;
                      }
                      i2[2] && a.ops.pop(), a.trys.pop();
                      continue;
                  }
                  o4 = t2.call(e2, a);
                } catch (e3) {
                  o4 = [6, e3], n2 = 0;
                } finally {
                  r2 = i2 = 0;
                }
                if (5 & o4[0]) throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, s2]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function() {
          function e2(e3) {
            void 0 === e3 && (e3 = 1e3), this._items = /* @__PURE__ */ new Map(), this._limit = e3;
          }
          return e2.prototype.get = function(e3) {
            return this._items.get(e3);
          }, e2.prototype.set = function(e3, t2) {
            if (this._items.set(e3, t2), this._items.size > this._limit) {
              var r2 = this._items.keys().next();
              r2.done || this._items.delete(r2.value);
            }
          }, e2.prototype.delete = function(e3) {
            return this._items.delete(e3);
          }, e2.prototype.has = function(e3) {
            return this._items.has(e3);
          }, e2.prototype.clear = function() {
            this._items.clear();
          }, Object.defineProperty(e2.prototype, "size", { get: function() {
            return this._items.size;
          }, enumerable: true, configurable: true }), e2.prototype.forEach = function(e3, t2) {
            this._items.forEach(function(r2, n2) {
              return e3.call(t2, n2, r2);
            });
          }, e2.prototype.keys = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.keys())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype.values = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.values())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype.entries = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.entries())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype[Symbol.iterator] = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items)];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, Object.defineProperty(e2.prototype, Symbol.toStringTag, { get: function() {
            return "ObjectCache";
          }, enumerable: true, configurable: true }), e2;
        }();
        t.ObjectCache = o;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2(e3) {
            void 0 === e3 && (e3 = 1e3), this._items = /* @__PURE__ */ new Map(), this._limit = e3;
          }
          return e2.prototype.check = function(e3, t2) {
            if (this._items.get(e3) === t2) return true;
            if (this._items.get(t2) === e3) return false;
            var r2 = Math.random() < 0.5;
            if (r2 ? this._items.set(e3, t2) : this._items.set(t2, e3), this._items.size > this._limit) {
              var n2 = this._items.keys().next();
              n2.done || this._items.delete(n2.value);
            }
            return r2;
          }, e2;
        }();
        t.CompareCache = n;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2(e3) {
            this._initialized = false, this._value = void 0, this._initFunc = e3;
          }
          return Object.defineProperty(e2.prototype, "value", { get: function() {
            return this._initialized || (this._value = this._initFunc(), this._initialized = true), this._value;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.Lazy = n;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2(e3) {
            this._pointer = 0, this._chars = Array.from(e3), this._length = this._chars.length;
          }
          return Object.defineProperty(e2.prototype, "eof", { get: function() {
            return this._pointer >= this._length;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "length", { get: function() {
            return this._length;
          }, enumerable: true, configurable: true }), e2.prototype.codePoint = function() {
            if (void 0 === this._codePoint) if (this.eof) this._codePoint = -1;
            else {
              var e3 = this._chars[this._pointer].codePointAt(0);
              this._codePoint = void 0 !== e3 ? e3 : -1;
            }
            return this._codePoint;
          }, e2.prototype.c = function() {
            return void 0 === this._c && (this._c = this.eof ? "" : this._chars[this._pointer]), this._c;
          }, e2.prototype.remaining = function() {
            return void 0 === this._remaining && (this._remaining = this.eof ? "" : this._chars.slice(this._pointer + 1).join("")), this._remaining;
          }, e2.prototype.substring = function() {
            return void 0 === this._substring && (this._substring = this.eof ? "" : this._chars.slice(this._pointer).join("")), this._substring;
          }, Object.defineProperty(e2.prototype, "pointer", { get: function() {
            return this._pointer;
          }, set: function(e3) {
            e3 !== this._pointer && (this._pointer = e3, this._codePoint = void 0, this._c = void 0, this._remaining = void 0, this._substring = void 0);
          }, enumerable: true, configurable: true }), e2;
        }();
        t.StringWalker = n;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(218);
        t.MapWriter = n.MapWriter;
        var i = r(258);
        t.XMLWriter = i.XMLWriter;
        var o = r(67);
        t.ObjectWriter = o.ObjectWriter;
        var a = r(260);
        t.JSONWriter = a.JSONWriter;
        var s = r(261);
        t.YAMLWriter = s.YAMLWriter;
      }, function(e, t, r) {
        "use strict";
        r(19), r(219), r(20), r(22), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(1), a = r(67), s = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            return n2._writerOptions = o.applyDefaults(r2, { format: "map", wellFormed: false, group: false, verbose: false }), n2;
          }
          return i(t2, e2), t2.prototype.serialize = function(e3) {
            var t3 = o.applyDefaults(this._writerOptions, { format: "object", wellFormed: false, verbose: false }), r2 = new a.ObjectWriter(this._builderOptions, t3).serialize(e3);
            return this._convertObject(r2);
          }, t2.prototype._convertObject = function(e3) {
            if (o.isArray(e3)) {
              for (var t3 = 0; t3 < e3.length; t3++) e3[t3] = this._convertObject(e3[t3]);
              return e3;
            }
            if (o.isObject(e3)) {
              var r2 = /* @__PURE__ */ new Map();
              for (var n2 in e3) r2.set(n2, this._convertObject(e3[n2]));
              return r2;
            }
            return e3;
          }, t2;
        }(r(50).BaseWriter);
        t.MapWriter = s;
      }, function(e, t, r) {
        "use strict";
        var n = r(139), i = r(143);
        e.exports = n("Map", function(e2) {
          return function() {
            return e2(this, arguments.length ? arguments[0] : void 0);
          };
        }, i);
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(8), o = r(59), a = r(13), s = r(27), u = r(26), l = r(134), c = r(128), h = r(63), p = r(5), f = r(129), d = p("isConcatSpreadable"), m = f >= 51 || !i(function() {
          var e2 = [];
          return e2[d] = false, e2.concat()[0] !== e2;
        }), y = h("concat"), v = function(e2) {
          if (!a(e2)) return false;
          var t2 = e2[d];
          return void 0 !== t2 ? !!t2 : o(e2);
        };
        n({ target: "Array", proto: true, forced: !m || !y }, { concat: function(e2) {
          var t2, r2, n2, i2, o2, a2 = s(this), h2 = c(a2, 0), p2 = 0;
          for (t2 = -1, n2 = arguments.length; t2 < n2; t2++) if (v(o2 = -1 === t2 ? a2 : arguments[t2])) {
            if (p2 + (i2 = u(o2.length)) > 9007199254740991) throw TypeError("Maximum allowed index exceeded");
            for (r2 = 0; r2 < i2; r2++, p2++) r2 in o2 && l(h2, p2, o2[r2]);
          } else {
            if (p2 >= 9007199254740991) throw TypeError("Maximum allowed index exceeded");
            l(h2, p2++, o2);
          }
          return h2.length = p2, h2;
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(8);
        function i(e2, t2) {
          return RegExp(e2, t2);
        }
        t.UNSUPPORTED_Y = n(function() {
          var e2 = i("a", "y");
          return e2.lastIndex = 2, null != e2.exec("abcd");
        }), t.BROKEN_CARET = n(function() {
          var e2 = i("^r", "gy");
          return e2.lastIndex = 2, null != e2.exec("str");
        });
      }, function(e, t, r) {
        var n = r(223);
        e.exports = function(e2) {
          if (n(e2)) throw TypeError("The method doesn't accept regular expressions");
          return e2;
        };
      }, function(e, t, r) {
        var n = r(13), i = r(42), o = r(5)("match");
        e.exports = function(e2) {
          var t2;
          return n(e2) && (void 0 !== (t2 = e2[o]) ? !!t2 : "RegExp" == i(e2));
        };
      }, function(e, t, r) {
        var n = r(5)("match");
        e.exports = function(e2) {
          var t2 = /./;
          try {
            "/./"[e2](t2);
          } catch (r2) {
            try {
              return t2[n] = false, "/./"[e2](t2);
            } catch (e3) {
            }
          }
          return false;
        };
      }, function(e, t, r) {
        "use strict";
        r(68);
        var n = r(25), i = r(8), o = r(5), a = r(93), s = r(21), u = o("species"), l = !i(function() {
          var e2 = /./;
          return e2.exec = function() {
            var e3 = [];
            return e3.groups = { a: "7" }, e3;
          }, "7" !== "".replace(e2, "$<a>");
        }), c = "$0" === "a".replace(/./, "$0"), h = o("replace"), p = !!/./[h] && "" === /./[h]("a", "$0"), f = !i(function() {
          var e2 = /(?:)/, t2 = e2.exec;
          e2.exec = function() {
            return t2.apply(this, arguments);
          };
          var r2 = "ab".split(e2);
          return 2 !== r2.length || "a" !== r2[0] || "b" !== r2[1];
        });
        e.exports = function(e2, t2, r2, h2) {
          var d = o(e2), m = !i(function() {
            var t3 = {};
            return t3[d] = function() {
              return 7;
            }, 7 != ""[e2](t3);
          }), y = m && !i(function() {
            var t3 = false, r3 = /a/;
            return "split" === e2 && ((r3 = {}).constructor = {}, r3.constructor[u] = function() {
              return r3;
            }, r3.flags = "", r3[d] = /./[d]), r3.exec = function() {
              return t3 = true, null;
            }, r3[d](""), !t3;
          });
          if (!m || !y || "replace" === e2 && (!l || !c || p) || "split" === e2 && !f) {
            var v = /./[d], _ = r2(d, ""[e2], function(e3, t3, r3, n2, i2) {
              return t3.exec === a ? m && !i2 ? { done: true, value: v.call(t3, r3, n2) } : { done: true, value: e3.call(r3, t3, n2) } : { done: false };
            }, { REPLACE_KEEPS_$0: c, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: p }), g = _[0], b = _[1];
            n(String.prototype, e2, g), n(RegExp.prototype, d, 2 == t2 ? function(e3, t3) {
              return b.call(e3, this, t3);
            } : function(e3) {
              return b.call(e3, this);
            });
          }
          h2 && s(RegExp.prototype[d], "sham", true);
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(137).charAt;
        e.exports = function(e2, t2, r2) {
          return t2 + (r2 ? n(e2, t2).length : 1);
        };
      }, function(e, t, r) {
        var n = r(42), i = r(93);
        e.exports = function(e2, t2) {
          var r2 = e2.exec;
          if ("function" == typeof r2) {
            var o = r2.call(e2, t2);
            if ("object" != typeof o) throw TypeError("RegExp exec method returned something other than an Object or null");
            return o;
          }
          if ("RegExp" !== n(e2)) throw TypeError("RegExp#exec called on incompatible receiver");
          return i.call(e2, t2);
        };
      }, function(e, t, r) {
        "use strict";
        (function(e2) {
          Object.defineProperty(t, "__esModule", { value: true });
          var n = r(96);
          t.forgivingBase64Encode = function(t2) {
            return e2.from(t2).toString("base64");
          }, t.forgivingBase64Decode = function(t2) {
            return "" === t2 ? "" : ((t2 = t2.replace(n.ASCIIWhiteSpace, "")).length % 4 == 0 && (t2.endsWith("==") ? t2 = t2.substr(0, t2.length - 2) : t2.endsWith("=") && (t2 = t2.substr(0, t2.length - 1))), t2.length % 4 == 1 ? null : /[0-9A-Za-z+/]/.test(t2) ? e2.from(t2, "base64").toString("utf8") : null);
          };
        }).call(this, r(145).Buffer);
      }, function(e, t, r) {
        "use strict";
        t.byteLength = function(e2) {
          var t2 = l(e2), r2 = t2[0], n2 = t2[1];
          return 3 * (r2 + n2) / 4 - n2;
        }, t.toByteArray = function(e2) {
          var t2, r2, n2 = l(e2), a2 = n2[0], s2 = n2[1], u2 = new o(function(e3, t3, r3) {
            return 3 * (t3 + r3) / 4 - r3;
          }(0, a2, s2)), c2 = 0, h = s2 > 0 ? a2 - 4 : a2;
          for (r2 = 0; r2 < h; r2 += 4) t2 = i[e2.charCodeAt(r2)] << 18 | i[e2.charCodeAt(r2 + 1)] << 12 | i[e2.charCodeAt(r2 + 2)] << 6 | i[e2.charCodeAt(r2 + 3)], u2[c2++] = t2 >> 16 & 255, u2[c2++] = t2 >> 8 & 255, u2[c2++] = 255 & t2;
          2 === s2 && (t2 = i[e2.charCodeAt(r2)] << 2 | i[e2.charCodeAt(r2 + 1)] >> 4, u2[c2++] = 255 & t2);
          1 === s2 && (t2 = i[e2.charCodeAt(r2)] << 10 | i[e2.charCodeAt(r2 + 1)] << 4 | i[e2.charCodeAt(r2 + 2)] >> 2, u2[c2++] = t2 >> 8 & 255, u2[c2++] = 255 & t2);
          return u2;
        }, t.fromByteArray = function(e2) {
          for (var t2, r2 = e2.length, i2 = r2 % 3, o2 = [], a2 = 0, s2 = r2 - i2; a2 < s2; a2 += 16383) o2.push(c(e2, a2, a2 + 16383 > s2 ? s2 : a2 + 16383));
          1 === i2 ? (t2 = e2[r2 - 1], o2.push(n[t2 >> 2] + n[t2 << 4 & 63] + "==")) : 2 === i2 && (t2 = (e2[r2 - 2] << 8) + e2[r2 - 1], o2.push(n[t2 >> 10] + n[t2 >> 4 & 63] + n[t2 << 2 & 63] + "="));
          return o2.join("");
        };
        for (var n = [], i = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, u = a.length; s < u; ++s) n[s] = a[s], i[a.charCodeAt(s)] = s;
        function l(e2) {
          var t2 = e2.length;
          if (t2 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var r2 = e2.indexOf("=");
          return -1 === r2 && (r2 = t2), [r2, r2 === t2 ? 0 : 4 - r2 % 4];
        }
        function c(e2, t2, r2) {
          for (var i2, o2, a2 = [], s2 = t2; s2 < r2; s2 += 3) i2 = (e2[s2] << 16 & 16711680) + (e2[s2 + 1] << 8 & 65280) + (255 & e2[s2 + 2]), a2.push(n[(o2 = i2) >> 18 & 63] + n[o2 >> 12 & 63] + n[o2 >> 6 & 63] + n[63 & o2]);
          return a2.join("");
        }
        i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63;
      }, function(e, t) {
        t.read = function(e2, t2, r, n, i) {
          var o, a, s = 8 * i - n - 1, u = (1 << s) - 1, l = u >> 1, c = -7, h = r ? i - 1 : 0, p = r ? -1 : 1, f = e2[t2 + h];
          for (h += p, o = f & (1 << -c) - 1, f >>= -c, c += s; c > 0; o = 256 * o + e2[t2 + h], h += p, c -= 8) ;
          for (a = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; a = 256 * a + e2[t2 + h], h += p, c -= 8) ;
          if (0 === o) o = 1 - l;
          else {
            if (o === u) return a ? NaN : 1 / 0 * (f ? -1 : 1);
            a += Math.pow(2, n), o -= l;
          }
          return (f ? -1 : 1) * a * Math.pow(2, o - n);
        }, t.write = function(e2, t2, r, n, i, o) {
          var a, s, u, l = 8 * o - i - 1, c = (1 << l) - 1, h = c >> 1, p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : o - 1, d = n ? 1 : -1, m = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
          for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s = isNaN(t2) ? 1 : 0, a = c) : (a = Math.floor(Math.log(t2) / Math.LN2), t2 * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), (t2 += a + h >= 1 ? p / u : p * Math.pow(2, 1 - h)) * u >= 2 && (a++, u /= 2), a + h >= c ? (s = 0, a = c) : a + h >= 1 ? (s = (t2 * u - 1) * Math.pow(2, i), a += h) : (s = t2 * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; e2[r + f] = 255 & s, f += d, s /= 256, i -= 8) ;
          for (a = a << i | s, l += i; l > 0; e2[r + f] = 255 & a, f += d, a /= 256, l -= 8) ;
          e2[r + f - d] |= 128 * m;
        };
      }, function(e, t) {
        var r = {}.toString;
        e.exports = Array.isArray || function(e2) {
          return "[object Array]" == r.call(e2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(1);
        function o(e2) {
          var t2, r2;
          if (null === e2 || i.isString(e2) || i.isNumber(e2)) return e2;
          if (i.isArray(e2)) {
            var a = new Array();
            try {
              for (var s = n(e2), u = s.next(); !u.done; u = s.next()) {
                var l = u.value;
                a.push(o(l));
              }
            } catch (e3) {
              t2 = { error: e3 };
            } finally {
              try {
                u && !u.done && (r2 = s.return) && r2.call(s);
              } finally {
                if (t2) throw t2.error;
              }
            }
            return a;
          }
          if (i.isObject(e2)) {
            a = /* @__PURE__ */ new Map();
            for (var c in e2) if (e2.hasOwnProperty(c)) {
              var h = e2[c];
              a.set(c, o(h));
            }
            return a;
          }
          return e2;
        }
        t.parseJSONFromBytes = function(e2) {
          var t2 = i.utf8Decode(e2);
          return JSON.parse.call(void 0, t2);
        }, t.serializeJSONToBytes = function(e2) {
          var t2 = JSON.stringify.call(void 0, e2);
          return i.utf8Encode(t2);
        }, t.parseJSONIntoInfraValues = function(e2) {
          return o(JSON.parse.call(void 0, e2));
        }, t.convertAJSONDerivedJavaScriptValueToAnInfraValue = o;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, a2 = { label: 0, sent: function() {
            if (1 & i2[0]) throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function s2(o3) {
            return function(s3) {
              return function(o4) {
                if (r2) throw new TypeError("Generator is already executing.");
                for (; a2; ) try {
                  if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done) return i2;
                  switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                    case 0:
                    case 1:
                      i2 = o4;
                      break;
                    case 4:
                      return a2.label++, { value: o4[1], done: false };
                    case 5:
                      a2.label++, n2 = o4[1], o4 = [0];
                      continue;
                    case 7:
                      o4 = a2.ops.pop(), a2.trys.pop();
                      continue;
                    default:
                      if (!(i2 = a2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                        a2 = 0;
                        continue;
                      }
                      if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                        a2.label = o4[1];
                        break;
                      }
                      if (6 === o4[0] && a2.label < i2[1]) {
                        a2.label = i2[1], i2 = o4;
                        break;
                      }
                      if (i2 && a2.label < i2[2]) {
                        a2.label = i2[2], a2.ops.push(o4);
                        break;
                      }
                      i2[2] && a2.ops.pop(), a2.trys.pop();
                      continue;
                  }
                  o4 = t2.call(e2, a2);
                } catch (e3) {
                  o4 = [6, e3], n2 = 0;
                } finally {
                  r2 = i2 = 0;
                }
                if (5 & o4[0]) throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, s3]);
            };
          }
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++) e2 = e2.concat(i(arguments[t2]));
          return e2;
        }, a = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(1);
        t.append = function(e2, t2) {
          e2.push(t2);
        }, t.extend = function(e2, t2) {
          e2.push.apply(e2, o(t2));
        }, t.prepend = function(e2, t2) {
          e2.unshift(t2);
        }, t.replace = function(e2, t2, r2) {
          var n2, i2, o2 = 0;
          try {
            for (var u = a(e2), l = u.next(); !l.done; l = u.next()) {
              var c = l.value;
              if (s.isFunction(t2)) t2.call(null, c) && (e2[o2] = r2);
              else if (c === t2) return void (e2[o2] = r2);
              o2++;
            }
          } catch (e3) {
            n2 = { error: e3 };
          } finally {
            try {
              l && !l.done && (i2 = u.return) && i2.call(u);
            } finally {
              if (n2) throw n2.error;
            }
          }
        }, t.insert = function(e2, t2, r2) {
          e2.splice(r2, 0, t2);
        }, t.remove = function(e2, t2) {
          for (var r2 = e2.length; r2--; ) {
            var n2 = e2[r2];
            if (s.isFunction(t2)) t2.call(null, n2) && e2.splice(r2, 1);
            else if (n2 === t2) return void e2.splice(r2, 1);
          }
        }, t.empty = function(e2) {
          e2.length = 0;
        }, t.contains = function(e2, t2) {
          var r2, n2;
          try {
            for (var i2 = a(e2), o2 = i2.next(); !o2.done; o2 = i2.next()) {
              var u = o2.value;
              if (s.isFunction(t2)) {
                if (t2.call(null, u)) return true;
              } else if (u === t2) return true;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              o2 && !o2.done && (n2 = i2.return) && n2.call(i2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          return false;
        }, t.size = function(e2, t2) {
          var r2, n2;
          if (void 0 === t2) return e2.length;
          var i2 = 0;
          try {
            for (var o2 = a(e2), s2 = o2.next(); !s2.done; s2 = o2.next()) {
              var u = s2.value;
              t2.call(null, u) && i2++;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          return i2;
        }, t.isEmpty = function(e2) {
          return 0 === e2.length;
        }, t.forEach = function(e2, t2) {
          var r2, i2, o2, s2, u, l;
          return n(this, function(n2) {
            switch (n2.label) {
              case 0:
                return void 0 !== t2 ? [3, 2] : [5, a(e2)];
              case 1:
                return n2.sent(), [3, 9];
              case 2:
                n2.trys.push([2, 7, 8, 9]), r2 = a(e2), i2 = r2.next(), n2.label = 3;
              case 3:
                return i2.done ? [3, 6] : (o2 = i2.value, t2.call(null, o2) ? [4, o2] : [3, 5]);
              case 4:
                n2.sent(), n2.label = 5;
              case 5:
                return i2 = r2.next(), [3, 3];
              case 6:
                return [3, 9];
              case 7:
                return s2 = n2.sent(), u = { error: s2 }, [3, 9];
              case 8:
                try {
                  i2 && !i2.done && (l = r2.return) && l.call(r2);
                } finally {
                  if (u) throw u.error;
                }
                return [7];
              case 9:
                return [2];
            }
          });
        }, t.clone = function(e2) {
          return new (Array.bind.apply(Array, o([void 0], e2)))();
        }, t.sortInAscendingOrder = function(e2, t2) {
          return e2.sort(function(e3, r2) {
            return t2.call(null, e3, r2) ? -1 : 1;
          });
        }, t.sortInDescendingOrder = function(e2, t2) {
          return e2.sort(function(e3, r2) {
            return t2.call(null, e3, r2) ? 1 : -1;
          });
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, a2 = { label: 0, sent: function() {
            if (1 & i2[0]) throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function s2(o3) {
            return function(s3) {
              return function(o4) {
                if (r2) throw new TypeError("Generator is already executing.");
                for (; a2; ) try {
                  if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done) return i2;
                  switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                    case 0:
                    case 1:
                      i2 = o4;
                      break;
                    case 4:
                      return a2.label++, { value: o4[1], done: false };
                    case 5:
                      a2.label++, n2 = o4[1], o4 = [0];
                      continue;
                    case 7:
                      o4 = a2.ops.pop(), a2.trys.pop();
                      continue;
                    default:
                      if (!(i2 = a2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                        a2 = 0;
                        continue;
                      }
                      if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                        a2.label = o4[1];
                        break;
                      }
                      if (6 === o4[0] && a2.label < i2[1]) {
                        a2.label = i2[1], i2 = o4;
                        break;
                      }
                      if (i2 && a2.label < i2[2]) {
                        a2.label = i2[2], a2.ops.push(o4);
                        break;
                      }
                      i2[2] && a2.ops.pop(), a2.trys.pop();
                      continue;
                  }
                  o4 = t2.call(e2, a2);
                } catch (e3) {
                  o4 = [6, e3], n2 = 0;
                } finally {
                  r2 = i2 = 0;
                }
                if (5 & o4[0]) throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, s3]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, o = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, a = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++) e2 = e2.concat(o(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(1);
        t.get = function(e2, t2) {
          return e2.get(t2);
        }, t.set = function(e2, t2, r2) {
          e2.set(t2, r2);
        }, t.remove = function(e2, t2) {
          var r2, n2, o2, a2;
          if (s.isFunction(t2)) {
            var u = [];
            try {
              for (var l = i(e2), c = l.next(); !c.done; c = l.next()) {
                var h = c.value;
                t2.call(null, h) && u.push(h[0]);
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                c && !c.done && (n2 = l.return) && n2.call(l);
              } finally {
                if (r2) throw r2.error;
              }
            }
            try {
              for (var p = i(u), f = p.next(); !f.done; f = p.next()) {
                var d = f.value;
                e2.delete(d);
              }
            } catch (e3) {
              o2 = { error: e3 };
            } finally {
              try {
                f && !f.done && (a2 = p.return) && a2.call(p);
              } finally {
                if (o2) throw o2.error;
              }
            }
          } else e2.delete(t2);
        }, t.contains = function(e2, t2) {
          var r2, n2;
          if (s.isFunction(t2)) {
            try {
              for (var o2 = i(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var u = a2.value;
                if (t2.call(null, u)) return true;
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                a2 && !a2.done && (n2 = o2.return) && n2.call(o2);
              } finally {
                if (r2) throw r2.error;
              }
            }
            return false;
          }
          return e2.has(t2);
        }, t.keys = function(e2) {
          return new Set(e2.keys());
        }, t.values = function(e2) {
          return a(e2.values());
        }, t.size = function(e2, t2) {
          var r2, n2;
          if (void 0 === t2) return e2.size;
          var o2 = 0;
          try {
            for (var a2 = i(e2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
              var u = s2.value;
              t2.call(null, u) && o2++;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (n2 = a2.return) && n2.call(a2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          return o2;
        }, t.isEmpty = function(e2) {
          return 0 === e2.size;
        }, t.forEach = function(e2, t2) {
          var r2, o2, a2, s2, u, l;
          return n(this, function(n2) {
            switch (n2.label) {
              case 0:
                return void 0 !== t2 ? [3, 2] : [5, i(e2)];
              case 1:
                return n2.sent(), [3, 9];
              case 2:
                n2.trys.push([2, 7, 8, 9]), r2 = i(e2), o2 = r2.next(), n2.label = 3;
              case 3:
                return o2.done ? [3, 6] : (a2 = o2.value, t2.call(null, a2) ? [4, a2] : [3, 5]);
              case 4:
                n2.sent(), n2.label = 5;
              case 5:
                return o2 = r2.next(), [3, 3];
              case 6:
                return [3, 9];
              case 7:
                return s2 = n2.sent(), u = { error: s2 }, [3, 9];
              case 8:
                try {
                  o2 && !o2.done && (l = r2.return) && l.call(r2);
                } finally {
                  if (u) throw u.error;
                }
                return [7];
              case 9:
                return [2];
            }
          });
        }, t.clone = function(e2) {
          return new Map(e2);
        }, t.sortInAscendingOrder = function(e2, t2) {
          var r2 = new (Array.bind.apply(Array, a([void 0], e2)))();
          return r2.sort(function(e3, r3) {
            return t2.call(null, e3, r3) ? -1 : 1;
          }), new Map(r2);
        }, t.sortInDescendingOrder = function(e2, t2) {
          var r2 = new (Array.bind.apply(Array, a([void 0], e2)))();
          return r2.sort(function(e3, r3) {
            return t2.call(null, e3, r3) ? 1 : -1;
          }), new Map(r2);
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.HTML = "http://www.w3.org/1999/xhtml", t.XML = "http://www.w3.org/XML/1998/namespace", t.XMLNS = "http://www.w3.org/2000/xmlns/", t.MathML = "http://www.w3.org/1998/Math/MathML", t.SVG = "http://www.w3.org/2000/svg", t.XLink = "http://www.w3.org/1999/xlink";
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.enqueue = function(e2, t2) {
          e2.push(t2);
        }, t.dequeue = function(e2) {
          return e2.shift() || null;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, a2 = { label: 0, sent: function() {
            if (1 & i2[0]) throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function s2(o3) {
            return function(s3) {
              return function(o4) {
                if (r2) throw new TypeError("Generator is already executing.");
                for (; a2; ) try {
                  if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done) return i2;
                  switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                    case 0:
                    case 1:
                      i2 = o4;
                      break;
                    case 4:
                      return a2.label++, { value: o4[1], done: false };
                    case 5:
                      a2.label++, n2 = o4[1], o4 = [0];
                      continue;
                    case 7:
                      o4 = a2.ops.pop(), a2.trys.pop();
                      continue;
                    default:
                      if (!(i2 = a2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                        a2 = 0;
                        continue;
                      }
                      if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                        a2.label = o4[1];
                        break;
                      }
                      if (6 === o4[0] && a2.label < i2[1]) {
                        a2.label = i2[1], i2 = o4;
                        break;
                      }
                      if (i2 && a2.label < i2[2]) {
                        a2.label = i2[2], a2.ops.push(o4);
                        break;
                      }
                      i2[2] && a2.ops.pop(), a2.trys.pop();
                      continue;
                  }
                  o4 = t2.call(e2, a2);
                } catch (e3) {
                  o4 = [6, e3], n2 = 0;
                } finally {
                  r2 = i2 = 0;
                }
                if (5 & o4[0]) throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, s3]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, o = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, a = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++) e2 = e2.concat(o(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(1);
        function u(e2, t2) {
          var r2, n2;
          try {
            for (var o2 = i(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              var s2 = a2.value;
              if (!t2.has(s2)) return false;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          return true;
        }
        t.append = function(e2, t2) {
          e2.add(t2);
        }, t.extend = function(e2, t2) {
          t2.forEach(e2.add, e2);
        }, t.prepend = function(e2, t2) {
          var r2 = new Set(e2);
          e2.clear(), e2.add(t2), r2.forEach(e2.add, e2);
        }, t.replace = function(e2, t2, r2) {
          var n2, o2, a2 = /* @__PURE__ */ new Set();
          try {
            for (var u2 = i(e2), l = u2.next(); !l.done; l = u2.next()) {
              var c = l.value;
              s.isFunction(t2) ? t2.call(null, c) ? a2.add(r2) : a2.add(c) : c === t2 ? a2.add(r2) : a2.add(c);
            }
          } catch (e3) {
            n2 = { error: e3 };
          } finally {
            try {
              l && !l.done && (o2 = u2.return) && o2.call(u2);
            } finally {
              if (n2) throw n2.error;
            }
          }
          e2.clear(), a2.forEach(e2.add, e2);
        }, t.insert = function(e2, t2, r2) {
          var n2, o2, a2 = /* @__PURE__ */ new Set(), s2 = 0;
          try {
            for (var u2 = i(e2), l = u2.next(); !l.done; l = u2.next()) {
              var c = l.value;
              s2 === r2 && a2.add(t2), a2.add(c), s2++;
            }
          } catch (e3) {
            n2 = { error: e3 };
          } finally {
            try {
              l && !l.done && (o2 = u2.return) && o2.call(u2);
            } finally {
              if (n2) throw n2.error;
            }
          }
          e2.clear(), a2.forEach(e2.add, e2);
        }, t.remove = function(e2, t2) {
          var r2, n2, o2, a2;
          if (s.isFunction(t2)) {
            var u2 = [];
            try {
              for (var l = i(e2), c = l.next(); !c.done; c = l.next()) {
                var h = c.value;
                t2.call(null, h) && u2.push(h);
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                c && !c.done && (n2 = l.return) && n2.call(l);
              } finally {
                if (r2) throw r2.error;
              }
            }
            try {
              for (var p = i(u2), f = p.next(); !f.done; f = p.next()) {
                var d = f.value;
                e2.delete(d);
              }
            } catch (e3) {
              o2 = { error: e3 };
            } finally {
              try {
                f && !f.done && (a2 = p.return) && a2.call(p);
              } finally {
                if (o2) throw o2.error;
              }
            }
          } else e2.delete(t2);
        }, t.empty = function(e2) {
          e2.clear();
        }, t.contains = function(e2, t2) {
          var r2, n2;
          if (!s.isFunction(t2)) return e2.has(t2);
          try {
            for (var o2 = i(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              var u2 = a2.value;
              if (t2.call(null, u2)) return true;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          return false;
        }, t.size = function(e2, t2) {
          var r2, n2;
          if (void 0 === t2) return e2.size;
          var o2 = 0;
          try {
            for (var a2 = i(e2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
              var u2 = s2.value;
              t2.call(null, u2) && o2++;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (n2 = a2.return) && n2.call(a2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          return o2;
        }, t.isEmpty = function(e2) {
          return 0 === e2.size;
        }, t.forEach = function(e2, t2) {
          var r2, o2, a2, s2, u2, l;
          return n(this, function(n2) {
            switch (n2.label) {
              case 0:
                return void 0 !== t2 ? [3, 2] : [5, i(e2)];
              case 1:
                return n2.sent(), [3, 9];
              case 2:
                n2.trys.push([2, 7, 8, 9]), r2 = i(e2), o2 = r2.next(), n2.label = 3;
              case 3:
                return o2.done ? [3, 6] : (a2 = o2.value, t2.call(null, a2) ? [4, a2] : [3, 5]);
              case 4:
                n2.sent(), n2.label = 5;
              case 5:
                return o2 = r2.next(), [3, 3];
              case 6:
                return [3, 9];
              case 7:
                return s2 = n2.sent(), u2 = { error: s2 }, [3, 9];
              case 8:
                try {
                  o2 && !o2.done && (l = r2.return) && l.call(r2);
                } finally {
                  if (u2) throw u2.error;
                }
                return [7];
              case 9:
                return [2];
            }
          });
        }, t.clone = function(e2) {
          return new Set(e2);
        }, t.sortInAscendingOrder = function(e2, t2) {
          var r2 = new (Array.bind.apply(Array, a([void 0], e2)))();
          return r2.sort(function(e3, r3) {
            return t2.call(null, e3, r3) ? -1 : 1;
          }), new Set(r2);
        }, t.sortInDescendingOrder = function(e2, t2) {
          var r2 = new (Array.bind.apply(Array, a([void 0], e2)))();
          return r2.sort(function(e3, r3) {
            return t2.call(null, e3, r3) ? 1 : -1;
          }), new Set(r2);
        }, t.isSubsetOf = u, t.isSupersetOf = function(e2, t2) {
          return u(t2, e2);
        }, t.intersection = function(e2, t2) {
          var r2, n2, o2 = /* @__PURE__ */ new Set();
          try {
            for (var a2 = i(e2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
              var u2 = s2.value;
              t2.has(u2) && o2.add(u2);
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (n2 = a2.return) && n2.call(a2);
            } finally {
              if (r2) throw r2.error;
            }
          }
          return o2;
        }, t.union = function(e2, t2) {
          var r2 = new Set(e2);
          return t2.forEach(r2.add, r2), r2;
        }, t.range = function(e2, t2) {
          for (var r2 = /* @__PURE__ */ new Set(), n2 = e2; n2 <= t2; n2++) r2.add(n2);
          return r2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.push = function(e2, t2) {
          e2.push(t2);
        }, t.pop = function(e2) {
          return e2.pop() || null;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(96), o = r(147), a = r(146), s = r(1);
        function u(e2, t2) {
          for (var r2 = 0; ; ) {
            var n2 = r2 < e2.length ? e2.charCodeAt(r2) : null, i2 = r2 < t2.length ? t2.charCodeAt(r2) : null;
            if (null === n2) return true;
            if (n2 !== i2) return false;
            r2++;
          }
        }
        function l(e2) {
          var t2, r2, i2 = Array.from(e2), o2 = new Uint8Array(i2.length), a2 = 0;
          try {
            for (var s2 = n(e2), u2 = s2.next(); !u2.done; u2 = s2.next()) {
              var l2 = u2.value.codePointAt(0);
              console.assert(void 0 !== l2 && l2 <= 255, "isomorphicEncode requires string bytes to be less than or equal to 0x00FF."), void 0 !== l2 && l2 <= 255 && (o2[a2++] = l2);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              u2 && !u2.done && (r2 = s2.return) && r2.call(s2);
            } finally {
              if (t2) throw t2.error;
            }
          }
          return o2;
        }
        function c(e2) {
          return /^[\u0000-\u007F]*$/.test(e2);
        }
        function h(e2) {
          var t2, r2, i2 = "";
          try {
            for (var o2 = n(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              var s2 = a2.value, u2 = s2.codePointAt(0);
              i2 += void 0 !== u2 && u2 >= 65 && u2 <= 90 ? String.fromCodePoint(u2 + 32) : s2;
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (t2) throw t2.error;
            }
          }
          return i2;
        }
        function p(e2) {
          return e2.replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "");
        }
        function f(e2, t2, r2) {
          if (!s.isArray(t2)) return f(e2, Array.from(t2), r2);
          for (var n2 = ""; r2.position < t2.length && e2.call(null, t2[r2.position]); ) n2 += t2[r2.position], r2.position++;
          return n2;
        }
        function d(e2, t2) {
          f(function(e3) {
            return i.ASCIIWhiteSpace.test(e3);
          }, e2, t2);
        }
        t.isCodeUnitPrefix = u, t.isCodeUnitLessThan = function(e2, t2) {
          if (u(t2, e2)) return false;
          if (u(e2, t2)) return true;
          for (var r2 = 0; r2 < Math.min(e2.length, t2.length); r2++) {
            var n2 = e2.charCodeAt(r2), i2 = t2.charCodeAt(r2);
            if (n2 !== i2) return n2 < i2;
          }
          return false;
        }, t.isomorphicEncode = l, t.isASCIIString = c, t.asciiLowercase = h, t.asciiUppercase = function(e2) {
          var t2, r2, i2 = "";
          try {
            for (var o2 = n(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              var s2 = a2.value, u2 = s2.codePointAt(0);
              i2 += void 0 !== u2 && u2 >= 97 && u2 <= 122 ? String.fromCodePoint(u2 - 32) : s2;
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (t2) throw t2.error;
            }
          }
          return i2;
        }, t.asciiCaseInsensitiveMatch = function(e2, t2) {
          return h(e2) === h(t2);
        }, t.asciiEncode = function(e2) {
          return console.assert(c(e2), "asciiEncode requires an ASCII string."), l(e2);
        }, t.asciiDecode = function(e2) {
          var t2, r2;
          try {
            for (var i2 = n(e2), s2 = i2.next(); !s2.done; s2 = i2.next()) {
              var u2 = s2.value;
              console.assert(a.isASCIIByte(u2), "asciiDecode requires an ASCII byte sequence.");
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (r2 = i2.return) && r2.call(i2);
            } finally {
              if (t2) throw t2.error;
            }
          }
          return o.isomorphicDecode(e2);
        }, t.stripNewlines = function(e2) {
          return e2.replace(/[\n\r]/g, "");
        }, t.normalizeNewlines = function(e2) {
          return e2.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        }, t.stripLeadingAndTrailingASCIIWhitespace = p, t.stripAndCollapseASCIIWhitespace = function(e2) {
          return p(e2.replace(/[\t\n\f\r ]{2,}/g, " "));
        }, t.collectASequenceOfCodePoints = f, t.skipASCIIWhitespace = d, t.strictlySplit = function e2(t2, r2) {
          if (!s.isArray(t2)) return e2(Array.from(t2), r2);
          var n2 = { position: 0 }, i2 = [], o2 = f(function(e3) {
            return r2 !== e3;
          }, t2, n2);
          for (i2.push(o2); n2.position < t2.length; ) console.assert(t2[n2.position] === r2, "strictlySplit found no delimiter in input string."), n2.position++, o2 = f(function(e3) {
            return r2 !== e3;
          }, t2, n2), i2.push(o2);
          return i2;
        }, t.splitAStringOnASCIIWhitespace = function e2(t2) {
          if (!s.isArray(t2)) return e2(Array.from(t2));
          var r2 = { position: 0 }, n2 = [];
          for (d(t2, r2); r2.position < t2.length; ) {
            var o2 = f(function(e3) {
              return !i.ASCIIWhiteSpace.test(e3);
            }, t2, r2);
            n2.push(o2), d(t2, r2);
          }
          return n2;
        }, t.splitAStringOnCommas = function e2(t2) {
          if (!s.isArray(t2)) return e2(Array.from(t2));
          for (var r2 = { position: 0 }, n2 = []; r2.position < t2.length; ) {
            var i2 = f(function(e3) {
              return "," !== e3;
            }, t2, r2);
            n2.push(p(i2)), r2.position < t2.length && (console.assert("," === t2[r2.position], "splitAStringOnCommas found no delimiter in input string."), r2.position++);
          }
          return n2;
        }, t.concatenate = function(e2, t2) {
          return void 0 === t2 && (t2 = ""), 0 === e2.length ? "" : e2.join(t2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(97);
        t.abort_add = function(e2, t2) {
          t2._abortedFlag || t2._abortAlgorithms.add(e2);
        }, t.abort_remove = function(e2, t2) {
          t2._abortAlgorithms.delete(e2);
        }, t.abort_signalAbort = function(e2) {
          var t2, r2;
          if (!e2._abortedFlag) {
            e2._abortedFlag = true;
            try {
              for (var o = n(e2._abortAlgorithms), a = o.next(); !a.done; a = o.next()) {
                a.value.call(e2);
              }
            } catch (e3) {
              t2 = { error: e3 };
            } finally {
              try {
                a && !a.done && (r2 = o.return) && r2.call(o);
              } finally {
                if (t2) throw t2.error;
              }
            }
            e2._abortAlgorithms.clear(), i.event_fireAnEvent("abort", e2);
          }
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(150), i = function() {
          function e2() {
          }
          return e2.asNode = function(e3) {
            if (n.Guard.isNode(e3)) return e3;
            throw new Error("Invalid object. Node expected.");
          }, e2;
        }();
        t.Cast = i;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "size", { get: function() {
            return 0;
          }, enumerable: true, configurable: true }), e2.prototype.add = function(e3) {
            throw new Error("Cannot add to an empty set.");
          }, e2.prototype.clear = function() {
          }, e2.prototype.delete = function(e3) {
            return false;
          }, e2.prototype.forEach = function(e3, t2) {
          }, e2.prototype.has = function(e3) {
            return false;
          }, e2.prototype[Symbol.iterator] = function() {
            return new i();
          }, e2.prototype.entries = function() {
            return new i();
          }, e2.prototype.keys = function() {
            return new i();
          }, e2.prototype.values = function() {
            return new i();
          }, Object.defineProperty(e2.prototype, Symbol.toStringTag, { get: function() {
            return "EmptySet";
          }, enumerable: true, configurable: true }), e2;
        }();
        t.EmptySet = n;
        var i = function() {
          function e2() {
          }
          return e2.prototype[Symbol.iterator] = function() {
            return this;
          }, e2.prototype.next = function() {
            return { done: true, value: null };
          }, e2;
        }();
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), function(e2) {
          e2[e2.SchemeStart = 0] = "SchemeStart", e2[e2.Scheme = 1] = "Scheme", e2[e2.NoScheme = 2] = "NoScheme", e2[e2.SpecialRelativeOrAuthority = 3] = "SpecialRelativeOrAuthority", e2[e2.PathOrAuthority = 4] = "PathOrAuthority", e2[e2.Relative = 5] = "Relative", e2[e2.RelativeSlash = 6] = "RelativeSlash", e2[e2.SpecialAuthoritySlashes = 7] = "SpecialAuthoritySlashes", e2[e2.SpecialAuthorityIgnoreSlashes = 8] = "SpecialAuthorityIgnoreSlashes", e2[e2.Authority = 9] = "Authority", e2[e2.Host = 10] = "Host", e2[e2.Hostname = 11] = "Hostname", e2[e2.Port = 12] = "Port", e2[e2.File = 13] = "File", e2[e2.FileSlash = 14] = "FileSlash", e2[e2.FileHost = 15] = "FileHost", e2[e2.PathStart = 16] = "PathStart", e2[e2.Path = 17] = "Path", e2[e2.CannotBeABaseURLPath = 18] = "CannotBeABaseURLPath", e2[e2.Query = 19] = "Query", e2[e2.Fragment = 20] = "Fragment";
        }(t.ParserState || (t.ParserState = {})), t.OpaqueOrigin = ["", "", null, null];
      }, function(e, t, r) {
        "use strict";
        var n = r(245), i = r(247);
        function o() {
          this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
        }
        t.parse = g, t.resolve = function(e2, t2) {
          return g(e2, false, true).resolve(t2);
        }, t.resolveObject = function(e2, t2) {
          return e2 ? g(e2, false, true).resolveObject(t2) : t2;
        }, t.format = function(e2) {
          i.isString(e2) && (e2 = g(e2));
          return e2 instanceof o ? e2.format() : o.prototype.format.call(e2);
        }, t.Url = o;
        var a = /^([a-z0-9.+-]+:)/i, s = /:[0-9]*$/, u = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, l = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), c = ["'"].concat(l), h = ["%", "/", "?", ";", "#"].concat(c), p = ["/", "?", "#"], f = /^[+a-z0-9A-Z_-]{0,63}$/, d = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, m = { javascript: true, "javascript:": true }, y = { javascript: true, "javascript:": true }, v = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, _ = r(248);
        function g(e2, t2, r2) {
          if (e2 && i.isObject(e2) && e2 instanceof o) return e2;
          var n2 = new o();
          return n2.parse(e2, t2, r2), n2;
        }
        o.prototype.parse = function(e2, t2, r2) {
          if (!i.isString(e2)) throw new TypeError("Parameter 'url' must be a string, not " + typeof e2);
          var o2 = e2.indexOf("?"), s2 = -1 !== o2 && o2 < e2.indexOf("#") ? "?" : "#", l2 = e2.split(s2);
          l2[0] = l2[0].replace(/\\/g, "/");
          var g2 = e2 = l2.join(s2);
          if (g2 = g2.trim(), !r2 && 1 === e2.split("#").length) {
            var b = u.exec(g2);
            if (b) return this.path = g2, this.href = g2, this.pathname = b[1], b[2] ? (this.search = b[2], this.query = t2 ? _.parse(this.search.substr(1)) : this.search.substr(1)) : t2 && (this.search = "", this.query = {}), this;
          }
          var x = a.exec(g2);
          if (x) {
            var w = (x = x[0]).toLowerCase();
            this.protocol = w, g2 = g2.substr(x.length);
          }
          if (r2 || x || g2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var E = "//" === g2.substr(0, 2);
            !E || x && y[x] || (g2 = g2.substr(2), this.slashes = true);
          }
          if (!y[x] && (E || x && !v[x])) {
            for (var D, S, C = -1, A = 0; A < p.length; A++) {
              -1 !== (N = g2.indexOf(p[A])) && (-1 === C || N < C) && (C = N);
            }
            -1 !== (S = -1 === C ? g2.lastIndexOf("@") : g2.lastIndexOf("@", C)) && (D = g2.slice(0, S), g2 = g2.slice(S + 1), this.auth = decodeURIComponent(D)), C = -1;
            for (A = 0; A < h.length; A++) {
              var N;
              -1 !== (N = g2.indexOf(h[A])) && (-1 === C || N < C) && (C = N);
            }
            -1 === C && (C = g2.length), this.host = g2.slice(0, C), g2 = g2.slice(C), this.parseHost(), this.hostname = this.hostname || "";
            var T = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
            if (!T) for (var O = this.hostname.split(/\./), F = (A = 0, O.length); A < F; A++) {
              var k = O[A];
              if (k && !k.match(f)) {
                for (var P = "", I = 0, L = k.length; I < L; I++) k.charCodeAt(I) > 127 ? P += "x" : P += k[I];
                if (!P.match(f)) {
                  var M = O.slice(0, A), B = O.slice(A + 1), j = k.match(d);
                  j && (M.push(j[1]), B.unshift(j[2])), B.length && (g2 = "/" + B.join(".") + g2), this.hostname = M.join(".");
                  break;
                }
              }
            }
            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), T || (this.hostname = n.toASCII(this.hostname));
            var R = this.port ? ":" + this.port : "", z = this.hostname || "";
            this.host = z + R, this.href += this.host, T && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== g2[0] && (g2 = "/" + g2));
          }
          if (!m[w]) for (A = 0, F = c.length; A < F; A++) {
            var U = c[A];
            if (-1 !== g2.indexOf(U)) {
              var G = encodeURIComponent(U);
              G === U && (G = escape(U)), g2 = g2.split(U).join(G);
            }
          }
          var X = g2.indexOf("#");
          -1 !== X && (this.hash = g2.substr(X), g2 = g2.slice(0, X));
          var q = g2.indexOf("?");
          if (-1 !== q ? (this.search = g2.substr(q), this.query = g2.substr(q + 1), t2 && (this.query = _.parse(this.query)), g2 = g2.slice(0, q)) : t2 && (this.search = "", this.query = {}), g2 && (this.pathname = g2), v[w] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            R = this.pathname || "";
            var W = this.search || "";
            this.path = R + W;
          }
          return this.href = this.format(), this;
        }, o.prototype.format = function() {
          var e2 = this.auth || "";
          e2 && (e2 = (e2 = encodeURIComponent(e2)).replace(/%3A/i, ":"), e2 += "@");
          var t2 = this.protocol || "", r2 = this.pathname || "", n2 = this.hash || "", o2 = false, a2 = "";
          this.host ? o2 = e2 + this.host : this.hostname && (o2 = e2 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (o2 += ":" + this.port)), this.query && i.isObject(this.query) && Object.keys(this.query).length && (a2 = _.stringify(this.query));
          var s2 = this.search || a2 && "?" + a2 || "";
          return t2 && ":" !== t2.substr(-1) && (t2 += ":"), this.slashes || (!t2 || v[t2]) && false !== o2 ? (o2 = "//" + (o2 || ""), r2 && "/" !== r2.charAt(0) && (r2 = "/" + r2)) : o2 || (o2 = ""), n2 && "#" !== n2.charAt(0) && (n2 = "#" + n2), s2 && "?" !== s2.charAt(0) && (s2 = "?" + s2), t2 + o2 + (r2 = r2.replace(/[?#]/g, function(e3) {
            return encodeURIComponent(e3);
          })) + (s2 = s2.replace("#", "%23")) + n2;
        }, o.prototype.resolve = function(e2) {
          return this.resolveObject(g(e2, false, true)).format();
        }, o.prototype.resolveObject = function(e2) {
          if (i.isString(e2)) {
            var t2 = new o();
            t2.parse(e2, false, true), e2 = t2;
          }
          for (var r2 = new o(), n2 = Object.keys(this), a2 = 0; a2 < n2.length; a2++) {
            var s2 = n2[a2];
            r2[s2] = this[s2];
          }
          if (r2.hash = e2.hash, "" === e2.href) return r2.href = r2.format(), r2;
          if (e2.slashes && !e2.protocol) {
            for (var u2 = Object.keys(e2), l2 = 0; l2 < u2.length; l2++) {
              var c2 = u2[l2];
              "protocol" !== c2 && (r2[c2] = e2[c2]);
            }
            return v[r2.protocol] && r2.hostname && !r2.pathname && (r2.path = r2.pathname = "/"), r2.href = r2.format(), r2;
          }
          if (e2.protocol && e2.protocol !== r2.protocol) {
            if (!v[e2.protocol]) {
              for (var h2 = Object.keys(e2), p2 = 0; p2 < h2.length; p2++) {
                var f2 = h2[p2];
                r2[f2] = e2[f2];
              }
              return r2.href = r2.format(), r2;
            }
            if (r2.protocol = e2.protocol, e2.host || y[e2.protocol]) r2.pathname = e2.pathname;
            else {
              for (var d2 = (e2.pathname || "").split("/"); d2.length && !(e2.host = d2.shift()); ) ;
              e2.host || (e2.host = ""), e2.hostname || (e2.hostname = ""), "" !== d2[0] && d2.unshift(""), d2.length < 2 && d2.unshift(""), r2.pathname = d2.join("/");
            }
            if (r2.search = e2.search, r2.query = e2.query, r2.host = e2.host || "", r2.auth = e2.auth, r2.hostname = e2.hostname || e2.host, r2.port = e2.port, r2.pathname || r2.search) {
              var m2 = r2.pathname || "", _2 = r2.search || "";
              r2.path = m2 + _2;
            }
            return r2.slashes = r2.slashes || e2.slashes, r2.href = r2.format(), r2;
          }
          var g2 = r2.pathname && "/" === r2.pathname.charAt(0), b = e2.host || e2.pathname && "/" === e2.pathname.charAt(0), x = b || g2 || r2.host && e2.pathname, w = x, E = r2.pathname && r2.pathname.split("/") || [], D = (d2 = e2.pathname && e2.pathname.split("/") || [], r2.protocol && !v[r2.protocol]);
          if (D && (r2.hostname = "", r2.port = null, r2.host && ("" === E[0] ? E[0] = r2.host : E.unshift(r2.host)), r2.host = "", e2.protocol && (e2.hostname = null, e2.port = null, e2.host && ("" === d2[0] ? d2[0] = e2.host : d2.unshift(e2.host)), e2.host = null), x = x && ("" === d2[0] || "" === E[0])), b) r2.host = e2.host || "" === e2.host ? e2.host : r2.host, r2.hostname = e2.hostname || "" === e2.hostname ? e2.hostname : r2.hostname, r2.search = e2.search, r2.query = e2.query, E = d2;
          else if (d2.length) E || (E = []), E.pop(), E = E.concat(d2), r2.search = e2.search, r2.query = e2.query;
          else if (!i.isNullOrUndefined(e2.search)) {
            if (D) r2.hostname = r2.host = E.shift(), (T = !!(r2.host && r2.host.indexOf("@") > 0) && r2.host.split("@")) && (r2.auth = T.shift(), r2.host = r2.hostname = T.shift());
            return r2.search = e2.search, r2.query = e2.query, i.isNull(r2.pathname) && i.isNull(r2.search) || (r2.path = (r2.pathname ? r2.pathname : "") + (r2.search ? r2.search : "")), r2.href = r2.format(), r2;
          }
          if (!E.length) return r2.pathname = null, r2.search ? r2.path = "/" + r2.search : r2.path = null, r2.href = r2.format(), r2;
          for (var S = E.slice(-1)[0], C = (r2.host || e2.host || E.length > 1) && ("." === S || ".." === S) || "" === S, A = 0, N = E.length; N >= 0; N--) "." === (S = E[N]) ? E.splice(N, 1) : ".." === S ? (E.splice(N, 1), A++) : A && (E.splice(N, 1), A--);
          if (!x && !w) for (; A--; A) E.unshift("..");
          !x || "" === E[0] || E[0] && "/" === E[0].charAt(0) || E.unshift(""), C && "/" !== E.join("/").substr(-1) && E.push("");
          var T, O = "" === E[0] || E[0] && "/" === E[0].charAt(0);
          D && (r2.hostname = r2.host = O ? "" : E.length ? E.shift() : "", (T = !!(r2.host && r2.host.indexOf("@") > 0) && r2.host.split("@")) && (r2.auth = T.shift(), r2.host = r2.hostname = T.shift()));
          return (x = x || r2.host && E.length) && !O && E.unshift(""), E.length ? r2.pathname = E.join("/") : (r2.pathname = null, r2.path = null), i.isNull(r2.pathname) && i.isNull(r2.search) || (r2.path = (r2.pathname ? r2.pathname : "") + (r2.search ? r2.search : "")), r2.auth = e2.auth || r2.auth, r2.slashes = r2.slashes || e2.slashes, r2.href = r2.format(), r2;
        }, o.prototype.parseHost = function() {
          var e2 = this.host, t2 = s.exec(e2);
          t2 && (":" !== (t2 = t2[0]) && (this.port = t2.substr(1)), e2 = e2.substr(0, e2.length - t2.length)), e2 && (this.hostname = e2);
        };
      }, function(e, t, r) {
        (function(e2, n) {
          var i;
          !function(o) {
            t && t.nodeType, e2 && e2.nodeType;
            var a = "object" == typeof n && n;
            a.global !== a && a.window !== a && a.self;
            var s, u = 2147483647, l = /^xn--/, c = /[^\x20-\x7E]/, h = /[\x2E\u3002\uFF0E\uFF61]/g, p = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, f = Math.floor, d = String.fromCharCode;
            function m(e3) {
              throw new RangeError(p[e3]);
            }
            function y(e3, t2) {
              for (var r2 = e3.length, n2 = []; r2--; ) n2[r2] = t2(e3[r2]);
              return n2;
            }
            function v(e3, t2) {
              var r2 = e3.split("@"), n2 = "";
              return r2.length > 1 && (n2 = r2[0] + "@", e3 = r2[1]), n2 + y((e3 = e3.replace(h, ".")).split("."), t2).join(".");
            }
            function _(e3) {
              for (var t2, r2, n2 = [], i2 = 0, o2 = e3.length; i2 < o2; ) (t2 = e3.charCodeAt(i2++)) >= 55296 && t2 <= 56319 && i2 < o2 ? 56320 == (64512 & (r2 = e3.charCodeAt(i2++))) ? n2.push(((1023 & t2) << 10) + (1023 & r2) + 65536) : (n2.push(t2), i2--) : n2.push(t2);
              return n2;
            }
            function g(e3) {
              return y(e3, function(e4) {
                var t2 = "";
                return e4 > 65535 && (t2 += d((e4 -= 65536) >>> 10 & 1023 | 55296), e4 = 56320 | 1023 & e4), t2 += d(e4);
              }).join("");
            }
            function b(e3, t2) {
              return e3 + 22 + 75 * (e3 < 26) - ((0 != t2) << 5);
            }
            function x(e3, t2, r2) {
              var n2 = 0;
              for (e3 = r2 ? f(e3 / 700) : e3 >> 1, e3 += f(e3 / t2); e3 > 455; n2 += 36) e3 = f(e3 / 35);
              return f(n2 + 36 * e3 / (e3 + 38));
            }
            function w(e3) {
              var t2, r2, n2, i2, o2, a2, s2, l2, c2, h2, p2, d2 = [], y2 = e3.length, v2 = 0, _2 = 128, b3 = 72;
              for ((r2 = e3.lastIndexOf("-")) < 0 && (r2 = 0), n2 = 0; n2 < r2; ++n2) e3.charCodeAt(n2) >= 128 && m("not-basic"), d2.push(e3.charCodeAt(n2));
              for (i2 = r2 > 0 ? r2 + 1 : 0; i2 < y2; ) {
                for (o2 = v2, a2 = 1, s2 = 36; i2 >= y2 && m("invalid-input"), ((l2 = (p2 = e3.charCodeAt(i2++)) - 48 < 10 ? p2 - 22 : p2 - 65 < 26 ? p2 - 65 : p2 - 97 < 26 ? p2 - 97 : 36) >= 36 || l2 > f((u - v2) / a2)) && m("overflow"), v2 += l2 * a2, !(l2 < (c2 = s2 <= b3 ? 1 : s2 >= b3 + 26 ? 26 : s2 - b3)); s2 += 36) a2 > f(u / (h2 = 36 - c2)) && m("overflow"), a2 *= h2;
                b3 = x(v2 - o2, t2 = d2.length + 1, 0 == o2), f(v2 / t2) > u - _2 && m("overflow"), _2 += f(v2 / t2), v2 %= t2, d2.splice(v2++, 0, _2);
              }
              return g(d2);
            }
            function E(e3) {
              var t2, r2, n2, i2, o2, a2, s2, l2, c2, h2, p2, y2, v2, g2, w2, E2 = [];
              for (y2 = (e3 = _(e3)).length, t2 = 128, r2 = 0, o2 = 72, a2 = 0; a2 < y2; ++a2) (p2 = e3[a2]) < 128 && E2.push(d(p2));
              for (n2 = i2 = E2.length, i2 && E2.push("-"); n2 < y2; ) {
                for (s2 = u, a2 = 0; a2 < y2; ++a2) (p2 = e3[a2]) >= t2 && p2 < s2 && (s2 = p2);
                for (s2 - t2 > f((u - r2) / (v2 = n2 + 1)) && m("overflow"), r2 += (s2 - t2) * v2, t2 = s2, a2 = 0; a2 < y2; ++a2) if ((p2 = e3[a2]) < t2 && ++r2 > u && m("overflow"), p2 == t2) {
                  for (l2 = r2, c2 = 36; !(l2 < (h2 = c2 <= o2 ? 1 : c2 >= o2 + 26 ? 26 : c2 - o2)); c2 += 36) w2 = l2 - h2, g2 = 36 - h2, E2.push(d(b(h2 + w2 % g2, 0))), l2 = f(w2 / g2);
                  E2.push(d(b(l2, 0))), o2 = x(r2, v2, n2 == i2), r2 = 0, ++n2;
                }
                ++r2, ++t2;
              }
              return E2.join("");
            }
            s = { version: "1.4.1", ucs2: { decode: _, encode: g }, decode: w, encode: E, toASCII: function(e3) {
              return v(e3, function(e4) {
                return c.test(e4) ? "xn--" + E(e4) : e4;
              });
            }, toUnicode: function(e3) {
              return v(e3, function(e4) {
                return l.test(e4) ? w(e4.slice(4).toLowerCase()) : e4;
              });
            } }, void 0 === (i = (function() {
              return s;
            }).call(t, r, t, e2)) || (e2.exports = i);
          }();
        }).call(this, r(246)(e), r(78));
      }, function(e, t) {
        e.exports = function(e2) {
          return e2.webpackPolyfill || (e2.deprecate = function() {
          }, e2.paths = [], e2.children || (e2.children = []), Object.defineProperty(e2, "loaded", { enumerable: true, get: function() {
            return e2.l;
          } }), Object.defineProperty(e2, "id", { enumerable: true, get: function() {
            return e2.i;
          } }), e2.webpackPolyfill = 1), e2;
        };
      }, function(e, t, r) {
        "use strict";
        e.exports = { isString: function(e2) {
          return "string" == typeof e2;
        }, isObject: function(e2) {
          return "object" == typeof e2 && null !== e2;
        }, isNull: function(e2) {
          return null === e2;
        }, isNullOrUndefined: function(e2) {
          return null == e2;
        } };
      }, function(e, t, r) {
        "use strict";
        t.decode = t.parse = r(249), t.encode = t.stringify = r(250);
      }, function(e, t, r) {
        "use strict";
        function n(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }
        e.exports = function(e2, t2, r2, o) {
          t2 = t2 || "&", r2 = r2 || "=";
          var a = {};
          if ("string" != typeof e2 || 0 === e2.length) return a;
          var s = /\+/g;
          e2 = e2.split(t2);
          var u = 1e3;
          o && "number" == typeof o.maxKeys && (u = o.maxKeys);
          var l = e2.length;
          u > 0 && l > u && (l = u);
          for (var c = 0; c < l; ++c) {
            var h, p, f, d, m = e2[c].replace(s, "%20"), y = m.indexOf(r2);
            y >= 0 ? (h = m.substr(0, y), p = m.substr(y + 1)) : (h = m, p = ""), f = decodeURIComponent(h), d = decodeURIComponent(p), n(a, f) ? i(a[f]) ? a[f].push(d) : a[f] = [a[f], d] : a[f] = d;
          }
          return a;
        };
        var i = Array.isArray || function(e2) {
          return "[object Array]" === Object.prototype.toString.call(e2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = function(e2) {
          switch (typeof e2) {
            case "string":
              return e2;
            case "boolean":
              return e2 ? "true" : "false";
            case "number":
              return isFinite(e2) ? e2 : "";
            default:
              return "";
          }
        };
        e.exports = function(e2, t2, r2, s) {
          return t2 = t2 || "&", r2 = r2 || "=", null === e2 && (e2 = void 0), "object" == typeof e2 ? o(a(e2), function(a2) {
            var s2 = encodeURIComponent(n(a2)) + r2;
            return i(e2[a2]) ? o(e2[a2], function(e3) {
              return s2 + encodeURIComponent(n(e3));
            }).join(t2) : s2 + encodeURIComponent(n(e2[a2]));
          }).join(t2) : s ? encodeURIComponent(n(s)) + r2 + encodeURIComponent(n(e2)) : "";
        };
        var i = Array.isArray || function(e2) {
          return "[object Array]" === Object.prototype.toString.call(e2);
        };
        function o(e2, t2) {
          if (e2.map) return e2.map(t2);
          for (var r2 = [], n2 = 0; n2 < e2.length; n2++) r2.push(t2(e2[n2], n2));
          return r2;
        }
        var a = Object.keys || function(e2) {
          var t2 = [];
          for (var r2 in e2) Object.prototype.hasOwnProperty.call(e2, r2) && t2.push(r2);
          return t2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(52);
        t.attr_setAnExistingAttributeValue = function(e2, t2) {
          null === e2._element ? e2._value = t2 : n.element_change(e2, e2._element, t2);
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(108), i = r(30), o = r(52);
        t.tokenList_validationSteps = function(e2, t2) {
          if (!i.dom_hasSupportedTokens(e2._attribute._localName)) throw new TypeError("There are no supported tokens defined for attribute name: '" + e2._attribute._localName + "'.");
          return i.dom_getSupportedTokens(e2._attribute._localName).has(t2.toLowerCase());
        }, t.tokenList_updateSteps = function(e2) {
          (e2._element.hasAttribute(e2._attribute._localName) || 0 !== e2._tokenSet.size) && o.element_setAnAttributeValue(e2._element, e2._attribute._localName, n.orderedSet_serialize(e2._tokenSet));
        }, t.tokenList_serializeSteps = function(e2) {
          return o.element_getAnAttributeValue(e2._element, e2._attribute._localName);
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(1);
        function o(e2) {
          return i.isBoolean(e2) ? e2 : e2.capture || false;
        }
        t.eventTarget_flatten = o, t.eventTarget_flattenMore = function(e2) {
          var t2 = o(e2), r2 = false, n2 = false;
          return i.isBoolean(e2) || (r2 = e2.once || false, n2 = e2.passive || false), [t2, n2, r2];
        }, t.eventTarget_addEventListener = function(e2, t2) {
          if (null !== t2.callback) {
            for (var r2 = 0; r2 < e2._eventListenerList.length; r2++) {
              var n2 = e2._eventListenerList[r2];
              if (n2.type === t2.type && n2.callback.handleEvent === t2.callback.handleEvent && n2.capture === t2.capture) return;
            }
            e2._eventListenerList.push(t2);
          }
        }, t.eventTarget_removeEventListener = function(e2, t2, r2) {
          t2.removed = true, e2._eventListenerList.splice(r2, 1);
        }, t.eventTarget_removeAllEventListeners = function(e2) {
          var t2, r2;
          try {
            for (var i2 = n(e2._eventListenerList), o2 = i2.next(); !o2.done; o2 = i2.next()) {
              o2.value.removed = true;
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              o2 && !o2.done && (r2 = i2.return) && r2.call(i2);
            } finally {
              if (t2) throw t2.error;
            }
          }
          e2._eventListenerList.length = 0;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(1), o = r(29);
        t.parentNode_convertNodesIntoANode = function(e2, t2) {
          for (var r2, a, s = null, u = 0; u < e2.length; u++) {
            var l = e2[u];
            if (i.isString(l)) {
              var c = o.create_text(t2, l);
              e2[u] = c;
            }
          }
          if (1 === e2.length) s = e2[0];
          else {
            var h = s = o.create_documentFragment(t2);
            try {
              for (var p = n(e2), f = p.next(); !f.done; f = p.next()) {
                l = f.value;
                h.appendChild(l);
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                f && !f.done && (a = p.return) && a.call(p);
              } finally {
                if (r2) throw r2.error;
              }
            }
          }
          return s;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++) e2 = e2.concat(i(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(2), s = r(9), u = r(3), l = r(29), c = r(17), h = r(175), p = r(107), f = r(176), d = r(37), m = r(177);
        function y(e2) {
          return e2._startNode === e2._endNode && e2._startOffset === e2._endOffset;
        }
        function v(e2) {
          return c.tree_rootNode(e2._startNode);
        }
        function _(e2, t2) {
          return c.tree_rootNode(e2) === v(t2) && h.boundaryPoint_position([e2, 0], t2._start) === a.BoundaryPosition.After && h.boundaryPoint_position([e2, c.tree_nodeLength(e2)], t2._end) === a.BoundaryPosition.Before;
        }
        function g(e2, t2) {
          var r2 = c.tree_isAncestorOf(t2._startNode, e2, true), n2 = c.tree_isAncestorOf(t2._endNode, e2, true);
          return r2 && !n2 || !r2 && n2;
        }
        function b(e2) {
          var t2, r2, i2, a2, h2, m2, v2 = l.create_documentFragment(e2._startNode._nodeDocument);
          if (y(e2)) return v2;
          var x = e2._startNode, w = e2._startOffset, E = e2._endNode, D = e2._endOffset;
          if (x === E && u.Guard.isCharacterDataNode(x)) return (R = f.node_clone(x))._data = p.characterData_substringData(x, w, D - w), d.mutation_append(R, v2), p.characterData_replaceData(x, w, D - w, ""), v2;
          for (var S = x; !c.tree_isAncestorOf(E, S, true); ) {
            if (null === S._parent) throw new Error("Parent node  is null.");
            S = S._parent;
          }
          var C = null;
          if (!c.tree_isAncestorOf(E, x, true)) try {
            for (var A = n(S._children), N = A.next(); !N.done; N = A.next()) {
              if (g(k = N.value, e2)) {
                C = k;
                break;
              }
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              N && !N.done && (r2 = A.return) && r2.call(A);
            } finally {
              if (t2) throw t2.error;
            }
          }
          var T = null;
          if (!c.tree_isAncestorOf(x, E, true)) for (var O = o(S._children), F = O.length - 1; F > 0; F--) {
            var k;
            if (g(k = O[F], e2)) {
              T = k;
              break;
            }
          }
          var P, I, L = [];
          try {
            for (var M = n(S._children), B = M.next(); !B.done; B = M.next()) {
              if (_(X = B.value, e2)) {
                if (u.Guard.isDocumentTypeNode(X)) throw new s.HierarchyRequestError();
                L.push(X);
              }
            }
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              B && !B.done && (a2 = M.return) && a2.call(M);
            } finally {
              if (i2) throw i2.error;
            }
          }
          if (c.tree_isAncestorOf(E, x, true)) P = x, I = w;
          else {
            for (var j = x; null !== j._parent && !c.tree_isAncestorOf(E, j._parent); ) j = j._parent;
            if (null === j._parent) throw new Error("Parent node is null.");
            P = j._parent, I = 1 + c.tree_index(j);
          }
          if (u.Guard.isCharacterDataNode(C)) (R = f.node_clone(x))._data = p.characterData_substringData(x, w, c.tree_nodeLength(x) - w), d.mutation_append(R, v2), p.characterData_replaceData(x, w, c.tree_nodeLength(x) - w, "");
          else if (null !== C) {
            var R = f.node_clone(C);
            d.mutation_append(R, v2);
            var z = b(l.create_range([x, w], [C, c.tree_nodeLength(C)]));
            d.mutation_append(z, R);
          }
          try {
            for (var U = n(L), G = U.next(); !G.done; G = U.next()) {
              var X = G.value;
              d.mutation_append(X, v2);
            }
          } catch (e3) {
            h2 = { error: e3 };
          } finally {
            try {
              G && !G.done && (m2 = U.return) && m2.call(U);
            } finally {
              if (h2) throw h2.error;
            }
          }
          if (u.Guard.isCharacterDataNode(T)) (R = f.node_clone(E))._data = p.characterData_substringData(E, 0, D), d.mutation_append(R, v2), p.characterData_replaceData(E, 0, D, "");
          else if (null !== T) {
            R = f.node_clone(T);
            d.mutation_append(R, v2);
            z = b(l.create_range([T, 0], [E, D]));
            d.mutation_append(z, R);
          }
          return e2._start = [P, I], e2._end = [P, I], v2;
        }
        t.range_collapsed = y, t.range_root = v, t.range_isContained = _, t.range_isPartiallyContained = g, t.range_setTheStart = function(e2, t2, r2) {
          if (u.Guard.isDocumentTypeNode(t2)) throw new s.InvalidNodeTypeError();
          if (r2 > c.tree_nodeLength(t2)) throw new s.IndexSizeError();
          var n2 = [t2, r2];
          v(e2) === c.tree_rootNode(t2) && h.boundaryPoint_position(n2, e2._end) !== a.BoundaryPosition.After || (e2._end = n2), e2._start = n2;
        }, t.range_setTheEnd = function(e2, t2, r2) {
          if (u.Guard.isDocumentTypeNode(t2)) throw new s.InvalidNodeTypeError();
          if (r2 > c.tree_nodeLength(t2)) throw new s.IndexSizeError();
          var n2 = [t2, r2];
          v(e2) === c.tree_rootNode(t2) && h.boundaryPoint_position(n2, e2._start) !== a.BoundaryPosition.Before || (e2._start = n2), e2._end = n2;
        }, t.range_select = function(e2, t2) {
          var r2 = e2._parent;
          if (null === r2) throw new s.InvalidNodeTypeError();
          var n2 = c.tree_index(e2);
          t2._start = [r2, n2], t2._end = [r2, n2 + 1];
        }, t.range_extract = b, t.range_cloneTheContents = function e2(t2) {
          var r2, i2, a2, h2, m2, v2, x = l.create_documentFragment(t2._startNode._nodeDocument);
          if (y(t2)) return x;
          var w = t2._startNode, E = t2._startOffset, D = t2._endNode, S = t2._endOffset;
          w === D && u.Guard.isCharacterDataNode(w) && ((B = f.node_clone(w))._data = p.characterData_substringData(w, E, S - E), d.mutation_append(B, x));
          for (var C = w; !c.tree_isAncestorOf(D, C, true); ) {
            if (null === C._parent) throw new Error("Parent node  is null.");
            C = C._parent;
          }
          var A = null;
          if (!c.tree_isAncestorOf(D, w, true)) try {
            for (var N = n(C._children), T = N.next(); !T.done; T = N.next()) {
              if (g(P = T.value, t2)) {
                A = P;
                break;
              }
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              T && !T.done && (i2 = N.return) && i2.call(N);
            } finally {
              if (r2) throw r2.error;
            }
          }
          var O = null;
          if (!c.tree_isAncestorOf(w, D, true)) for (var F = o(C._children), k = F.length - 1; k > 0; k--) {
            var P;
            if (g(P = F[k], t2)) {
              O = P;
              break;
            }
          }
          var I = [];
          try {
            for (var L = n(C._children), M = L.next(); !M.done; M = L.next()) {
              if (_(U = M.value, t2)) {
                if (u.Guard.isDocumentTypeNode(U)) throw new s.HierarchyRequestError();
                I.push(U);
              }
            }
          } catch (e3) {
            a2 = { error: e3 };
          } finally {
            try {
              M && !M.done && (h2 = L.return) && h2.call(L);
            } finally {
              if (a2) throw a2.error;
            }
          }
          if (u.Guard.isCharacterDataNode(A)) (B = f.node_clone(w))._data = p.characterData_substringData(w, E, c.tree_nodeLength(w) - E), d.mutation_append(B, x);
          else if (null !== A) {
            var B = f.node_clone(A);
            d.mutation_append(B, x);
            var j = e2(l.create_range([w, E], [A, c.tree_nodeLength(A)]));
            d.mutation_append(j, B);
          }
          try {
            for (var R = n(I), z = R.next(); !z.done; z = R.next()) {
              var U = z.value, B = f.node_clone(U);
              d.mutation_append(B, x);
            }
          } catch (e3) {
            m2 = { error: e3 };
          } finally {
            try {
              z && !z.done && (v2 = R.return) && v2.call(R);
            } finally {
              if (m2) throw m2.error;
            }
          }
          if (u.Guard.isCharacterDataNode(O)) (B = f.node_clone(D))._data = p.characterData_substringData(D, 0, S), d.mutation_append(B, x);
          else if (null !== O) {
            B = f.node_clone(O);
            x.append(B);
            j = b(l.create_range([O, 0], [D, S]));
            d.mutation_append(j, B);
          }
          return x;
        }, t.range_insert = function(e2, t2) {
          var r2, i2;
          if (u.Guard.isProcessingInstructionNode(t2._startNode) || u.Guard.isCommentNode(t2._startNode) || u.Guard.isTextNode(t2._startNode) && null === t2._startNode._parent || t2._startNode === e2) throw new s.HierarchyRequestError();
          var o2, a2 = null;
          if (u.Guard.isTextNode(t2._startNode)) a2 = t2._startNode;
          else {
            var l2 = 0;
            try {
              for (var h2 = n(t2._startNode._children), p2 = h2.next(); !p2.done; p2 = h2.next()) {
                var f2 = p2.value;
                if (l2 === t2._startOffset) {
                  a2 = f2;
                  break;
                }
                l2++;
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                p2 && !p2.done && (i2 = h2.return) && i2.call(h2);
              } finally {
                if (r2) throw r2.error;
              }
            }
          }
          if (null === a2) o2 = t2._startNode;
          else {
            if (null === a2._parent) throw new Error("Parent node is null.");
            o2 = a2._parent;
          }
          d.mutation_ensurePreInsertionValidity(e2, o2, a2), u.Guard.isTextNode(t2._startNode) && (a2 = m.text_split(t2._startNode, t2._startOffset)), e2 === a2 && (a2 = e2._nextSibling), null !== e2._parent && d.mutation_remove(e2, e2._parent);
          var v2 = null === a2 ? c.tree_nodeLength(o2) : c.tree_index(a2);
          u.Guard.isDocumentFragmentNode(e2) ? v2 += c.tree_nodeLength(e2) : v2++, d.mutation_preInsert(e2, o2, a2), y(t2) && (t2._end = [o2, v2]);
        }, t.range_getContainedNodes = function(e2) {
          var t2;
          return (t2 = {})[Symbol.iterator] = function() {
            var t3 = e2.commonAncestorContainer, r2 = c.tree_getFirstDescendantNode(t3);
            return { next: function() {
              for (; r2 && !_(r2, e2); ) r2 = c.tree_getNextDescendantNode(t3, r2);
              if (null === r2) return { done: true, value: null };
              var n2 = { done: false, value: r2 };
              return r2 = c.tree_getNextDescendantNode(t3, r2), n2;
            } };
          }, t2;
        }, t.range_getPartiallyContainedNodes = function(e2) {
          var t2;
          return (t2 = {})[Symbol.iterator] = function() {
            var t3 = e2.commonAncestorContainer, r2 = c.tree_getFirstDescendantNode(t3);
            return { next: function() {
              for (; r2 && !g(r2, e2); ) r2 = c.tree_getNextDescendantNode(t3, r2);
              if (null === r2) return { done: true, value: null };
              var n2 = { done: false, value: r2 };
              return r2 = c.tree_getNextDescendantNode(t3, r2), n2;
            } };
          }, t2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(9);
        t.selectors_scopeMatchASelectorsString = function(e2, t2) {
          throw new n.NotSupportedError();
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(2), i = r(105);
        t.treeWalker_traverseChildren = function(e2, t2) {
          for (var r2 = t2 ? e2._current._firstChild : e2._current._lastChild; null !== r2; ) {
            var o = i.traversal_filter(e2, r2);
            if (o === n.FilterResult.Accept) return e2._current = r2, r2;
            if (o === n.FilterResult.Skip) {
              var a = t2 ? r2._firstChild : r2._lastChild;
              if (null !== a) {
                r2 = a;
                continue;
              }
            }
            for (; null !== r2; ) {
              var s = t2 ? r2._nextSibling : r2._previousSibling;
              if (null !== s) {
                r2 = s;
                break;
              }
              var u = r2._parent;
              if (null === u || u === e2._root || u === e2._current) return null;
              r2 = u;
            }
          }
          return null;
        }, t.treeWalker_traverseSiblings = function(e2, t2) {
          var r2 = e2._current;
          if (r2 === e2._root) return null;
          for (; ; ) {
            for (var o = t2 ? r2._nextSibling : r2._previousSibling; null !== o; ) {
              r2 = o;
              var a = i.traversal_filter(e2, r2);
              if (a === n.FilterResult.Accept) return e2._current = r2, r2;
              o = t2 ? r2._firstChild : r2._lastChild, a !== n.FilterResult.Reject && null !== o || (o = t2 ? r2._nextSibling : r2._previousSibling);
            }
            if (null === (r2 = r2._parent) || r2 === e2._root) return null;
            if (i.traversal_filter(e2, r2) === n.FilterResult.Accept) return null;
          }
        };
      }, function(e, t, r) {
        "use strict";
        r(89), r(74);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(1), a = r(2), s = r(50), u = r(3), l = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            return n2._indentation = {}, n2._lengthToLastNewline = 0, n2._writerOptions = o.applyDefaults(r2, { wellFormed: false, headless: false, prettyPrint: false, indent: "  ", newline: "\n", offset: 0, width: 0, allowEmptyTags: false, indentTextOnlyNodes: false, spaceBeforeSlash: false }), n2;
          }
          return i(t2, e2), t2.prototype.serialize = function(e3) {
            return this._refs = { suppressPretty: false, emptyNode: false, markup: "" }, e3.nodeType !== a.NodeType.Document || this._writerOptions.headless || this.declaration(this._builderOptions.version, this._builderOptions.encoding, this._builderOptions.standalone), this.serializeNode(e3, this._writerOptions.wellFormed), this._writerOptions.prettyPrint && this._refs.markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline && (this._refs.markup = this._refs.markup.slice(0, -this._writerOptions.newline.length)), this._refs.markup;
          }, t2.prototype.declaration = function(e3, t3, r2) {
            this._beginLine(), this._refs.markup += '<?xml version="' + e3 + '"', void 0 !== t3 && (this._refs.markup += ' encoding="' + t3 + '"'), void 0 !== r2 && (this._refs.markup += ' standalone="' + (r2 ? "yes" : "no") + '"'), this._refs.markup += "?>", this._endLine();
          }, t2.prototype.docType = function(e3, t3, r2) {
            this._beginLine(), this._refs.markup += t3 && r2 ? "<!DOCTYPE " + e3 + ' PUBLIC "' + t3 + '" "' + r2 + '">' : t3 ? "<!DOCTYPE " + e3 + ' PUBLIC "' + t3 + '">' : r2 ? "<!DOCTYPE " + e3 + ' SYSTEM "' + r2 + '">' : "<!DOCTYPE " + e3 + ">", this._endLine();
          }, t2.prototype.openTagBegin = function(e3) {
            this._beginLine(), this._refs.markup += "<" + e3;
          }, t2.prototype.openTagEnd = function(e3, t3, r2) {
            if (this._refs.suppressPretty = false, this._refs.emptyNode = false, this._writerOptions.prettyPrint && !t3 && !r2) {
              for (var n2 = true, i2 = true, o2 = this.currentNode.firstChild, a2 = 0, s2 = 0; o2; ) {
                if (u.Guard.isExclusiveTextNode(o2)) s2++;
                else {
                  if (!u.Guard.isCDATASectionNode(o2)) {
                    n2 = false, i2 = false;
                    break;
                  }
                  a2++;
                }
                "" !== o2.data && (i2 = false), o2 = o2.nextSibling;
              }
              this._refs.suppressPretty = !this._writerOptions.indentTextOnlyNodes && n2 && (a2 <= 1 && 0 === s2 || 0 === a2), this._refs.emptyNode = i2;
            }
            (r2 || t3 || this._refs.emptyNode) && this._writerOptions.allowEmptyTags ? this._refs.markup += "></" + e3 + ">" : this._refs.markup += r2 ? " />" : t3 || this._refs.emptyNode ? this._writerOptions.spaceBeforeSlash ? " />" : "/>" : ">", this._endLine();
          }, t2.prototype.closeTag = function(e3) {
            this._refs.emptyNode || (this._beginLine(), this._refs.markup += "</" + e3 + ">"), this._refs.suppressPretty = false, this._refs.emptyNode = false, this._endLine();
          }, t2.prototype.attribute = function(e3, t3) {
            var r2 = e3 + '="' + t3 + '"';
            this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._refs.markup.length - this._lengthToLastNewline + 1 + r2.length > this._writerOptions.width ? (this._endLine(), this._beginLine(), this._refs.markup += this._indent(1) + r2) : this._refs.markup += " " + r2;
          }, t2.prototype.text = function(e3) {
            "" !== e3 && (this._beginLine(), this._refs.markup += e3, this._endLine());
          }, t2.prototype.cdata = function(e3) {
            "" !== e3 && (this._beginLine(), this._refs.markup += "<![CDATA[" + e3 + "]]>", this._endLine());
          }, t2.prototype.comment = function(e3) {
            this._beginLine(), this._refs.markup += "<!--" + e3 + "-->", this._endLine();
          }, t2.prototype.instruction = function(e3, t3) {
            this._beginLine(), this._refs.markup += "<?" + ("" === t3 ? e3 : e3 + " " + t3) + "?>", this._endLine();
          }, t2.prototype._beginLine = function() {
            this._writerOptions.prettyPrint && !this._refs.suppressPretty && (this._refs.markup += this._indent(this._writerOptions.offset + this.level));
          }, t2.prototype._endLine = function() {
            this._writerOptions.prettyPrint && !this._refs.suppressPretty && (this._refs.markup += this._writerOptions.newline, this._lengthToLastNewline = this._refs.markup.length);
          }, t2.prototype._indent = function(e3) {
            if (e3 <= 0) return "";
            if (void 0 !== this._indentation[e3]) return this._indentation[e3];
            var t3 = this._writerOptions.indent.repeat(e3);
            return this._indentation[e3] = t3, t3;
          }, t2;
        }(s.BaseWriter);
        t.XMLWriter = l;
      }, function(e, t, r) {
        "use strict";
        var n = r(47), i = r(35);
        e.exports = "".repeat || function(e2) {
          var t2 = String(i(this)), r2 = "", o = n(e2);
          if (o < 0 || o == 1 / 0) throw RangeError("Wrong number of repetitions");
          for (; o > 0; (o >>>= 1) && (t2 += t2)) 1 & o && (r2 += t2);
          return r2;
        };
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(19), r(178), r(20), r(22), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(67), s = r(1), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            return n2._writerOptions = s.applyDefaults(r2, { wellFormed: false, prettyPrint: false, indent: "  ", newline: "\n", offset: 0, group: false, verbose: false }), n2;
          }
          return i(t2, e2), t2.prototype.serialize = function(e3) {
            var t3 = s.applyDefaults(this._writerOptions, { format: "object", wellFormed: false }), r2 = new a.ObjectWriter(this._builderOptions, t3).serialize(e3);
            return this._beginLine(this._writerOptions, 0) + this._convertObject(r2, this._writerOptions);
          }, t2.prototype._convertObject = function(e3, t3, r2) {
            var n2, i2, a2 = this;
            void 0 === r2 && (r2 = 0);
            var u2 = "", l = this._isLeafNode(e3);
            if (s.isArray(e3)) {
              u2 += "[";
              var c = e3.length, h = 0;
              try {
                for (var p = o(e3), f = p.next(); !f.done; f = p.next()) {
                  var d = f.value;
                  u2 += this._endLine(t3, r2 + 1) + this._beginLine(t3, r2 + 1) + this._convertObject(d, t3, r2 + 1), h < c - 1 && (u2 += ","), h++;
                }
              } catch (e4) {
                n2 = { error: e4 };
              } finally {
                try {
                  f && !f.done && (i2 = p.return) && i2.call(p);
                } finally {
                  if (n2) throw n2.error;
                }
              }
              u2 += this._endLine(t3, r2) + this._beginLine(t3, r2), u2 += "]";
            } else if (s.isObject(e3)) {
              u2 += "{";
              var m = s.objectLength(e3), y = 0;
              s.forEachObject(e3, function(e4, n3) {
                l && t3.prettyPrint ? u2 += " " : u2 += a2._endLine(t3, r2 + 1) + a2._beginLine(t3, r2 + 1), u2 += a2._key(e4), t3.prettyPrint && (u2 += " "), u2 += a2._convertObject(n3, t3, r2 + 1), y < m - 1 && (u2 += ","), y++;
              }, this), l && t3.prettyPrint ? u2 += " " : u2 += this._endLine(t3, r2) + this._beginLine(t3, r2), u2 += "}";
            } else u2 += this._val(e3);
            return u2;
          }, t2.prototype._beginLine = function(e3, t3) {
            if (!e3.prettyPrint) return "";
            var r2 = e3.offset + t3 + 1;
            return r2 > 0 ? new Array(r2).join(e3.indent) : "";
          }, t2.prototype._endLine = function(e3, t3) {
            return e3.prettyPrint ? e3.newline : "";
          }, t2.prototype._key = function(e3) {
            return '"' + e3 + '":';
          }, t2.prototype._val = function(e3) {
            return JSON.stringify(e3);
          }, t2.prototype._isLeafNode = function(e3) {
            return this._descendantCount(e3) <= 1;
          }, t2.prototype._descendantCount = function(e3, t3) {
            var r2 = this;
            return void 0 === t3 && (t3 = 0), s.isArray(e3) ? s.forEachArray(e3, function(e4) {
              return t3 += r2._descendantCount(e4, t3);
            }, this) : s.isObject(e3) ? s.forEachObject(e3, function(e4, n2) {
              return t3 += r2._descendantCount(n2, t3);
            }, this) : t3++, t3;
          }, t2;
        }(r(50).BaseWriter);
        t.JSONWriter = u;
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(19), r(178), r(89), r(20), r(22), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(67), s = r(1), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            if (n2._writerOptions = s.applyDefaults(r2, { wellFormed: false, indent: "  ", newline: "\n", offset: 0, group: false, verbose: false }), n2._writerOptions.indent.length < 2) throw new Error("YAML indententation string must be at least two characters long.");
            if (n2._writerOptions.offset < 0) throw new Error("YAML offset should be zero or a positive number.");
            return n2;
          }
          return i(t2, e2), t2.prototype.serialize = function(e3) {
            var t3 = s.applyDefaults(this._writerOptions, { format: "object", wellFormed: false }), r2 = new a.ObjectWriter(this._builderOptions, t3).serialize(e3), n2 = this._beginLine(this._writerOptions, 0) + "---" + this._endLine(this._writerOptions) + this._convertObject(r2, this._writerOptions, 0);
            return n2.slice(-this._writerOptions.newline.length) === this._writerOptions.newline && (n2 = n2.slice(0, -this._writerOptions.newline.length)), n2;
          }, t2.prototype._convertObject = function(e3, t3, r2, n2) {
            var i2, a2, u2 = this;
            void 0 === n2 && (n2 = false);
            var l = "";
            if (s.isArray(e3)) try {
              for (var c = o(e3), h = c.next(); !h.done; h = c.next()) {
                var p = h.value;
                l += this._beginLine(t3, r2, true), s.isObject(p) ? s.isEmpty(p) ? l += '""' + this._endLine(t3) : l += this._convertObject(p, t3, r2, true) : l += this._val(p) + this._endLine(t3);
              }
            } catch (e4) {
              i2 = { error: e4 };
            } finally {
              try {
                h && !h.done && (a2 = c.return) && a2.call(c);
              } finally {
                if (i2) throw i2.error;
              }
            }
            else s.forEachObject(e3, function(e4, i3) {
              n2 ? (l += u2._key(e4), n2 = false) : l += u2._beginLine(t3, r2) + u2._key(e4), s.isObject(i3) ? s.isEmpty(i3) ? l += ' ""' + u2._endLine(t3) : l += u2._endLine(t3) + u2._convertObject(i3, t3, r2 + 1) : l += " " + u2._val(i3) + u2._endLine(t3);
            }, this);
            return l;
          }, t2.prototype._beginLine = function(e3, t3, r2) {
            void 0 === r2 && (r2 = false);
            var n2 = e3.offset + t3 + 1, i2 = new Array(n2).join(e3.indent);
            return r2 ? i2.substr(0, i2.length - 2) + "-" + i2.substr(-1, 1) : i2;
          }, t2.prototype._endLine = function(e3) {
            return e3.newline;
          }, t2.prototype._key = function(e3) {
            return '"' + e3 + '":';
          }, t2.prototype._val = function(e3) {
            return JSON.stringify(e3);
          }, t2;
        }(r(50).BaseWriter);
        t.YAMLWriter = u;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), r(110).dom.setFeatures(true);
        var n = r(110);
        t.DOMImplementation = n.DOMImplementation;
        var i = r(271);
        t.DOMParser = i.DOMParser;
        var o = r(274);
        t.XMLSerializer = o.XMLSerializer;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(3), i = r(0), o = function() {
          function e2() {
          }
          return e2.prototype.before = function() {
            for (var e3 = [], t2 = 0; t2 < arguments.length; t2++) e3[t2] = arguments[t2];
            var r2 = n.Cast.asNode(this), o2 = r2._parent;
            if (null !== o2) {
              for (var a = r2._previousSibling, s = true; s && a; ) {
                s = false;
                for (var u = 0; u < e3.length; u++) {
                  var l = e3[u];
                  if (l === a) {
                    a = a._previousSibling, s = true;
                    break;
                  }
                }
              }
              var c = i.parentNode_convertNodesIntoANode(e3, r2._nodeDocument);
              a = null === a ? o2._firstChild : a._nextSibling, i.mutation_preInsert(c, o2, a);
            }
          }, e2.prototype.after = function() {
            for (var e3 = [], t2 = 0; t2 < arguments.length; t2++) e3[t2] = arguments[t2];
            var r2 = n.Cast.asNode(this), o2 = r2._parent;
            if (o2) {
              for (var a = r2._nextSibling, s = true; s && a; ) {
                s = false;
                for (var u = 0; u < e3.length; u++) {
                  var l = e3[u];
                  if (l === a) {
                    a = a._nextSibling, s = true;
                    break;
                  }
                }
              }
              var c = i.parentNode_convertNodesIntoANode(e3, r2._nodeDocument);
              i.mutation_preInsert(c, o2, a);
            }
          }, e2.prototype.replaceWith = function() {
            for (var e3 = [], t2 = 0; t2 < arguments.length; t2++) e3[t2] = arguments[t2];
            var r2 = n.Cast.asNode(this), o2 = r2._parent;
            if (o2) {
              for (var a = r2._nextSibling, s = true; s && a; ) {
                s = false;
                for (var u = 0; u < e3.length; u++) {
                  var l = e3[u];
                  if (l === a) {
                    a = a._nextSibling, s = true;
                    break;
                  }
                }
              }
              var c = i.parentNode_convertNodesIntoANode(e3, r2._nodeDocument);
              r2._parent === o2 ? i.mutation_replace(r2, c, o2) : i.mutation_preInsert(c, o2, a);
            }
          }, e2.prototype.remove = function() {
            var e3 = n.Cast.asNode(this), t2 = e3._parent;
            t2 && i.mutation_remove(e3, t2);
          }, e2;
        }();
        t.ChildNodeImpl = o;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
        };
        t.DocumentOrShadowRootImpl = n;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(3), a = r(7), s = function() {
          function e2(e3) {
            this._nodeList = [], this._recordQueue = [], this._callback = e3;
            var t2 = i.dom.window;
            a.set.append(t2._mutationObservers, this);
          }
          return e2.prototype.observe = function(e3, t2) {
            var r2, i2;
            if (void 0 === (t2 = t2 || { childList: false, subtree: false }).attributeOldValue && void 0 === t2.attributeFilter || void 0 !== t2.attributes || (t2.attributes = true), void 0 !== t2.characterDataOldValue && void 0 === t2.characterData && (t2.characterData = true), !t2.childList && !t2.attributes && !t2.characterData) throw new TypeError();
            if (t2.attributeOldValue && !t2.attributes) throw new TypeError();
            if (void 0 !== t2.attributeFilter && !t2.attributes) throw new TypeError();
            if (t2.characterDataOldValue && !t2.characterData) throw new TypeError();
            var s2 = false, u = t2, l = function(e4) {
              var t3, r3;
              if (e4.observer === c) {
                s2 = true;
                try {
                  for (var i3 = (t3 = void 0, n(c._nodeList)), l2 = i3.next(); !l2.done; l2 = i3.next()) {
                    var h2 = l2.value;
                    a.list.remove(h2._registeredObserverList, function(t4) {
                      return o.Guard.isTransientRegisteredObserver(t4) && t4.source === e4;
                    });
                  }
                } catch (e5) {
                  t3 = { error: e5 };
                } finally {
                  try {
                    l2 && !l2.done && (r3 = i3.return) && r3.call(i3);
                  } finally {
                    if (t3) throw t3.error;
                  }
                }
                e4.options = u;
              }
            }, c = this;
            try {
              for (var h = n(e3._registeredObserverList), p = h.next(); !p.done; p = h.next()) {
                l(p.value);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                p && !p.done && (i2 = h.return) && i2.call(h);
              } finally {
                if (r2) throw r2.error;
              }
            }
            s2 || (e3._registeredObserverList.push({ observer: this, options: t2 }), this._nodeList.push(e3));
          }, e2.prototype.disconnect = function() {
            var e3, t2, r2 = this;
            try {
              for (var i2 = n(this._nodeList), o2 = i2.next(); !o2.done; o2 = i2.next()) {
                var s2 = o2.value;
                a.list.remove(s2._registeredObserverList, function(e4) {
                  return e4.observer === r2;
                });
              }
            } catch (t3) {
              e3 = { error: t3 };
            } finally {
              try {
                o2 && !o2.done && (t2 = i2.return) && t2.call(i2);
              } finally {
                if (e3) throw e3.error;
              }
            }
            this._recordQueue = [];
          }, e2.prototype.takeRecords = function() {
            var e3 = this._recordQueue;
            return this._recordQueue = [], e3;
          }, e2;
        }();
        t.MutationObserverImpl = s;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(3), i = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "previousElementSibling", { get: function() {
            for (var e3 = n.Cast.asNode(this)._previousSibling; e3; ) {
              if (n.Guard.isElementNode(e3)) return e3;
              e3 = e3._previousSibling;
            }
            return null;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "nextElementSibling", { get: function() {
            for (var e3 = n.Cast.asNode(this)._nextSibling; e3; ) {
              if (n.Guard.isElementNode(e3)) return e3;
              e3 = e3._nextSibling;
            }
            return null;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.NonDocumentTypeChildNodeImpl = i;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(3), i = r(0), o = function() {
          function e2() {
          }
          return e2.prototype.getElementById = function(e3) {
            for (var t2 = i.tree_getFirstDescendantNode(n.Cast.asNode(this), false, false, function(e4) {
              return n.Guard.isElementNode(e4);
            }); null !== t2; ) {
              if (t2._uniqueIdentifier === e3) return t2;
              t2 = i.tree_getNextDescendantNode(n.Cast.asNode(this), t2, false, false, function(e4) {
                return n.Guard.isElementNode(e4);
              });
            }
            return null;
          }, e2;
        }();
        t.NonElementParentNodeImpl = o;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(3), o = r(0), a = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "children", { get: function() {
            return o.create_htmlCollection(i.Cast.asNode(this));
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "firstElementChild", { get: function() {
            for (var e3 = i.Cast.asNode(this)._firstChild; e3; ) {
              if (i.Guard.isElementNode(e3)) return e3;
              e3 = e3._nextSibling;
            }
            return null;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "lastElementChild", { get: function() {
            for (var e3 = i.Cast.asNode(this)._lastChild; e3; ) {
              if (i.Guard.isElementNode(e3)) return e3;
              e3 = e3._previousSibling;
            }
            return null;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "childElementCount", { get: function() {
            var e3, t2, r2 = 0;
            try {
              for (var o2 = n(i.Cast.asNode(this)._children), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var s = a2.value;
                i.Guard.isElementNode(s) && r2++;
              }
            } catch (t3) {
              e3 = { error: t3 };
            } finally {
              try {
                a2 && !a2.done && (t2 = o2.return) && t2.call(o2);
              } finally {
                if (e3) throw e3.error;
              }
            }
            return r2;
          }, enumerable: true, configurable: true }), e2.prototype.prepend = function() {
            for (var e3 = [], t2 = 0; t2 < arguments.length; t2++) e3[t2] = arguments[t2];
            var r2 = i.Cast.asNode(this), n2 = o.parentNode_convertNodesIntoANode(e3, r2._nodeDocument);
            o.mutation_preInsert(n2, r2, r2._firstChild);
          }, e2.prototype.append = function() {
            for (var e3 = [], t2 = 0; t2 < arguments.length; t2++) e3[t2] = arguments[t2];
            var r2 = i.Cast.asNode(this), n2 = o.parentNode_convertNodesIntoANode(e3, r2._nodeDocument);
            o.mutation_append(n2, r2);
          }, e2.prototype.querySelector = function(e3) {
            var t2 = i.Cast.asNode(this), r2 = o.selectors_scopeMatchASelectorsString(e3, t2);
            return 0 === r2.length ? null : r2[0];
          }, e2.prototype.querySelectorAll = function(e3) {
            var t2 = i.Cast.asNode(this), r2 = o.selectors_scopeMatchASelectorsString(e3, t2);
            return o.create_nodeListStatic(t2, r2);
          }, e2;
        }();
        t.ParentNodeImpl = a;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(0), i = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "_name", { get: function() {
            return this.__name || "";
          }, set: function(e3) {
            this.__name = e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_assignedSlot", { get: function() {
            return this.__assignedSlot || null;
          }, set: function(e3) {
            this.__assignedSlot = e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "assignedSlot", { get: function() {
            return n.shadowTree_findASlot(this, true);
          }, enumerable: true, configurable: true }), e2;
        }();
        t.SlotableImpl = i;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(102), a = r(9), s = r(3), u = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this) || this;
            if (s.Guard.isDocumentTypeNode(t3.startContainer) || s.Guard.isAttrNode(t3.startContainer) || s.Guard.isDocumentTypeNode(t3.endContainer) || s.Guard.isAttrNode(t3.endContainer)) throw new a.InvalidNodeTypeError();
            return r2._start = [t3.startContainer, t3.startOffset], r2._end = [t3.endContainer, t3.endOffset], r2;
          }
          return i(t2, e2), t2;
        }(o.AbstractRangeImpl);
        t.StaticRangeImpl = u;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(272);
        t.DOMParser = n.DOMParserImpl;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(0), i = r(273), o = function() {
          function e2() {
          }
          return e2.prototype.parseFromString = function(e3, t2) {
            if ("text/html" === t2) throw new Error("HTML parser not implemented.");
            try {
              return (r2 = new i.XMLParserImpl().parse(e3))._contentType = t2, r2;
            } catch (e4) {
              var r2, o2 = "http://www.mozilla.org/newlayout/xml/parsererror.xml", a = (r2 = n.create_xmlDocument()).createElementNS(o2, "parsererror"), s = r2.createElementNS(o2, "error");
              return s.setAttribute("message", e4.message), a.appendChild(s), r2.appendChild(a), r2;
            }
          }, e2;
        }();
        t.DOMParserImpl = o;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(180), a = r(111), s = r(7), u = r(0), l = r(69), c = function() {
          function e2() {
          }
          return e2.prototype.parse = function(e3) {
            for (var t2, r2, c2, h, p = new o.XMLStringLexer(e3, { skipWhitespaceOnlyText: true }), f = u.create_document(), d = f, m = p.nextToken(); m.type !== a.TokenType.EOF; ) {
              switch (m.type) {
                case a.TokenType.Declaration:
                  var y = m;
                  if ("1.0" !== y.version) throw new Error("Invalid xml version: " + y.version);
                  break;
                case a.TokenType.DocType:
                  var v = m;
                  if (!u.xml_isPubidChar(v.pubId)) throw new Error("DocType public identifier does not match PubidChar construct.");
                  if (!u.xml_isLegalChar(v.sysId) || -1 !== v.sysId.indexOf('"') && -1 !== v.sysId.indexOf("'")) throw new Error("DocType system identifier contains invalid characters.");
                  d.appendChild(f.implementation.createDocumentType(v.name, v.pubId, v.sysId));
                  break;
                case a.TokenType.CDATA:
                  var _ = m;
                  if (!u.xml_isLegalChar(_.data) || -1 !== _.data.indexOf("]]>")) throw new Error("CDATA contains invalid characters.");
                  d.appendChild(f.createCDATASection(_.data));
                  break;
                case a.TokenType.Comment:
                  var g = m;
                  if (!u.xml_isLegalChar(g.data) || -1 !== g.data.indexOf("--") || g.data.endsWith("-")) throw new Error("Comment data contains invalid characters.");
                  d.appendChild(f.createComment(g.data));
                  break;
                case a.TokenType.PI:
                  var b = m;
                  if (-1 !== b.target.indexOf(":") || /^xml$/i.test(b.target)) throw new Error("Processing instruction target contains invalid characters.");
                  if (!u.xml_isLegalChar(b.data) || -1 !== b.data.indexOf("?>")) throw new Error("Processing instruction data contains invalid characters.");
                  d.appendChild(f.createProcessingInstruction(b.target, b.data));
                  break;
                case a.TokenType.Text:
                  var x = m;
                  if (!u.xml_isLegalChar(x.data)) throw new Error("Text data contains invalid characters.");
                  d.appendChild(f.createTextNode(this._decodeText(x.data)));
                  break;
                case a.TokenType.Element:
                  var w = m, E = n(u.namespace_extractQName(w.name), 2), D = E[0], S = E[1];
                  if (-1 !== S.indexOf(":") || !u.xml_isName(S)) throw new Error("Node local name contains invalid characters.");
                  if ("xmlns" === D) throw new Error("An element cannot have the 'xmlns' prefix.");
                  var C = d.lookupNamespaceURI(D), A = {};
                  try {
                    for (var N = (t2 = void 0, i(w.attributes)), T = N.next(); !T.done; T = N.next()) {
                      var O = n(T.value, 2), F = O[0], k = O[1];
                      if ("xmlns" === F) C = k;
                      else {
                        var P = n(u.namespace_extractQName(F), 2), I = P[0], L = P[1];
                        "xmlns" === I && (L === D && (C = k), A[L] = k);
                      }
                    }
                  } catch (e4) {
                    t2 = { error: e4 };
                  } finally {
                    try {
                      T && !T.done && (r2 = N.return) && r2.call(N);
                    } finally {
                      if (t2) throw t2.error;
                    }
                  }
                  var M = null !== C ? f.createElementNS(C, w.name) : f.createElement(w.name);
                  d.appendChild(M);
                  var B = new l.LocalNameSet();
                  try {
                    for (var j = (c2 = void 0, i(w.attributes)), R = j.next(); !R.done; R = j.next()) {
                      var z = n(R.value, 2), U = (F = z[0], k = z[1], n(u.namespace_extractQName(F), 2)), G = (I = U[0], L = U[1], null);
                      if ("xmlns" === I || null === I && "xmlns" === L ? G = s.namespace.XMLNS : null !== (G = M.lookupNamespaceURI(I)) && M.isDefaultNamespace(G) ? G = null : null === G && null !== I && (G = A[I] || null), B.has(G, L)) throw new Error("Element contains duplicate attributes.");
                      if (B.set(G, L), G === s.namespace.XMLNS && k === s.namespace.XMLNS) throw new Error("XMLNS namespace is reserved.");
                      if (-1 !== L.indexOf(":") || !u.xml_isName(L)) throw new Error("Attribute local name contains invalid characters.");
                      if ("xmlns" === I && "" === k) throw new Error("Empty XML namespace is not allowed.");
                      null !== G ? M.setAttributeNS(G, F, this._decodeAttributeValue(k)) : M.setAttribute(F, this._decodeAttributeValue(k));
                    }
                  } catch (e4) {
                    c2 = { error: e4 };
                  } finally {
                    try {
                      R && !R.done && (h = j.return) && h.call(j);
                    } finally {
                      if (c2) throw c2.error;
                    }
                  }
                  w.selfClosing || (d = M);
                  break;
                case a.TokenType.ClosingTag:
                  if (m.name !== d.nodeName) throw new Error("Closing tag name does not match opening tag name.");
                  d._parent && (d = d._parent);
              }
              m = p.nextToken();
            }
            return f;
          }, e2.prototype._decodeText = function(e3) {
            return null == e3 ? e3 : e3.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
          }, e2.prototype._decodeAttributeValue = function(e3) {
            return null == e3 ? e3 : e3.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
          }, e2;
        }();
        t.XMLParserImpl = c;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(275);
        t.XMLSerializer = n.XMLSerializerImpl;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(2), o = r(69), a = r(95), s = r(9), u = r(7), l = r(0), c = function() {
          function e2() {
          }
          return e2.prototype.serializeToString = function(e3) {
            return this._xmlSerialization(e3, false);
          }, e2.prototype._xmlSerialization = function(e3, t2) {
            if (void 0 === e3._nodeDocument || e3._nodeDocument._hasNamespaces) {
              var r2 = new a.NamespacePrefixMap();
              r2.set("xml", u.namespace.XML);
              try {
                return this._serializeNodeNS(e3, null, r2, { value: 1 }, t2);
              } catch (e4) {
                throw new s.InvalidStateError();
              }
            } else try {
              return this._serializeNode(e3, t2);
            } catch (e4) {
              throw new s.InvalidStateError();
            }
          }, e2.prototype._serializeNodeNS = function(e3, t2, r2, n2, o2) {
            switch (e3.nodeType) {
              case i.NodeType.Element:
                return this._serializeElementNS(e3, t2, r2, n2, o2);
              case i.NodeType.Document:
                return this._serializeDocumentNS(e3, t2, r2, n2, o2);
              case i.NodeType.Comment:
                return this._serializeComment(e3, o2);
              case i.NodeType.Text:
                return this._serializeText(e3, o2);
              case i.NodeType.DocumentFragment:
                return this._serializeDocumentFragmentNS(e3, t2, r2, n2, o2);
              case i.NodeType.DocumentType:
                return this._serializeDocumentType(e3, o2);
              case i.NodeType.ProcessingInstruction:
                return this._serializeProcessingInstruction(e3, o2);
              case i.NodeType.CData:
                return this._serializeCData(e3, o2);
              default:
                throw new Error("Unknown node type: " + e3.nodeType);
            }
          }, e2.prototype._serializeNode = function(e3, t2) {
            switch (e3.nodeType) {
              case i.NodeType.Element:
                return this._serializeElement(e3, t2);
              case i.NodeType.Document:
                return this._serializeDocument(e3, t2);
              case i.NodeType.Comment:
                return this._serializeComment(e3, t2);
              case i.NodeType.Text:
                return this._serializeText(e3, t2);
              case i.NodeType.DocumentFragment:
                return this._serializeDocumentFragment(e3, t2);
              case i.NodeType.DocumentType:
                return this._serializeDocumentType(e3, t2);
              case i.NodeType.ProcessingInstruction:
                return this._serializeProcessingInstruction(e3, t2);
              case i.NodeType.CData:
                return this._serializeCData(e3, t2);
              default:
                throw new Error("Unknown node type: " + e3.nodeType);
            }
          }, e2.prototype._serializeElementNS = function(t2, r2, i2, o2, a2) {
            var s2, c2;
            if (a2 && (-1 !== t2.localName.indexOf(":") || !l.xml_isName(t2.localName))) throw new Error("Node local name contains invalid characters (well-formed required).");
            var h = "<", p = "", f = false, d = false, m = i2.copy(), y = {}, v = this._recordNamespaceInformation(t2, m, y), _ = r2, g = t2.namespaceURI;
            if (_ === g) null !== v && (d = true), h += p = g === u.namespace.XML ? "xml:" + t2.localName : t2.localName;
            else {
              var b = t2.prefix, x = null;
              if (null === b && g === v || (x = m.get(b, g)), "xmlns" === b) {
                if (a2) throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
                x = b;
              }
              null !== x ? (p = x + ":" + t2.localName, null !== v && v !== u.namespace.XML && (_ = v || null), h += p) : null !== b ? (b in y && (b = this._generatePrefix(g, m, o2)), m.set(b, g), h += p += b + ":" + t2.localName, h += " xmlns:" + b + '="' + this._serializeAttributeValue(g, a2) + '"', null !== v && (_ = v || null)) : null === v || null !== v && v !== g ? (d = true, _ = g, h += p += t2.localName, h += ' xmlns="' + this._serializeAttributeValue(g, a2) + '"') : (_ = g, h += p += t2.localName);
            }
            h += this._serializeAttributesNS(t2, m, o2, y, d, a2);
            var w = g === u.namespace.HTML;
            if (w && 0 === t2.childNodes.length && e2._VoidElementNames.has(t2.localName) ? (h += " /", f = true) : w || 0 !== t2.childNodes.length || (h += "/", f = true), h += ">", f) return h;
            if (w && "template" === t2.localName) ;
            else try {
              for (var E = n(t2._children || t2.childNodes), D = E.next(); !D.done; D = E.next()) {
                var S = D.value;
                h += this._serializeNodeNS(S, _, m, o2, a2);
              }
            } catch (e3) {
              s2 = { error: e3 };
            } finally {
              try {
                D && !D.done && (c2 = E.return) && c2.call(E);
              } finally {
                if (s2) throw s2.error;
              }
            }
            return h += "</" + p + ">";
          }, e2.prototype._serializeDocumentNS = function(e3, t2, r2, i2, o2) {
            var a2, s2;
            if (o2 && null === e3.documentElement) throw new Error("Missing document element (well-formed required).");
            var u2 = "";
            try {
              for (var l2 = n(e3._children || e3.childNodes), c2 = l2.next(); !c2.done; c2 = l2.next()) {
                var h = c2.value;
                u2 += this._serializeNodeNS(h, t2, r2, i2, o2);
              }
            } catch (e4) {
              a2 = { error: e4 };
            } finally {
              try {
                c2 && !c2.done && (s2 = l2.return) && s2.call(l2);
              } finally {
                if (a2) throw a2.error;
              }
            }
            return u2;
          }, e2.prototype._serializeComment = function(e3, t2) {
            if (t2 && (!l.xml_isLegalChar(e3.data) || -1 !== e3.data.indexOf("--") || e3.data.endsWith("-"))) throw new Error("Comment data contains invalid characters (well-formed required).");
            return "<!--" + e3.data + "-->";
          }, e2.prototype._serializeText = function(e3, t2) {
            if (t2 && !l.xml_isLegalChar(e3.data)) throw new Error("Text data contains invalid characters (well-formed required).");
            for (var r2 = "", n2 = 0; n2 < e3.data.length; n2++) {
              var i2 = e3.data[n2];
              r2 += "&" === i2 ? "&amp;" : "<" === i2 ? "&lt;" : ">" === i2 ? "&gt;" : i2;
            }
            return r2;
          }, e2.prototype._serializeDocumentFragmentNS = function(e3, t2, r2, i2, o2) {
            var a2, s2, u2 = "";
            try {
              for (var l2 = n(e3._children || e3.childNodes), c2 = l2.next(); !c2.done; c2 = l2.next()) {
                var h = c2.value;
                u2 += this._serializeNodeNS(h, t2, r2, i2, o2);
              }
            } catch (e4) {
              a2 = { error: e4 };
            } finally {
              try {
                c2 && !c2.done && (s2 = l2.return) && s2.call(l2);
              } finally {
                if (a2) throw a2.error;
              }
            }
            return u2;
          }, e2.prototype._serializeDocumentType = function(e3, t2) {
            if (t2 && !l.xml_isPubidChar(e3.publicId)) throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
            if (t2 && (!l.xml_isLegalChar(e3.systemId) || -1 !== e3.systemId.indexOf('"') && -1 !== e3.systemId.indexOf("'"))) throw new Error("DocType system identifier contains invalid characters (well-formed required).");
            return e3.publicId && e3.systemId ? "<!DOCTYPE " + e3.name + ' PUBLIC "' + e3.publicId + '" "' + e3.systemId + '">' : e3.publicId ? "<!DOCTYPE " + e3.name + ' PUBLIC "' + e3.publicId + '">' : e3.systemId ? "<!DOCTYPE " + e3.name + ' SYSTEM "' + e3.systemId + '">' : "<!DOCTYPE " + e3.name + ">";
          }, e2.prototype._serializeProcessingInstruction = function(e3, t2) {
            if (t2 && (-1 !== e3.target.indexOf(":") || /^xml$/i.test(e3.target))) throw new Error("Processing instruction target contains invalid characters (well-formed required).");
            if (t2 && (!l.xml_isLegalChar(e3.data) || -1 !== e3.data.indexOf("?>"))) throw new Error("Processing instruction data contains invalid characters (well-formed required).");
            return "<?" + ("" === e3.data ? e3.target : e3.target + " " + e3.data) + "?>";
          }, e2.prototype._serializeCData = function(e3, t2) {
            if (t2 && -1 !== e3.data.indexOf("]]>")) throw new Error("CDATA contains invalid characters (well-formed required).");
            return "<![CDATA[" + e3.data + "]]>";
          }, e2.prototype._serializeAttributesNS = function(e3, t2, r2, i2, a2, s2) {
            var c2, h, p = "", f = s2 ? new o.LocalNameSet() : void 0;
            try {
              for (var d = n(e3.attributes), m = d.next(); !m.done; m = d.next()) {
                var y = m.value;
                if (a2 || s2 || null !== y.namespaceURI) {
                  if (s2 && f && f.has(y.namespaceURI, y.localName)) throw new Error("Element contains duplicate attributes (well-formed required).");
                  s2 && f && f.set(y.namespaceURI, y.localName);
                  var v = y.namespaceURI, _ = null;
                  if (null !== v) if (_ = t2.get(y.prefix, v), v === u.namespace.XMLNS) {
                    if (y.value === u.namespace.XML || null === y.prefix && a2 || null !== y.prefix && (!(y.localName in i2) || i2[y.localName] !== y.value) && t2.has(y.localName, y.value)) continue;
                    if (s2 && y.value === u.namespace.XMLNS) throw new Error("XMLNS namespace is reserved (well-formed required).");
                    if (s2 && "" === y.value) throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                    "xmlns" === y.prefix && (_ = "xmlns");
                  } else null === _ && (p += " xmlns:" + (_ = null === y.prefix || t2.hasPrefix(y.prefix) && !t2.has(y.prefix, v) ? this._generatePrefix(v, t2, r2) : y.prefix) + '="' + this._serializeAttributeValue(v, s2) + '"');
                  if (p += " ", null !== _ && (p += _ + ":"), s2 && (-1 !== y.localName.indexOf(":") || !l.xml_isName(y.localName) || "xmlns" === y.localName && null === v)) throw new Error("Attribute local name contains invalid characters (well-formed required).");
                  p += y.localName + '="' + this._serializeAttributeValue(y.value, s2) + '"';
                } else p += " " + y.localName + '="' + this._serializeAttributeValue(y.value, s2) + '"';
              }
            } catch (e4) {
              c2 = { error: e4 };
            } finally {
              try {
                m && !m.done && (h = d.return) && h.call(d);
              } finally {
                if (c2) throw c2.error;
              }
            }
            return p;
          }, e2.prototype._recordNamespaceInformation = function(e3, t2, r2) {
            var i2, o2, a2 = null;
            try {
              for (var s2 = n(e3.attributes), l2 = s2.next(); !l2.done; l2 = s2.next()) {
                var c2 = l2.value, h = c2.namespaceURI, p = c2.prefix;
                if (h === u.namespace.XMLNS) {
                  if (null === p) {
                    a2 = c2.value;
                    continue;
                  }
                  var f = c2.localName, d = c2.value;
                  if (d === u.namespace.XML) continue;
                  if ("" === d && (d = null), t2.has(f, d)) continue;
                  t2.set(f, d), r2[f] = d || "";
                }
              }
            } catch (e4) {
              i2 = { error: e4 };
            } finally {
              try {
                l2 && !l2.done && (o2 = s2.return) && o2.call(s2);
              } finally {
                if (i2) throw i2.error;
              }
            }
            return a2;
          }, e2.prototype._generatePrefix = function(e3, t2, r2) {
            var n2 = "ns" + r2.value;
            return r2.value++, t2.set(n2, e3), n2;
          }, e2.prototype._serializeAttributeValue = function(e3, t2) {
            if (t2 && null !== e3 && !l.xml_isLegalChar(e3)) throw new Error("Invalid characters in attribute value.");
            if (null === e3) return "";
            for (var r2 = "", n2 = 0; n2 < e3.length; n2++) {
              var i2 = e3[n2];
              r2 += '"' === i2 ? "&quot;" : "&" === i2 ? "&amp;" : "<" === i2 ? "&lt;" : ">" === i2 ? "&gt;" : i2;
            }
            return r2;
          }, e2.prototype._serializeElement = function(e3, t2) {
            var r2, i2;
            if (t2 && (-1 !== e3.localName.indexOf(":") || !l.xml_isName(e3.localName))) throw new Error("Node local name contains invalid characters (well-formed required).");
            var o2 = false, a2 = e3.localName, s2 = "<" + a2;
            if (s2 += this._serializeAttributes(e3, t2), 0 === e3._children.size && (s2 += "/", o2 = true), s2 += ">", o2) return s2;
            try {
              for (var u2 = n(e3._children), c2 = u2.next(); !c2.done; c2 = u2.next()) {
                var h = c2.value;
                s2 += this._serializeNode(h, t2);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                c2 && !c2.done && (i2 = u2.return) && i2.call(u2);
              } finally {
                if (r2) throw r2.error;
              }
            }
            return s2 += "</" + a2 + ">";
          }, e2.prototype._serializeDocument = function(e3, t2) {
            var r2, i2;
            if (t2 && null === e3.documentElement) throw new Error("Missing document element (well-formed required).");
            var o2 = "";
            try {
              for (var a2 = n(e3._children), s2 = a2.next(); !s2.done; s2 = a2.next()) {
                var u2 = s2.value;
                o2 += this._serializeNode(u2, t2);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                s2 && !s2.done && (i2 = a2.return) && i2.call(a2);
              } finally {
                if (r2) throw r2.error;
              }
            }
            return o2;
          }, e2.prototype._serializeDocumentFragment = function(e3, t2) {
            var r2, i2, o2 = "";
            try {
              for (var a2 = n(e3._children), s2 = a2.next(); !s2.done; s2 = a2.next()) {
                var u2 = s2.value;
                o2 += this._serializeNode(u2, t2);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                s2 && !s2.done && (i2 = a2.return) && i2.call(a2);
              } finally {
                if (r2) throw r2.error;
              }
            }
            return o2;
          }, e2.prototype._serializeAttributes = function(e3, t2) {
            var r2, i2, o2 = "", a2 = t2 ? {} : void 0;
            try {
              for (var s2 = n(e3.attributes), u2 = s2.next(); !u2.done; u2 = s2.next()) {
                var c2 = u2.value;
                if (t2 && a2 && c2.localName in a2) throw new Error("Element contains duplicate attributes (well-formed required).");
                if (t2 && a2 && (a2[c2.localName] = true), t2 && (-1 !== c2.localName.indexOf(":") || !l.xml_isName(c2.localName))) throw new Error("Attribute local name contains invalid characters (well-formed required).");
                o2 += " " + c2.localName + '="' + this._serializeAttributeValue(c2.value, t2) + '"';
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                u2 && !u2.done && (i2 = s2.return) && i2.call(s2);
              } finally {
                if (r2) throw r2.error;
              }
            }
            return o2;
          }, e2._VoidElementNames = /* @__PURE__ */ new Set(["area", "base", "basefont", "bgsound", "br", "col", "embed", "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"]), e2;
        }();
        t.XMLSerializerImpl = c;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(277);
        t.XMLReader = n.XMLReader;
        var i = r(112);
        t.ObjectReader = i.ObjectReader;
        var o = r(280);
        t.JSONReader = o.JSONReader;
        var a = r(281);
        t.YAMLReader = a.YAMLReader;
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(19), r(65), r(20), r(22), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        }, a = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(180), u = r(111), l = r(7), c = r(0), h = function(e2) {
          function t2() {
            return null !== e2 && e2.apply(this, arguments) || this;
          }
          return i(t2, e2), t2.prototype._parse = function(e3, t3) {
            for (var r2, n2, i2, h2, p = new s.XMLStringLexer(t3, { skipWhitespaceOnlyText: true }), f = e3, d = e3, m = p.nextToken(); m.type !== u.TokenType.EOF; ) {
              switch (m.type) {
                case u.TokenType.Declaration:
                  var y = m, v = this.sanitize(y.version);
                  if ("1.0" !== v) throw new Error("Invalid xml version: " + v);
                  var _ = { version: v };
                  y.encoding && (_.encoding = this.sanitize(y.encoding)), y.standalone && (_.standalone = "yes" === this.sanitize(y.standalone)), d.set(_);
                  break;
                case u.TokenType.DocType:
                  var g = m;
                  d = this.docType(d, this.sanitize(g.name), this.sanitize(g.pubId), this.sanitize(g.sysId)) || d;
                  break;
                case u.TokenType.CDATA:
                  var b = m;
                  d = this.cdata(d, this.sanitize(b.data)) || d;
                  break;
                case u.TokenType.Comment:
                  var x = m;
                  d = this.comment(d, this.sanitize(x.data)) || d;
                  break;
                case u.TokenType.PI:
                  var w = m;
                  d = this.instruction(d, this.sanitize(w.target), this.sanitize(w.data)) || d;
                  break;
                case u.TokenType.Text:
                  var E = m;
                  d = this.text(d, this._decodeText(this.sanitize(E.data))) || d;
                  break;
                case u.TokenType.Element:
                  var D = m, S = this.sanitize(D.name), C = o(c.namespace_extractQName(S), 1)[0], A = d.node.lookupNamespaceURI(C), N = {};
                  try {
                    for (var T = (r2 = void 0, a(D.attributes)), O = T.next(); !O.done; O = T.next()) {
                      var F = o(O.value, 2), k = F[0], P = F[1];
                      if (k = this.sanitize(k), P = this.sanitize(P), "xmlns" === k) A = P;
                      else {
                        var I = o(c.namespace_extractQName(k), 2), L = I[0], M = I[1];
                        "xmlns" === L && (M === C && (A = P), N[M] = P);
                      }
                    }
                  } catch (e4) {
                    r2 = { error: e4 };
                  } finally {
                    try {
                      O && !O.done && (n2 = T.return) && n2.call(T);
                    } finally {
                      if (r2) throw r2.error;
                    }
                  }
                  var B = null !== A ? this.element(d, A, S) : this.element(d, void 0, S);
                  if (void 0 === B) break;
                  d.node === e3.node && (f = B);
                  try {
                    for (var j = (i2 = void 0, a(D.attributes)), R = j.next(); !R.done; R = j.next()) {
                      var z = o(R.value, 2);
                      k = z[0], P = z[1];
                      k = this.sanitize(k), P = this.sanitize(P);
                      var U = o(c.namespace_extractQName(k), 2), G = (L = U[0], M = U[1], null);
                      "xmlns" === L || null === L && "xmlns" === M ? G = l.namespace.XMLNS : null !== (G = B.node.lookupNamespaceURI(L)) && B.node.isDefaultNamespace(G) ? G = null : null === G && null !== L && (G = N[L] || null), null !== G ? this.attribute(B, G, k, this._decodeAttributeValue(P)) : this.attribute(B, void 0, k, this._decodeAttributeValue(P));
                    }
                  } catch (e4) {
                    i2 = { error: e4 };
                  } finally {
                    try {
                      R && !R.done && (h2 = j.return) && h2.call(j);
                    } finally {
                      if (i2) throw i2.error;
                    }
                  }
                  D.selfClosing || (d = B);
                  break;
                case u.TokenType.ClosingTag:
                  d.node.parentNode && (d = d.up());
              }
              m = p.nextToken();
            }
            return f;
          }, t2;
        }(r(75).BaseReader);
        t.XMLReader = h;
      }, function(e, t, r) {
        var n = r(4), i = r(279);
        n({ target: "Object", stat: true, forced: Object.assign !== i }, { assign: i });
      }, function(e, t, r) {
        "use strict";
        var n = r(16), i = r(8), o = r(61), a = r(85), s = r(79), u = r(27), l = r(41), c = Object.assign, h = Object.defineProperty;
        e.exports = !c || i(function() {
          if (n && 1 !== c({ b: 1 }, c(h({}, "a", { enumerable: true, get: function() {
            h(this, "b", { value: 3, enumerable: false });
          } }), { b: 2 })).b) return true;
          var e2 = {}, t2 = {}, r2 = Symbol();
          return e2[r2] = 7, "abcdefghijklmnopqrst".split("").forEach(function(e3) {
            t2[e3] = e3;
          }), 7 != c({}, e2)[r2] || "abcdefghijklmnopqrst" != o(c({}, t2)).join("");
        }) ? function(e2, t2) {
          for (var r2 = u(e2), i2 = arguments.length, c2 = 1, h2 = a.f, p = s.f; i2 > c2; ) for (var f, d = l(arguments[c2++]), m = h2 ? o(d).concat(h2(d)) : o(d), y = m.length, v = 0; y > v; ) f = m[v++], n && !p.call(d, f) || (r2[f] = d[f]);
          return r2;
        } : c;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(112), a = function(e2) {
          function t2() {
            return null !== e2 && e2.apply(this, arguments) || this;
          }
          return i(t2, e2), t2.prototype._parse = function(e3, t3) {
            return new o.ObjectReader(this._builderOptions).parse(e3, JSON.parse(t3));
          }, t2;
        }(r(75).BaseReader);
        t.JSONReader = a;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(112), a = r(75), s = r(282), u = function(e2) {
          function t2() {
            return null !== e2 && e2.apply(this, arguments) || this;
          }
          return i(t2, e2), t2.prototype._parse = function(e3, t3) {
            var r2 = s.safeLoad(t3);
            if (void 0 === r2) throw new Error("Unable to parse YAML document.");
            return new o.ObjectReader(this._builderOptions).parse(e3, r2);
          }, t2;
        }(a.BaseReader);
        t.YAMLReader = u;
      }, function(e, t, r) {
        "use strict";
        var n = r(283);
        e.exports = n;
      }, function(e, t, r) {
        "use strict";
        var n = r(284), i = r(303);
        function o(e2) {
          return function() {
            throw new Error("Function " + e2 + " is deprecated and cannot be used.");
          };
        }
        e.exports.Type = r(10), e.exports.Schema = r(39), e.exports.FAILSAFE_SCHEMA = r(113), e.exports.JSON_SCHEMA = r(182), e.exports.CORE_SCHEMA = r(181), e.exports.DEFAULT_SAFE_SCHEMA = r(54), e.exports.DEFAULT_FULL_SCHEMA = r(76), e.exports.load = n.load, e.exports.loadAll = n.loadAll, e.exports.safeLoad = n.safeLoad, e.exports.safeLoadAll = n.safeLoadAll, e.exports.dump = i.dump, e.exports.safeDump = i.safeDump, e.exports.YAMLException = r(53), e.exports.MINIMAL_SCHEMA = r(113), e.exports.SAFE_SCHEMA = r(54), e.exports.DEFAULT_SCHEMA = r(76), e.exports.scan = o("scan"), e.exports.parse = o("parse"), e.exports.compose = o("compose"), e.exports.addConstructor = o("addConstructor");
      }, function(e, t, r) {
        "use strict";
        var n = r(38), i = r(53), o = r(285), a = r(54), s = r(76), u = Object.prototype.hasOwnProperty, l = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, c = /[\x85\u2028\u2029]/, h = /[,\[\]\{\}]/, p = /^(?:!|!!|![a-z\-]+!)$/i, f = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
        function d(e2) {
          return Object.prototype.toString.call(e2);
        }
        function m(e2) {
          return 10 === e2 || 13 === e2;
        }
        function y(e2) {
          return 9 === e2 || 32 === e2;
        }
        function v(e2) {
          return 9 === e2 || 32 === e2 || 10 === e2 || 13 === e2;
        }
        function _(e2) {
          return 44 === e2 || 91 === e2 || 93 === e2 || 123 === e2 || 125 === e2;
        }
        function g(e2) {
          var t2;
          return 48 <= e2 && e2 <= 57 ? e2 - 48 : 97 <= (t2 = 32 | e2) && t2 <= 102 ? t2 - 97 + 10 : -1;
        }
        function b(e2) {
          return 48 === e2 ? "\0" : 97 === e2 ? "\x07" : 98 === e2 ? "\b" : 116 === e2 || 9 === e2 ? "	" : 110 === e2 ? "\n" : 118 === e2 ? "\v" : 102 === e2 ? "\f" : 114 === e2 ? "\r" : 101 === e2 ? "\x1B" : 32 === e2 ? " " : 34 === e2 ? '"' : 47 === e2 ? "/" : 92 === e2 ? "\\" : 78 === e2 ? "" : 95 === e2 ? "" : 76 === e2 ? "\u2028" : 80 === e2 ? "\u2029" : "";
        }
        function x(e2) {
          return e2 <= 65535 ? String.fromCharCode(e2) : String.fromCharCode(55296 + (e2 - 65536 >> 10), 56320 + (e2 - 65536 & 1023));
        }
        for (var w = new Array(256), E = new Array(256), D = 0; D < 256; D++) w[D] = b(D) ? 1 : 0, E[D] = b(D);
        function S(e2, t2) {
          this.input = e2, this.filename = t2.filename || null, this.schema = t2.schema || s, this.onWarning = t2.onWarning || null, this.legacy = t2.legacy || false, this.json = t2.json || false, this.listener = t2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
        }
        function C(e2, t2) {
          return new i(t2, new o(e2.filename, e2.input, e2.position, e2.line, e2.position - e2.lineStart));
        }
        function A(e2, t2) {
          throw C(e2, t2);
        }
        function N(e2, t2) {
          e2.onWarning && e2.onWarning.call(null, C(e2, t2));
        }
        var T = { YAML: function(e2, t2, r2) {
          var n2, i2, o2;
          null !== e2.version && A(e2, "duplication of %YAML directive"), 1 !== r2.length && A(e2, "YAML directive accepts exactly one argument"), null === (n2 = /^([0-9]+)\.([0-9]+)$/.exec(r2[0])) && A(e2, "ill-formed argument of the YAML directive"), i2 = parseInt(n2[1], 10), o2 = parseInt(n2[2], 10), 1 !== i2 && A(e2, "unacceptable YAML version of the document"), e2.version = r2[0], e2.checkLineBreaks = o2 < 2, 1 !== o2 && 2 !== o2 && N(e2, "unsupported YAML version of the document");
        }, TAG: function(e2, t2, r2) {
          var n2, i2;
          2 !== r2.length && A(e2, "TAG directive accepts exactly two arguments"), n2 = r2[0], i2 = r2[1], p.test(n2) || A(e2, "ill-formed tag handle (first argument) of the TAG directive"), u.call(e2.tagMap, n2) && A(e2, 'there is a previously declared suffix for "' + n2 + '" tag handle'), f.test(i2) || A(e2, "ill-formed tag prefix (second argument) of the TAG directive"), e2.tagMap[n2] = i2;
        } };
        function O(e2, t2, r2, n2) {
          var i2, o2, a2, s2;
          if (t2 < r2) {
            if (s2 = e2.input.slice(t2, r2), n2) for (i2 = 0, o2 = s2.length; i2 < o2; i2 += 1) 9 === (a2 = s2.charCodeAt(i2)) || 32 <= a2 && a2 <= 1114111 || A(e2, "expected valid JSON character");
            else l.test(s2) && A(e2, "the stream contains non-printable characters");
            e2.result += s2;
          }
        }
        function F(e2, t2, r2, i2) {
          var o2, a2, s2, l2;
          for (n.isObject(r2) || A(e2, "cannot merge mappings; the provided source object is unacceptable"), s2 = 0, l2 = (o2 = Object.keys(r2)).length; s2 < l2; s2 += 1) a2 = o2[s2], u.call(t2, a2) || (t2[a2] = r2[a2], i2[a2] = true);
        }
        function k(e2, t2, r2, n2, i2, o2, a2, s2) {
          var l2, c2;
          if (Array.isArray(i2)) for (l2 = 0, c2 = (i2 = Array.prototype.slice.call(i2)).length; l2 < c2; l2 += 1) Array.isArray(i2[l2]) && A(e2, "nested arrays are not supported inside keys"), "object" == typeof i2 && "[object Object]" === d(i2[l2]) && (i2[l2] = "[object Object]");
          if ("object" == typeof i2 && "[object Object]" === d(i2) && (i2 = "[object Object]"), i2 = String(i2), null === t2 && (t2 = {}), "tag:yaml.org,2002:merge" === n2) if (Array.isArray(o2)) for (l2 = 0, c2 = o2.length; l2 < c2; l2 += 1) F(e2, t2, o2[l2], r2);
          else F(e2, t2, o2, r2);
          else e2.json || u.call(r2, i2) || !u.call(t2, i2) || (e2.line = a2 || e2.line, e2.position = s2 || e2.position, A(e2, "duplicated mapping key")), t2[i2] = o2, delete r2[i2];
          return t2;
        }
        function P(e2) {
          var t2;
          10 === (t2 = e2.input.charCodeAt(e2.position)) ? e2.position++ : 13 === t2 ? (e2.position++, 10 === e2.input.charCodeAt(e2.position) && e2.position++) : A(e2, "a line break is expected"), e2.line += 1, e2.lineStart = e2.position;
        }
        function I(e2, t2, r2) {
          for (var n2 = 0, i2 = e2.input.charCodeAt(e2.position); 0 !== i2; ) {
            for (; y(i2); ) i2 = e2.input.charCodeAt(++e2.position);
            if (t2 && 35 === i2) do {
              i2 = e2.input.charCodeAt(++e2.position);
            } while (10 !== i2 && 13 !== i2 && 0 !== i2);
            if (!m(i2)) break;
            for (P(e2), i2 = e2.input.charCodeAt(e2.position), n2++, e2.lineIndent = 0; 32 === i2; ) e2.lineIndent++, i2 = e2.input.charCodeAt(++e2.position);
          }
          return -1 !== r2 && 0 !== n2 && e2.lineIndent < r2 && N(e2, "deficient indentation"), n2;
        }
        function L(e2) {
          var t2, r2 = e2.position;
          return !(45 !== (t2 = e2.input.charCodeAt(r2)) && 46 !== t2 || t2 !== e2.input.charCodeAt(r2 + 1) || t2 !== e2.input.charCodeAt(r2 + 2) || (r2 += 3, 0 !== (t2 = e2.input.charCodeAt(r2)) && !v(t2)));
        }
        function M(e2, t2) {
          1 === t2 ? e2.result += " " : t2 > 1 && (e2.result += n.repeat("\n", t2 - 1));
        }
        function B(e2, t2) {
          var r2, n2, i2 = e2.tag, o2 = e2.anchor, a2 = [], s2 = false;
          for (null !== e2.anchor && (e2.anchorMap[e2.anchor] = a2), n2 = e2.input.charCodeAt(e2.position); 0 !== n2 && 45 === n2 && v(e2.input.charCodeAt(e2.position + 1)); ) if (s2 = true, e2.position++, I(e2, true, -1) && e2.lineIndent <= t2) a2.push(null), n2 = e2.input.charCodeAt(e2.position);
          else if (r2 = e2.line, z(e2, t2, 3, false, true), a2.push(e2.result), I(e2, true, -1), n2 = e2.input.charCodeAt(e2.position), (e2.line === r2 || e2.lineIndent > t2) && 0 !== n2) A(e2, "bad indentation of a sequence entry");
          else if (e2.lineIndent < t2) break;
          return !!s2 && (e2.tag = i2, e2.anchor = o2, e2.kind = "sequence", e2.result = a2, true);
        }
        function j(e2) {
          var t2, r2, n2, i2, o2 = false, a2 = false;
          if (33 !== (i2 = e2.input.charCodeAt(e2.position))) return false;
          if (null !== e2.tag && A(e2, "duplication of a tag property"), 60 === (i2 = e2.input.charCodeAt(++e2.position)) ? (o2 = true, i2 = e2.input.charCodeAt(++e2.position)) : 33 === i2 ? (a2 = true, r2 = "!!", i2 = e2.input.charCodeAt(++e2.position)) : r2 = "!", t2 = e2.position, o2) {
            do {
              i2 = e2.input.charCodeAt(++e2.position);
            } while (0 !== i2 && 62 !== i2);
            e2.position < e2.length ? (n2 = e2.input.slice(t2, e2.position), i2 = e2.input.charCodeAt(++e2.position)) : A(e2, "unexpected end of the stream within a verbatim tag");
          } else {
            for (; 0 !== i2 && !v(i2); ) 33 === i2 && (a2 ? A(e2, "tag suffix cannot contain exclamation marks") : (r2 = e2.input.slice(t2 - 1, e2.position + 1), p.test(r2) || A(e2, "named tag handle cannot contain such characters"), a2 = true, t2 = e2.position + 1)), i2 = e2.input.charCodeAt(++e2.position);
            n2 = e2.input.slice(t2, e2.position), h.test(n2) && A(e2, "tag suffix cannot contain flow indicator characters");
          }
          return n2 && !f.test(n2) && A(e2, "tag name cannot contain such characters: " + n2), o2 ? e2.tag = n2 : u.call(e2.tagMap, r2) ? e2.tag = e2.tagMap[r2] + n2 : "!" === r2 ? e2.tag = "!" + n2 : "!!" === r2 ? e2.tag = "tag:yaml.org,2002:" + n2 : A(e2, 'undeclared tag handle "' + r2 + '"'), true;
        }
        function R(e2) {
          var t2, r2;
          if (38 !== (r2 = e2.input.charCodeAt(e2.position))) return false;
          for (null !== e2.anchor && A(e2, "duplication of an anchor property"), r2 = e2.input.charCodeAt(++e2.position), t2 = e2.position; 0 !== r2 && !v(r2) && !_(r2); ) r2 = e2.input.charCodeAt(++e2.position);
          return e2.position === t2 && A(e2, "name of an anchor node must contain at least one character"), e2.anchor = e2.input.slice(t2, e2.position), true;
        }
        function z(e2, t2, r2, i2, o2) {
          var a2, s2, l2, c2, h2, p2, f2, d2, b3 = 1, D2 = false, S2 = false;
          if (null !== e2.listener && e2.listener("open", e2), e2.tag = null, e2.anchor = null, e2.kind = null, e2.result = null, a2 = s2 = l2 = 4 === r2 || 3 === r2, i2 && I(e2, true, -1) && (D2 = true, e2.lineIndent > t2 ? b3 = 1 : e2.lineIndent === t2 ? b3 = 0 : e2.lineIndent < t2 && (b3 = -1)), 1 === b3) for (; j(e2) || R(e2); ) I(e2, true, -1) ? (D2 = true, l2 = a2, e2.lineIndent > t2 ? b3 = 1 : e2.lineIndent === t2 ? b3 = 0 : e2.lineIndent < t2 && (b3 = -1)) : l2 = false;
          if (l2 && (l2 = D2 || o2), 1 !== b3 && 4 !== r2 || (f2 = 1 === r2 || 2 === r2 ? t2 : t2 + 1, d2 = e2.position - e2.lineStart, 1 === b3 ? l2 && (B(e2, d2) || function(e3, t3, r3) {
            var n2, i3, o3, a3, s3, u2 = e3.tag, l3 = e3.anchor, c3 = {}, h3 = {}, p3 = null, f3 = null, d3 = null, m2 = false, _2 = false;
            for (null !== e3.anchor && (e3.anchorMap[e3.anchor] = c3), s3 = e3.input.charCodeAt(e3.position); 0 !== s3; ) {
              if (n2 = e3.input.charCodeAt(e3.position + 1), o3 = e3.line, a3 = e3.position, 63 !== s3 && 58 !== s3 || !v(n2)) {
                if (!z(e3, r3, 2, false, true)) break;
                if (e3.line === o3) {
                  for (s3 = e3.input.charCodeAt(e3.position); y(s3); ) s3 = e3.input.charCodeAt(++e3.position);
                  if (58 === s3) v(s3 = e3.input.charCodeAt(++e3.position)) || A(e3, "a whitespace character is expected after the key-value separator within a block mapping"), m2 && (k(e3, c3, h3, p3, f3, null), p3 = f3 = d3 = null), _2 = true, m2 = false, i3 = false, p3 = e3.tag, f3 = e3.result;
                  else {
                    if (!_2) return e3.tag = u2, e3.anchor = l3, true;
                    A(e3, "can not read an implicit mapping pair; a colon is missed");
                  }
                } else {
                  if (!_2) return e3.tag = u2, e3.anchor = l3, true;
                  A(e3, "can not read a block mapping entry; a multiline key may not be an implicit key");
                }
              } else 63 === s3 ? (m2 && (k(e3, c3, h3, p3, f3, null), p3 = f3 = d3 = null), _2 = true, m2 = true, i3 = true) : m2 ? (m2 = false, i3 = true) : A(e3, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e3.position += 1, s3 = n2;
              if ((e3.line === o3 || e3.lineIndent > t3) && (z(e3, t3, 4, true, i3) && (m2 ? f3 = e3.result : d3 = e3.result), m2 || (k(e3, c3, h3, p3, f3, d3, o3, a3), p3 = f3 = d3 = null), I(e3, true, -1), s3 = e3.input.charCodeAt(e3.position)), e3.lineIndent > t3 && 0 !== s3) A(e3, "bad indentation of a mapping entry");
              else if (e3.lineIndent < t3) break;
            }
            return m2 && k(e3, c3, h3, p3, f3, null), _2 && (e3.tag = u2, e3.anchor = l3, e3.kind = "mapping", e3.result = c3), _2;
          }(e2, d2, f2)) || function(e3, t3) {
            var r3, n2, i3, o3, a3, s3, u2, l3, c3, h3, p3 = true, f3 = e3.tag, d3 = e3.anchor, m2 = {};
            if (91 === (h3 = e3.input.charCodeAt(e3.position))) i3 = 93, s3 = false, n2 = [];
            else {
              if (123 !== h3) return false;
              i3 = 125, s3 = true, n2 = {};
            }
            for (null !== e3.anchor && (e3.anchorMap[e3.anchor] = n2), h3 = e3.input.charCodeAt(++e3.position); 0 !== h3; ) {
              if (I(e3, true, t3), (h3 = e3.input.charCodeAt(e3.position)) === i3) return e3.position++, e3.tag = f3, e3.anchor = d3, e3.kind = s3 ? "mapping" : "sequence", e3.result = n2, true;
              p3 || A(e3, "missed comma between flow collection entries"), c3 = null, o3 = a3 = false, 63 === h3 && v(e3.input.charCodeAt(e3.position + 1)) && (o3 = a3 = true, e3.position++, I(e3, true, t3)), r3 = e3.line, z(e3, t3, 1, false, true), l3 = e3.tag, u2 = e3.result, I(e3, true, t3), h3 = e3.input.charCodeAt(e3.position), !a3 && e3.line !== r3 || 58 !== h3 || (o3 = true, h3 = e3.input.charCodeAt(++e3.position), I(e3, true, t3), z(e3, t3, 1, false, true), c3 = e3.result), s3 ? k(e3, n2, m2, l3, u2, c3) : o3 ? n2.push(k(e3, null, m2, l3, u2, c3)) : n2.push(u2), I(e3, true, t3), 44 === (h3 = e3.input.charCodeAt(e3.position)) ? (p3 = true, h3 = e3.input.charCodeAt(++e3.position)) : p3 = false;
            }
            A(e3, "unexpected end of the stream within a flow collection");
          }(e2, f2) ? S2 = true : (s2 && function(e3, t3) {
            var r3, i3, o3, a3, s3, u2 = 1, l3 = false, c3 = false, h3 = t3, p3 = 0, f3 = false;
            if (124 === (a3 = e3.input.charCodeAt(e3.position))) i3 = false;
            else {
              if (62 !== a3) return false;
              i3 = true;
            }
            for (e3.kind = "scalar", e3.result = ""; 0 !== a3; ) if (43 === (a3 = e3.input.charCodeAt(++e3.position)) || 45 === a3) 1 === u2 ? u2 = 43 === a3 ? 3 : 2 : A(e3, "repeat of a chomping mode identifier");
            else {
              if (!((o3 = 48 <= (s3 = a3) && s3 <= 57 ? s3 - 48 : -1) >= 0)) break;
              0 === o3 ? A(e3, "bad explicit indentation width of a block scalar; it cannot be less than one") : c3 ? A(e3, "repeat of an indentation width identifier") : (h3 = t3 + o3 - 1, c3 = true);
            }
            if (y(a3)) {
              do {
                a3 = e3.input.charCodeAt(++e3.position);
              } while (y(a3));
              if (35 === a3) do {
                a3 = e3.input.charCodeAt(++e3.position);
              } while (!m(a3) && 0 !== a3);
            }
            for (; 0 !== a3; ) {
              for (P(e3), e3.lineIndent = 0, a3 = e3.input.charCodeAt(e3.position); (!c3 || e3.lineIndent < h3) && 32 === a3; ) e3.lineIndent++, a3 = e3.input.charCodeAt(++e3.position);
              if (!c3 && e3.lineIndent > h3 && (h3 = e3.lineIndent), m(a3)) p3++;
              else {
                if (e3.lineIndent < h3) {
                  3 === u2 ? e3.result += n.repeat("\n", l3 ? 1 + p3 : p3) : 1 === u2 && l3 && (e3.result += "\n");
                  break;
                }
                for (i3 ? y(a3) ? (f3 = true, e3.result += n.repeat("\n", l3 ? 1 + p3 : p3)) : f3 ? (f3 = false, e3.result += n.repeat("\n", p3 + 1)) : 0 === p3 ? l3 && (e3.result += " ") : e3.result += n.repeat("\n", p3) : e3.result += n.repeat("\n", l3 ? 1 + p3 : p3), l3 = true, c3 = true, p3 = 0, r3 = e3.position; !m(a3) && 0 !== a3; ) a3 = e3.input.charCodeAt(++e3.position);
                O(e3, r3, e3.position, false);
              }
            }
            return true;
          }(e2, f2) || function(e3, t3) {
            var r3, n2, i3;
            if (39 !== (r3 = e3.input.charCodeAt(e3.position))) return false;
            for (e3.kind = "scalar", e3.result = "", e3.position++, n2 = i3 = e3.position; 0 !== (r3 = e3.input.charCodeAt(e3.position)); ) if (39 === r3) {
              if (O(e3, n2, e3.position, true), 39 !== (r3 = e3.input.charCodeAt(++e3.position))) return true;
              n2 = e3.position, e3.position++, i3 = e3.position;
            } else m(r3) ? (O(e3, n2, i3, true), M(e3, I(e3, false, t3)), n2 = i3 = e3.position) : e3.position === e3.lineStart && L(e3) ? A(e3, "unexpected end of the document within a single quoted scalar") : (e3.position++, i3 = e3.position);
            A(e3, "unexpected end of the stream within a single quoted scalar");
          }(e2, f2) || function(e3, t3) {
            var r3, n2, i3, o3, a3, s3, u2;
            if (34 !== (s3 = e3.input.charCodeAt(e3.position))) return false;
            for (e3.kind = "scalar", e3.result = "", e3.position++, r3 = n2 = e3.position; 0 !== (s3 = e3.input.charCodeAt(e3.position)); ) {
              if (34 === s3) return O(e3, r3, e3.position, true), e3.position++, true;
              if (92 === s3) {
                if (O(e3, r3, e3.position, true), m(s3 = e3.input.charCodeAt(++e3.position))) I(e3, false, t3);
                else if (s3 < 256 && w[s3]) e3.result += E[s3], e3.position++;
                else if ((a3 = 120 === (u2 = s3) ? 2 : 117 === u2 ? 4 : 85 === u2 ? 8 : 0) > 0) {
                  for (i3 = a3, o3 = 0; i3 > 0; i3--) (a3 = g(s3 = e3.input.charCodeAt(++e3.position))) >= 0 ? o3 = (o3 << 4) + a3 : A(e3, "expected hexadecimal character");
                  e3.result += x(o3), e3.position++;
                } else A(e3, "unknown escape sequence");
                r3 = n2 = e3.position;
              } else m(s3) ? (O(e3, r3, n2, true), M(e3, I(e3, false, t3)), r3 = n2 = e3.position) : e3.position === e3.lineStart && L(e3) ? A(e3, "unexpected end of the document within a double quoted scalar") : (e3.position++, n2 = e3.position);
            }
            A(e3, "unexpected end of the stream within a double quoted scalar");
          }(e2, f2) ? S2 = true : !function(e3) {
            var t3, r3, n2;
            if (42 !== (n2 = e3.input.charCodeAt(e3.position))) return false;
            for (n2 = e3.input.charCodeAt(++e3.position), t3 = e3.position; 0 !== n2 && !v(n2) && !_(n2); ) n2 = e3.input.charCodeAt(++e3.position);
            return e3.position === t3 && A(e3, "name of an alias node must contain at least one character"), r3 = e3.input.slice(t3, e3.position), e3.anchorMap.hasOwnProperty(r3) || A(e3, 'unidentified alias "' + r3 + '"'), e3.result = e3.anchorMap[r3], I(e3, true, -1), true;
          }(e2) ? function(e3, t3, r3) {
            var n2, i3, o3, a3, s3, u2, l3, c3, h3 = e3.kind, p3 = e3.result;
            if (v(c3 = e3.input.charCodeAt(e3.position)) || _(c3) || 35 === c3 || 38 === c3 || 42 === c3 || 33 === c3 || 124 === c3 || 62 === c3 || 39 === c3 || 34 === c3 || 37 === c3 || 64 === c3 || 96 === c3) return false;
            if ((63 === c3 || 45 === c3) && (v(n2 = e3.input.charCodeAt(e3.position + 1)) || r3 && _(n2))) return false;
            for (e3.kind = "scalar", e3.result = "", i3 = o3 = e3.position, a3 = false; 0 !== c3; ) {
              if (58 === c3) {
                if (v(n2 = e3.input.charCodeAt(e3.position + 1)) || r3 && _(n2)) break;
              } else if (35 === c3) {
                if (v(e3.input.charCodeAt(e3.position - 1))) break;
              } else {
                if (e3.position === e3.lineStart && L(e3) || r3 && _(c3)) break;
                if (m(c3)) {
                  if (s3 = e3.line, u2 = e3.lineStart, l3 = e3.lineIndent, I(e3, false, -1), e3.lineIndent >= t3) {
                    a3 = true, c3 = e3.input.charCodeAt(e3.position);
                    continue;
                  }
                  e3.position = o3, e3.line = s3, e3.lineStart = u2, e3.lineIndent = l3;
                  break;
                }
              }
              a3 && (O(e3, i3, o3, false), M(e3, e3.line - s3), i3 = o3 = e3.position, a3 = false), y(c3) || (o3 = e3.position + 1), c3 = e3.input.charCodeAt(++e3.position);
            }
            return O(e3, i3, o3, false), !!e3.result || (e3.kind = h3, e3.result = p3, false);
          }(e2, f2, 1 === r2) && (S2 = true, null === e2.tag && (e2.tag = "?")) : (S2 = true, null === e2.tag && null === e2.anchor || A(e2, "alias node should not have any properties")), null !== e2.anchor && (e2.anchorMap[e2.anchor] = e2.result)) : 0 === b3 && (S2 = l2 && B(e2, d2))), null !== e2.tag && "!" !== e2.tag) if ("?" === e2.tag) {
            for (null !== e2.result && "scalar" !== e2.kind && A(e2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e2.kind + '"'), c2 = 0, h2 = e2.implicitTypes.length; c2 < h2; c2 += 1) if ((p2 = e2.implicitTypes[c2]).resolve(e2.result)) {
              e2.result = p2.construct(e2.result), e2.tag = p2.tag, null !== e2.anchor && (e2.anchorMap[e2.anchor] = e2.result);
              break;
            }
          } else u.call(e2.typeMap[e2.kind || "fallback"], e2.tag) ? (p2 = e2.typeMap[e2.kind || "fallback"][e2.tag], null !== e2.result && p2.kind !== e2.kind && A(e2, "unacceptable node kind for !<" + e2.tag + '> tag; it should be "' + p2.kind + '", not "' + e2.kind + '"'), p2.resolve(e2.result) ? (e2.result = p2.construct(e2.result), null !== e2.anchor && (e2.anchorMap[e2.anchor] = e2.result)) : A(e2, "cannot resolve a node with !<" + e2.tag + "> explicit tag")) : A(e2, "unknown tag !<" + e2.tag + ">");
          return null !== e2.listener && e2.listener("close", e2), null !== e2.tag || null !== e2.anchor || S2;
        }
        function U(e2) {
          var t2, r2, n2, i2, o2 = e2.position, a2 = false;
          for (e2.version = null, e2.checkLineBreaks = e2.legacy, e2.tagMap = {}, e2.anchorMap = {}; 0 !== (i2 = e2.input.charCodeAt(e2.position)) && (I(e2, true, -1), i2 = e2.input.charCodeAt(e2.position), !(e2.lineIndent > 0 || 37 !== i2)); ) {
            for (a2 = true, i2 = e2.input.charCodeAt(++e2.position), t2 = e2.position; 0 !== i2 && !v(i2); ) i2 = e2.input.charCodeAt(++e2.position);
            for (n2 = [], (r2 = e2.input.slice(t2, e2.position)).length < 1 && A(e2, "directive name must not be less than one character in length"); 0 !== i2; ) {
              for (; y(i2); ) i2 = e2.input.charCodeAt(++e2.position);
              if (35 === i2) {
                do {
                  i2 = e2.input.charCodeAt(++e2.position);
                } while (0 !== i2 && !m(i2));
                break;
              }
              if (m(i2)) break;
              for (t2 = e2.position; 0 !== i2 && !v(i2); ) i2 = e2.input.charCodeAt(++e2.position);
              n2.push(e2.input.slice(t2, e2.position));
            }
            0 !== i2 && P(e2), u.call(T, r2) ? T[r2](e2, r2, n2) : N(e2, 'unknown document directive "' + r2 + '"');
          }
          I(e2, true, -1), 0 === e2.lineIndent && 45 === e2.input.charCodeAt(e2.position) && 45 === e2.input.charCodeAt(e2.position + 1) && 45 === e2.input.charCodeAt(e2.position + 2) ? (e2.position += 3, I(e2, true, -1)) : a2 && A(e2, "directives end mark is expected"), z(e2, e2.lineIndent - 1, 4, false, true), I(e2, true, -1), e2.checkLineBreaks && c.test(e2.input.slice(o2, e2.position)) && N(e2, "non-ASCII line breaks are interpreted as content"), e2.documents.push(e2.result), e2.position === e2.lineStart && L(e2) ? 46 === e2.input.charCodeAt(e2.position) && (e2.position += 3, I(e2, true, -1)) : e2.position < e2.length - 1 && A(e2, "end of the stream or a document separator is expected");
        }
        function G(e2, t2) {
          t2 = t2 || {}, 0 !== (e2 = String(e2)).length && (10 !== e2.charCodeAt(e2.length - 1) && 13 !== e2.charCodeAt(e2.length - 1) && (e2 += "\n"), 65279 === e2.charCodeAt(0) && (e2 = e2.slice(1)));
          var r2 = new S(e2, t2), n2 = e2.indexOf("\0");
          for (-1 !== n2 && (r2.position = n2, A(r2, "null byte is not allowed in input")), r2.input += "\0"; 32 === r2.input.charCodeAt(r2.position); ) r2.lineIndent += 1, r2.position += 1;
          for (; r2.position < r2.length - 1; ) U(r2);
          return r2.documents;
        }
        function X(e2, t2, r2) {
          null !== t2 && "object" == typeof t2 && void 0 === r2 && (r2 = t2, t2 = null);
          var n2 = G(e2, r2);
          if ("function" != typeof t2) return n2;
          for (var i2 = 0, o2 = n2.length; i2 < o2; i2 += 1) t2(n2[i2]);
        }
        function q(e2, t2) {
          var r2 = G(e2, t2);
          if (0 !== r2.length) {
            if (1 === r2.length) return r2[0];
            throw new i("expected a single document in the stream, but found more");
          }
        }
        e.exports.loadAll = X, e.exports.load = q, e.exports.safeLoadAll = function(e2, t2, r2) {
          return "object" == typeof t2 && null !== t2 && void 0 === r2 && (r2 = t2, t2 = null), X(e2, t2, n.extend({ schema: a }, r2));
        }, e.exports.safeLoad = function(e2, t2) {
          return q(e2, n.extend({ schema: a }, t2));
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(38);
        function i(e2, t2, r2, n2, i2) {
          this.name = e2, this.buffer = t2, this.position = r2, this.line = n2, this.column = i2;
        }
        i.prototype.getSnippet = function(e2, t2) {
          var r2, i2, o, a, s;
          if (!this.buffer) return null;
          for (e2 = e2 || 4, t2 = t2 || 75, r2 = "", i2 = this.position; i2 > 0 && -1 === "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(i2 - 1)); ) if (i2 -= 1, this.position - i2 > t2 / 2 - 1) {
            r2 = " ... ", i2 += 5;
            break;
          }
          for (o = "", a = this.position; a < this.buffer.length && -1 === "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(a)); ) if ((a += 1) - this.position > t2 / 2 - 1) {
            o = " ... ", a -= 5;
            break;
          }
          return s = this.buffer.slice(i2, a), n.repeat(" ", e2) + r2 + s + o + "\n" + n.repeat(" ", e2 + this.position - i2 + r2.length) + "^";
        }, i.prototype.toString = function(e2) {
          var t2, r2 = "";
          return this.name && (r2 += 'in "' + this.name + '" '), r2 += "at line " + (this.line + 1) + ", column " + (this.column + 1), e2 || (t2 = this.getSnippet()) && (r2 += ":\n" + t2), r2;
        }, e.exports = i;
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:str", { kind: "scalar", construct: function(e2) {
          return null !== e2 ? e2 : "";
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:seq", { kind: "sequence", construct: function(e2) {
          return null !== e2 ? e2 : [];
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:map", { kind: "mapping", construct: function(e2) {
          return null !== e2 ? e2 : {};
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:null", { kind: "scalar", resolve: function(e2) {
          if (null === e2) return true;
          var t2 = e2.length;
          return 1 === t2 && "~" === e2 || 4 === t2 && ("null" === e2 || "Null" === e2 || "NULL" === e2);
        }, construct: function() {
          return null;
        }, predicate: function(e2) {
          return null === e2;
        }, represent: { canonical: function() {
          return "~";
        }, lowercase: function() {
          return "null";
        }, uppercase: function() {
          return "NULL";
        }, camelcase: function() {
          return "Null";
        } }, defaultStyle: "lowercase" });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:bool", { kind: "scalar", resolve: function(e2) {
          if (null === e2) return false;
          var t2 = e2.length;
          return 4 === t2 && ("true" === e2 || "True" === e2 || "TRUE" === e2) || 5 === t2 && ("false" === e2 || "False" === e2 || "FALSE" === e2);
        }, construct: function(e2) {
          return "true" === e2 || "True" === e2 || "TRUE" === e2;
        }, predicate: function(e2) {
          return "[object Boolean]" === Object.prototype.toString.call(e2);
        }, represent: { lowercase: function(e2) {
          return e2 ? "true" : "false";
        }, uppercase: function(e2) {
          return e2 ? "TRUE" : "FALSE";
        }, camelcase: function(e2) {
          return e2 ? "True" : "False";
        } }, defaultStyle: "lowercase" });
      }, function(e, t, r) {
        "use strict";
        var n = r(38), i = r(10);
        function o(e2) {
          return 48 <= e2 && e2 <= 55;
        }
        function a(e2) {
          return 48 <= e2 && e2 <= 57;
        }
        e.exports = new i("tag:yaml.org,2002:int", { kind: "scalar", resolve: function(e2) {
          if (null === e2) return false;
          var t2, r2, n2 = e2.length, i2 = 0, s = false;
          if (!n2) return false;
          if ("-" !== (t2 = e2[i2]) && "+" !== t2 || (t2 = e2[++i2]), "0" === t2) {
            if (i2 + 1 === n2) return true;
            if ("b" === (t2 = e2[++i2])) {
              for (i2++; i2 < n2; i2++) if ("_" !== (t2 = e2[i2])) {
                if ("0" !== t2 && "1" !== t2) return false;
                s = true;
              }
              return s && "_" !== t2;
            }
            if ("x" === t2) {
              for (i2++; i2 < n2; i2++) if ("_" !== (t2 = e2[i2])) {
                if (!(48 <= (r2 = e2.charCodeAt(i2)) && r2 <= 57 || 65 <= r2 && r2 <= 70 || 97 <= r2 && r2 <= 102)) return false;
                s = true;
              }
              return s && "_" !== t2;
            }
            for (; i2 < n2; i2++) if ("_" !== (t2 = e2[i2])) {
              if (!o(e2.charCodeAt(i2))) return false;
              s = true;
            }
            return s && "_" !== t2;
          }
          if ("_" === t2) return false;
          for (; i2 < n2; i2++) if ("_" !== (t2 = e2[i2])) {
            if (":" === t2) break;
            if (!a(e2.charCodeAt(i2))) return false;
            s = true;
          }
          return !(!s || "_" === t2) && (":" !== t2 || /^(:[0-5]?[0-9])+$/.test(e2.slice(i2)));
        }, construct: function(e2) {
          var t2, r2, n2 = e2, i2 = 1, o2 = [];
          return -1 !== n2.indexOf("_") && (n2 = n2.replace(/_/g, "")), "-" !== (t2 = n2[0]) && "+" !== t2 || ("-" === t2 && (i2 = -1), t2 = (n2 = n2.slice(1))[0]), "0" === n2 ? 0 : "0" === t2 ? "b" === n2[1] ? i2 * parseInt(n2.slice(2), 2) : "x" === n2[1] ? i2 * parseInt(n2, 16) : i2 * parseInt(n2, 8) : -1 !== n2.indexOf(":") ? (n2.split(":").forEach(function(e3) {
            o2.unshift(parseInt(e3, 10));
          }), n2 = 0, r2 = 1, o2.forEach(function(e3) {
            n2 += e3 * r2, r2 *= 60;
          }), i2 * n2) : i2 * parseInt(n2, 10);
        }, predicate: function(e2) {
          return "[object Number]" === Object.prototype.toString.call(e2) && e2 % 1 == 0 && !n.isNegativeZero(e2);
        }, represent: { binary: function(e2) {
          return e2 >= 0 ? "0b" + e2.toString(2) : "-0b" + e2.toString(2).slice(1);
        }, octal: function(e2) {
          return e2 >= 0 ? "0" + e2.toString(8) : "-0" + e2.toString(8).slice(1);
        }, decimal: function(e2) {
          return e2.toString(10);
        }, hexadecimal: function(e2) {
          return e2 >= 0 ? "0x" + e2.toString(16).toUpperCase() : "-0x" + e2.toString(16).toUpperCase().slice(1);
        } }, defaultStyle: "decimal", styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] } });
      }, function(e, t, r) {
        "use strict";
        var n = r(38), i = r(10), o = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
        var a = /^[-+]?[0-9]+e/;
        e.exports = new i("tag:yaml.org,2002:float", { kind: "scalar", resolve: function(e2) {
          return null !== e2 && !(!o.test(e2) || "_" === e2[e2.length - 1]);
        }, construct: function(e2) {
          var t2, r2, n2, i2;
          return r2 = "-" === (t2 = e2.replace(/_/g, "").toLowerCase())[0] ? -1 : 1, i2 = [], "+-".indexOf(t2[0]) >= 0 && (t2 = t2.slice(1)), ".inf" === t2 ? 1 === r2 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : ".nan" === t2 ? NaN : t2.indexOf(":") >= 0 ? (t2.split(":").forEach(function(e3) {
            i2.unshift(parseFloat(e3, 10));
          }), t2 = 0, n2 = 1, i2.forEach(function(e3) {
            t2 += e3 * n2, n2 *= 60;
          }), r2 * t2) : r2 * parseFloat(t2, 10);
        }, predicate: function(e2) {
          return "[object Number]" === Object.prototype.toString.call(e2) && (e2 % 1 != 0 || n.isNegativeZero(e2));
        }, represent: function(e2, t2) {
          var r2;
          if (isNaN(e2)) switch (t2) {
            case "lowercase":
              return ".nan";
            case "uppercase":
              return ".NAN";
            case "camelcase":
              return ".NaN";
          }
          else if (Number.POSITIVE_INFINITY === e2) switch (t2) {
            case "lowercase":
              return ".inf";
            case "uppercase":
              return ".INF";
            case "camelcase":
              return ".Inf";
          }
          else if (Number.NEGATIVE_INFINITY === e2) switch (t2) {
            case "lowercase":
              return "-.inf";
            case "uppercase":
              return "-.INF";
            case "camelcase":
              return "-.Inf";
          }
          else if (n.isNegativeZero(e2)) return "-0.0";
          return r2 = e2.toString(10), a.test(r2) ? r2.replace("e", ".e") : r2;
        }, defaultStyle: "lowercase" });
      }, function(e, t, r) {
        "use strict";
        var n = r(10), i = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), o = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
        e.exports = new n("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: function(e2) {
          return null !== e2 && (null !== i.exec(e2) || null !== o.exec(e2));
        }, construct: function(e2) {
          var t2, r2, n2, a, s, u, l, c, h = 0, p = null;
          if (null === (t2 = i.exec(e2)) && (t2 = o.exec(e2)), null === t2) throw new Error("Date resolve error");
          if (r2 = +t2[1], n2 = +t2[2] - 1, a = +t2[3], !t2[4]) return new Date(Date.UTC(r2, n2, a));
          if (s = +t2[4], u = +t2[5], l = +t2[6], t2[7]) {
            for (h = t2[7].slice(0, 3); h.length < 3; ) h += "0";
            h = +h;
          }
          return t2[9] && (p = 6e4 * (60 * +t2[10] + +(t2[11] || 0)), "-" === t2[9] && (p = -p)), c = new Date(Date.UTC(r2, n2, a, s, u, l, h)), p && c.setTime(c.getTime() - p), c;
        }, instanceOf: Date, represent: function(e2) {
          return e2.toISOString();
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:merge", { kind: "scalar", resolve: function(e2) {
          return "<<" === e2 || null === e2;
        } });
      }, function(e, t, r) {
        "use strict";
        var n;
        try {
          n = r(145).Buffer;
        } catch (e2) {
        }
        var i = r(10), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
        e.exports = new i("tag:yaml.org,2002:binary", { kind: "scalar", resolve: function(e2) {
          if (null === e2) return false;
          var t2, r2, n2 = 0, i2 = e2.length, a = o;
          for (r2 = 0; r2 < i2; r2++) if (!((t2 = a.indexOf(e2.charAt(r2))) > 64)) {
            if (t2 < 0) return false;
            n2 += 6;
          }
          return n2 % 8 == 0;
        }, construct: function(e2) {
          var t2, r2, i2 = e2.replace(/[\r\n=]/g, ""), a = i2.length, s = o, u = 0, l = [];
          for (t2 = 0; t2 < a; t2++) t2 % 4 == 0 && t2 && (l.push(u >> 16 & 255), l.push(u >> 8 & 255), l.push(255 & u)), u = u << 6 | s.indexOf(i2.charAt(t2));
          return 0 === (r2 = a % 4 * 6) ? (l.push(u >> 16 & 255), l.push(u >> 8 & 255), l.push(255 & u)) : 18 === r2 ? (l.push(u >> 10 & 255), l.push(u >> 2 & 255)) : 12 === r2 && l.push(u >> 4 & 255), n ? n.from ? n.from(l) : new n(l) : l;
        }, predicate: function(e2) {
          return n && n.isBuffer(e2);
        }, represent: function(e2) {
          var t2, r2, n2 = "", i2 = 0, a = e2.length, s = o;
          for (t2 = 0; t2 < a; t2++) t2 % 3 == 0 && t2 && (n2 += s[i2 >> 18 & 63], n2 += s[i2 >> 12 & 63], n2 += s[i2 >> 6 & 63], n2 += s[63 & i2]), i2 = (i2 << 8) + e2[t2];
          return 0 === (r2 = a % 3) ? (n2 += s[i2 >> 18 & 63], n2 += s[i2 >> 12 & 63], n2 += s[i2 >> 6 & 63], n2 += s[63 & i2]) : 2 === r2 ? (n2 += s[i2 >> 10 & 63], n2 += s[i2 >> 4 & 63], n2 += s[i2 << 2 & 63], n2 += s[64]) : 1 === r2 && (n2 += s[i2 >> 2 & 63], n2 += s[i2 << 4 & 63], n2 += s[64], n2 += s[64]), n2;
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10), i = Object.prototype.hasOwnProperty, o = Object.prototype.toString;
        e.exports = new n("tag:yaml.org,2002:omap", { kind: "sequence", resolve: function(e2) {
          if (null === e2) return true;
          var t2, r2, n2, a, s, u = [], l = e2;
          for (t2 = 0, r2 = l.length; t2 < r2; t2 += 1) {
            if (n2 = l[t2], s = false, "[object Object]" !== o.call(n2)) return false;
            for (a in n2) if (i.call(n2, a)) {
              if (s) return false;
              s = true;
            }
            if (!s) return false;
            if (-1 !== u.indexOf(a)) return false;
            u.push(a);
          }
          return true;
        }, construct: function(e2) {
          return null !== e2 ? e2 : [];
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10), i = Object.prototype.toString;
        e.exports = new n("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: function(e2) {
          if (null === e2) return true;
          var t2, r2, n2, o, a, s = e2;
          for (a = new Array(s.length), t2 = 0, r2 = s.length; t2 < r2; t2 += 1) {
            if (n2 = s[t2], "[object Object]" !== i.call(n2)) return false;
            if (1 !== (o = Object.keys(n2)).length) return false;
            a[t2] = [o[0], n2[o[0]]];
          }
          return true;
        }, construct: function(e2) {
          if (null === e2) return [];
          var t2, r2, n2, i2, o, a = e2;
          for (o = new Array(a.length), t2 = 0, r2 = a.length; t2 < r2; t2 += 1) n2 = a[t2], i2 = Object.keys(n2), o[t2] = [i2[0], n2[i2[0]]];
          return o;
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10), i = Object.prototype.hasOwnProperty;
        e.exports = new n("tag:yaml.org,2002:set", { kind: "mapping", resolve: function(e2) {
          if (null === e2) return true;
          var t2, r2 = e2;
          for (t2 in r2) if (i.call(r2, t2) && null !== r2[t2]) return false;
          return true;
        }, construct: function(e2) {
          return null !== e2 ? e2 : {};
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:js/undefined", { kind: "scalar", resolve: function() {
          return true;
        }, construct: function() {
        }, predicate: function(e2) {
          return void 0 === e2;
        }, represent: function() {
          return "";
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:js/regexp", { kind: "scalar", resolve: function(e2) {
          if (null === e2) return false;
          if (0 === e2.length) return false;
          var t2 = e2, r2 = /\/([gim]*)$/.exec(e2), n2 = "";
          if ("/" === t2[0]) {
            if (r2 && (n2 = r2[1]), n2.length > 3) return false;
            if ("/" !== t2[t2.length - n2.length - 1]) return false;
          }
          return true;
        }, construct: function(e2) {
          var t2 = e2, r2 = /\/([gim]*)$/.exec(e2), n2 = "";
          return "/" === t2[0] && (r2 && (n2 = r2[1]), t2 = t2.slice(1, t2.length - n2.length - 1)), new RegExp(t2, n2);
        }, predicate: function(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }, represent: function(e2) {
          var t2 = "/" + e2.source + "/";
          return e2.global && (t2 += "g"), e2.multiline && (t2 += "m"), e2.ignoreCase && (t2 += "i"), t2;
        } });
      }, function(e, t, r) {
        "use strict";
        var n;
        try {
          n = r(302);
        } catch (e2) {
          "undefined" != typeof window && (n = window.esprima);
        }
        var i = r(10);
        e.exports = new i("tag:yaml.org,2002:js/function", { kind: "scalar", resolve: function(e2) {
          if (null === e2) return false;
          try {
            var t2 = "(" + e2 + ")", r2 = n.parse(t2, { range: true });
            return "Program" === r2.type && 1 === r2.body.length && "ExpressionStatement" === r2.body[0].type && ("ArrowFunctionExpression" === r2.body[0].expression.type || "FunctionExpression" === r2.body[0].expression.type);
          } catch (e3) {
            return false;
          }
        }, construct: function(e2) {
          var t2, r2 = "(" + e2 + ")", i2 = n.parse(r2, { range: true }), o = [];
          if ("Program" !== i2.type || 1 !== i2.body.length || "ExpressionStatement" !== i2.body[0].type || "ArrowFunctionExpression" !== i2.body[0].expression.type && "FunctionExpression" !== i2.body[0].expression.type) throw new Error("Failed to resolve function");
          return i2.body[0].expression.params.forEach(function(e3) {
            o.push(e3.name);
          }), t2 = i2.body[0].expression.body.range, "BlockStatement" === i2.body[0].expression.body.type ? new Function(o, r2.slice(t2[0] + 1, t2[1] - 1)) : new Function(o, "return " + r2.slice(t2[0], t2[1]));
        }, predicate: function(e2) {
          return "[object Function]" === Object.prototype.toString.call(e2);
        }, represent: function(e2) {
          return e2.toString();
        } });
      }, function(e, t, r) {
        var n;
        n = function() {
          return function(e2) {
            var t2 = {};
            function r2(n2) {
              if (t2[n2]) return t2[n2].exports;
              var i = t2[n2] = { exports: {}, id: n2, loaded: false };
              return e2[n2].call(i.exports, i, i.exports, r2), i.loaded = true, i.exports;
            }
            return r2.m = e2, r2.c = t2, r2.p = "", r2(0);
          }([function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(1), i = r2(3), o = r2(8), a = r2(15);
            function s(e3, t3, r3) {
              var a2 = null, s2 = function(e4, t4) {
                r3 && r3(e4, t4), a2 && a2.visit(e4, t4);
              }, u2 = "function" == typeof r3 ? s2 : null, l = false;
              if (t3) {
                l = "boolean" == typeof t3.comment && t3.comment;
                var c = "boolean" == typeof t3.attachComment && t3.attachComment;
                (l || c) && ((a2 = new n2.CommentHandler()).attach = c, t3.comment = true, u2 = s2);
              }
              var h, p = false;
              t3 && "string" == typeof t3.sourceType && (p = "module" === t3.sourceType), h = t3 && "boolean" == typeof t3.jsx && t3.jsx ? new i.JSXParser(e3, t3, u2) : new o.Parser(e3, t3, u2);
              var f = p ? h.parseModule() : h.parseScript();
              return l && a2 && (f.comments = a2.comments), h.config.tokens && (f.tokens = h.tokens), h.config.tolerant && (f.errors = h.errorHandler.errors), f;
            }
            t2.parse = s, t2.parseModule = function(e3, t3, r3) {
              var n3 = t3 || {};
              return n3.sourceType = "module", s(e3, n3, r3);
            }, t2.parseScript = function(e3, t3, r3) {
              var n3 = t3 || {};
              return n3.sourceType = "script", s(e3, n3, r3);
            }, t2.tokenize = function(e3, t3, r3) {
              var n3, i2 = new a.Tokenizer(e3, t3);
              n3 = [];
              try {
                for (; ; ) {
                  var o2 = i2.getNextToken();
                  if (!o2) break;
                  r3 && (o2 = r3(o2)), n3.push(o2);
                }
              } catch (e4) {
                i2.errorHandler.tolerate(e4);
              }
              return i2.errorHandler.tolerant && (n3.errors = i2.errors()), n3;
            };
            var u = r2(2);
            t2.Syntax = u.Syntax, t2.version = "4.0.1";
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(2), i = function() {
              function e3() {
                this.attach = false, this.comments = [], this.stack = [], this.leading = [], this.trailing = [];
              }
              return e3.prototype.insertInnerComments = function(e4, t3) {
                if (e4.type === n2.Syntax.BlockStatement && 0 === e4.body.length) {
                  for (var r3 = [], i2 = this.leading.length - 1; i2 >= 0; --i2) {
                    var o = this.leading[i2];
                    t3.end.offset >= o.start && (r3.unshift(o.comment), this.leading.splice(i2, 1), this.trailing.splice(i2, 1));
                  }
                  r3.length && (e4.innerComments = r3);
                }
              }, e3.prototype.findTrailingComments = function(e4) {
                var t3 = [];
                if (this.trailing.length > 0) {
                  for (var r3 = this.trailing.length - 1; r3 >= 0; --r3) {
                    var n3 = this.trailing[r3];
                    n3.start >= e4.end.offset && t3.unshift(n3.comment);
                  }
                  return this.trailing.length = 0, t3;
                }
                var i2 = this.stack[this.stack.length - 1];
                if (i2 && i2.node.trailingComments) {
                  var o = i2.node.trailingComments[0];
                  o && o.range[0] >= e4.end.offset && (t3 = i2.node.trailingComments, delete i2.node.trailingComments);
                }
                return t3;
              }, e3.prototype.findLeadingComments = function(e4) {
                for (var t3, r3 = []; this.stack.length > 0 && ((o = this.stack[this.stack.length - 1]) && o.start >= e4.start.offset); ) t3 = o.node, this.stack.pop();
                if (t3) {
                  for (var n3 = (t3.leadingComments ? t3.leadingComments.length : 0) - 1; n3 >= 0; --n3) {
                    var i2 = t3.leadingComments[n3];
                    i2.range[1] <= e4.start.offset && (r3.unshift(i2), t3.leadingComments.splice(n3, 1));
                  }
                  return t3.leadingComments && 0 === t3.leadingComments.length && delete t3.leadingComments, r3;
                }
                for (n3 = this.leading.length - 1; n3 >= 0; --n3) {
                  var o;
                  (o = this.leading[n3]).start <= e4.start.offset && (r3.unshift(o.comment), this.leading.splice(n3, 1));
                }
                return r3;
              }, e3.prototype.visitNode = function(e4, t3) {
                if (!(e4.type === n2.Syntax.Program && e4.body.length > 0)) {
                  this.insertInnerComments(e4, t3);
                  var r3 = this.findTrailingComments(t3), i2 = this.findLeadingComments(t3);
                  i2.length > 0 && (e4.leadingComments = i2), r3.length > 0 && (e4.trailingComments = r3), this.stack.push({ node: e4, start: t3.start.offset });
                }
              }, e3.prototype.visitComment = function(e4, t3) {
                var r3 = "L" === e4.type[0] ? "Line" : "Block", n3 = { type: r3, value: e4.value };
                if (e4.range && (n3.range = e4.range), e4.loc && (n3.loc = e4.loc), this.comments.push(n3), this.attach) {
                  var i2 = { comment: { type: r3, value: e4.value, range: [t3.start.offset, t3.end.offset] }, start: t3.start.offset };
                  e4.loc && (i2.comment.loc = e4.loc), e4.type = r3, this.leading.push(i2), this.trailing.push(i2);
                }
              }, e3.prototype.visit = function(e4, t3) {
                "LineComment" === e4.type || "BlockComment" === e4.type ? this.visitComment(e4, t3) : this.attach && this.visitNode(e4, t3);
              }, e3;
            }();
            t2.CommentHandler = i;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.Syntax = { AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", AwaitExpression: "AwaitExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DoWhileStatement: "DoWhileStatement", DebuggerStatement: "DebuggerStatement", EmptyStatement: "EmptyStatement", ExportAllDeclaration: "ExportAllDeclaration", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportSpecifier: "ExportSpecifier", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForOfStatement: "ForOfStatement", ForInStatement: "ForInStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", Identifier: "Identifier", IfStatement: "IfStatement", ImportDeclaration: "ImportDeclaration", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier", ImportSpecifier: "ImportSpecifier", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", Program: "Program", Property: "Property", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchCase: "SwitchCase", SwitchStatement: "SwitchStatement", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression" };
          }, function(e2, t2, r2) {
            "use strict";
            var n2, i = this && this.__extends || (n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
              e3.__proto__ = t3;
            } || function(e3, t3) {
              for (var r3 in t3) t3.hasOwnProperty(r3) && (e3[r3] = t3[r3]);
            }, function(e3, t3) {
              function r3() {
                this.constructor = e3;
              }
              n2(e3, t3), e3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            });
            Object.defineProperty(t2, "__esModule", { value: true });
            var o = r2(4), a = r2(5), s = r2(6), u = r2(7), l = r2(8), c = r2(13), h = r2(14);
            function p(e3) {
              var t3;
              switch (e3.type) {
                case s.JSXSyntax.JSXIdentifier:
                  t3 = e3.name;
                  break;
                case s.JSXSyntax.JSXNamespacedName:
                  var r3 = e3;
                  t3 = p(r3.namespace) + ":" + p(r3.name);
                  break;
                case s.JSXSyntax.JSXMemberExpression:
                  var n3 = e3;
                  t3 = p(n3.object) + "." + p(n3.property);
              }
              return t3;
            }
            c.TokenName[100] = "JSXIdentifier", c.TokenName[101] = "JSXText";
            var f = function(e3) {
              function t3(t4, r3, n3) {
                return e3.call(this, t4, r3, n3) || this;
              }
              return i(t3, e3), t3.prototype.parsePrimaryExpression = function() {
                return this.match("<") ? this.parseJSXRoot() : e3.prototype.parsePrimaryExpression.call(this);
              }, t3.prototype.startJSX = function() {
                this.scanner.index = this.startMarker.index, this.scanner.lineNumber = this.startMarker.line, this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
              }, t3.prototype.finishJSX = function() {
                this.nextToken();
              }, t3.prototype.reenterJSX = function() {
                this.startJSX(), this.expectJSX("}"), this.config.tokens && this.tokens.pop();
              }, t3.prototype.createJSXNode = function() {
                return this.collectComments(), { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart };
              }, t3.prototype.createJSXChildNode = function() {
                return { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart };
              }, t3.prototype.scanXHTMLEntity = function(e4) {
                for (var t4 = "&", r3 = true, n3 = false, i2 = false, a2 = false; !this.scanner.eof() && r3 && !n3; ) {
                  var s2 = this.scanner.source[this.scanner.index];
                  if (s2 === e4) break;
                  if (n3 = ";" === s2, t4 += s2, ++this.scanner.index, !n3) switch (t4.length) {
                    case 2:
                      i2 = "#" === s2;
                      break;
                    case 3:
                      i2 && (r3 = (a2 = "x" === s2) || o.Character.isDecimalDigit(s2.charCodeAt(0)), i2 = i2 && !a2);
                      break;
                    default:
                      r3 = (r3 = r3 && !(i2 && !o.Character.isDecimalDigit(s2.charCodeAt(0)))) && !(a2 && !o.Character.isHexDigit(s2.charCodeAt(0)));
                  }
                }
                if (r3 && n3 && t4.length > 2) {
                  var u2 = t4.substr(1, t4.length - 2);
                  i2 && u2.length > 1 ? t4 = String.fromCharCode(parseInt(u2.substr(1), 10)) : a2 && u2.length > 2 ? t4 = String.fromCharCode(parseInt("0" + u2.substr(1), 16)) : i2 || a2 || !h.XHTMLEntities[u2] || (t4 = h.XHTMLEntities[u2]);
                }
                return t4;
              }, t3.prototype.lexJSX = function() {
                var e4 = this.scanner.source.charCodeAt(this.scanner.index);
                if (60 === e4 || 62 === e4 || 47 === e4 || 58 === e4 || 61 === e4 || 123 === e4 || 125 === e4) return { type: 7, value: s2 = this.scanner.source[this.scanner.index++], lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: this.scanner.index - 1, end: this.scanner.index };
                if (34 === e4 || 39 === e4) {
                  for (var t4 = this.scanner.index, r3 = this.scanner.source[this.scanner.index++], n3 = ""; !this.scanner.eof() && (u2 = this.scanner.source[this.scanner.index++]) !== r3; ) n3 += "&" === u2 ? this.scanXHTMLEntity(r3) : u2;
                  return { type: 8, value: n3, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: t4, end: this.scanner.index };
                }
                if (46 === e4) {
                  var i2 = this.scanner.source.charCodeAt(this.scanner.index + 1), a2 = this.scanner.source.charCodeAt(this.scanner.index + 2), s2 = 46 === i2 && 46 === a2 ? "..." : ".";
                  return t4 = this.scanner.index, this.scanner.index += s2.length, { type: 7, value: s2, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: t4, end: this.scanner.index };
                }
                if (96 === e4) return { type: 10, value: "", lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: this.scanner.index, end: this.scanner.index };
                if (o.Character.isIdentifierStart(e4) && 92 !== e4) {
                  for (t4 = this.scanner.index, ++this.scanner.index; !this.scanner.eof(); ) {
                    var u2 = this.scanner.source.charCodeAt(this.scanner.index);
                    if (o.Character.isIdentifierPart(u2) && 92 !== u2) ++this.scanner.index;
                    else {
                      if (45 !== u2) break;
                      ++this.scanner.index;
                    }
                  }
                  return { type: 100, value: this.scanner.source.slice(t4, this.scanner.index), lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: t4, end: this.scanner.index };
                }
                return this.scanner.lex();
              }, t3.prototype.nextJSXToken = function() {
                this.collectComments(), this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                var e4 = this.lexJSX();
                return this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.config.tokens && this.tokens.push(this.convertToken(e4)), e4;
              }, t3.prototype.nextJSXText = function() {
                this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                for (var e4 = this.scanner.index, t4 = ""; !this.scanner.eof(); ) {
                  var r3 = this.scanner.source[this.scanner.index];
                  if ("{" === r3 || "<" === r3) break;
                  ++this.scanner.index, t4 += r3, o.Character.isLineTerminator(r3.charCodeAt(0)) && (++this.scanner.lineNumber, "\r" === r3 && "\n" === this.scanner.source[this.scanner.index] && ++this.scanner.index, this.scanner.lineStart = this.scanner.index);
                }
                this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                var n3 = { type: 101, value: t4, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: e4, end: this.scanner.index };
                return t4.length > 0 && this.config.tokens && this.tokens.push(this.convertToken(n3)), n3;
              }, t3.prototype.peekJSXToken = function() {
                var e4 = this.scanner.saveState();
                this.scanner.scanComments();
                var t4 = this.lexJSX();
                return this.scanner.restoreState(e4), t4;
              }, t3.prototype.expectJSX = function(e4) {
                var t4 = this.nextJSXToken();
                7 === t4.type && t4.value === e4 || this.throwUnexpectedToken(t4);
              }, t3.prototype.matchJSX = function(e4) {
                var t4 = this.peekJSXToken();
                return 7 === t4.type && t4.value === e4;
              }, t3.prototype.parseJSXIdentifier = function() {
                var e4 = this.createJSXNode(), t4 = this.nextJSXToken();
                return 100 !== t4.type && this.throwUnexpectedToken(t4), this.finalize(e4, new a.JSXIdentifier(t4.value));
              }, t3.prototype.parseJSXElementName = function() {
                var e4 = this.createJSXNode(), t4 = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var r3 = t4;
                  this.expectJSX(":");
                  var n3 = this.parseJSXIdentifier();
                  t4 = this.finalize(e4, new a.JSXNamespacedName(r3, n3));
                } else if (this.matchJSX(".")) for (; this.matchJSX("."); ) {
                  var i2 = t4;
                  this.expectJSX(".");
                  var o2 = this.parseJSXIdentifier();
                  t4 = this.finalize(e4, new a.JSXMemberExpression(i2, o2));
                }
                return t4;
              }, t3.prototype.parseJSXAttributeName = function() {
                var e4, t4 = this.createJSXNode(), r3 = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var n3 = r3;
                  this.expectJSX(":");
                  var i2 = this.parseJSXIdentifier();
                  e4 = this.finalize(t4, new a.JSXNamespacedName(n3, i2));
                } else e4 = r3;
                return e4;
              }, t3.prototype.parseJSXStringLiteralAttribute = function() {
                var e4 = this.createJSXNode(), t4 = this.nextJSXToken();
                8 !== t4.type && this.throwUnexpectedToken(t4);
                var r3 = this.getTokenRaw(t4);
                return this.finalize(e4, new u.Literal(t4.value, r3));
              }, t3.prototype.parseJSXExpressionAttribute = function() {
                var e4 = this.createJSXNode();
                this.expectJSX("{"), this.finishJSX(), this.match("}") && this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                var t4 = this.parseAssignmentExpression();
                return this.reenterJSX(), this.finalize(e4, new a.JSXExpressionContainer(t4));
              }, t3.prototype.parseJSXAttributeValue = function() {
                return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
              }, t3.prototype.parseJSXNameValueAttribute = function() {
                var e4 = this.createJSXNode(), t4 = this.parseJSXAttributeName(), r3 = null;
                return this.matchJSX("=") && (this.expectJSX("="), r3 = this.parseJSXAttributeValue()), this.finalize(e4, new a.JSXAttribute(t4, r3));
              }, t3.prototype.parseJSXSpreadAttribute = function() {
                var e4 = this.createJSXNode();
                this.expectJSX("{"), this.expectJSX("..."), this.finishJSX();
                var t4 = this.parseAssignmentExpression();
                return this.reenterJSX(), this.finalize(e4, new a.JSXSpreadAttribute(t4));
              }, t3.prototype.parseJSXAttributes = function() {
                for (var e4 = []; !this.matchJSX("/") && !this.matchJSX(">"); ) {
                  var t4 = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                  e4.push(t4);
                }
                return e4;
              }, t3.prototype.parseJSXOpeningElement = function() {
                var e4 = this.createJSXNode();
                this.expectJSX("<");
                var t4 = this.parseJSXElementName(), r3 = this.parseJSXAttributes(), n3 = this.matchJSX("/");
                return n3 && this.expectJSX("/"), this.expectJSX(">"), this.finalize(e4, new a.JSXOpeningElement(t4, n3, r3));
              }, t3.prototype.parseJSXBoundaryElement = function() {
                var e4 = this.createJSXNode();
                if (this.expectJSX("<"), this.matchJSX("/")) {
                  this.expectJSX("/");
                  var t4 = this.parseJSXElementName();
                  return this.expectJSX(">"), this.finalize(e4, new a.JSXClosingElement(t4));
                }
                var r3 = this.parseJSXElementName(), n3 = this.parseJSXAttributes(), i2 = this.matchJSX("/");
                return i2 && this.expectJSX("/"), this.expectJSX(">"), this.finalize(e4, new a.JSXOpeningElement(r3, i2, n3));
              }, t3.prototype.parseJSXEmptyExpression = function() {
                var e4 = this.createJSXChildNode();
                return this.collectComments(), this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.finalize(e4, new a.JSXEmptyExpression());
              }, t3.prototype.parseJSXExpressionContainer = function() {
                var e4, t4 = this.createJSXNode();
                return this.expectJSX("{"), this.matchJSX("}") ? (e4 = this.parseJSXEmptyExpression(), this.expectJSX("}")) : (this.finishJSX(), e4 = this.parseAssignmentExpression(), this.reenterJSX()), this.finalize(t4, new a.JSXExpressionContainer(e4));
              }, t3.prototype.parseJSXChildren = function() {
                for (var e4 = []; !this.scanner.eof(); ) {
                  var t4 = this.createJSXChildNode(), r3 = this.nextJSXText();
                  if (r3.start < r3.end) {
                    var n3 = this.getTokenRaw(r3), i2 = this.finalize(t4, new a.JSXText(r3.value, n3));
                    e4.push(i2);
                  }
                  if ("{" !== this.scanner.source[this.scanner.index]) break;
                  var o2 = this.parseJSXExpressionContainer();
                  e4.push(o2);
                }
                return e4;
              }, t3.prototype.parseComplexJSXElement = function(e4) {
                for (var t4 = []; !this.scanner.eof(); ) {
                  e4.children = e4.children.concat(this.parseJSXChildren());
                  var r3 = this.createJSXChildNode(), n3 = this.parseJSXBoundaryElement();
                  if (n3.type === s.JSXSyntax.JSXOpeningElement) {
                    var i2 = n3;
                    if (i2.selfClosing) {
                      var o2 = this.finalize(r3, new a.JSXElement(i2, [], null));
                      e4.children.push(o2);
                    } else t4.push(e4), e4 = { node: r3, opening: i2, closing: null, children: [] };
                  }
                  if (n3.type === s.JSXSyntax.JSXClosingElement) {
                    e4.closing = n3;
                    var u2 = p(e4.opening.name);
                    if (u2 !== p(e4.closing.name) && this.tolerateError("Expected corresponding JSX closing tag for %0", u2), !(t4.length > 0)) break;
                    o2 = this.finalize(e4.node, new a.JSXElement(e4.opening, e4.children, e4.closing)), (e4 = t4[t4.length - 1]).children.push(o2), t4.pop();
                  }
                }
                return e4;
              }, t3.prototype.parseJSXElement = function() {
                var e4 = this.createJSXNode(), t4 = this.parseJSXOpeningElement(), r3 = [], n3 = null;
                if (!t4.selfClosing) {
                  var i2 = this.parseComplexJSXElement({ node: e4, opening: t4, closing: n3, children: r3 });
                  r3 = i2.children, n3 = i2.closing;
                }
                return this.finalize(e4, new a.JSXElement(t4, r3, n3));
              }, t3.prototype.parseJSXRoot = function() {
                this.config.tokens && this.tokens.pop(), this.startJSX();
                var e4 = this.parseJSXElement();
                return this.finishJSX(), e4;
              }, t3.prototype.isStartOfExpression = function() {
                return e3.prototype.isStartOfExpression.call(this) || this.match("<");
              }, t3;
            }(l.Parser);
            t2.JSXParser = f;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var r2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            t2.Character = { fromCodePoint: function(e3) {
              return e3 < 65536 ? String.fromCharCode(e3) : String.fromCharCode(55296 + (e3 - 65536 >> 10)) + String.fromCharCode(56320 + (e3 - 65536 & 1023));
            }, isWhiteSpace: function(e3) {
              return 32 === e3 || 9 === e3 || 11 === e3 || 12 === e3 || 160 === e3 || e3 >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(e3) >= 0;
            }, isLineTerminator: function(e3) {
              return 10 === e3 || 13 === e3 || 8232 === e3 || 8233 === e3;
            }, isIdentifierStart: function(e3) {
              return 36 === e3 || 95 === e3 || e3 >= 65 && e3 <= 90 || e3 >= 97 && e3 <= 122 || 92 === e3 || e3 >= 128 && r2.NonAsciiIdentifierStart.test(t2.Character.fromCodePoint(e3));
            }, isIdentifierPart: function(e3) {
              return 36 === e3 || 95 === e3 || e3 >= 65 && e3 <= 90 || e3 >= 97 && e3 <= 122 || e3 >= 48 && e3 <= 57 || 92 === e3 || e3 >= 128 && r2.NonAsciiIdentifierPart.test(t2.Character.fromCodePoint(e3));
            }, isDecimalDigit: function(e3) {
              return e3 >= 48 && e3 <= 57;
            }, isHexDigit: function(e3) {
              return e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102;
            }, isOctalDigit: function(e3) {
              return e3 >= 48 && e3 <= 55;
            } };
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(6), i = function(e3) {
              this.type = n2.JSXSyntax.JSXClosingElement, this.name = e3;
            };
            t2.JSXClosingElement = i;
            var o = function(e3, t3, r3) {
              this.type = n2.JSXSyntax.JSXElement, this.openingElement = e3, this.children = t3, this.closingElement = r3;
            };
            t2.JSXElement = o;
            var a = function() {
              this.type = n2.JSXSyntax.JSXEmptyExpression;
            };
            t2.JSXEmptyExpression = a;
            var s = function(e3) {
              this.type = n2.JSXSyntax.JSXExpressionContainer, this.expression = e3;
            };
            t2.JSXExpressionContainer = s;
            var u = function(e3) {
              this.type = n2.JSXSyntax.JSXIdentifier, this.name = e3;
            };
            t2.JSXIdentifier = u;
            var l = function(e3, t3) {
              this.type = n2.JSXSyntax.JSXMemberExpression, this.object = e3, this.property = t3;
            };
            t2.JSXMemberExpression = l;
            var c = function(e3, t3) {
              this.type = n2.JSXSyntax.JSXAttribute, this.name = e3, this.value = t3;
            };
            t2.JSXAttribute = c;
            var h = function(e3, t3) {
              this.type = n2.JSXSyntax.JSXNamespacedName, this.namespace = e3, this.name = t3;
            };
            t2.JSXNamespacedName = h;
            var p = function(e3, t3, r3) {
              this.type = n2.JSXSyntax.JSXOpeningElement, this.name = e3, this.selfClosing = t3, this.attributes = r3;
            };
            t2.JSXOpeningElement = p;
            var f = function(e3) {
              this.type = n2.JSXSyntax.JSXSpreadAttribute, this.argument = e3;
            };
            t2.JSXSpreadAttribute = f;
            var d = function(e3, t3) {
              this.type = n2.JSXSyntax.JSXText, this.value = e3, this.raw = t3;
            };
            t2.JSXText = d;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.JSXSyntax = { JSXAttribute: "JSXAttribute", JSXClosingElement: "JSXClosingElement", JSXElement: "JSXElement", JSXEmptyExpression: "JSXEmptyExpression", JSXExpressionContainer: "JSXExpressionContainer", JSXIdentifier: "JSXIdentifier", JSXMemberExpression: "JSXMemberExpression", JSXNamespacedName: "JSXNamespacedName", JSXOpeningElement: "JSXOpeningElement", JSXSpreadAttribute: "JSXSpreadAttribute", JSXText: "JSXText" };
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(2), i = function(e3) {
              this.type = n2.Syntax.ArrayExpression, this.elements = e3;
            };
            t2.ArrayExpression = i;
            var o = function(e3) {
              this.type = n2.Syntax.ArrayPattern, this.elements = e3;
            };
            t2.ArrayPattern = o;
            var a = function(e3, t3, r3) {
              this.type = n2.Syntax.ArrowFunctionExpression, this.id = null, this.params = e3, this.body = t3, this.generator = false, this.expression = r3, this.async = false;
            };
            t2.ArrowFunctionExpression = a;
            var s = function(e3, t3, r3) {
              this.type = n2.Syntax.AssignmentExpression, this.operator = e3, this.left = t3, this.right = r3;
            };
            t2.AssignmentExpression = s;
            var u = function(e3, t3) {
              this.type = n2.Syntax.AssignmentPattern, this.left = e3, this.right = t3;
            };
            t2.AssignmentPattern = u;
            var l = function(e3, t3, r3) {
              this.type = n2.Syntax.ArrowFunctionExpression, this.id = null, this.params = e3, this.body = t3, this.generator = false, this.expression = r3, this.async = true;
            };
            t2.AsyncArrowFunctionExpression = l;
            var c = function(e3, t3, r3) {
              this.type = n2.Syntax.FunctionDeclaration, this.id = e3, this.params = t3, this.body = r3, this.generator = false, this.expression = false, this.async = true;
            };
            t2.AsyncFunctionDeclaration = c;
            var h = function(e3, t3, r3) {
              this.type = n2.Syntax.FunctionExpression, this.id = e3, this.params = t3, this.body = r3, this.generator = false, this.expression = false, this.async = true;
            };
            t2.AsyncFunctionExpression = h;
            var p = function(e3) {
              this.type = n2.Syntax.AwaitExpression, this.argument = e3;
            };
            t2.AwaitExpression = p;
            var f = function(e3, t3, r3) {
              var i2 = "||" === e3 || "&&" === e3;
              this.type = i2 ? n2.Syntax.LogicalExpression : n2.Syntax.BinaryExpression, this.operator = e3, this.left = t3, this.right = r3;
            };
            t2.BinaryExpression = f;
            var d = function(e3) {
              this.type = n2.Syntax.BlockStatement, this.body = e3;
            };
            t2.BlockStatement = d;
            var m = function(e3) {
              this.type = n2.Syntax.BreakStatement, this.label = e3;
            };
            t2.BreakStatement = m;
            var y = function(e3, t3) {
              this.type = n2.Syntax.CallExpression, this.callee = e3, this.arguments = t3;
            };
            t2.CallExpression = y;
            var v = function(e3, t3) {
              this.type = n2.Syntax.CatchClause, this.param = e3, this.body = t3;
            };
            t2.CatchClause = v;
            var _ = function(e3) {
              this.type = n2.Syntax.ClassBody, this.body = e3;
            };
            t2.ClassBody = _;
            var g = function(e3, t3, r3) {
              this.type = n2.Syntax.ClassDeclaration, this.id = e3, this.superClass = t3, this.body = r3;
            };
            t2.ClassDeclaration = g;
            var b = function(e3, t3, r3) {
              this.type = n2.Syntax.ClassExpression, this.id = e3, this.superClass = t3, this.body = r3;
            };
            t2.ClassExpression = b;
            var x = function(e3, t3) {
              this.type = n2.Syntax.MemberExpression, this.computed = true, this.object = e3, this.property = t3;
            };
            t2.ComputedMemberExpression = x;
            var w = function(e3, t3, r3) {
              this.type = n2.Syntax.ConditionalExpression, this.test = e3, this.consequent = t3, this.alternate = r3;
            };
            t2.ConditionalExpression = w;
            var E = function(e3) {
              this.type = n2.Syntax.ContinueStatement, this.label = e3;
            };
            t2.ContinueStatement = E;
            var D = function() {
              this.type = n2.Syntax.DebuggerStatement;
            };
            t2.DebuggerStatement = D;
            var S = function(e3, t3) {
              this.type = n2.Syntax.ExpressionStatement, this.expression = e3, this.directive = t3;
            };
            t2.Directive = S;
            var C = function(e3, t3) {
              this.type = n2.Syntax.DoWhileStatement, this.body = e3, this.test = t3;
            };
            t2.DoWhileStatement = C;
            var A = function() {
              this.type = n2.Syntax.EmptyStatement;
            };
            t2.EmptyStatement = A;
            var N = function(e3) {
              this.type = n2.Syntax.ExportAllDeclaration, this.source = e3;
            };
            t2.ExportAllDeclaration = N;
            var T = function(e3) {
              this.type = n2.Syntax.ExportDefaultDeclaration, this.declaration = e3;
            };
            t2.ExportDefaultDeclaration = T;
            var O = function(e3, t3, r3) {
              this.type = n2.Syntax.ExportNamedDeclaration, this.declaration = e3, this.specifiers = t3, this.source = r3;
            };
            t2.ExportNamedDeclaration = O;
            var F = function(e3, t3) {
              this.type = n2.Syntax.ExportSpecifier, this.exported = t3, this.local = e3;
            };
            t2.ExportSpecifier = F;
            var k = function(e3) {
              this.type = n2.Syntax.ExpressionStatement, this.expression = e3;
            };
            t2.ExpressionStatement = k;
            var P = function(e3, t3, r3) {
              this.type = n2.Syntax.ForInStatement, this.left = e3, this.right = t3, this.body = r3, this.each = false;
            };
            t2.ForInStatement = P;
            var I = function(e3, t3, r3) {
              this.type = n2.Syntax.ForOfStatement, this.left = e3, this.right = t3, this.body = r3;
            };
            t2.ForOfStatement = I;
            var L = function(e3, t3, r3, i2) {
              this.type = n2.Syntax.ForStatement, this.init = e3, this.test = t3, this.update = r3, this.body = i2;
            };
            t2.ForStatement = L;
            var M = function(e3, t3, r3, i2) {
              this.type = n2.Syntax.FunctionDeclaration, this.id = e3, this.params = t3, this.body = r3, this.generator = i2, this.expression = false, this.async = false;
            };
            t2.FunctionDeclaration = M;
            var B = function(e3, t3, r3, i2) {
              this.type = n2.Syntax.FunctionExpression, this.id = e3, this.params = t3, this.body = r3, this.generator = i2, this.expression = false, this.async = false;
            };
            t2.FunctionExpression = B;
            var j = function(e3) {
              this.type = n2.Syntax.Identifier, this.name = e3;
            };
            t2.Identifier = j;
            var R = function(e3, t3, r3) {
              this.type = n2.Syntax.IfStatement, this.test = e3, this.consequent = t3, this.alternate = r3;
            };
            t2.IfStatement = R;
            var z = function(e3, t3) {
              this.type = n2.Syntax.ImportDeclaration, this.specifiers = e3, this.source = t3;
            };
            t2.ImportDeclaration = z;
            var U = function(e3) {
              this.type = n2.Syntax.ImportDefaultSpecifier, this.local = e3;
            };
            t2.ImportDefaultSpecifier = U;
            var G = function(e3) {
              this.type = n2.Syntax.ImportNamespaceSpecifier, this.local = e3;
            };
            t2.ImportNamespaceSpecifier = G;
            var X = function(e3, t3) {
              this.type = n2.Syntax.ImportSpecifier, this.local = e3, this.imported = t3;
            };
            t2.ImportSpecifier = X;
            var q = function(e3, t3) {
              this.type = n2.Syntax.LabeledStatement, this.label = e3, this.body = t3;
            };
            t2.LabeledStatement = q;
            var W = function(e3, t3) {
              this.type = n2.Syntax.Literal, this.value = e3, this.raw = t3;
            };
            t2.Literal = W;
            var H = function(e3, t3) {
              this.type = n2.Syntax.MetaProperty, this.meta = e3, this.property = t3;
            };
            t2.MetaProperty = H;
            var J = function(e3, t3, r3, i2, o2) {
              this.type = n2.Syntax.MethodDefinition, this.key = e3, this.computed = t3, this.value = r3, this.kind = i2, this.static = o2;
            };
            t2.MethodDefinition = J;
            var Y = function(e3) {
              this.type = n2.Syntax.Program, this.body = e3, this.sourceType = "module";
            };
            t2.Module = Y;
            var V = function(e3, t3) {
              this.type = n2.Syntax.NewExpression, this.callee = e3, this.arguments = t3;
            };
            t2.NewExpression = V;
            var K = function(e3) {
              this.type = n2.Syntax.ObjectExpression, this.properties = e3;
            };
            t2.ObjectExpression = K;
            var $ = function(e3) {
              this.type = n2.Syntax.ObjectPattern, this.properties = e3;
            };
            t2.ObjectPattern = $;
            var Q = function(e3, t3, r3, i2, o2, a2) {
              this.type = n2.Syntax.Property, this.key = t3, this.computed = r3, this.value = i2, this.kind = e3, this.method = o2, this.shorthand = a2;
            };
            t2.Property = Q;
            var Z = function(e3, t3, r3, i2) {
              this.type = n2.Syntax.Literal, this.value = e3, this.raw = t3, this.regex = { pattern: r3, flags: i2 };
            };
            t2.RegexLiteral = Z;
            var ee = function(e3) {
              this.type = n2.Syntax.RestElement, this.argument = e3;
            };
            t2.RestElement = ee;
            var te2 = function(e3) {
              this.type = n2.Syntax.ReturnStatement, this.argument = e3;
            };
            t2.ReturnStatement = te2;
            var re = function(e3) {
              this.type = n2.Syntax.Program, this.body = e3, this.sourceType = "script";
            };
            t2.Script = re;
            var ne = function(e3) {
              this.type = n2.Syntax.SequenceExpression, this.expressions = e3;
            };
            t2.SequenceExpression = ne;
            var ie = function(e3) {
              this.type = n2.Syntax.SpreadElement, this.argument = e3;
            };
            t2.SpreadElement = ie;
            var oe = function(e3, t3) {
              this.type = n2.Syntax.MemberExpression, this.computed = false, this.object = e3, this.property = t3;
            };
            t2.StaticMemberExpression = oe;
            var ae = function() {
              this.type = n2.Syntax.Super;
            };
            t2.Super = ae;
            var se = function(e3, t3) {
              this.type = n2.Syntax.SwitchCase, this.test = e3, this.consequent = t3;
            };
            t2.SwitchCase = se;
            var ue = function(e3, t3) {
              this.type = n2.Syntax.SwitchStatement, this.discriminant = e3, this.cases = t3;
            };
            t2.SwitchStatement = ue;
            var le = function(e3, t3) {
              this.type = n2.Syntax.TaggedTemplateExpression, this.tag = e3, this.quasi = t3;
            };
            t2.TaggedTemplateExpression = le;
            var ce = function(e3, t3) {
              this.type = n2.Syntax.TemplateElement, this.value = e3, this.tail = t3;
            };
            t2.TemplateElement = ce;
            var he = function(e3, t3) {
              this.type = n2.Syntax.TemplateLiteral, this.quasis = e3, this.expressions = t3;
            };
            t2.TemplateLiteral = he;
            var pe = function() {
              this.type = n2.Syntax.ThisExpression;
            };
            t2.ThisExpression = pe;
            var fe = function(e3) {
              this.type = n2.Syntax.ThrowStatement, this.argument = e3;
            };
            t2.ThrowStatement = fe;
            var de = function(e3, t3, r3) {
              this.type = n2.Syntax.TryStatement, this.block = e3, this.handler = t3, this.finalizer = r3;
            };
            t2.TryStatement = de;
            var me = function(e3, t3) {
              this.type = n2.Syntax.UnaryExpression, this.operator = e3, this.argument = t3, this.prefix = true;
            };
            t2.UnaryExpression = me;
            var ye = function(e3, t3, r3) {
              this.type = n2.Syntax.UpdateExpression, this.operator = e3, this.argument = t3, this.prefix = r3;
            };
            t2.UpdateExpression = ye;
            var ve = function(e3, t3) {
              this.type = n2.Syntax.VariableDeclaration, this.declarations = e3, this.kind = t3;
            };
            t2.VariableDeclaration = ve;
            var _e = function(e3, t3) {
              this.type = n2.Syntax.VariableDeclarator, this.id = e3, this.init = t3;
            };
            t2.VariableDeclarator = _e;
            var ge = function(e3, t3) {
              this.type = n2.Syntax.WhileStatement, this.test = e3, this.body = t3;
            };
            t2.WhileStatement = ge;
            var be = function(e3, t3) {
              this.type = n2.Syntax.WithStatement, this.object = e3, this.body = t3;
            };
            t2.WithStatement = be;
            var xe = function(e3, t3) {
              this.type = n2.Syntax.YieldExpression, this.argument = e3, this.delegate = t3;
            };
            t2.YieldExpression = xe;
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(9), i = r2(10), o = r2(11), a = r2(7), s = r2(12), u = r2(2), l = r2(13), c = function() {
              function e3(e4, t3, r3) {
                void 0 === t3 && (t3 = {}), this.config = { range: "boolean" == typeof t3.range && t3.range, loc: "boolean" == typeof t3.loc && t3.loc, source: null, tokens: "boolean" == typeof t3.tokens && t3.tokens, comment: "boolean" == typeof t3.comment && t3.comment, tolerant: "boolean" == typeof t3.tolerant && t3.tolerant }, this.config.loc && t3.source && null !== t3.source && (this.config.source = String(t3.source)), this.delegate = r3, this.errorHandler = new i.ErrorHandler(), this.errorHandler.tolerant = this.config.tolerant, this.scanner = new s.Scanner(e4, this.errorHandler), this.scanner.trackComment = this.config.comment, this.operatorPrecedence = { ")": 0, ";": 0, ",": 0, "=": 0, "]": 0, "||": 1, "&&": 2, "|": 3, "^": 4, "&": 5, "==": 6, "!=": 6, "===": 6, "!==": 6, "<": 7, ">": 7, "<=": 7, ">=": 7, "<<": 8, ">>": 8, ">>>": 8, "+": 9, "-": 9, "*": 11, "/": 11, "%": 11 }, this.lookahead = { type: 2, value: "", lineNumber: this.scanner.lineNumber, lineStart: 0, start: 0, end: 0 }, this.hasLineTerminator = false, this.context = { isModule: false, await: false, allowIn: true, allowStrictDirective: true, allowYield: true, firstCoverInitializedNameError: null, isAssignmentTarget: false, isBindingElement: false, inFunctionBody: false, inIteration: false, inSwitch: false, labelSet: {}, strict: false }, this.tokens = [], this.startMarker = { index: 0, line: this.scanner.lineNumber, column: 0 }, this.lastMarker = { index: 0, line: this.scanner.lineNumber, column: 0 }, this.nextToken(), this.lastMarker = { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart };
              }
              return e3.prototype.throwError = function(e4) {
                for (var t3 = [], r3 = 1; r3 < arguments.length; r3++) t3[r3 - 1] = arguments[r3];
                var i2 = Array.prototype.slice.call(arguments, 1), o2 = e4.replace(/%(\d)/g, function(e5, t4) {
                  return n2.assert(t4 < i2.length, "Message reference must be in range"), i2[t4];
                }), a2 = this.lastMarker.index, s2 = this.lastMarker.line, u2 = this.lastMarker.column + 1;
                throw this.errorHandler.createError(a2, s2, u2, o2);
              }, e3.prototype.tolerateError = function(e4) {
                for (var t3 = [], r3 = 1; r3 < arguments.length; r3++) t3[r3 - 1] = arguments[r3];
                var i2 = Array.prototype.slice.call(arguments, 1), o2 = e4.replace(/%(\d)/g, function(e5, t4) {
                  return n2.assert(t4 < i2.length, "Message reference must be in range"), i2[t4];
                }), a2 = this.lastMarker.index, s2 = this.scanner.lineNumber, u2 = this.lastMarker.column + 1;
                this.errorHandler.tolerateError(a2, s2, u2, o2);
              }, e3.prototype.unexpectedTokenError = function(e4, t3) {
                var r3, n3 = t3 || o.Messages.UnexpectedToken;
                if (e4 ? (t3 || (n3 = 2 === e4.type ? o.Messages.UnexpectedEOS : 3 === e4.type ? o.Messages.UnexpectedIdentifier : 6 === e4.type ? o.Messages.UnexpectedNumber : 8 === e4.type ? o.Messages.UnexpectedString : 10 === e4.type ? o.Messages.UnexpectedTemplate : o.Messages.UnexpectedToken, 4 === e4.type && (this.scanner.isFutureReservedWord(e4.value) ? n3 = o.Messages.UnexpectedReserved : this.context.strict && this.scanner.isStrictModeReservedWord(e4.value) && (n3 = o.Messages.StrictReservedWord))), r3 = e4.value) : r3 = "ILLEGAL", n3 = n3.replace("%0", r3), e4 && "number" == typeof e4.lineNumber) {
                  var i2 = e4.start, a2 = e4.lineNumber, s2 = this.lastMarker.index - this.lastMarker.column, u2 = e4.start - s2 + 1;
                  return this.errorHandler.createError(i2, a2, u2, n3);
                }
                return i2 = this.lastMarker.index, a2 = this.lastMarker.line, u2 = this.lastMarker.column + 1, this.errorHandler.createError(i2, a2, u2, n3);
              }, e3.prototype.throwUnexpectedToken = function(e4, t3) {
                throw this.unexpectedTokenError(e4, t3);
              }, e3.prototype.tolerateUnexpectedToken = function(e4, t3) {
                this.errorHandler.tolerate(this.unexpectedTokenError(e4, t3));
              }, e3.prototype.collectComments = function() {
                if (this.config.comment) {
                  var e4 = this.scanner.scanComments();
                  if (e4.length > 0 && this.delegate) for (var t3 = 0; t3 < e4.length; ++t3) {
                    var r3 = e4[t3], n3 = void 0;
                    n3 = { type: r3.multiLine ? "BlockComment" : "LineComment", value: this.scanner.source.slice(r3.slice[0], r3.slice[1]) }, this.config.range && (n3.range = r3.range), this.config.loc && (n3.loc = r3.loc);
                    var i2 = { start: { line: r3.loc.start.line, column: r3.loc.start.column, offset: r3.range[0] }, end: { line: r3.loc.end.line, column: r3.loc.end.column, offset: r3.range[1] } };
                    this.delegate(n3, i2);
                  }
                } else this.scanner.scanComments();
              }, e3.prototype.getTokenRaw = function(e4) {
                return this.scanner.source.slice(e4.start, e4.end);
              }, e3.prototype.convertToken = function(e4) {
                var t3 = { type: l.TokenName[e4.type], value: this.getTokenRaw(e4) };
                if (this.config.range && (t3.range = [e4.start, e4.end]), this.config.loc && (t3.loc = { start: { line: this.startMarker.line, column: this.startMarker.column }, end: { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart } }), 9 === e4.type) {
                  var r3 = e4.pattern, n3 = e4.flags;
                  t3.regex = { pattern: r3, flags: n3 };
                }
                return t3;
              }, e3.prototype.nextToken = function() {
                var e4 = this.lookahead;
                this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.collectComments(), this.scanner.index !== this.startMarker.index && (this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart);
                var t3 = this.scanner.lex();
                return this.hasLineTerminator = e4.lineNumber !== t3.lineNumber, t3 && this.context.strict && 3 === t3.type && this.scanner.isStrictModeReservedWord(t3.value) && (t3.type = 4), this.lookahead = t3, this.config.tokens && 2 !== t3.type && this.tokens.push(this.convertToken(t3)), e4;
              }, e3.prototype.nextRegexToken = function() {
                this.collectComments();
                var e4 = this.scanner.scanRegExp();
                return this.config.tokens && (this.tokens.pop(), this.tokens.push(this.convertToken(e4))), this.lookahead = e4, this.nextToken(), e4;
              }, e3.prototype.createNode = function() {
                return { index: this.startMarker.index, line: this.startMarker.line, column: this.startMarker.column };
              }, e3.prototype.startNode = function(e4, t3) {
                void 0 === t3 && (t3 = 0);
                var r3 = e4.start - e4.lineStart, n3 = e4.lineNumber;
                return r3 < 0 && (r3 += t3, n3--), { index: e4.start, line: n3, column: r3 };
              }, e3.prototype.finalize = function(e4, t3) {
                if (this.config.range && (t3.range = [e4.index, this.lastMarker.index]), this.config.loc && (t3.loc = { start: { line: e4.line, column: e4.column }, end: { line: this.lastMarker.line, column: this.lastMarker.column } }, this.config.source && (t3.loc.source = this.config.source)), this.delegate) {
                  var r3 = { start: { line: e4.line, column: e4.column, offset: e4.index }, end: { line: this.lastMarker.line, column: this.lastMarker.column, offset: this.lastMarker.index } };
                  this.delegate(t3, r3);
                }
                return t3;
              }, e3.prototype.expect = function(e4) {
                var t3 = this.nextToken();
                7 === t3.type && t3.value === e4 || this.throwUnexpectedToken(t3);
              }, e3.prototype.expectCommaSeparator = function() {
                if (this.config.tolerant) {
                  var e4 = this.lookahead;
                  7 === e4.type && "," === e4.value ? this.nextToken() : 7 === e4.type && ";" === e4.value ? (this.nextToken(), this.tolerateUnexpectedToken(e4)) : this.tolerateUnexpectedToken(e4, o.Messages.UnexpectedToken);
                } else this.expect(",");
              }, e3.prototype.expectKeyword = function(e4) {
                var t3 = this.nextToken();
                4 === t3.type && t3.value === e4 || this.throwUnexpectedToken(t3);
              }, e3.prototype.match = function(e4) {
                return 7 === this.lookahead.type && this.lookahead.value === e4;
              }, e3.prototype.matchKeyword = function(e4) {
                return 4 === this.lookahead.type && this.lookahead.value === e4;
              }, e3.prototype.matchContextualKeyword = function(e4) {
                return 3 === this.lookahead.type && this.lookahead.value === e4;
              }, e3.prototype.matchAssign = function() {
                if (7 !== this.lookahead.type) return false;
                var e4 = this.lookahead.value;
                return "=" === e4 || "*=" === e4 || "**=" === e4 || "/=" === e4 || "%=" === e4 || "+=" === e4 || "-=" === e4 || "<<=" === e4 || ">>=" === e4 || ">>>=" === e4 || "&=" === e4 || "^=" === e4 || "|=" === e4;
              }, e3.prototype.isolateCoverGrammar = function(e4) {
                var t3 = this.context.isBindingElement, r3 = this.context.isAssignmentTarget, n3 = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = true, this.context.isAssignmentTarget = true, this.context.firstCoverInitializedNameError = null;
                var i2 = e4.call(this);
                return null !== this.context.firstCoverInitializedNameError && this.throwUnexpectedToken(this.context.firstCoverInitializedNameError), this.context.isBindingElement = t3, this.context.isAssignmentTarget = r3, this.context.firstCoverInitializedNameError = n3, i2;
              }, e3.prototype.inheritCoverGrammar = function(e4) {
                var t3 = this.context.isBindingElement, r3 = this.context.isAssignmentTarget, n3 = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = true, this.context.isAssignmentTarget = true, this.context.firstCoverInitializedNameError = null;
                var i2 = e4.call(this);
                return this.context.isBindingElement = this.context.isBindingElement && t3, this.context.isAssignmentTarget = this.context.isAssignmentTarget && r3, this.context.firstCoverInitializedNameError = n3 || this.context.firstCoverInitializedNameError, i2;
              }, e3.prototype.consumeSemicolon = function() {
                this.match(";") ? this.nextToken() : this.hasLineTerminator || (2 === this.lookahead.type || this.match("}") || this.throwUnexpectedToken(this.lookahead), this.lastMarker.index = this.startMarker.index, this.lastMarker.line = this.startMarker.line, this.lastMarker.column = this.startMarker.column);
              }, e3.prototype.parsePrimaryExpression = function() {
                var e4, t3, r3, n3 = this.createNode();
                switch (this.lookahead.type) {
                  case 3:
                    (this.context.isModule || this.context.await) && "await" === this.lookahead.value && this.tolerateUnexpectedToken(this.lookahead), e4 = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(n3, new a.Identifier(this.nextToken().value));
                    break;
                  case 6:
                  case 8:
                    this.context.strict && this.lookahead.octal && this.tolerateUnexpectedToken(this.lookahead, o.Messages.StrictOctalLiteral), this.context.isAssignmentTarget = false, this.context.isBindingElement = false, t3 = this.nextToken(), r3 = this.getTokenRaw(t3), e4 = this.finalize(n3, new a.Literal(t3.value, r3));
                    break;
                  case 1:
                    this.context.isAssignmentTarget = false, this.context.isBindingElement = false, t3 = this.nextToken(), r3 = this.getTokenRaw(t3), e4 = this.finalize(n3, new a.Literal("true" === t3.value, r3));
                    break;
                  case 5:
                    this.context.isAssignmentTarget = false, this.context.isBindingElement = false, t3 = this.nextToken(), r3 = this.getTokenRaw(t3), e4 = this.finalize(n3, new a.Literal(null, r3));
                    break;
                  case 10:
                    e4 = this.parseTemplateLiteral();
                    break;
                  case 7:
                    switch (this.lookahead.value) {
                      case "(":
                        this.context.isBindingElement = false, e4 = this.inheritCoverGrammar(this.parseGroupExpression);
                        break;
                      case "[":
                        e4 = this.inheritCoverGrammar(this.parseArrayInitializer);
                        break;
                      case "{":
                        e4 = this.inheritCoverGrammar(this.parseObjectInitializer);
                        break;
                      case "/":
                      case "/=":
                        this.context.isAssignmentTarget = false, this.context.isBindingElement = false, this.scanner.index = this.startMarker.index, t3 = this.nextRegexToken(), r3 = this.getTokenRaw(t3), e4 = this.finalize(n3, new a.RegexLiteral(t3.regex, r3, t3.pattern, t3.flags));
                        break;
                      default:
                        e4 = this.throwUnexpectedToken(this.nextToken());
                    }
                    break;
                  case 4:
                    !this.context.strict && this.context.allowYield && this.matchKeyword("yield") ? e4 = this.parseIdentifierName() : !this.context.strict && this.matchKeyword("let") ? e4 = this.finalize(n3, new a.Identifier(this.nextToken().value)) : (this.context.isAssignmentTarget = false, this.context.isBindingElement = false, this.matchKeyword("function") ? e4 = this.parseFunctionExpression() : this.matchKeyword("this") ? (this.nextToken(), e4 = this.finalize(n3, new a.ThisExpression())) : e4 = this.matchKeyword("class") ? this.parseClassExpression() : this.throwUnexpectedToken(this.nextToken()));
                    break;
                  default:
                    e4 = this.throwUnexpectedToken(this.nextToken());
                }
                return e4;
              }, e3.prototype.parseSpreadElement = function() {
                var e4 = this.createNode();
                this.expect("...");
                var t3 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                return this.finalize(e4, new a.SpreadElement(t3));
              }, e3.prototype.parseArrayInitializer = function() {
                var e4 = this.createNode(), t3 = [];
                for (this.expect("["); !this.match("]"); ) if (this.match(",")) this.nextToken(), t3.push(null);
                else if (this.match("...")) {
                  var r3 = this.parseSpreadElement();
                  this.match("]") || (this.context.isAssignmentTarget = false, this.context.isBindingElement = false, this.expect(",")), t3.push(r3);
                } else t3.push(this.inheritCoverGrammar(this.parseAssignmentExpression)), this.match("]") || this.expect(",");
                return this.expect("]"), this.finalize(e4, new a.ArrayExpression(t3));
              }, e3.prototype.parsePropertyMethod = function(e4) {
                this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                var t3 = this.context.strict, r3 = this.context.allowStrictDirective;
                this.context.allowStrictDirective = e4.simple;
                var n3 = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                return this.context.strict && e4.firstRestricted && this.tolerateUnexpectedToken(e4.firstRestricted, e4.message), this.context.strict && e4.stricted && this.tolerateUnexpectedToken(e4.stricted, e4.message), this.context.strict = t3, this.context.allowStrictDirective = r3, n3;
              }, e3.prototype.parsePropertyMethodFunction = function() {
                var e4 = this.createNode(), t3 = this.context.allowYield;
                this.context.allowYield = true;
                var r3 = this.parseFormalParameters(), n3 = this.parsePropertyMethod(r3);
                return this.context.allowYield = t3, this.finalize(e4, new a.FunctionExpression(null, r3.params, n3, false));
              }, e3.prototype.parsePropertyMethodAsyncFunction = function() {
                var e4 = this.createNode(), t3 = this.context.allowYield, r3 = this.context.await;
                this.context.allowYield = false, this.context.await = true;
                var n3 = this.parseFormalParameters(), i2 = this.parsePropertyMethod(n3);
                return this.context.allowYield = t3, this.context.await = r3, this.finalize(e4, new a.AsyncFunctionExpression(null, n3.params, i2));
              }, e3.prototype.parseObjectPropertyKey = function() {
                var e4, t3 = this.createNode(), r3 = this.nextToken();
                switch (r3.type) {
                  case 8:
                  case 6:
                    this.context.strict && r3.octal && this.tolerateUnexpectedToken(r3, o.Messages.StrictOctalLiteral);
                    var n3 = this.getTokenRaw(r3);
                    e4 = this.finalize(t3, new a.Literal(r3.value, n3));
                    break;
                  case 3:
                  case 1:
                  case 5:
                  case 4:
                    e4 = this.finalize(t3, new a.Identifier(r3.value));
                    break;
                  case 7:
                    "[" === r3.value ? (e4 = this.isolateCoverGrammar(this.parseAssignmentExpression), this.expect("]")) : e4 = this.throwUnexpectedToken(r3);
                    break;
                  default:
                    e4 = this.throwUnexpectedToken(r3);
                }
                return e4;
              }, e3.prototype.isPropertyKey = function(e4, t3) {
                return e4.type === u.Syntax.Identifier && e4.name === t3 || e4.type === u.Syntax.Literal && e4.value === t3;
              }, e3.prototype.parseObjectProperty = function(e4) {
                var t3, r3 = this.createNode(), n3 = this.lookahead, i2 = null, s2 = null, u2 = false, l2 = false, c2 = false, h = false;
                if (3 === n3.type) {
                  var p = n3.value;
                  this.nextToken(), u2 = this.match("["), i2 = (h = !(this.hasLineTerminator || "async" !== p || this.match(":") || this.match("(") || this.match("*") || this.match(","))) ? this.parseObjectPropertyKey() : this.finalize(r3, new a.Identifier(p));
                } else this.match("*") ? this.nextToken() : (u2 = this.match("["), i2 = this.parseObjectPropertyKey());
                var f = this.qualifiedPropertyName(this.lookahead);
                if (3 === n3.type && !h && "get" === n3.value && f) t3 = "get", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), this.context.allowYield = false, s2 = this.parseGetterMethod();
                else if (3 === n3.type && !h && "set" === n3.value && f) t3 = "set", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), s2 = this.parseSetterMethod();
                else if (7 === n3.type && "*" === n3.value && f) t3 = "init", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), s2 = this.parseGeneratorMethod(), l2 = true;
                else if (i2 || this.throwUnexpectedToken(this.lookahead), t3 = "init", this.match(":") && !h) !u2 && this.isPropertyKey(i2, "__proto__") && (e4.value && this.tolerateError(o.Messages.DuplicateProtoProperty), e4.value = true), this.nextToken(), s2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                else if (this.match("(")) s2 = h ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), l2 = true;
                else if (3 === n3.type) if (p = this.finalize(r3, new a.Identifier(n3.value)), this.match("=")) {
                  this.context.firstCoverInitializedNameError = this.lookahead, this.nextToken(), c2 = true;
                  var d = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  s2 = this.finalize(r3, new a.AssignmentPattern(p, d));
                } else c2 = true, s2 = p;
                else this.throwUnexpectedToken(this.nextToken());
                return this.finalize(r3, new a.Property(t3, i2, u2, s2, l2, c2));
              }, e3.prototype.parseObjectInitializer = function() {
                var e4 = this.createNode();
                this.expect("{");
                for (var t3 = [], r3 = { value: false }; !this.match("}"); ) t3.push(this.parseObjectProperty(r3)), this.match("}") || this.expectCommaSeparator();
                return this.expect("}"), this.finalize(e4, new a.ObjectExpression(t3));
              }, e3.prototype.parseTemplateHead = function() {
                n2.assert(this.lookahead.head, "Template literal must start with a template head");
                var e4 = this.createNode(), t3 = this.nextToken(), r3 = t3.value, i2 = t3.cooked;
                return this.finalize(e4, new a.TemplateElement({ raw: r3, cooked: i2 }, t3.tail));
              }, e3.prototype.parseTemplateElement = function() {
                10 !== this.lookahead.type && this.throwUnexpectedToken();
                var e4 = this.createNode(), t3 = this.nextToken(), r3 = t3.value, n3 = t3.cooked;
                return this.finalize(e4, new a.TemplateElement({ raw: r3, cooked: n3 }, t3.tail));
              }, e3.prototype.parseTemplateLiteral = function() {
                var e4 = this.createNode(), t3 = [], r3 = [], n3 = this.parseTemplateHead();
                for (r3.push(n3); !n3.tail; ) t3.push(this.parseExpression()), n3 = this.parseTemplateElement(), r3.push(n3);
                return this.finalize(e4, new a.TemplateLiteral(r3, t3));
              }, e3.prototype.reinterpretExpressionAsPattern = function(e4) {
                switch (e4.type) {
                  case u.Syntax.Identifier:
                  case u.Syntax.MemberExpression:
                  case u.Syntax.RestElement:
                  case u.Syntax.AssignmentPattern:
                    break;
                  case u.Syntax.SpreadElement:
                    e4.type = u.Syntax.RestElement, this.reinterpretExpressionAsPattern(e4.argument);
                    break;
                  case u.Syntax.ArrayExpression:
                    e4.type = u.Syntax.ArrayPattern;
                    for (var t3 = 0; t3 < e4.elements.length; t3++) null !== e4.elements[t3] && this.reinterpretExpressionAsPattern(e4.elements[t3]);
                    break;
                  case u.Syntax.ObjectExpression:
                    for (e4.type = u.Syntax.ObjectPattern, t3 = 0; t3 < e4.properties.length; t3++) this.reinterpretExpressionAsPattern(e4.properties[t3].value);
                    break;
                  case u.Syntax.AssignmentExpression:
                    e4.type = u.Syntax.AssignmentPattern, delete e4.operator, this.reinterpretExpressionAsPattern(e4.left);
                }
              }, e3.prototype.parseGroupExpression = function() {
                var e4;
                if (this.expect("("), this.match(")")) this.nextToken(), this.match("=>") || this.expect("=>"), e4 = { type: "ArrowParameterPlaceHolder", params: [], async: false };
                else {
                  var t3 = this.lookahead, r3 = [];
                  if (this.match("...")) e4 = this.parseRestElement(r3), this.expect(")"), this.match("=>") || this.expect("=>"), e4 = { type: "ArrowParameterPlaceHolder", params: [e4], async: false };
                  else {
                    var n3 = false;
                    if (this.context.isBindingElement = true, e4 = this.inheritCoverGrammar(this.parseAssignmentExpression), this.match(",")) {
                      var i2 = [];
                      for (this.context.isAssignmentTarget = false, i2.push(e4); 2 !== this.lookahead.type && this.match(","); ) {
                        if (this.nextToken(), this.match(")")) {
                          this.nextToken();
                          for (var o2 = 0; o2 < i2.length; o2++) this.reinterpretExpressionAsPattern(i2[o2]);
                          n3 = true, e4 = { type: "ArrowParameterPlaceHolder", params: i2, async: false };
                        } else if (this.match("...")) {
                          for (this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), i2.push(this.parseRestElement(r3)), this.expect(")"), this.match("=>") || this.expect("=>"), this.context.isBindingElement = false, o2 = 0; o2 < i2.length; o2++) this.reinterpretExpressionAsPattern(i2[o2]);
                          n3 = true, e4 = { type: "ArrowParameterPlaceHolder", params: i2, async: false };
                        } else i2.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                        if (n3) break;
                      }
                      n3 || (e4 = this.finalize(this.startNode(t3), new a.SequenceExpression(i2)));
                    }
                    if (!n3) {
                      if (this.expect(")"), this.match("=>") && (e4.type === u.Syntax.Identifier && "yield" === e4.name && (n3 = true, e4 = { type: "ArrowParameterPlaceHolder", params: [e4], async: false }), !n3)) {
                        if (this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), e4.type === u.Syntax.SequenceExpression) for (o2 = 0; o2 < e4.expressions.length; o2++) this.reinterpretExpressionAsPattern(e4.expressions[o2]);
                        else this.reinterpretExpressionAsPattern(e4);
                        e4 = { type: "ArrowParameterPlaceHolder", params: e4.type === u.Syntax.SequenceExpression ? e4.expressions : [e4], async: false };
                      }
                      this.context.isBindingElement = false;
                    }
                  }
                }
                return e4;
              }, e3.prototype.parseArguments = function() {
                this.expect("(");
                var e4 = [];
                if (!this.match(")")) for (; ; ) {
                  var t3 = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                  if (e4.push(t3), this.match(")")) break;
                  if (this.expectCommaSeparator(), this.match(")")) break;
                }
                return this.expect(")"), e4;
              }, e3.prototype.isIdentifierName = function(e4) {
                return 3 === e4.type || 4 === e4.type || 1 === e4.type || 5 === e4.type;
              }, e3.prototype.parseIdentifierName = function() {
                var e4 = this.createNode(), t3 = this.nextToken();
                return this.isIdentifierName(t3) || this.throwUnexpectedToken(t3), this.finalize(e4, new a.Identifier(t3.value));
              }, e3.prototype.parseNewExpression = function() {
                var e4, t3 = this.createNode(), r3 = this.parseIdentifierName();
                if (n2.assert("new" === r3.name, "New expression must start with `new`"), this.match(".")) if (this.nextToken(), 3 === this.lookahead.type && this.context.inFunctionBody && "target" === this.lookahead.value) {
                  var i2 = this.parseIdentifierName();
                  e4 = new a.MetaProperty(r3, i2);
                } else this.throwUnexpectedToken(this.lookahead);
                else {
                  var o2 = this.isolateCoverGrammar(this.parseLeftHandSideExpression), s2 = this.match("(") ? this.parseArguments() : [];
                  e4 = new a.NewExpression(o2, s2), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                }
                return this.finalize(t3, e4);
              }, e3.prototype.parseAsyncArgument = function() {
                var e4 = this.parseAssignmentExpression();
                return this.context.firstCoverInitializedNameError = null, e4;
              }, e3.prototype.parseAsyncArguments = function() {
                this.expect("(");
                var e4 = [];
                if (!this.match(")")) for (; ; ) {
                  var t3 = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                  if (e4.push(t3), this.match(")")) break;
                  if (this.expectCommaSeparator(), this.match(")")) break;
                }
                return this.expect(")"), e4;
              }, e3.prototype.parseLeftHandSideExpressionAllowCall = function() {
                var e4, t3 = this.lookahead, r3 = this.matchContextualKeyword("async"), n3 = this.context.allowIn;
                for (this.context.allowIn = true, this.matchKeyword("super") && this.context.inFunctionBody ? (e4 = this.createNode(), this.nextToken(), e4 = this.finalize(e4, new a.Super()), this.match("(") || this.match(".") || this.match("[") || this.throwUnexpectedToken(this.lookahead)) : e4 = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; ) if (this.match(".")) {
                  this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect(".");
                  var i2 = this.parseIdentifierName();
                  e4 = this.finalize(this.startNode(t3), new a.StaticMemberExpression(e4, i2));
                } else if (this.match("(")) {
                  var o2 = r3 && t3.lineNumber === this.lookahead.lineNumber;
                  this.context.isBindingElement = false, this.context.isAssignmentTarget = false;
                  var s2 = o2 ? this.parseAsyncArguments() : this.parseArguments();
                  if (e4 = this.finalize(this.startNode(t3), new a.CallExpression(e4, s2)), o2 && this.match("=>")) {
                    for (var u2 = 0; u2 < s2.length; ++u2) this.reinterpretExpressionAsPattern(s2[u2]);
                    e4 = { type: "ArrowParameterPlaceHolder", params: s2, async: true };
                  }
                } else if (this.match("[")) this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect("["), i2 = this.isolateCoverGrammar(this.parseExpression), this.expect("]"), e4 = this.finalize(this.startNode(t3), new a.ComputedMemberExpression(e4, i2));
                else {
                  if (10 !== this.lookahead.type || !this.lookahead.head) break;
                  var l2 = this.parseTemplateLiteral();
                  e4 = this.finalize(this.startNode(t3), new a.TaggedTemplateExpression(e4, l2));
                }
                return this.context.allowIn = n3, e4;
              }, e3.prototype.parseSuper = function() {
                var e4 = this.createNode();
                return this.expectKeyword("super"), this.match("[") || this.match(".") || this.throwUnexpectedToken(this.lookahead), this.finalize(e4, new a.Super());
              }, e3.prototype.parseLeftHandSideExpression = function() {
                n2.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                for (var e4 = this.startNode(this.lookahead), t3 = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; ) if (this.match("[")) {
                  this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect("[");
                  var r3 = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]"), t3 = this.finalize(e4, new a.ComputedMemberExpression(t3, r3));
                } else if (this.match(".")) this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect("."), r3 = this.parseIdentifierName(), t3 = this.finalize(e4, new a.StaticMemberExpression(t3, r3));
                else {
                  if (10 !== this.lookahead.type || !this.lookahead.head) break;
                  var i2 = this.parseTemplateLiteral();
                  t3 = this.finalize(e4, new a.TaggedTemplateExpression(t3, i2));
                }
                return t3;
              }, e3.prototype.parseUpdateExpression = function() {
                var e4, t3 = this.lookahead;
                if (this.match("++") || this.match("--")) {
                  var r3 = this.startNode(t3), n3 = this.nextToken();
                  e4 = this.inheritCoverGrammar(this.parseUnaryExpression), this.context.strict && e4.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(e4.name) && this.tolerateError(o.Messages.StrictLHSPrefix), this.context.isAssignmentTarget || this.tolerateError(o.Messages.InvalidLHSInAssignment);
                  var i2 = true;
                  e4 = this.finalize(r3, new a.UpdateExpression(n3.value, e4, i2)), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                } else if (e4 = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall), !this.hasLineTerminator && 7 === this.lookahead.type && (this.match("++") || this.match("--"))) {
                  this.context.strict && e4.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(e4.name) && this.tolerateError(o.Messages.StrictLHSPostfix), this.context.isAssignmentTarget || this.tolerateError(o.Messages.InvalidLHSInAssignment), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                  var s2 = this.nextToken().value;
                  i2 = false, e4 = this.finalize(this.startNode(t3), new a.UpdateExpression(s2, e4, i2));
                }
                return e4;
              }, e3.prototype.parseAwaitExpression = function() {
                var e4 = this.createNode();
                this.nextToken();
                var t3 = this.parseUnaryExpression();
                return this.finalize(e4, new a.AwaitExpression(t3));
              }, e3.prototype.parseUnaryExpression = function() {
                var e4;
                if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                  var t3 = this.startNode(this.lookahead), r3 = this.nextToken();
                  e4 = this.inheritCoverGrammar(this.parseUnaryExpression), e4 = this.finalize(t3, new a.UnaryExpression(r3.value, e4)), this.context.strict && "delete" === e4.operator && e4.argument.type === u.Syntax.Identifier && this.tolerateError(o.Messages.StrictDelete), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                } else e4 = this.context.await && this.matchContextualKeyword("await") ? this.parseAwaitExpression() : this.parseUpdateExpression();
                return e4;
              }, e3.prototype.parseExponentiationExpression = function() {
                var e4 = this.lookahead, t3 = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (t3.type !== u.Syntax.UnaryExpression && this.match("**")) {
                  this.nextToken(), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                  var r3 = t3, n3 = this.isolateCoverGrammar(this.parseExponentiationExpression);
                  t3 = this.finalize(this.startNode(e4), new a.BinaryExpression("**", r3, n3));
                }
                return t3;
              }, e3.prototype.binaryPrecedence = function(e4) {
                var t3 = e4.value;
                return 7 === e4.type ? this.operatorPrecedence[t3] || 0 : 4 === e4.type && ("instanceof" === t3 || this.context.allowIn && "in" === t3) ? 7 : 0;
              }, e3.prototype.parseBinaryExpression = function() {
                var e4 = this.lookahead, t3 = this.inheritCoverGrammar(this.parseExponentiationExpression), r3 = this.lookahead, n3 = this.binaryPrecedence(r3);
                if (n3 > 0) {
                  this.nextToken(), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                  for (var i2 = [e4, this.lookahead], o2 = t3, s2 = this.isolateCoverGrammar(this.parseExponentiationExpression), u2 = [o2, r3.value, s2], l2 = [n3]; !((n3 = this.binaryPrecedence(this.lookahead)) <= 0); ) {
                    for (; u2.length > 2 && n3 <= l2[l2.length - 1]; ) {
                      s2 = u2.pop();
                      var c2 = u2.pop();
                      l2.pop(), o2 = u2.pop(), i2.pop();
                      var h = this.startNode(i2[i2.length - 1]);
                      u2.push(this.finalize(h, new a.BinaryExpression(c2, o2, s2)));
                    }
                    u2.push(this.nextToken().value), l2.push(n3), i2.push(this.lookahead), u2.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                  }
                  var p = u2.length - 1;
                  t3 = u2[p];
                  for (var f = i2.pop(); p > 1; ) {
                    var d = i2.pop(), m = f && f.lineStart;
                    h = this.startNode(d, m), c2 = u2[p - 1], t3 = this.finalize(h, new a.BinaryExpression(c2, u2[p - 2], t3)), p -= 2, f = d;
                  }
                }
                return t3;
              }, e3.prototype.parseConditionalExpression = function() {
                var e4 = this.lookahead, t3 = this.inheritCoverGrammar(this.parseBinaryExpression);
                if (this.match("?")) {
                  this.nextToken();
                  var r3 = this.context.allowIn;
                  this.context.allowIn = true;
                  var n3 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = r3, this.expect(":");
                  var i2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  t3 = this.finalize(this.startNode(e4), new a.ConditionalExpression(t3, n3, i2)), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                }
                return t3;
              }, e3.prototype.checkPatternParam = function(e4, t3) {
                switch (t3.type) {
                  case u.Syntax.Identifier:
                    this.validateParam(e4, t3, t3.name);
                    break;
                  case u.Syntax.RestElement:
                    this.checkPatternParam(e4, t3.argument);
                    break;
                  case u.Syntax.AssignmentPattern:
                    this.checkPatternParam(e4, t3.left);
                    break;
                  case u.Syntax.ArrayPattern:
                    for (var r3 = 0; r3 < t3.elements.length; r3++) null !== t3.elements[r3] && this.checkPatternParam(e4, t3.elements[r3]);
                    break;
                  case u.Syntax.ObjectPattern:
                    for (r3 = 0; r3 < t3.properties.length; r3++) this.checkPatternParam(e4, t3.properties[r3].value);
                }
                e4.simple = e4.simple && t3 instanceof a.Identifier;
              }, e3.prototype.reinterpretAsCoverFormalsList = function(e4) {
                var t3, r3 = [e4], n3 = false;
                switch (e4.type) {
                  case u.Syntax.Identifier:
                    break;
                  case "ArrowParameterPlaceHolder":
                    r3 = e4.params, n3 = e4.async;
                    break;
                  default:
                    return null;
                }
                t3 = { simple: true, paramSet: {} };
                for (var i2 = 0; i2 < r3.length; ++i2) (a2 = r3[i2]).type === u.Syntax.AssignmentPattern ? a2.right.type === u.Syntax.YieldExpression && (a2.right.argument && this.throwUnexpectedToken(this.lookahead), a2.right.type = u.Syntax.Identifier, a2.right.name = "yield", delete a2.right.argument, delete a2.right.delegate) : n3 && a2.type === u.Syntax.Identifier && "await" === a2.name && this.throwUnexpectedToken(this.lookahead), this.checkPatternParam(t3, a2), r3[i2] = a2;
                if (this.context.strict || !this.context.allowYield) for (i2 = 0; i2 < r3.length; ++i2) {
                  var a2;
                  (a2 = r3[i2]).type === u.Syntax.YieldExpression && this.throwUnexpectedToken(this.lookahead);
                }
                if (t3.message === o.Messages.StrictParamDupe) {
                  var s2 = this.context.strict ? t3.stricted : t3.firstRestricted;
                  this.throwUnexpectedToken(s2, t3.message);
                }
                return { simple: t3.simple, params: r3, stricted: t3.stricted, firstRestricted: t3.firstRestricted, message: t3.message };
              }, e3.prototype.parseAssignmentExpression = function() {
                var e4;
                if (!this.context.allowYield && this.matchKeyword("yield")) e4 = this.parseYieldExpression();
                else {
                  var t3 = this.lookahead, r3 = t3;
                  if (e4 = this.parseConditionalExpression(), 3 === r3.type && r3.lineNumber === this.lookahead.lineNumber && "async" === r3.value && (3 === this.lookahead.type || this.matchKeyword("yield"))) {
                    var n3 = this.parsePrimaryExpression();
                    this.reinterpretExpressionAsPattern(n3), e4 = { type: "ArrowParameterPlaceHolder", params: [n3], async: true };
                  }
                  if ("ArrowParameterPlaceHolder" === e4.type || this.match("=>")) {
                    this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                    var i2 = e4.async, s2 = this.reinterpretAsCoverFormalsList(e4);
                    if (s2) {
                      this.hasLineTerminator && this.tolerateUnexpectedToken(this.lookahead), this.context.firstCoverInitializedNameError = null;
                      var l2 = this.context.strict, c2 = this.context.allowStrictDirective;
                      this.context.allowStrictDirective = s2.simple;
                      var h = this.context.allowYield, p = this.context.await;
                      this.context.allowYield = true, this.context.await = i2;
                      var f = this.startNode(t3);
                      this.expect("=>");
                      var d = void 0;
                      if (this.match("{")) {
                        var m = this.context.allowIn;
                        this.context.allowIn = true, d = this.parseFunctionSourceElements(), this.context.allowIn = m;
                      } else d = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      var y = d.type !== u.Syntax.BlockStatement;
                      this.context.strict && s2.firstRestricted && this.throwUnexpectedToken(s2.firstRestricted, s2.message), this.context.strict && s2.stricted && this.tolerateUnexpectedToken(s2.stricted, s2.message), e4 = i2 ? this.finalize(f, new a.AsyncArrowFunctionExpression(s2.params, d, y)) : this.finalize(f, new a.ArrowFunctionExpression(s2.params, d, y)), this.context.strict = l2, this.context.allowStrictDirective = c2, this.context.allowYield = h, this.context.await = p;
                    }
                  } else if (this.matchAssign()) {
                    if (this.context.isAssignmentTarget || this.tolerateError(o.Messages.InvalidLHSInAssignment), this.context.strict && e4.type === u.Syntax.Identifier) {
                      var v = e4;
                      this.scanner.isRestrictedWord(v.name) && this.tolerateUnexpectedToken(r3, o.Messages.StrictLHSAssignment), this.scanner.isStrictModeReservedWord(v.name) && this.tolerateUnexpectedToken(r3, o.Messages.StrictReservedWord);
                    }
                    this.match("=") ? this.reinterpretExpressionAsPattern(e4) : (this.context.isAssignmentTarget = false, this.context.isBindingElement = false);
                    var _ = (r3 = this.nextToken()).value, g = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    e4 = this.finalize(this.startNode(t3), new a.AssignmentExpression(_, e4, g)), this.context.firstCoverInitializedNameError = null;
                  }
                }
                return e4;
              }, e3.prototype.parseExpression = function() {
                var e4 = this.lookahead, t3 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var r3 = [];
                  for (r3.push(t3); 2 !== this.lookahead.type && this.match(","); ) this.nextToken(), r3.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                  t3 = this.finalize(this.startNode(e4), new a.SequenceExpression(r3));
                }
                return t3;
              }, e3.prototype.parseStatementListItem = function() {
                var e4;
                if (this.context.isAssignmentTarget = true, this.context.isBindingElement = true, 4 === this.lookahead.type) switch (this.lookahead.value) {
                  case "export":
                    this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, o.Messages.IllegalExportDeclaration), e4 = this.parseExportDeclaration();
                    break;
                  case "import":
                    this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, o.Messages.IllegalImportDeclaration), e4 = this.parseImportDeclaration();
                    break;
                  case "const":
                    e4 = this.parseLexicalDeclaration({ inFor: false });
                    break;
                  case "function":
                    e4 = this.parseFunctionDeclaration();
                    break;
                  case "class":
                    e4 = this.parseClassDeclaration();
                    break;
                  case "let":
                    e4 = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                    break;
                  default:
                    e4 = this.parseStatement();
                }
                else e4 = this.parseStatement();
                return e4;
              }, e3.prototype.parseBlock = function() {
                var e4 = this.createNode();
                this.expect("{");
                for (var t3 = []; !this.match("}"); ) t3.push(this.parseStatementListItem());
                return this.expect("}"), this.finalize(e4, new a.BlockStatement(t3));
              }, e3.prototype.parseLexicalBinding = function(e4, t3) {
                var r3 = this.createNode(), n3 = this.parsePattern([], e4);
                this.context.strict && n3.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(n3.name) && this.tolerateError(o.Messages.StrictVarName);
                var i2 = null;
                return "const" === e4 ? this.matchKeyword("in") || this.matchContextualKeyword("of") || (this.match("=") ? (this.nextToken(), i2 = this.isolateCoverGrammar(this.parseAssignmentExpression)) : this.throwError(o.Messages.DeclarationMissingInitializer, "const")) : (!t3.inFor && n3.type !== u.Syntax.Identifier || this.match("=")) && (this.expect("="), i2 = this.isolateCoverGrammar(this.parseAssignmentExpression)), this.finalize(r3, new a.VariableDeclarator(n3, i2));
              }, e3.prototype.parseBindingList = function(e4, t3) {
                for (var r3 = [this.parseLexicalBinding(e4, t3)]; this.match(","); ) this.nextToken(), r3.push(this.parseLexicalBinding(e4, t3));
                return r3;
              }, e3.prototype.isLexicalDeclaration = function() {
                var e4 = this.scanner.saveState();
                this.scanner.scanComments();
                var t3 = this.scanner.lex();
                return this.scanner.restoreState(e4), 3 === t3.type || 7 === t3.type && "[" === t3.value || 7 === t3.type && "{" === t3.value || 4 === t3.type && "let" === t3.value || 4 === t3.type && "yield" === t3.value;
              }, e3.prototype.parseLexicalDeclaration = function(e4) {
                var t3 = this.createNode(), r3 = this.nextToken().value;
                n2.assert("let" === r3 || "const" === r3, "Lexical declaration must be either let or const");
                var i2 = this.parseBindingList(r3, e4);
                return this.consumeSemicolon(), this.finalize(t3, new a.VariableDeclaration(i2, r3));
              }, e3.prototype.parseBindingRestElement = function(e4, t3) {
                var r3 = this.createNode();
                this.expect("...");
                var n3 = this.parsePattern(e4, t3);
                return this.finalize(r3, new a.RestElement(n3));
              }, e3.prototype.parseArrayPattern = function(e4, t3) {
                var r3 = this.createNode();
                this.expect("[");
                for (var n3 = []; !this.match("]"); ) if (this.match(",")) this.nextToken(), n3.push(null);
                else {
                  if (this.match("...")) {
                    n3.push(this.parseBindingRestElement(e4, t3));
                    break;
                  }
                  n3.push(this.parsePatternWithDefault(e4, t3)), this.match("]") || this.expect(",");
                }
                return this.expect("]"), this.finalize(r3, new a.ArrayPattern(n3));
              }, e3.prototype.parsePropertyPattern = function(e4, t3) {
                var r3, n3, i2 = this.createNode(), o2 = false, s2 = false;
                if (3 === this.lookahead.type) {
                  var u2 = this.lookahead;
                  r3 = this.parseVariableIdentifier();
                  var l2 = this.finalize(i2, new a.Identifier(u2.value));
                  if (this.match("=")) {
                    e4.push(u2), s2 = true, this.nextToken();
                    var c2 = this.parseAssignmentExpression();
                    n3 = this.finalize(this.startNode(u2), new a.AssignmentPattern(l2, c2));
                  } else this.match(":") ? (this.expect(":"), n3 = this.parsePatternWithDefault(e4, t3)) : (e4.push(u2), s2 = true, n3 = l2);
                } else o2 = this.match("["), r3 = this.parseObjectPropertyKey(), this.expect(":"), n3 = this.parsePatternWithDefault(e4, t3);
                return this.finalize(i2, new a.Property("init", r3, o2, n3, false, s2));
              }, e3.prototype.parseObjectPattern = function(e4, t3) {
                var r3 = this.createNode(), n3 = [];
                for (this.expect("{"); !this.match("}"); ) n3.push(this.parsePropertyPattern(e4, t3)), this.match("}") || this.expect(",");
                return this.expect("}"), this.finalize(r3, new a.ObjectPattern(n3));
              }, e3.prototype.parsePattern = function(e4, t3) {
                var r3;
                return this.match("[") ? r3 = this.parseArrayPattern(e4, t3) : this.match("{") ? r3 = this.parseObjectPattern(e4, t3) : (!this.matchKeyword("let") || "const" !== t3 && "let" !== t3 || this.tolerateUnexpectedToken(this.lookahead, o.Messages.LetInLexicalBinding), e4.push(this.lookahead), r3 = this.parseVariableIdentifier(t3)), r3;
              }, e3.prototype.parsePatternWithDefault = function(e4, t3) {
                var r3 = this.lookahead, n3 = this.parsePattern(e4, t3);
                if (this.match("=")) {
                  this.nextToken();
                  var i2 = this.context.allowYield;
                  this.context.allowYield = true;
                  var o2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowYield = i2, n3 = this.finalize(this.startNode(r3), new a.AssignmentPattern(n3, o2));
                }
                return n3;
              }, e3.prototype.parseVariableIdentifier = function(e4) {
                var t3 = this.createNode(), r3 = this.nextToken();
                return 4 === r3.type && "yield" === r3.value ? this.context.strict ? this.tolerateUnexpectedToken(r3, o.Messages.StrictReservedWord) : this.context.allowYield || this.throwUnexpectedToken(r3) : 3 !== r3.type ? this.context.strict && 4 === r3.type && this.scanner.isStrictModeReservedWord(r3.value) ? this.tolerateUnexpectedToken(r3, o.Messages.StrictReservedWord) : (this.context.strict || "let" !== r3.value || "var" !== e4) && this.throwUnexpectedToken(r3) : (this.context.isModule || this.context.await) && 3 === r3.type && "await" === r3.value && this.tolerateUnexpectedToken(r3), this.finalize(t3, new a.Identifier(r3.value));
              }, e3.prototype.parseVariableDeclaration = function(e4) {
                var t3 = this.createNode(), r3 = this.parsePattern([], "var");
                this.context.strict && r3.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(r3.name) && this.tolerateError(o.Messages.StrictVarName);
                var n3 = null;
                return this.match("=") ? (this.nextToken(), n3 = this.isolateCoverGrammar(this.parseAssignmentExpression)) : r3.type === u.Syntax.Identifier || e4.inFor || this.expect("="), this.finalize(t3, new a.VariableDeclarator(r3, n3));
              }, e3.prototype.parseVariableDeclarationList = function(e4) {
                var t3 = { inFor: e4.inFor }, r3 = [];
                for (r3.push(this.parseVariableDeclaration(t3)); this.match(","); ) this.nextToken(), r3.push(this.parseVariableDeclaration(t3));
                return r3;
              }, e3.prototype.parseVariableStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("var");
                var t3 = this.parseVariableDeclarationList({ inFor: false });
                return this.consumeSemicolon(), this.finalize(e4, new a.VariableDeclaration(t3, "var"));
              }, e3.prototype.parseEmptyStatement = function() {
                var e4 = this.createNode();
                return this.expect(";"), this.finalize(e4, new a.EmptyStatement());
              }, e3.prototype.parseExpressionStatement = function() {
                var e4 = this.createNode(), t3 = this.parseExpression();
                return this.consumeSemicolon(), this.finalize(e4, new a.ExpressionStatement(t3));
              }, e3.prototype.parseIfClause = function() {
                return this.context.strict && this.matchKeyword("function") && this.tolerateError(o.Messages.StrictFunction), this.parseStatement();
              }, e3.prototype.parseIfStatement = function() {
                var e4, t3 = this.createNode(), r3 = null;
                this.expectKeyword("if"), this.expect("(");
                var n3 = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), e4 = this.finalize(this.createNode(), new a.EmptyStatement())) : (this.expect(")"), e4 = this.parseIfClause(), this.matchKeyword("else") && (this.nextToken(), r3 = this.parseIfClause())), this.finalize(t3, new a.IfStatement(n3, e4, r3));
              }, e3.prototype.parseDoWhileStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("do");
                var t3 = this.context.inIteration;
                this.context.inIteration = true;
                var r3 = this.parseStatement();
                this.context.inIteration = t3, this.expectKeyword("while"), this.expect("(");
                var n3 = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? this.tolerateUnexpectedToken(this.nextToken()) : (this.expect(")"), this.match(";") && this.nextToken()), this.finalize(e4, new a.DoWhileStatement(r3, n3));
              }, e3.prototype.parseWhileStatement = function() {
                var e4, t3 = this.createNode();
                this.expectKeyword("while"), this.expect("(");
                var r3 = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) this.tolerateUnexpectedToken(this.nextToken()), e4 = this.finalize(this.createNode(), new a.EmptyStatement());
                else {
                  this.expect(")");
                  var n3 = this.context.inIteration;
                  this.context.inIteration = true, e4 = this.parseStatement(), this.context.inIteration = n3;
                }
                return this.finalize(t3, new a.WhileStatement(r3, e4));
              }, e3.prototype.parseForStatement = function() {
                var e4, t3, r3, n3 = null, i2 = null, s2 = null, l2 = true, c2 = this.createNode();
                if (this.expectKeyword("for"), this.expect("("), this.match(";")) this.nextToken();
                else if (this.matchKeyword("var")) {
                  n3 = this.createNode(), this.nextToken();
                  var h = this.context.allowIn;
                  this.context.allowIn = false;
                  var p = this.parseVariableDeclarationList({ inFor: true });
                  if (this.context.allowIn = h, 1 === p.length && this.matchKeyword("in")) {
                    var f = p[0];
                    f.init && (f.id.type === u.Syntax.ArrayPattern || f.id.type === u.Syntax.ObjectPattern || this.context.strict) && this.tolerateError(o.Messages.ForInOfLoopInitializer, "for-in"), n3 = this.finalize(n3, new a.VariableDeclaration(p, "var")), this.nextToken(), e4 = n3, t3 = this.parseExpression(), n3 = null;
                  } else 1 === p.length && null === p[0].init && this.matchContextualKeyword("of") ? (n3 = this.finalize(n3, new a.VariableDeclaration(p, "var")), this.nextToken(), e4 = n3, t3 = this.parseAssignmentExpression(), n3 = null, l2 = false) : (n3 = this.finalize(n3, new a.VariableDeclaration(p, "var")), this.expect(";"));
                } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                  n3 = this.createNode();
                  var d = this.nextToken().value;
                  this.context.strict || "in" !== this.lookahead.value ? (h = this.context.allowIn, this.context.allowIn = false, p = this.parseBindingList(d, { inFor: true }), this.context.allowIn = h, 1 === p.length && null === p[0].init && this.matchKeyword("in") ? (n3 = this.finalize(n3, new a.VariableDeclaration(p, d)), this.nextToken(), e4 = n3, t3 = this.parseExpression(), n3 = null) : 1 === p.length && null === p[0].init && this.matchContextualKeyword("of") ? (n3 = this.finalize(n3, new a.VariableDeclaration(p, d)), this.nextToken(), e4 = n3, t3 = this.parseAssignmentExpression(), n3 = null, l2 = false) : (this.consumeSemicolon(), n3 = this.finalize(n3, new a.VariableDeclaration(p, d)))) : (n3 = this.finalize(n3, new a.Identifier(d)), this.nextToken(), e4 = n3, t3 = this.parseExpression(), n3 = null);
                } else {
                  var m = this.lookahead;
                  if (h = this.context.allowIn, this.context.allowIn = false, n3 = this.inheritCoverGrammar(this.parseAssignmentExpression), this.context.allowIn = h, this.matchKeyword("in")) this.context.isAssignmentTarget && n3.type !== u.Syntax.AssignmentExpression || this.tolerateError(o.Messages.InvalidLHSInForIn), this.nextToken(), this.reinterpretExpressionAsPattern(n3), e4 = n3, t3 = this.parseExpression(), n3 = null;
                  else if (this.matchContextualKeyword("of")) this.context.isAssignmentTarget && n3.type !== u.Syntax.AssignmentExpression || this.tolerateError(o.Messages.InvalidLHSInForLoop), this.nextToken(), this.reinterpretExpressionAsPattern(n3), e4 = n3, t3 = this.parseAssignmentExpression(), n3 = null, l2 = false;
                  else {
                    if (this.match(",")) {
                      for (var y = [n3]; this.match(","); ) this.nextToken(), y.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      n3 = this.finalize(this.startNode(m), new a.SequenceExpression(y));
                    }
                    this.expect(";");
                  }
                }
                if (void 0 === e4 && (this.match(";") || (i2 = this.parseExpression()), this.expect(";"), this.match(")") || (s2 = this.parseExpression())), !this.match(")") && this.config.tolerant) this.tolerateUnexpectedToken(this.nextToken()), r3 = this.finalize(this.createNode(), new a.EmptyStatement());
                else {
                  this.expect(")");
                  var v = this.context.inIteration;
                  this.context.inIteration = true, r3 = this.isolateCoverGrammar(this.parseStatement), this.context.inIteration = v;
                }
                return void 0 === e4 ? this.finalize(c2, new a.ForStatement(n3, i2, s2, r3)) : l2 ? this.finalize(c2, new a.ForInStatement(e4, t3, r3)) : this.finalize(c2, new a.ForOfStatement(e4, t3, r3));
              }, e3.prototype.parseContinueStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("continue");
                var t3 = null;
                if (3 === this.lookahead.type && !this.hasLineTerminator) {
                  var r3 = this.parseVariableIdentifier();
                  t3 = r3;
                  var n3 = "$" + r3.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, n3) || this.throwError(o.Messages.UnknownLabel, r3.name);
                }
                return this.consumeSemicolon(), null !== t3 || this.context.inIteration || this.throwError(o.Messages.IllegalContinue), this.finalize(e4, new a.ContinueStatement(t3));
              }, e3.prototype.parseBreakStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("break");
                var t3 = null;
                if (3 === this.lookahead.type && !this.hasLineTerminator) {
                  var r3 = this.parseVariableIdentifier(), n3 = "$" + r3.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, n3) || this.throwError(o.Messages.UnknownLabel, r3.name), t3 = r3;
                }
                return this.consumeSemicolon(), null !== t3 || this.context.inIteration || this.context.inSwitch || this.throwError(o.Messages.IllegalBreak), this.finalize(e4, new a.BreakStatement(t3));
              }, e3.prototype.parseReturnStatement = function() {
                this.context.inFunctionBody || this.tolerateError(o.Messages.IllegalReturn);
                var e4 = this.createNode();
                this.expectKeyword("return");
                var t3 = (this.match(";") || this.match("}") || this.hasLineTerminator || 2 === this.lookahead.type) && 8 !== this.lookahead.type && 10 !== this.lookahead.type ? null : this.parseExpression();
                return this.consumeSemicolon(), this.finalize(e4, new a.ReturnStatement(t3));
              }, e3.prototype.parseWithStatement = function() {
                this.context.strict && this.tolerateError(o.Messages.StrictModeWith);
                var e4, t3 = this.createNode();
                this.expectKeyword("with"), this.expect("(");
                var r3 = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), e4 = this.finalize(this.createNode(), new a.EmptyStatement())) : (this.expect(")"), e4 = this.parseStatement()), this.finalize(t3, new a.WithStatement(r3, e4));
              }, e3.prototype.parseSwitchCase = function() {
                var e4, t3 = this.createNode();
                this.matchKeyword("default") ? (this.nextToken(), e4 = null) : (this.expectKeyword("case"), e4 = this.parseExpression()), this.expect(":");
                for (var r3 = []; !(this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")); ) r3.push(this.parseStatementListItem());
                return this.finalize(t3, new a.SwitchCase(e4, r3));
              }, e3.prototype.parseSwitchStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("switch"), this.expect("(");
                var t3 = this.parseExpression();
                this.expect(")");
                var r3 = this.context.inSwitch;
                this.context.inSwitch = true;
                var n3 = [], i2 = false;
                for (this.expect("{"); !this.match("}"); ) {
                  var s2 = this.parseSwitchCase();
                  null === s2.test && (i2 && this.throwError(o.Messages.MultipleDefaultsInSwitch), i2 = true), n3.push(s2);
                }
                return this.expect("}"), this.context.inSwitch = r3, this.finalize(e4, new a.SwitchStatement(t3, n3));
              }, e3.prototype.parseLabelledStatement = function() {
                var e4, t3 = this.createNode(), r3 = this.parseExpression();
                if (r3.type === u.Syntax.Identifier && this.match(":")) {
                  this.nextToken();
                  var n3 = r3, i2 = "$" + n3.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, i2) && this.throwError(o.Messages.Redeclaration, "Label", n3.name), this.context.labelSet[i2] = true;
                  var s2 = void 0;
                  if (this.matchKeyword("class")) this.tolerateUnexpectedToken(this.lookahead), s2 = this.parseClassDeclaration();
                  else if (this.matchKeyword("function")) {
                    var l2 = this.lookahead, c2 = this.parseFunctionDeclaration();
                    this.context.strict ? this.tolerateUnexpectedToken(l2, o.Messages.StrictFunction) : c2.generator && this.tolerateUnexpectedToken(l2, o.Messages.GeneratorInLegacyContext), s2 = c2;
                  } else s2 = this.parseStatement();
                  delete this.context.labelSet[i2], e4 = new a.LabeledStatement(n3, s2);
                } else this.consumeSemicolon(), e4 = new a.ExpressionStatement(r3);
                return this.finalize(t3, e4);
              }, e3.prototype.parseThrowStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("throw"), this.hasLineTerminator && this.throwError(o.Messages.NewlineAfterThrow);
                var t3 = this.parseExpression();
                return this.consumeSemicolon(), this.finalize(e4, new a.ThrowStatement(t3));
              }, e3.prototype.parseCatchClause = function() {
                var e4 = this.createNode();
                this.expectKeyword("catch"), this.expect("("), this.match(")") && this.throwUnexpectedToken(this.lookahead);
                for (var t3 = [], r3 = this.parsePattern(t3), n3 = {}, i2 = 0; i2 < t3.length; i2++) {
                  var s2 = "$" + t3[i2].value;
                  Object.prototype.hasOwnProperty.call(n3, s2) && this.tolerateError(o.Messages.DuplicateBinding, t3[i2].value), n3[s2] = true;
                }
                this.context.strict && r3.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(r3.name) && this.tolerateError(o.Messages.StrictCatchVariable), this.expect(")");
                var l2 = this.parseBlock();
                return this.finalize(e4, new a.CatchClause(r3, l2));
              }, e3.prototype.parseFinallyClause = function() {
                return this.expectKeyword("finally"), this.parseBlock();
              }, e3.prototype.parseTryStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("try");
                var t3 = this.parseBlock(), r3 = this.matchKeyword("catch") ? this.parseCatchClause() : null, n3 = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                return r3 || n3 || this.throwError(o.Messages.NoCatchOrFinally), this.finalize(e4, new a.TryStatement(t3, r3, n3));
              }, e3.prototype.parseDebuggerStatement = function() {
                var e4 = this.createNode();
                return this.expectKeyword("debugger"), this.consumeSemicolon(), this.finalize(e4, new a.DebuggerStatement());
              }, e3.prototype.parseStatement = function() {
                var e4;
                switch (this.lookahead.type) {
                  case 1:
                  case 5:
                  case 6:
                  case 8:
                  case 10:
                  case 9:
                    e4 = this.parseExpressionStatement();
                    break;
                  case 7:
                    var t3 = this.lookahead.value;
                    e4 = "{" === t3 ? this.parseBlock() : "(" === t3 ? this.parseExpressionStatement() : ";" === t3 ? this.parseEmptyStatement() : this.parseExpressionStatement();
                    break;
                  case 3:
                    e4 = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                    break;
                  case 4:
                    switch (this.lookahead.value) {
                      case "break":
                        e4 = this.parseBreakStatement();
                        break;
                      case "continue":
                        e4 = this.parseContinueStatement();
                        break;
                      case "debugger":
                        e4 = this.parseDebuggerStatement();
                        break;
                      case "do":
                        e4 = this.parseDoWhileStatement();
                        break;
                      case "for":
                        e4 = this.parseForStatement();
                        break;
                      case "function":
                        e4 = this.parseFunctionDeclaration();
                        break;
                      case "if":
                        e4 = this.parseIfStatement();
                        break;
                      case "return":
                        e4 = this.parseReturnStatement();
                        break;
                      case "switch":
                        e4 = this.parseSwitchStatement();
                        break;
                      case "throw":
                        e4 = this.parseThrowStatement();
                        break;
                      case "try":
                        e4 = this.parseTryStatement();
                        break;
                      case "var":
                        e4 = this.parseVariableStatement();
                        break;
                      case "while":
                        e4 = this.parseWhileStatement();
                        break;
                      case "with":
                        e4 = this.parseWithStatement();
                        break;
                      default:
                        e4 = this.parseExpressionStatement();
                    }
                    break;
                  default:
                    e4 = this.throwUnexpectedToken(this.lookahead);
                }
                return e4;
              }, e3.prototype.parseFunctionSourceElements = function() {
                var e4 = this.createNode();
                this.expect("{");
                var t3 = this.parseDirectivePrologues(), r3 = this.context.labelSet, n3 = this.context.inIteration, i2 = this.context.inSwitch, o2 = this.context.inFunctionBody;
                for (this.context.labelSet = {}, this.context.inIteration = false, this.context.inSwitch = false, this.context.inFunctionBody = true; 2 !== this.lookahead.type && !this.match("}"); ) t3.push(this.parseStatementListItem());
                return this.expect("}"), this.context.labelSet = r3, this.context.inIteration = n3, this.context.inSwitch = i2, this.context.inFunctionBody = o2, this.finalize(e4, new a.BlockStatement(t3));
              }, e3.prototype.validateParam = function(e4, t3, r3) {
                var n3 = "$" + r3;
                this.context.strict ? (this.scanner.isRestrictedWord(r3) && (e4.stricted = t3, e4.message = o.Messages.StrictParamName), Object.prototype.hasOwnProperty.call(e4.paramSet, n3) && (e4.stricted = t3, e4.message = o.Messages.StrictParamDupe)) : e4.firstRestricted || (this.scanner.isRestrictedWord(r3) ? (e4.firstRestricted = t3, e4.message = o.Messages.StrictParamName) : this.scanner.isStrictModeReservedWord(r3) ? (e4.firstRestricted = t3, e4.message = o.Messages.StrictReservedWord) : Object.prototype.hasOwnProperty.call(e4.paramSet, n3) && (e4.stricted = t3, e4.message = o.Messages.StrictParamDupe)), "function" == typeof Object.defineProperty ? Object.defineProperty(e4.paramSet, n3, { value: true, enumerable: true, writable: true, configurable: true }) : e4.paramSet[n3] = true;
              }, e3.prototype.parseRestElement = function(e4) {
                var t3 = this.createNode();
                this.expect("...");
                var r3 = this.parsePattern(e4);
                return this.match("=") && this.throwError(o.Messages.DefaultRestParameter), this.match(")") || this.throwError(o.Messages.ParameterAfterRestParameter), this.finalize(t3, new a.RestElement(r3));
              }, e3.prototype.parseFormalParameter = function(e4) {
                for (var t3 = [], r3 = this.match("...") ? this.parseRestElement(t3) : this.parsePatternWithDefault(t3), n3 = 0; n3 < t3.length; n3++) this.validateParam(e4, t3[n3], t3[n3].value);
                e4.simple = e4.simple && r3 instanceof a.Identifier, e4.params.push(r3);
              }, e3.prototype.parseFormalParameters = function(e4) {
                var t3;
                if (t3 = { simple: true, params: [], firstRestricted: e4 }, this.expect("("), !this.match(")")) for (t3.paramSet = {}; 2 !== this.lookahead.type && (this.parseFormalParameter(t3), !this.match(")")) && (this.expect(","), !this.match(")")); ) ;
                return this.expect(")"), { simple: t3.simple, params: t3.params, stricted: t3.stricted, firstRestricted: t3.firstRestricted, message: t3.message };
              }, e3.prototype.matchAsyncFunction = function() {
                var e4 = this.matchContextualKeyword("async");
                if (e4) {
                  var t3 = this.scanner.saveState();
                  this.scanner.scanComments();
                  var r3 = this.scanner.lex();
                  this.scanner.restoreState(t3), e4 = t3.lineNumber === r3.lineNumber && 4 === r3.type && "function" === r3.value;
                }
                return e4;
              }, e3.prototype.parseFunctionDeclaration = function(e4) {
                var t3 = this.createNode(), r3 = this.matchContextualKeyword("async");
                r3 && this.nextToken(), this.expectKeyword("function");
                var n3, i2 = !r3 && this.match("*");
                i2 && this.nextToken();
                var s2 = null, u2 = null;
                if (!e4 || !this.match("(")) {
                  var l2 = this.lookahead;
                  s2 = this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(l2.value) && this.tolerateUnexpectedToken(l2, o.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(l2.value) ? (u2 = l2, n3 = o.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(l2.value) && (u2 = l2, n3 = o.Messages.StrictReservedWord);
                }
                var c2 = this.context.await, h = this.context.allowYield;
                this.context.await = r3, this.context.allowYield = !i2;
                var p = this.parseFormalParameters(u2), f = p.params, d = p.stricted;
                u2 = p.firstRestricted, p.message && (n3 = p.message);
                var m = this.context.strict, y = this.context.allowStrictDirective;
                this.context.allowStrictDirective = p.simple;
                var v = this.parseFunctionSourceElements();
                return this.context.strict && u2 && this.throwUnexpectedToken(u2, n3), this.context.strict && d && this.tolerateUnexpectedToken(d, n3), this.context.strict = m, this.context.allowStrictDirective = y, this.context.await = c2, this.context.allowYield = h, r3 ? this.finalize(t3, new a.AsyncFunctionDeclaration(s2, f, v)) : this.finalize(t3, new a.FunctionDeclaration(s2, f, v, i2));
              }, e3.prototype.parseFunctionExpression = function() {
                var e4 = this.createNode(), t3 = this.matchContextualKeyword("async");
                t3 && this.nextToken(), this.expectKeyword("function");
                var r3, n3 = !t3 && this.match("*");
                n3 && this.nextToken();
                var i2, s2 = null, u2 = this.context.await, l2 = this.context.allowYield;
                if (this.context.await = t3, this.context.allowYield = !n3, !this.match("(")) {
                  var c2 = this.lookahead;
                  s2 = this.context.strict || n3 || !this.matchKeyword("yield") ? this.parseVariableIdentifier() : this.parseIdentifierName(), this.context.strict ? this.scanner.isRestrictedWord(c2.value) && this.tolerateUnexpectedToken(c2, o.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(c2.value) ? (i2 = c2, r3 = o.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(c2.value) && (i2 = c2, r3 = o.Messages.StrictReservedWord);
                }
                var h = this.parseFormalParameters(i2), p = h.params, f = h.stricted;
                i2 = h.firstRestricted, h.message && (r3 = h.message);
                var d = this.context.strict, m = this.context.allowStrictDirective;
                this.context.allowStrictDirective = h.simple;
                var y = this.parseFunctionSourceElements();
                return this.context.strict && i2 && this.throwUnexpectedToken(i2, r3), this.context.strict && f && this.tolerateUnexpectedToken(f, r3), this.context.strict = d, this.context.allowStrictDirective = m, this.context.await = u2, this.context.allowYield = l2, t3 ? this.finalize(e4, new a.AsyncFunctionExpression(s2, p, y)) : this.finalize(e4, new a.FunctionExpression(s2, p, y, n3));
              }, e3.prototype.parseDirective = function() {
                var e4 = this.lookahead, t3 = this.createNode(), r3 = this.parseExpression(), n3 = r3.type === u.Syntax.Literal ? this.getTokenRaw(e4).slice(1, -1) : null;
                return this.consumeSemicolon(), this.finalize(t3, n3 ? new a.Directive(r3, n3) : new a.ExpressionStatement(r3));
              }, e3.prototype.parseDirectivePrologues = function() {
                for (var e4 = null, t3 = []; ; ) {
                  var r3 = this.lookahead;
                  if (8 !== r3.type) break;
                  var n3 = this.parseDirective();
                  t3.push(n3);
                  var i2 = n3.directive;
                  if ("string" != typeof i2) break;
                  "use strict" === i2 ? (this.context.strict = true, e4 && this.tolerateUnexpectedToken(e4, o.Messages.StrictOctalLiteral), this.context.allowStrictDirective || this.tolerateUnexpectedToken(r3, o.Messages.IllegalLanguageModeDirective)) : !e4 && r3.octal && (e4 = r3);
                }
                return t3;
              }, e3.prototype.qualifiedPropertyName = function(e4) {
                switch (e4.type) {
                  case 3:
                  case 8:
                  case 1:
                  case 5:
                  case 6:
                  case 4:
                    return true;
                  case 7:
                    return "[" === e4.value;
                }
                return false;
              }, e3.prototype.parseGetterMethod = function() {
                var e4 = this.createNode(), t3 = this.context.allowYield;
                this.context.allowYield = true;
                var r3 = this.parseFormalParameters();
                r3.params.length > 0 && this.tolerateError(o.Messages.BadGetterArity);
                var n3 = this.parsePropertyMethod(r3);
                return this.context.allowYield = t3, this.finalize(e4, new a.FunctionExpression(null, r3.params, n3, false));
              }, e3.prototype.parseSetterMethod = function() {
                var e4 = this.createNode(), t3 = this.context.allowYield;
                this.context.allowYield = true;
                var r3 = this.parseFormalParameters();
                1 !== r3.params.length ? this.tolerateError(o.Messages.BadSetterArity) : r3.params[0] instanceof a.RestElement && this.tolerateError(o.Messages.BadSetterRestParameter);
                var n3 = this.parsePropertyMethod(r3);
                return this.context.allowYield = t3, this.finalize(e4, new a.FunctionExpression(null, r3.params, n3, false));
              }, e3.prototype.parseGeneratorMethod = function() {
                var e4 = this.createNode(), t3 = this.context.allowYield;
                this.context.allowYield = true;
                var r3 = this.parseFormalParameters();
                this.context.allowYield = false;
                var n3 = this.parsePropertyMethod(r3);
                return this.context.allowYield = t3, this.finalize(e4, new a.FunctionExpression(null, r3.params, n3, true));
              }, e3.prototype.isStartOfExpression = function() {
                var e4 = true, t3 = this.lookahead.value;
                switch (this.lookahead.type) {
                  case 7:
                    e4 = "[" === t3 || "(" === t3 || "{" === t3 || "+" === t3 || "-" === t3 || "!" === t3 || "~" === t3 || "++" === t3 || "--" === t3 || "/" === t3 || "/=" === t3;
                    break;
                  case 4:
                    e4 = "class" === t3 || "delete" === t3 || "function" === t3 || "let" === t3 || "new" === t3 || "super" === t3 || "this" === t3 || "typeof" === t3 || "void" === t3 || "yield" === t3;
                }
                return e4;
              }, e3.prototype.parseYieldExpression = function() {
                var e4 = this.createNode();
                this.expectKeyword("yield");
                var t3 = null, r3 = false;
                if (!this.hasLineTerminator) {
                  var n3 = this.context.allowYield;
                  this.context.allowYield = false, (r3 = this.match("*")) ? (this.nextToken(), t3 = this.parseAssignmentExpression()) : this.isStartOfExpression() && (t3 = this.parseAssignmentExpression()), this.context.allowYield = n3;
                }
                return this.finalize(e4, new a.YieldExpression(t3, r3));
              }, e3.prototype.parseClassElement = function(e4) {
                var t3 = this.lookahead, r3 = this.createNode(), n3 = "", i2 = null, s2 = null, u2 = false, l2 = false, c2 = false, h = false;
                if (this.match("*")) this.nextToken();
                else if (u2 = this.match("["), "static" === (i2 = this.parseObjectPropertyKey()).name && (this.qualifiedPropertyName(this.lookahead) || this.match("*")) && (t3 = this.lookahead, c2 = true, u2 = this.match("["), this.match("*") ? this.nextToken() : i2 = this.parseObjectPropertyKey()), 3 === t3.type && !this.hasLineTerminator && "async" === t3.value) {
                  var p = this.lookahead.value;
                  ":" !== p && "(" !== p && "*" !== p && (h = true, t3 = this.lookahead, i2 = this.parseObjectPropertyKey(), 3 === t3.type && "constructor" === t3.value && this.tolerateUnexpectedToken(t3, o.Messages.ConstructorIsAsync));
                }
                var f = this.qualifiedPropertyName(this.lookahead);
                return 3 === t3.type ? "get" === t3.value && f ? (n3 = "get", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), this.context.allowYield = false, s2 = this.parseGetterMethod()) : "set" === t3.value && f && (n3 = "set", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), s2 = this.parseSetterMethod()) : 7 === t3.type && "*" === t3.value && f && (n3 = "init", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), s2 = this.parseGeneratorMethod(), l2 = true), !n3 && i2 && this.match("(") && (n3 = "init", s2 = h ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), l2 = true), n3 || this.throwUnexpectedToken(this.lookahead), "init" === n3 && (n3 = "method"), u2 || (c2 && this.isPropertyKey(i2, "prototype") && this.throwUnexpectedToken(t3, o.Messages.StaticPrototype), !c2 && this.isPropertyKey(i2, "constructor") && (("method" !== n3 || !l2 || s2 && s2.generator) && this.throwUnexpectedToken(t3, o.Messages.ConstructorSpecialMethod), e4.value ? this.throwUnexpectedToken(t3, o.Messages.DuplicateConstructor) : e4.value = true, n3 = "constructor")), this.finalize(r3, new a.MethodDefinition(i2, u2, s2, n3, c2));
              }, e3.prototype.parseClassElementList = function() {
                var e4 = [], t3 = { value: false };
                for (this.expect("{"); !this.match("}"); ) this.match(";") ? this.nextToken() : e4.push(this.parseClassElement(t3));
                return this.expect("}"), e4;
              }, e3.prototype.parseClassBody = function() {
                var e4 = this.createNode(), t3 = this.parseClassElementList();
                return this.finalize(e4, new a.ClassBody(t3));
              }, e3.prototype.parseClassDeclaration = function(e4) {
                var t3 = this.createNode(), r3 = this.context.strict;
                this.context.strict = true, this.expectKeyword("class");
                var n3 = e4 && 3 !== this.lookahead.type ? null : this.parseVariableIdentifier(), i2 = null;
                this.matchKeyword("extends") && (this.nextToken(), i2 = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
                var o2 = this.parseClassBody();
                return this.context.strict = r3, this.finalize(t3, new a.ClassDeclaration(n3, i2, o2));
              }, e3.prototype.parseClassExpression = function() {
                var e4 = this.createNode(), t3 = this.context.strict;
                this.context.strict = true, this.expectKeyword("class");
                var r3 = 3 === this.lookahead.type ? this.parseVariableIdentifier() : null, n3 = null;
                this.matchKeyword("extends") && (this.nextToken(), n3 = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
                var i2 = this.parseClassBody();
                return this.context.strict = t3, this.finalize(e4, new a.ClassExpression(r3, n3, i2));
              }, e3.prototype.parseModule = function() {
                this.context.strict = true, this.context.isModule = true, this.scanner.isModule = true;
                for (var e4 = this.createNode(), t3 = this.parseDirectivePrologues(); 2 !== this.lookahead.type; ) t3.push(this.parseStatementListItem());
                return this.finalize(e4, new a.Module(t3));
              }, e3.prototype.parseScript = function() {
                for (var e4 = this.createNode(), t3 = this.parseDirectivePrologues(); 2 !== this.lookahead.type; ) t3.push(this.parseStatementListItem());
                return this.finalize(e4, new a.Script(t3));
              }, e3.prototype.parseModuleSpecifier = function() {
                var e4 = this.createNode();
                8 !== this.lookahead.type && this.throwError(o.Messages.InvalidModuleSpecifier);
                var t3 = this.nextToken(), r3 = this.getTokenRaw(t3);
                return this.finalize(e4, new a.Literal(t3.value, r3));
              }, e3.prototype.parseImportSpecifier = function() {
                var e4, t3, r3 = this.createNode();
                return 3 === this.lookahead.type ? (t3 = e4 = this.parseVariableIdentifier(), this.matchContextualKeyword("as") && (this.nextToken(), t3 = this.parseVariableIdentifier())) : (t3 = e4 = this.parseIdentifierName(), this.matchContextualKeyword("as") ? (this.nextToken(), t3 = this.parseVariableIdentifier()) : this.throwUnexpectedToken(this.nextToken())), this.finalize(r3, new a.ImportSpecifier(t3, e4));
              }, e3.prototype.parseNamedImports = function() {
                this.expect("{");
                for (var e4 = []; !this.match("}"); ) e4.push(this.parseImportSpecifier()), this.match("}") || this.expect(",");
                return this.expect("}"), e4;
              }, e3.prototype.parseImportDefaultSpecifier = function() {
                var e4 = this.createNode(), t3 = this.parseIdentifierName();
                return this.finalize(e4, new a.ImportDefaultSpecifier(t3));
              }, e3.prototype.parseImportNamespaceSpecifier = function() {
                var e4 = this.createNode();
                this.expect("*"), this.matchContextualKeyword("as") || this.throwError(o.Messages.NoAsAfterImportNamespace), this.nextToken();
                var t3 = this.parseIdentifierName();
                return this.finalize(e4, new a.ImportNamespaceSpecifier(t3));
              }, e3.prototype.parseImportDeclaration = function() {
                this.context.inFunctionBody && this.throwError(o.Messages.IllegalImportDeclaration);
                var e4, t3 = this.createNode();
                this.expectKeyword("import");
                var r3 = [];
                if (8 === this.lookahead.type) e4 = this.parseModuleSpecifier();
                else {
                  if (this.match("{") ? r3 = r3.concat(this.parseNamedImports()) : this.match("*") ? r3.push(this.parseImportNamespaceSpecifier()) : this.isIdentifierName(this.lookahead) && !this.matchKeyword("default") ? (r3.push(this.parseImportDefaultSpecifier()), this.match(",") && (this.nextToken(), this.match("*") ? r3.push(this.parseImportNamespaceSpecifier()) : this.match("{") ? r3 = r3.concat(this.parseNamedImports()) : this.throwUnexpectedToken(this.lookahead))) : this.throwUnexpectedToken(this.nextToken()), !this.matchContextualKeyword("from")) {
                    var n3 = this.lookahead.value ? o.Messages.UnexpectedToken : o.Messages.MissingFromClause;
                    this.throwError(n3, this.lookahead.value);
                  }
                  this.nextToken(), e4 = this.parseModuleSpecifier();
                }
                return this.consumeSemicolon(), this.finalize(t3, new a.ImportDeclaration(r3, e4));
              }, e3.prototype.parseExportSpecifier = function() {
                var e4 = this.createNode(), t3 = this.parseIdentifierName(), r3 = t3;
                return this.matchContextualKeyword("as") && (this.nextToken(), r3 = this.parseIdentifierName()), this.finalize(e4, new a.ExportSpecifier(t3, r3));
              }, e3.prototype.parseExportDeclaration = function() {
                this.context.inFunctionBody && this.throwError(o.Messages.IllegalExportDeclaration);
                var e4, t3 = this.createNode();
                if (this.expectKeyword("export"), this.matchKeyword("default")) if (this.nextToken(), this.matchKeyword("function")) {
                  var r3 = this.parseFunctionDeclaration(true);
                  e4 = this.finalize(t3, new a.ExportDefaultDeclaration(r3));
                } else this.matchKeyword("class") ? (r3 = this.parseClassDeclaration(true), e4 = this.finalize(t3, new a.ExportDefaultDeclaration(r3))) : this.matchContextualKeyword("async") ? (r3 = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression(), e4 = this.finalize(t3, new a.ExportDefaultDeclaration(r3))) : (this.matchContextualKeyword("from") && this.throwError(o.Messages.UnexpectedToken, this.lookahead.value), r3 = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression(), this.consumeSemicolon(), e4 = this.finalize(t3, new a.ExportDefaultDeclaration(r3)));
                else if (this.match("*")) {
                  if (this.nextToken(), !this.matchContextualKeyword("from")) {
                    var n3 = this.lookahead.value ? o.Messages.UnexpectedToken : o.Messages.MissingFromClause;
                    this.throwError(n3, this.lookahead.value);
                  }
                  this.nextToken();
                  var i2 = this.parseModuleSpecifier();
                  this.consumeSemicolon(), e4 = this.finalize(t3, new a.ExportAllDeclaration(i2));
                } else if (4 === this.lookahead.type) {
                  switch (r3 = void 0, this.lookahead.value) {
                    case "let":
                    case "const":
                      r3 = this.parseLexicalDeclaration({ inFor: false });
                      break;
                    case "var":
                    case "class":
                    case "function":
                      r3 = this.parseStatementListItem();
                      break;
                    default:
                      this.throwUnexpectedToken(this.lookahead);
                  }
                  e4 = this.finalize(t3, new a.ExportNamedDeclaration(r3, [], null));
                } else if (this.matchAsyncFunction()) r3 = this.parseFunctionDeclaration(), e4 = this.finalize(t3, new a.ExportNamedDeclaration(r3, [], null));
                else {
                  var s2 = [], u2 = null, l2 = false;
                  for (this.expect("{"); !this.match("}"); ) l2 = l2 || this.matchKeyword("default"), s2.push(this.parseExportSpecifier()), this.match("}") || this.expect(",");
                  this.expect("}"), this.matchContextualKeyword("from") ? (this.nextToken(), u2 = this.parseModuleSpecifier(), this.consumeSemicolon()) : l2 ? (n3 = this.lookahead.value ? o.Messages.UnexpectedToken : o.Messages.MissingFromClause, this.throwError(n3, this.lookahead.value)) : this.consumeSemicolon(), e4 = this.finalize(t3, new a.ExportNamedDeclaration(null, s2, u2));
                }
                return e4;
              }, e3;
            }();
            t2.Parser = c;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.assert = function(e3, t3) {
              if (!e3) throw new Error("ASSERT: " + t3);
            };
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var r2 = function() {
              function e3() {
                this.errors = [], this.tolerant = false;
              }
              return e3.prototype.recordError = function(e4) {
                this.errors.push(e4);
              }, e3.prototype.tolerate = function(e4) {
                if (!this.tolerant) throw e4;
                this.recordError(e4);
              }, e3.prototype.constructError = function(e4, t3) {
                var r3 = new Error(e4);
                try {
                  throw r3;
                } catch (e5) {
                  Object.create && Object.defineProperty && (r3 = Object.create(e5), Object.defineProperty(r3, "column", { value: t3 }));
                }
                return r3;
              }, e3.prototype.createError = function(e4, t3, r3, n2) {
                var i = "Line " + t3 + ": " + n2, o = this.constructError(i, r3);
                return o.index = e4, o.lineNumber = t3, o.description = n2, o;
              }, e3.prototype.throwError = function(e4, t3, r3, n2) {
                throw this.createError(e4, t3, r3, n2);
              }, e3.prototype.tolerateError = function(e4, t3, r3, n2) {
                var i = this.createError(e4, t3, r3, n2);
                if (!this.tolerant) throw i;
                this.recordError(i);
              }, e3;
            }();
            t2.ErrorHandler = r2;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.Messages = { BadGetterArity: "Getter must not have any formal parameters", BadSetterArity: "Setter must have exactly one formal parameter", BadSetterRestParameter: "Setter function argument must not be a rest parameter", ConstructorIsAsync: "Class constructor may not be an async method", ConstructorSpecialMethod: "Class constructor may not be an accessor", DeclarationMissingInitializer: "Missing initializer in %0 declaration", DefaultRestParameter: "Unexpected token =", DuplicateBinding: "Duplicate binding %0", DuplicateConstructor: "A class may only have one constructor", DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals", ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer", GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts", IllegalBreak: "Illegal break statement", IllegalContinue: "Illegal continue statement", IllegalExportDeclaration: "Unexpected token", IllegalImportDeclaration: "Unexpected token", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list", IllegalReturn: "Illegal return statement", InvalidEscapedReservedWord: "Keyword must not contain escaped characters", InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence", InvalidLHSInAssignment: "Invalid left-hand side in assignment", InvalidLHSInForIn: "Invalid left-hand side in for-in", InvalidLHSInForLoop: "Invalid left-hand side in for-loop", InvalidModuleSpecifier: "Unexpected token", InvalidRegExp: "Invalid regular expression", LetInLexicalBinding: "let is disallowed as a lexically bound name", MissingFromClause: "Unexpected token", MultipleDefaultsInSwitch: "More than one default clause in switch statement", NewlineAfterThrow: "Illegal newline after throw", NoAsAfterImportNamespace: "Unexpected token", NoCatchOrFinally: "Missing catch or finally after try", ParameterAfterRestParameter: "Rest parameter must be last formal parameter", Redeclaration: "%0 '%1' has already been declared", StaticPrototype: "Classes may not have static property named prototype", StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode", StrictDelete: "Delete of an unqualified identifier in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block", StrictFunctionName: "Function name may not be eval or arguments in strict mode", StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode", StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode", StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode", StrictModeWith: "Strict mode code may not include a with statement", StrictOctalLiteral: "Octal literals are not allowed in strict mode.", StrictParamDupe: "Strict mode function may not have duplicate parameter names", StrictParamName: "Parameter name eval or arguments is not allowed in strict mode", StrictReservedWord: "Use of future reserved word in strict mode", StrictVarName: "Variable name may not be eval or arguments in strict mode", TemplateOctalLiteral: "Octal literals are not allowed in template strings.", UnexpectedEOS: "Unexpected end of input", UnexpectedIdentifier: "Unexpected identifier", UnexpectedNumber: "Unexpected number", UnexpectedReserved: "Unexpected reserved word", UnexpectedString: "Unexpected string", UnexpectedTemplate: "Unexpected quasi %0", UnexpectedToken: "Unexpected token %0", UnexpectedTokenIllegal: "Unexpected token ILLEGAL", UnknownLabel: "Undefined label '%0'", UnterminatedRegExp: "Invalid regular expression: missing /" };
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(9), i = r2(4), o = r2(11);
            function a(e3) {
              return "0123456789abcdef".indexOf(e3.toLowerCase());
            }
            function s(e3) {
              return "01234567".indexOf(e3);
            }
            var u = function() {
              function e3(e4, t3) {
                this.source = e4, this.errorHandler = t3, this.trackComment = false, this.isModule = false, this.length = e4.length, this.index = 0, this.lineNumber = e4.length > 0 ? 1 : 0, this.lineStart = 0, this.curlyStack = [];
              }
              return e3.prototype.saveState = function() {
                return { index: this.index, lineNumber: this.lineNumber, lineStart: this.lineStart };
              }, e3.prototype.restoreState = function(e4) {
                this.index = e4.index, this.lineNumber = e4.lineNumber, this.lineStart = e4.lineStart;
              }, e3.prototype.eof = function() {
                return this.index >= this.length;
              }, e3.prototype.throwUnexpectedToken = function(e4) {
                return void 0 === e4 && (e4 = o.Messages.UnexpectedTokenIllegal), this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, e4);
              }, e3.prototype.tolerateUnexpectedToken = function(e4) {
                void 0 === e4 && (e4 = o.Messages.UnexpectedTokenIllegal), this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, e4);
              }, e3.prototype.skipSingleLineComment = function(e4) {
                var t3, r3, n3 = [];
                for (this.trackComment && (n3 = [], t3 = this.index - e4, r3 = { start: { line: this.lineNumber, column: this.index - this.lineStart - e4 }, end: {} }); !this.eof(); ) {
                  var o2 = this.source.charCodeAt(this.index);
                  if (++this.index, i.Character.isLineTerminator(o2)) {
                    if (this.trackComment) {
                      r3.end = { line: this.lineNumber, column: this.index - this.lineStart - 1 };
                      var a2 = { multiLine: false, slice: [t3 + e4, this.index - 1], range: [t3, this.index - 1], loc: r3 };
                      n3.push(a2);
                    }
                    return 13 === o2 && 10 === this.source.charCodeAt(this.index) && ++this.index, ++this.lineNumber, this.lineStart = this.index, n3;
                  }
                }
                return this.trackComment && (r3.end = { line: this.lineNumber, column: this.index - this.lineStart }, a2 = { multiLine: false, slice: [t3 + e4, this.index], range: [t3, this.index], loc: r3 }, n3.push(a2)), n3;
              }, e3.prototype.skipMultiLineComment = function() {
                var e4, t3, r3 = [];
                for (this.trackComment && (r3 = [], e4 = this.index - 2, t3 = { start: { line: this.lineNumber, column: this.index - this.lineStart - 2 }, end: {} }); !this.eof(); ) {
                  var n3 = this.source.charCodeAt(this.index);
                  if (i.Character.isLineTerminator(n3)) 13 === n3 && 10 === this.source.charCodeAt(this.index + 1) && ++this.index, ++this.lineNumber, ++this.index, this.lineStart = this.index;
                  else if (42 === n3) {
                    if (47 === this.source.charCodeAt(this.index + 1)) {
                      if (this.index += 2, this.trackComment) {
                        t3.end = { line: this.lineNumber, column: this.index - this.lineStart };
                        var o2 = { multiLine: true, slice: [e4 + 2, this.index - 2], range: [e4, this.index], loc: t3 };
                        r3.push(o2);
                      }
                      return r3;
                    }
                    ++this.index;
                  } else ++this.index;
                }
                return this.trackComment && (t3.end = { line: this.lineNumber, column: this.index - this.lineStart }, o2 = { multiLine: true, slice: [e4 + 2, this.index], range: [e4, this.index], loc: t3 }, r3.push(o2)), this.tolerateUnexpectedToken(), r3;
              }, e3.prototype.scanComments = function() {
                var e4;
                this.trackComment && (e4 = []);
                for (var t3 = 0 === this.index; !this.eof(); ) {
                  var r3 = this.source.charCodeAt(this.index);
                  if (i.Character.isWhiteSpace(r3)) ++this.index;
                  else if (i.Character.isLineTerminator(r3)) ++this.index, 13 === r3 && 10 === this.source.charCodeAt(this.index) && ++this.index, ++this.lineNumber, this.lineStart = this.index, t3 = true;
                  else if (47 === r3) if (47 === (r3 = this.source.charCodeAt(this.index + 1))) {
                    this.index += 2;
                    var n3 = this.skipSingleLineComment(2);
                    this.trackComment && (e4 = e4.concat(n3)), t3 = true;
                  } else {
                    if (42 !== r3) break;
                    this.index += 2, n3 = this.skipMultiLineComment(), this.trackComment && (e4 = e4.concat(n3));
                  }
                  else if (t3 && 45 === r3) {
                    if (45 !== this.source.charCodeAt(this.index + 1) || 62 !== this.source.charCodeAt(this.index + 2)) break;
                    this.index += 3, n3 = this.skipSingleLineComment(3), this.trackComment && (e4 = e4.concat(n3));
                  } else {
                    if (60 !== r3 || this.isModule) break;
                    if ("!--" !== this.source.slice(this.index + 1, this.index + 4)) break;
                    this.index += 4, n3 = this.skipSingleLineComment(4), this.trackComment && (e4 = e4.concat(n3));
                  }
                }
                return e4;
              }, e3.prototype.isFutureReservedWord = function(e4) {
                switch (e4) {
                  case "enum":
                  case "export":
                  case "import":
                  case "super":
                    return true;
                  default:
                    return false;
                }
              }, e3.prototype.isStrictModeReservedWord = function(e4) {
                switch (e4) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "yield":
                  case "let":
                    return true;
                  default:
                    return false;
                }
              }, e3.prototype.isRestrictedWord = function(e4) {
                return "eval" === e4 || "arguments" === e4;
              }, e3.prototype.isKeyword = function(e4) {
                switch (e4.length) {
                  case 2:
                    return "if" === e4 || "in" === e4 || "do" === e4;
                  case 3:
                    return "var" === e4 || "for" === e4 || "new" === e4 || "try" === e4 || "let" === e4;
                  case 4:
                    return "this" === e4 || "else" === e4 || "case" === e4 || "void" === e4 || "with" === e4 || "enum" === e4;
                  case 5:
                    return "while" === e4 || "break" === e4 || "catch" === e4 || "throw" === e4 || "const" === e4 || "yield" === e4 || "class" === e4 || "super" === e4;
                  case 6:
                    return "return" === e4 || "typeof" === e4 || "delete" === e4 || "switch" === e4 || "export" === e4 || "import" === e4;
                  case 7:
                    return "default" === e4 || "finally" === e4 || "extends" === e4;
                  case 8:
                    return "function" === e4 || "continue" === e4 || "debugger" === e4;
                  case 10:
                    return "instanceof" === e4;
                  default:
                    return false;
                }
              }, e3.prototype.codePointAt = function(e4) {
                var t3 = this.source.charCodeAt(e4);
                if (t3 >= 55296 && t3 <= 56319) {
                  var r3 = this.source.charCodeAt(e4 + 1);
                  r3 >= 56320 && r3 <= 57343 && (t3 = 1024 * (t3 - 55296) + r3 - 56320 + 65536);
                }
                return t3;
              }, e3.prototype.scanHexEscape = function(e4) {
                for (var t3 = "u" === e4 ? 4 : 2, r3 = 0, n3 = 0; n3 < t3; ++n3) {
                  if (this.eof() || !i.Character.isHexDigit(this.source.charCodeAt(this.index))) return null;
                  r3 = 16 * r3 + a(this.source[this.index++]);
                }
                return String.fromCharCode(r3);
              }, e3.prototype.scanUnicodeCodePointEscape = function() {
                var e4 = this.source[this.index], t3 = 0;
                for ("}" === e4 && this.throwUnexpectedToken(); !this.eof() && (e4 = this.source[this.index++], i.Character.isHexDigit(e4.charCodeAt(0))); ) t3 = 16 * t3 + a(e4);
                return (t3 > 1114111 || "}" !== e4) && this.throwUnexpectedToken(), i.Character.fromCodePoint(t3);
              }, e3.prototype.getIdentifier = function() {
                for (var e4 = this.index++; !this.eof(); ) {
                  var t3 = this.source.charCodeAt(this.index);
                  if (92 === t3) return this.index = e4, this.getComplexIdentifier();
                  if (t3 >= 55296 && t3 < 57343) return this.index = e4, this.getComplexIdentifier();
                  if (!i.Character.isIdentifierPart(t3)) break;
                  ++this.index;
                }
                return this.source.slice(e4, this.index);
              }, e3.prototype.getComplexIdentifier = function() {
                var e4, t3 = this.codePointAt(this.index), r3 = i.Character.fromCodePoint(t3);
                for (this.index += r3.length, 92 === t3 && (117 !== this.source.charCodeAt(this.index) && this.throwUnexpectedToken(), ++this.index, "{" === this.source[this.index] ? (++this.index, e4 = this.scanUnicodeCodePointEscape()) : null !== (e4 = this.scanHexEscape("u")) && "\\" !== e4 && i.Character.isIdentifierStart(e4.charCodeAt(0)) || this.throwUnexpectedToken(), r3 = e4); !this.eof() && (t3 = this.codePointAt(this.index), i.Character.isIdentifierPart(t3)); ) r3 += e4 = i.Character.fromCodePoint(t3), this.index += e4.length, 92 === t3 && (r3 = r3.substr(0, r3.length - 1), 117 !== this.source.charCodeAt(this.index) && this.throwUnexpectedToken(), ++this.index, "{" === this.source[this.index] ? (++this.index, e4 = this.scanUnicodeCodePointEscape()) : null !== (e4 = this.scanHexEscape("u")) && "\\" !== e4 && i.Character.isIdentifierPart(e4.charCodeAt(0)) || this.throwUnexpectedToken(), r3 += e4);
                return r3;
              }, e3.prototype.octalToDecimal = function(e4) {
                var t3 = "0" !== e4, r3 = s(e4);
                return !this.eof() && i.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (t3 = true, r3 = 8 * r3 + s(this.source[this.index++]), "0123".indexOf(e4) >= 0 && !this.eof() && i.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (r3 = 8 * r3 + s(this.source[this.index++]))), { code: r3, octal: t3 };
              }, e3.prototype.scanIdentifier = function() {
                var e4, t3 = this.index, r3 = 92 === this.source.charCodeAt(t3) ? this.getComplexIdentifier() : this.getIdentifier();
                if (3 != (e4 = 1 === r3.length ? 3 : this.isKeyword(r3) ? 4 : "null" === r3 ? 5 : "true" === r3 || "false" === r3 ? 1 : 3) && t3 + r3.length !== this.index) {
                  var n3 = this.index;
                  this.index = t3, this.tolerateUnexpectedToken(o.Messages.InvalidEscapedReservedWord), this.index = n3;
                }
                return { type: e4, value: r3, lineNumber: this.lineNumber, lineStart: this.lineStart, start: t3, end: this.index };
              }, e3.prototype.scanPunctuator = function() {
                var e4 = this.index, t3 = this.source[this.index];
                switch (t3) {
                  case "(":
                  case "{":
                    "{" === t3 && this.curlyStack.push("{"), ++this.index;
                    break;
                  case ".":
                    ++this.index, "." === this.source[this.index] && "." === this.source[this.index + 1] && (this.index += 2, t3 = "...");
                    break;
                  case "}":
                    ++this.index, this.curlyStack.pop();
                    break;
                  case ")":
                  case ";":
                  case ",":
                  case "[":
                  case "]":
                  case ":":
                  case "?":
                  case "~":
                    ++this.index;
                    break;
                  default:
                    ">>>=" === (t3 = this.source.substr(this.index, 4)) ? this.index += 4 : "===" === (t3 = t3.substr(0, 3)) || "!==" === t3 || ">>>" === t3 || "<<=" === t3 || ">>=" === t3 || "**=" === t3 ? this.index += 3 : "&&" === (t3 = t3.substr(0, 2)) || "||" === t3 || "==" === t3 || "!=" === t3 || "+=" === t3 || "-=" === t3 || "*=" === t3 || "/=" === t3 || "++" === t3 || "--" === t3 || "<<" === t3 || ">>" === t3 || "&=" === t3 || "|=" === t3 || "^=" === t3 || "%=" === t3 || "<=" === t3 || ">=" === t3 || "=>" === t3 || "**" === t3 ? this.index += 2 : (t3 = this.source[this.index], "<>=!+-*%&|^/".indexOf(t3) >= 0 && ++this.index);
                }
                return this.index === e4 && this.throwUnexpectedToken(), { type: 7, value: t3, lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.scanHexLiteral = function(e4) {
                for (var t3 = ""; !this.eof() && i.Character.isHexDigit(this.source.charCodeAt(this.index)); ) t3 += this.source[this.index++];
                return 0 === t3.length && this.throwUnexpectedToken(), i.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), { type: 6, value: parseInt("0x" + t3, 16), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.scanBinaryLiteral = function(e4) {
                for (var t3, r3 = ""; !this.eof() && ("0" === (t3 = this.source[this.index]) || "1" === t3); ) r3 += this.source[this.index++];
                return 0 === r3.length && this.throwUnexpectedToken(), this.eof() || (t3 = this.source.charCodeAt(this.index), (i.Character.isIdentifierStart(t3) || i.Character.isDecimalDigit(t3)) && this.throwUnexpectedToken()), { type: 6, value: parseInt(r3, 2), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.scanOctalLiteral = function(e4, t3) {
                var r3 = "", n3 = false;
                for (i.Character.isOctalDigit(e4.charCodeAt(0)) ? (n3 = true, r3 = "0" + this.source[this.index++]) : ++this.index; !this.eof() && i.Character.isOctalDigit(this.source.charCodeAt(this.index)); ) r3 += this.source[this.index++];
                return n3 || 0 !== r3.length || this.throwUnexpectedToken(), (i.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || i.Character.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), { type: 6, value: parseInt(r3, 8), octal: n3, lineNumber: this.lineNumber, lineStart: this.lineStart, start: t3, end: this.index };
              }, e3.prototype.isImplicitOctalLiteral = function() {
                for (var e4 = this.index + 1; e4 < this.length; ++e4) {
                  var t3 = this.source[e4];
                  if ("8" === t3 || "9" === t3) return false;
                  if (!i.Character.isOctalDigit(t3.charCodeAt(0))) return true;
                }
                return true;
              }, e3.prototype.scanNumericLiteral = function() {
                var e4 = this.index, t3 = this.source[e4];
                n2.assert(i.Character.isDecimalDigit(t3.charCodeAt(0)) || "." === t3, "Numeric literal must start with a decimal digit or a decimal point");
                var r3 = "";
                if ("." !== t3) {
                  if (r3 = this.source[this.index++], t3 = this.source[this.index], "0" === r3) {
                    if ("x" === t3 || "X" === t3) return ++this.index, this.scanHexLiteral(e4);
                    if ("b" === t3 || "B" === t3) return ++this.index, this.scanBinaryLiteral(e4);
                    if ("o" === t3 || "O" === t3) return this.scanOctalLiteral(t3, e4);
                    if (t3 && i.Character.isOctalDigit(t3.charCodeAt(0)) && this.isImplicitOctalLiteral()) return this.scanOctalLiteral(t3, e4);
                  }
                  for (; i.Character.isDecimalDigit(this.source.charCodeAt(this.index)); ) r3 += this.source[this.index++];
                  t3 = this.source[this.index];
                }
                if ("." === t3) {
                  for (r3 += this.source[this.index++]; i.Character.isDecimalDigit(this.source.charCodeAt(this.index)); ) r3 += this.source[this.index++];
                  t3 = this.source[this.index];
                }
                if ("e" === t3 || "E" === t3) if (r3 += this.source[this.index++], "+" !== (t3 = this.source[this.index]) && "-" !== t3 || (r3 += this.source[this.index++]), i.Character.isDecimalDigit(this.source.charCodeAt(this.index))) for (; i.Character.isDecimalDigit(this.source.charCodeAt(this.index)); ) r3 += this.source[this.index++];
                else this.throwUnexpectedToken();
                return i.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), { type: 6, value: parseFloat(r3), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.scanStringLiteral = function() {
                var e4 = this.index, t3 = this.source[e4];
                n2.assert("'" === t3 || '"' === t3, "String literal must starts with a quote"), ++this.index;
                for (var r3 = false, a2 = ""; !this.eof(); ) {
                  var s2 = this.source[this.index++];
                  if (s2 === t3) {
                    t3 = "";
                    break;
                  }
                  if ("\\" === s2) if ((s2 = this.source[this.index++]) && i.Character.isLineTerminator(s2.charCodeAt(0))) ++this.lineNumber, "\r" === s2 && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index;
                  else switch (s2) {
                    case "u":
                      if ("{" === this.source[this.index]) ++this.index, a2 += this.scanUnicodeCodePointEscape();
                      else {
                        var u2 = this.scanHexEscape(s2);
                        null === u2 && this.throwUnexpectedToken(), a2 += u2;
                      }
                      break;
                    case "x":
                      var l = this.scanHexEscape(s2);
                      null === l && this.throwUnexpectedToken(o.Messages.InvalidHexEscapeSequence), a2 += l;
                      break;
                    case "n":
                      a2 += "\n";
                      break;
                    case "r":
                      a2 += "\r";
                      break;
                    case "t":
                      a2 += "	";
                      break;
                    case "b":
                      a2 += "\b";
                      break;
                    case "f":
                      a2 += "\f";
                      break;
                    case "v":
                      a2 += "\v";
                      break;
                    case "8":
                    case "9":
                      a2 += s2, this.tolerateUnexpectedToken();
                      break;
                    default:
                      if (s2 && i.Character.isOctalDigit(s2.charCodeAt(0))) {
                        var c = this.octalToDecimal(s2);
                        r3 = c.octal || r3, a2 += String.fromCharCode(c.code);
                      } else a2 += s2;
                  }
                  else {
                    if (i.Character.isLineTerminator(s2.charCodeAt(0))) break;
                    a2 += s2;
                  }
                }
                return "" !== t3 && (this.index = e4, this.throwUnexpectedToken()), { type: 8, value: a2, octal: r3, lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.scanTemplate = function() {
                var e4 = "", t3 = false, r3 = this.index, n3 = "`" === this.source[r3], a2 = false, s2 = 2;
                for (++this.index; !this.eof(); ) {
                  var u2 = this.source[this.index++];
                  if ("`" === u2) {
                    s2 = 1, a2 = true, t3 = true;
                    break;
                  }
                  if ("$" === u2) {
                    if ("{" === this.source[this.index]) {
                      this.curlyStack.push("${"), ++this.index, t3 = true;
                      break;
                    }
                    e4 += u2;
                  } else if ("\\" === u2) if (u2 = this.source[this.index++], i.Character.isLineTerminator(u2.charCodeAt(0))) ++this.lineNumber, "\r" === u2 && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index;
                  else switch (u2) {
                    case "n":
                      e4 += "\n";
                      break;
                    case "r":
                      e4 += "\r";
                      break;
                    case "t":
                      e4 += "	";
                      break;
                    case "u":
                      if ("{" === this.source[this.index]) ++this.index, e4 += this.scanUnicodeCodePointEscape();
                      else {
                        var l = this.index, c = this.scanHexEscape(u2);
                        null !== c ? e4 += c : (this.index = l, e4 += u2);
                      }
                      break;
                    case "x":
                      var h = this.scanHexEscape(u2);
                      null === h && this.throwUnexpectedToken(o.Messages.InvalidHexEscapeSequence), e4 += h;
                      break;
                    case "b":
                      e4 += "\b";
                      break;
                    case "f":
                      e4 += "\f";
                      break;
                    case "v":
                      e4 += "\v";
                      break;
                    default:
                      "0" === u2 ? (i.Character.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(o.Messages.TemplateOctalLiteral), e4 += "\0") : i.Character.isOctalDigit(u2.charCodeAt(0)) ? this.throwUnexpectedToken(o.Messages.TemplateOctalLiteral) : e4 += u2;
                  }
                  else i.Character.isLineTerminator(u2.charCodeAt(0)) ? (++this.lineNumber, "\r" === u2 && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index, e4 += "\n") : e4 += u2;
                }
                return t3 || this.throwUnexpectedToken(), n3 || this.curlyStack.pop(), { type: 10, value: this.source.slice(r3 + 1, this.index - s2), cooked: e4, head: n3, tail: a2, lineNumber: this.lineNumber, lineStart: this.lineStart, start: r3, end: this.index };
              }, e3.prototype.testRegExp = function(e4, t3) {
                var r3 = e4, n3 = this;
                t3.indexOf("u") >= 0 && (r3 = r3.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function(e5, t4, r4) {
                  var i2 = parseInt(t4 || r4, 16);
                  return i2 > 1114111 && n3.throwUnexpectedToken(o.Messages.InvalidRegExp), i2 <= 65535 ? String.fromCharCode(i2) : "";
                }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, ""));
                try {
                  RegExp(r3);
                } catch (e5) {
                  this.throwUnexpectedToken(o.Messages.InvalidRegExp);
                }
                try {
                  return new RegExp(e4, t3);
                } catch (e5) {
                  return null;
                }
              }, e3.prototype.scanRegExpBody = function() {
                var e4 = this.source[this.index];
                n2.assert("/" === e4, "Regular expression literal must start with a slash");
                for (var t3 = this.source[this.index++], r3 = false, a2 = false; !this.eof(); ) if (t3 += e4 = this.source[this.index++], "\\" === e4) e4 = this.source[this.index++], i.Character.isLineTerminator(e4.charCodeAt(0)) && this.throwUnexpectedToken(o.Messages.UnterminatedRegExp), t3 += e4;
                else if (i.Character.isLineTerminator(e4.charCodeAt(0))) this.throwUnexpectedToken(o.Messages.UnterminatedRegExp);
                else if (r3) "]" === e4 && (r3 = false);
                else {
                  if ("/" === e4) {
                    a2 = true;
                    break;
                  }
                  "[" === e4 && (r3 = true);
                }
                return a2 || this.throwUnexpectedToken(o.Messages.UnterminatedRegExp), t3.substr(1, t3.length - 2);
              }, e3.prototype.scanRegExpFlags = function() {
                for (var e4 = ""; !this.eof(); ) {
                  var t3 = this.source[this.index];
                  if (!i.Character.isIdentifierPart(t3.charCodeAt(0))) break;
                  if (++this.index, "\\" !== t3 || this.eof()) e4 += t3;
                  else if ("u" === (t3 = this.source[this.index])) {
                    ++this.index;
                    var r3 = this.index, n3 = this.scanHexEscape("u");
                    if (null !== n3) for (e4 += n3; r3 < this.index; ++r3) this.source[r3];
                    else this.index = r3, e4 += "u";
                    this.tolerateUnexpectedToken();
                  } else this.tolerateUnexpectedToken();
                }
                return e4;
              }, e3.prototype.scanRegExp = function() {
                var e4 = this.index, t3 = this.scanRegExpBody(), r3 = this.scanRegExpFlags();
                return { type: 9, value: "", pattern: t3, flags: r3, regex: this.testRegExp(t3, r3), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.lex = function() {
                if (this.eof()) return { type: 2, value: "", lineNumber: this.lineNumber, lineStart: this.lineStart, start: this.index, end: this.index };
                var e4 = this.source.charCodeAt(this.index);
                return i.Character.isIdentifierStart(e4) ? this.scanIdentifier() : 40 === e4 || 41 === e4 || 59 === e4 ? this.scanPunctuator() : 39 === e4 || 34 === e4 ? this.scanStringLiteral() : 46 === e4 ? i.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this.scanNumericLiteral() : this.scanPunctuator() : i.Character.isDecimalDigit(e4) ? this.scanNumericLiteral() : 96 === e4 || 125 === e4 && "${" === this.curlyStack[this.curlyStack.length - 1] ? this.scanTemplate() : e4 >= 55296 && e4 < 57343 && i.Character.isIdentifierStart(this.codePointAt(this.index)) ? this.scanIdentifier() : this.scanPunctuator();
              }, e3;
            }();
            t2.Scanner = u;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.TokenName = {}, t2.TokenName[1] = "Boolean", t2.TokenName[2] = "<end>", t2.TokenName[3] = "Identifier", t2.TokenName[4] = "Keyword", t2.TokenName[5] = "Null", t2.TokenName[6] = "Numeric", t2.TokenName[7] = "Punctuator", t2.TokenName[8] = "String", t2.TokenName[9] = "RegularExpression", t2.TokenName[10] = "Template";
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.XHTMLEntities = { quot: '"', amp: "&", apos: "'", gt: ">", nbsp: "", iexcl: "", cent: "", pound: "", curren: "", yen: "", brvbar: "", sect: "", uml: "", copy: "", ordf: "", laquo: "", not: "", shy: "", reg: "", macr: "", deg: "", plusmn: "", sup2: "", sup3: "", acute: "", micro: "", para: "", middot: "", cedil: "", sup1: "", ordm: "", raquo: "", frac14: "", frac12: "", frac34: "", iquest: "", Agrave: "", Aacute: "", Acirc: "", Atilde: "", Auml: "", Aring: "", AElig: "", Ccedil: "", Egrave: "", Eacute: "", Ecirc: "", Euml: "", Igrave: "", Iacute: "", Icirc: "", Iuml: "", ETH: "", Ntilde: "", Ograve: "", Oacute: "", Ocirc: "", Otilde: "", Ouml: "", times: "", Oslash: "", Ugrave: "", Uacute: "", Ucirc: "", Uuml: "", Yacute: "", THORN: "", szlig: "", agrave: "", aacute: "", acirc: "", atilde: "", auml: "", aring: "", aelig: "", ccedil: "", egrave: "", eacute: "", ecirc: "", euml: "", igrave: "", iacute: "", icirc: "", iuml: "", eth: "", ntilde: "", ograve: "", oacute: "", ocirc: "", otilde: "", ouml: "", divide: "", oslash: "", ugrave: "", uacute: "", ucirc: "", uuml: "", yacute: "", thorn: "", yuml: "", OElig: "", oelig: "", Scaron: "", scaron: "", Yuml: "", fnof: "", circ: "", tilde: "", Alpha: "", Beta: "", Gamma: "", Delta: "", Epsilon: "", Zeta: "", Eta: "", Theta: "", Iota: "", Kappa: "", Lambda: "", Mu: "", Nu: "", Xi: "", Omicron: "", Pi: "", Rho: "", Sigma: "", Tau: "", Upsilon: "", Phi: "", Chi: "", Psi: "", Omega: "", alpha: "", beta: "", gamma: "", delta: "", epsilon: "", zeta: "", eta: "", theta: "", iota: "", kappa: "", lambda: "", mu: "", nu: "", xi: "", omicron: "", pi: "", rho: "", sigmaf: "", sigma: "", tau: "", upsilon: "", phi: "", chi: "", psi: "", omega: "", thetasym: "", upsih: "", piv: "", ensp: "", emsp: "", thinsp: "", zwnj: "", zwj: "", lrm: "", rlm: "", ndash: "", mdash: "", lsquo: "", rsquo: "", sbquo: "", ldquo: "", rdquo: "", bdquo: "", dagger: "", Dagger: "", bull: "", hellip: "", permil: "", prime: "", Prime: "", lsaquo: "", rsaquo: "", oline: "", frasl: "", euro: "", image: "", weierp: "", real: "", trade: "", alefsym: "", larr: "", uarr: "", rarr: "", darr: "", harr: "", crarr: "", lArr: "", uArr: "", rArr: "", dArr: "", hArr: "", forall: "", part: "", exist: "", empty: "", nabla: "", isin: "", notin: "", ni: "", prod: "", sum: "", minus: "", lowast: "", radic: "", prop: "", infin: "", ang: "", and: "", or: "", cap: "", cup: "", int: "", there4: "", sim: "", cong: "", asymp: "", ne: "", equiv: "", le: "", ge: "", sub: "", sup: "", nsub: "", sube: "", supe: "", oplus: "", otimes: "", perp: "", sdot: "", lceil: "", rceil: "", lfloor: "", rfloor: "", loz: "", spades: "", clubs: "", hearts: "", diams: "", lang: "", rang: "" };
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(10), i = r2(12), o = r2(13), a = function() {
              function e3() {
                this.values = [], this.curly = this.paren = -1;
              }
              return e3.prototype.beforeFunctionExpression = function(e4) {
                return ["(", "{", "[", "in", "typeof", "instanceof", "new", "return", "case", "delete", "throw", "void", "=", "+=", "-=", "*=", "**=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ",", "+", "-", "*", "**", "/", "%", "++", "--", "<<", ">>", ">>>", "&", "|", "^", "!", "~", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!=="].indexOf(e4) >= 0;
              }, e3.prototype.isRegexStart = function() {
                var e4 = this.values[this.values.length - 1], t3 = null !== e4;
                switch (e4) {
                  case "this":
                  case "]":
                    t3 = false;
                    break;
                  case ")":
                    var r3 = this.values[this.paren - 1];
                    t3 = "if" === r3 || "while" === r3 || "for" === r3 || "with" === r3;
                    break;
                  case "}":
                    if (t3 = false, "function" === this.values[this.curly - 3]) t3 = !!(n3 = this.values[this.curly - 4]) && !this.beforeFunctionExpression(n3);
                    else if ("function" === this.values[this.curly - 4]) {
                      var n3;
                      t3 = !(n3 = this.values[this.curly - 5]) || !this.beforeFunctionExpression(n3);
                    }
                }
                return t3;
              }, e3.prototype.push = function(e4) {
                7 === e4.type || 4 === e4.type ? ("{" === e4.value ? this.curly = this.values.length : "(" === e4.value && (this.paren = this.values.length), this.values.push(e4.value)) : this.values.push(null);
              }, e3;
            }(), s = function() {
              function e3(e4, t3) {
                this.errorHandler = new n2.ErrorHandler(), this.errorHandler.tolerant = !!t3 && "boolean" == typeof t3.tolerant && t3.tolerant, this.scanner = new i.Scanner(e4, this.errorHandler), this.scanner.trackComment = !!t3 && "boolean" == typeof t3.comment && t3.comment, this.trackRange = !!t3 && "boolean" == typeof t3.range && t3.range, this.trackLoc = !!t3 && "boolean" == typeof t3.loc && t3.loc, this.buffer = [], this.reader = new a();
              }
              return e3.prototype.errors = function() {
                return this.errorHandler.errors;
              }, e3.prototype.getNextToken = function() {
                if (0 === this.buffer.length) {
                  var e4 = this.scanner.scanComments();
                  if (this.scanner.trackComment) for (var t3 = 0; t3 < e4.length; ++t3) {
                    var r3 = e4[t3], n3 = this.scanner.source.slice(r3.slice[0], r3.slice[1]), i2 = { type: r3.multiLine ? "BlockComment" : "LineComment", value: n3 };
                    this.trackRange && (i2.range = r3.range), this.trackLoc && (i2.loc = r3.loc), this.buffer.push(i2);
                  }
                  if (!this.scanner.eof()) {
                    var a2 = void 0;
                    this.trackLoc && (a2 = { start: { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart }, end: {} });
                    var s2 = "/" === this.scanner.source[this.scanner.index] && this.reader.isRegexStart() ? this.scanner.scanRegExp() : this.scanner.lex();
                    this.reader.push(s2);
                    var u = { type: o.TokenName[s2.type], value: this.scanner.source.slice(s2.start, s2.end) };
                    if (this.trackRange && (u.range = [s2.start, s2.end]), this.trackLoc && (a2.end = { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart }, u.loc = a2), 9 === s2.type) {
                      var l = s2.pattern, c = s2.flags;
                      u.regex = { pattern: l, flags: c };
                    }
                    this.buffer.push(u);
                  }
                }
                return this.buffer.shift();
              }, e3;
            }();
            t2.Tokenizer = s;
          }]);
        }, e.exports = n();
      }, function(e, t, r) {
        "use strict";
        var n = r(38), i = r(53), o = r(76), a = r(54), s = Object.prototype.toString, u = Object.prototype.hasOwnProperty, l = { 0: "\\0", 7: "\\a", 8: "\\b", 9: "\\t", 10: "\\n", 11: "\\v", 12: "\\f", 13: "\\r", 27: "\\e", 34: '\\"', 92: "\\\\", 133: "\\N", 160: "\\_", 8232: "\\L", 8233: "\\P" }, c = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"];
        function h(e2) {
          var t2, r2, o2;
          if (t2 = e2.toString(16).toUpperCase(), e2 <= 255) r2 = "x", o2 = 2;
          else if (e2 <= 65535) r2 = "u", o2 = 4;
          else {
            if (!(e2 <= 4294967295)) throw new i("code point within a string may not be greater than 0xFFFFFFFF");
            r2 = "U", o2 = 8;
          }
          return "\\" + r2 + n.repeat("0", o2 - t2.length) + t2;
        }
        function p(e2) {
          this.schema = e2.schema || o, this.indent = Math.max(1, e2.indent || 2), this.noArrayIndent = e2.noArrayIndent || false, this.skipInvalid = e2.skipInvalid || false, this.flowLevel = n.isNothing(e2.flowLevel) ? -1 : e2.flowLevel, this.styleMap = function(e3, t2) {
            var r2, n2, i2, o2, a2, s2, l2;
            if (null === t2) return {};
            for (r2 = {}, i2 = 0, o2 = (n2 = Object.keys(t2)).length; i2 < o2; i2 += 1) a2 = n2[i2], s2 = String(t2[a2]), "!!" === a2.slice(0, 2) && (a2 = "tag:yaml.org,2002:" + a2.slice(2)), (l2 = e3.compiledTypeMap.fallback[a2]) && u.call(l2.styleAliases, s2) && (s2 = l2.styleAliases[s2]), r2[a2] = s2;
            return r2;
          }(this.schema, e2.styles || null), this.sortKeys = e2.sortKeys || false, this.lineWidth = e2.lineWidth || 80, this.noRefs = e2.noRefs || false, this.noCompatMode = e2.noCompatMode || false, this.condenseFlow = e2.condenseFlow || false, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
        }
        function f(e2, t2) {
          for (var r2, i2 = n.repeat(" ", t2), o2 = 0, a2 = -1, s2 = "", u2 = e2.length; o2 < u2; ) -1 === (a2 = e2.indexOf("\n", o2)) ? (r2 = e2.slice(o2), o2 = u2) : (r2 = e2.slice(o2, a2 + 1), o2 = a2 + 1), r2.length && "\n" !== r2 && (s2 += i2), s2 += r2;
          return s2;
        }
        function d(e2, t2) {
          return "\n" + n.repeat(" ", e2.indent * t2);
        }
        function m(e2) {
          return 32 === e2 || 9 === e2;
        }
        function y(e2) {
          return 32 <= e2 && e2 <= 126 || 161 <= e2 && e2 <= 55295 && 8232 !== e2 && 8233 !== e2 || 57344 <= e2 && e2 <= 65533 && 65279 !== e2 || 65536 <= e2 && e2 <= 1114111;
        }
        function v(e2, t2) {
          return y(e2) && 65279 !== e2 && 44 !== e2 && 91 !== e2 && 93 !== e2 && 123 !== e2 && 125 !== e2 && 58 !== e2 && (35 !== e2 || t2 && function(e3) {
            return y(e3) && !m(e3) && 65279 !== e3 && 13 !== e3 && 10 !== e3;
          }(t2));
        }
        function _(e2) {
          return /^\n* /.test(e2);
        }
        function g(e2, t2, r2, n2, i2) {
          var o2, a2, s2, u2, l2 = false, c2 = false, h2 = -1 !== n2, p2 = -1, f2 = y(u2 = e2.charCodeAt(0)) && 65279 !== u2 && !m(u2) && 45 !== u2 && 63 !== u2 && 58 !== u2 && 44 !== u2 && 91 !== u2 && 93 !== u2 && 123 !== u2 && 125 !== u2 && 35 !== u2 && 38 !== u2 && 42 !== u2 && 33 !== u2 && 124 !== u2 && 61 !== u2 && 62 !== u2 && 39 !== u2 && 34 !== u2 && 37 !== u2 && 64 !== u2 && 96 !== u2 && !m(e2.charCodeAt(e2.length - 1));
          if (t2) for (o2 = 0; o2 < e2.length; o2++) {
            if (!y(a2 = e2.charCodeAt(o2))) return 5;
            s2 = o2 > 0 ? e2.charCodeAt(o2 - 1) : null, f2 = f2 && v(a2, s2);
          }
          else {
            for (o2 = 0; o2 < e2.length; o2++) {
              if (10 === (a2 = e2.charCodeAt(o2))) l2 = true, h2 && (c2 = c2 || o2 - p2 - 1 > n2 && " " !== e2[p2 + 1], p2 = o2);
              else if (!y(a2)) return 5;
              s2 = o2 > 0 ? e2.charCodeAt(o2 - 1) : null, f2 = f2 && v(a2, s2);
            }
            c2 = c2 || h2 && o2 - p2 - 1 > n2 && " " !== e2[p2 + 1];
          }
          return l2 || c2 ? r2 > 9 && _(e2) ? 5 : c2 ? 4 : 3 : f2 && !i2(e2) ? 1 : 2;
        }
        function b(e2, t2, r2, n2) {
          e2.dump = function() {
            if (0 === t2.length) return "''";
            if (!e2.noCompatMode && -1 !== c.indexOf(t2)) return "'" + t2 + "'";
            var o2 = e2.indent * Math.max(1, r2), a2 = -1 === e2.lineWidth ? -1 : Math.max(Math.min(e2.lineWidth, 40), e2.lineWidth - o2), s2 = n2 || e2.flowLevel > -1 && r2 >= e2.flowLevel;
            switch (g(t2, s2, e2.indent, a2, function(t3) {
              return function(e3, t4) {
                var r3, n3;
                for (r3 = 0, n3 = e3.implicitTypes.length; r3 < n3; r3 += 1) if (e3.implicitTypes[r3].resolve(t4)) return true;
                return false;
              }(e2, t3);
            })) {
              case 1:
                return t2;
              case 2:
                return "'" + t2.replace(/'/g, "''") + "'";
              case 3:
                return "|" + x(t2, e2.indent) + w(f(t2, o2));
              case 4:
                return ">" + x(t2, e2.indent) + w(f(function(e3, t3) {
                  var r3, n3, i2 = /(\n+)([^\n]*)/g, o3 = (s3 = e3.indexOf("\n"), s3 = -1 !== s3 ? s3 : e3.length, i2.lastIndex = s3, E(e3.slice(0, s3), t3)), a3 = "\n" === e3[0] || " " === e3[0];
                  var s3;
                  for (; n3 = i2.exec(e3); ) {
                    var u2 = n3[1], l2 = n3[2];
                    r3 = " " === l2[0], o3 += u2 + (a3 || r3 || "" === l2 ? "" : "\n") + E(l2, t3), a3 = r3;
                  }
                  return o3;
                }(t2, a2), o2));
              case 5:
                return '"' + function(e3) {
                  for (var t3, r3, n3, i2 = "", o3 = 0; o3 < e3.length; o3++) (t3 = e3.charCodeAt(o3)) >= 55296 && t3 <= 56319 && (r3 = e3.charCodeAt(o3 + 1)) >= 56320 && r3 <= 57343 ? (i2 += h(1024 * (t3 - 55296) + r3 - 56320 + 65536), o3++) : (n3 = l[t3], i2 += !n3 && y(t3) ? e3[o3] : n3 || h(t3));
                  return i2;
                }(t2) + '"';
              default:
                throw new i("impossible error: invalid scalar style");
            }
          }();
        }
        function x(e2, t2) {
          var r2 = _(e2) ? String(t2) : "", n2 = "\n" === e2[e2.length - 1];
          return r2 + (n2 && ("\n" === e2[e2.length - 2] || "\n" === e2) ? "+" : n2 ? "" : "-") + "\n";
        }
        function w(e2) {
          return "\n" === e2[e2.length - 1] ? e2.slice(0, -1) : e2;
        }
        function E(e2, t2) {
          if ("" === e2 || " " === e2[0]) return e2;
          for (var r2, n2, i2 = / [^ ]/g, o2 = 0, a2 = 0, s2 = 0, u2 = ""; r2 = i2.exec(e2); ) (s2 = r2.index) - o2 > t2 && (n2 = a2 > o2 ? a2 : s2, u2 += "\n" + e2.slice(o2, n2), o2 = n2 + 1), a2 = s2;
          return u2 += "\n", e2.length - o2 > t2 && a2 > o2 ? u2 += e2.slice(o2, a2) + "\n" + e2.slice(a2 + 1) : u2 += e2.slice(o2), u2.slice(1);
        }
        function D(e2, t2, r2) {
          var n2, o2, a2, l2, c2, h2;
          for (a2 = 0, l2 = (o2 = r2 ? e2.explicitTypes : e2.implicitTypes).length; a2 < l2; a2 += 1) if (((c2 = o2[a2]).instanceOf || c2.predicate) && (!c2.instanceOf || "object" == typeof t2 && t2 instanceof c2.instanceOf) && (!c2.predicate || c2.predicate(t2))) {
            if (e2.tag = r2 ? c2.tag : "?", c2.represent) {
              if (h2 = e2.styleMap[c2.tag] || c2.defaultStyle, "[object Function]" === s.call(c2.represent)) n2 = c2.represent(t2, h2);
              else {
                if (!u.call(c2.represent, h2)) throw new i("!<" + c2.tag + '> tag resolver accepts not "' + h2 + '" style');
                n2 = c2.represent[h2](t2, h2);
              }
              e2.dump = n2;
            }
            return true;
          }
          return false;
        }
        function S(e2, t2, r2, n2, o2, a2) {
          e2.tag = null, e2.dump = r2, D(e2, r2, false) || D(e2, r2, true);
          var u2 = s.call(e2.dump);
          n2 && (n2 = e2.flowLevel < 0 || e2.flowLevel > t2);
          var l2, c2, h2 = "[object Object]" === u2 || "[object Array]" === u2;
          if (h2 && (c2 = -1 !== (l2 = e2.duplicates.indexOf(r2))), (null !== e2.tag && "?" !== e2.tag || c2 || 2 !== e2.indent && t2 > 0) && (o2 = false), c2 && e2.usedDuplicates[l2]) e2.dump = "*ref_" + l2;
          else {
            if (h2 && c2 && !e2.usedDuplicates[l2] && (e2.usedDuplicates[l2] = true), "[object Object]" === u2) n2 && 0 !== Object.keys(e2.dump).length ? (!function(e3, t3, r3, n3) {
              var o3, a3, s2, u3, l3, c3, h3 = "", p3 = e3.tag, f2 = Object.keys(r3);
              if (true === e3.sortKeys) f2.sort();
              else if ("function" == typeof e3.sortKeys) f2.sort(e3.sortKeys);
              else if (e3.sortKeys) throw new i("sortKeys must be a boolean or a function");
              for (o3 = 0, a3 = f2.length; o3 < a3; o3 += 1) c3 = "", n3 && 0 === o3 || (c3 += d(e3, t3)), u3 = r3[s2 = f2[o3]], S(e3, t3 + 1, s2, true, true, true) && ((l3 = null !== e3.tag && "?" !== e3.tag || e3.dump && e3.dump.length > 1024) && (e3.dump && 10 === e3.dump.charCodeAt(0) ? c3 += "?" : c3 += "? "), c3 += e3.dump, l3 && (c3 += d(e3, t3)), S(e3, t3 + 1, u3, true, l3) && (e3.dump && 10 === e3.dump.charCodeAt(0) ? c3 += ":" : c3 += ": ", h3 += c3 += e3.dump));
              e3.tag = p3, e3.dump = h3 || "{}";
            }(e2, t2, e2.dump, o2), c2 && (e2.dump = "&ref_" + l2 + e2.dump)) : (!function(e3, t3, r3) {
              var n3, i2, o3, a3, s2, u3 = "", l3 = e3.tag, c3 = Object.keys(r3);
              for (n3 = 0, i2 = c3.length; n3 < i2; n3 += 1) s2 = "", 0 !== n3 && (s2 += ", "), e3.condenseFlow && (s2 += '"'), a3 = r3[o3 = c3[n3]], S(e3, t3, o3, false, false) && (e3.dump.length > 1024 && (s2 += "? "), s2 += e3.dump + (e3.condenseFlow ? '"' : "") + ":" + (e3.condenseFlow ? "" : " "), S(e3, t3, a3, false, false) && (u3 += s2 += e3.dump));
              e3.tag = l3, e3.dump = "{" + u3 + "}";
            }(e2, t2, e2.dump), c2 && (e2.dump = "&ref_" + l2 + " " + e2.dump));
            else if ("[object Array]" === u2) {
              var p2 = e2.noArrayIndent && t2 > 0 ? t2 - 1 : t2;
              n2 && 0 !== e2.dump.length ? (!function(e3, t3, r3, n3) {
                var i2, o3, a3 = "", s2 = e3.tag;
                for (i2 = 0, o3 = r3.length; i2 < o3; i2 += 1) S(e3, t3 + 1, r3[i2], true, true) && (n3 && 0 === i2 || (a3 += d(e3, t3)), e3.dump && 10 === e3.dump.charCodeAt(0) ? a3 += "-" : a3 += "- ", a3 += e3.dump);
                e3.tag = s2, e3.dump = a3 || "[]";
              }(e2, p2, e2.dump, o2), c2 && (e2.dump = "&ref_" + l2 + e2.dump)) : (!function(e3, t3, r3) {
                var n3, i2, o3 = "", a3 = e3.tag;
                for (n3 = 0, i2 = r3.length; n3 < i2; n3 += 1) S(e3, t3, r3[n3], false, false) && (0 !== n3 && (o3 += "," + (e3.condenseFlow ? "" : " ")), o3 += e3.dump);
                e3.tag = a3, e3.dump = "[" + o3 + "]";
              }(e2, p2, e2.dump), c2 && (e2.dump = "&ref_" + l2 + " " + e2.dump));
            } else {
              if ("[object String]" !== u2) {
                if (e2.skipInvalid) return false;
                throw new i("unacceptable kind of an object to dump " + u2);
              }
              "?" !== e2.tag && b(e2, e2.dump, t2, a2);
            }
            null !== e2.tag && "?" !== e2.tag && (e2.dump = "!<" + e2.tag + "> " + e2.dump);
          }
          return true;
        }
        function C(e2, t2) {
          var r2, n2, i2 = [], o2 = [];
          for (function e3(t3, r3, n3) {
            var i3, o3, a2;
            if (null !== t3 && "object" == typeof t3) if (-1 !== (o3 = r3.indexOf(t3))) -1 === n3.indexOf(o3) && n3.push(o3);
            else if (r3.push(t3), Array.isArray(t3)) for (o3 = 0, a2 = t3.length; o3 < a2; o3 += 1) e3(t3[o3], r3, n3);
            else for (i3 = Object.keys(t3), o3 = 0, a2 = i3.length; o3 < a2; o3 += 1) e3(t3[i3[o3]], r3, n3);
          }(e2, i2, o2), r2 = 0, n2 = o2.length; r2 < n2; r2 += 1) t2.duplicates.push(i2[o2[r2]]);
          t2.usedDuplicates = new Array(n2);
        }
        function A(e2, t2) {
          var r2 = new p(t2 = t2 || {});
          return r2.noRefs || C(e2, r2), S(r2, 0, e2, true, true) ? r2.dump + "\n" : "";
        }
        e.exports.dump = A, e.exports.safeDump = function(e2, t2) {
          return A(e2, n.extend({ schema: a }, t2));
        };
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(64), r(19), r(65), r(20), r(68), r(92), r(144), r(22), r(94), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2) return r2.call(e2);
          if (e2 && "number" == typeof e2.length) return { next: function() {
            return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
          } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, a = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2) return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; ) a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2) throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(91), u = r(1), l = r(183), c = r(0), h = r(7), p = r(95), f = r(69), d = r(3), m = r(305), y = r(306), v = r(307), _ = function(e2) {
          function t2(t3, r2) {
            void 0 === r2 && (r2 = false);
            var n2 = e2.call(this) || this;
            return n2._hasDeclaration = false, n2._docTypeName = "", n2._hasDocumentElement = false, n2._currentElementSerialized = false, n2._openTags = [], n2._ended = false, n2._fragment = r2, n2._options = u.applyDefaults(t3 || {}, s.DefaultXMLBuilderCBOptions), n2._builderOptions = { defaultNamespace: n2._options.defaultNamespace, namespaceAlias: n2._options.namespaceAlias }, "json" === n2._options.format ? n2._writer = new y.JSONCBWriter(n2._options) : "yaml" === n2._options.format ? n2._writer = new v.YAMLCBWriter(n2._options) : n2._writer = new m.XMLCBWriter(n2._options), void 0 !== n2._options.data && n2.on("data", n2._options.data), void 0 !== n2._options.end && n2.on("end", n2._options.end), void 0 !== n2._options.error && n2.on("error", n2._options.error), n2._prefixMap = new p.NamespacePrefixMap(), n2._prefixMap.set("xml", h.namespace.XML), n2._prefixIndex = { value: 1 }, n2._push(n2._writer.frontMatter()), n2;
          }
          return i(t2, e2), t2.prototype.ele = function(e3, t3, r2) {
            var n2, i2;
            if (u.isObject(e3) || u.isString(e3) && (/^\s*</.test(e3) || /^\s*[\{\[]/.test(e3) || /^(\s*|(#.*)|(%.*))*---/.test(e3))) {
              var a2 = l.fragment().set(this._options);
              try {
                a2.ele(e3);
              } catch (e4) {
                return this.emit("error", e4), this;
              }
              try {
                for (var s2 = o(a2.node.childNodes), c2 = s2.next(); !c2.done; c2 = s2.next()) {
                  var h2 = c2.value;
                  this._fromNode(h2);
                }
              } catch (e4) {
                n2 = { error: e4 };
              } finally {
                try {
                  c2 && !c2.done && (i2 = s2.return) && i2.call(s2);
                } finally {
                  if (n2) throw n2.error;
                }
              }
              return this;
            }
            if (this._serializeOpenTag(true), !this._fragment && this._hasDocumentElement && 0 === this._writer.level) return this.emit("error", new Error("Document cannot have multiple document element nodes.")), this;
            try {
              this._currentElement = l.fragment(this._builderOptions).ele(e3, t3, r2);
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return this._fragment || this._hasDocumentElement || "" === this._docTypeName || this._currentElement.node._qualifiedName === this._docTypeName ? (this._currentElementSerialized = false, this._fragment || (this._hasDocumentElement = true), this) : (this.emit("error", new Error("Document element name does not match DocType declaration name.")), this);
          }, t2.prototype.att = function(e3, t3, r2) {
            if (void 0 === this._currentElement) return this.emit("error", new Error("Cannot insert an attribute node as child of a document node.")), this;
            try {
              this._currentElement.att(e3, t3, r2);
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return this;
          }, t2.prototype.com = function(e3) {
            var t3;
            this._serializeOpenTag(true);
            try {
              t3 = l.fragment(this._builderOptions).com(e3).first().node;
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return !this._options.wellFormed || c.xml_isLegalChar(t3.data) && -1 === t3.data.indexOf("--") && !t3.data.endsWith("-") ? (this._push(this._writer.comment(t3.data)), this) : (this.emit("error", new Error("Comment data contains invalid characters (well-formed required).")), this);
          }, t2.prototype.txt = function(e3) {
            if (!this._fragment && void 0 === this._currentElement) return this.emit("error", new Error("Cannot insert a text node as child of a document node.")), this;
            var t3;
            this._serializeOpenTag(true);
            try {
              t3 = l.fragment(this._builderOptions).txt(e3).first().node;
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            if (this._options.wellFormed && !c.xml_isLegalChar(t3.data)) return this.emit("error", new Error("Text data contains invalid characters (well-formed required).")), this;
            var r2 = t3.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            return this._push(this._writer.text(r2)), this;
          }, t2.prototype.ins = function(e3, t3) {
            var r2;
            void 0 === t3 && (t3 = ""), this._serializeOpenTag(true);
            try {
              r2 = l.fragment(this._builderOptions).ins(e3, t3).first().node;
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return this._options.wellFormed && (-1 !== r2.target.indexOf(":") || /^xml$/i.test(r2.target)) ? (this.emit("error", new Error("Processing instruction target contains invalid characters (well-formed required).")), this) : this._options.wellFormed && !c.xml_isLegalChar(r2.data) ? (this.emit("error", Error("Processing instruction data contains invalid characters (well-formed required).")), this) : (this._push(this._writer.instruction(r2.target, r2.data)), this);
          }, t2.prototype.dat = function(e3) {
            var t3;
            this._serializeOpenTag(true);
            try {
              t3 = l.fragment(this._builderOptions).dat(e3).first().node;
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return this._push(this._writer.cdata(t3.data)), this;
          }, t2.prototype.dec = function(e3) {
            return void 0 === e3 && (e3 = { version: "1.0" }), this._fragment ? (this.emit("error", Error("Cannot insert an XML declaration into a document fragment.")), this) : this._hasDeclaration ? (this.emit("error", Error("XML declaration is already inserted.")), this) : (this._push(this._writer.declaration(e3.version || "1.0", e3.encoding, e3.standalone)), this._hasDeclaration = true, this);
          }, t2.prototype.dtd = function(e3) {
            if (this._fragment) return this.emit("error", Error("Cannot insert a DocType declaration into a document fragment.")), this;
            if ("" !== this._docTypeName) return this.emit("error", new Error("DocType declaration is already inserted.")), this;
            if (this._hasDocumentElement) return this.emit("error", new Error("Cannot insert DocType declaration after document element.")), this;
            var t3;
            try {
              t3 = l.create().dtd(e3).first().node;
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return this._options.wellFormed && !c.xml_isPubidChar(t3.publicId) ? (this.emit("error", new Error("DocType public identifier does not match PubidChar construct (well-formed required).")), this) : this._options.wellFormed && (!c.xml_isLegalChar(t3.systemId) || -1 !== t3.systemId.indexOf('"') && -1 !== t3.systemId.indexOf("'")) ? (this.emit("error", new Error("DocType system identifier contains invalid characters (well-formed required).")), this) : (this._docTypeName = e3.name, this._push(this._writer.docType(e3.name, t3.publicId, t3.systemId)), this);
          }, t2.prototype.import = function(e3) {
            var t3, r2, n2 = l.fragment().set(this._options);
            try {
              n2.import(e3);
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            try {
              for (var i2 = o(n2.node.childNodes), a2 = i2.next(); !a2.done; a2 = i2.next()) {
                var s2 = a2.value;
                this._fromNode(s2);
              }
            } catch (e4) {
              t3 = { error: e4 };
            } finally {
              try {
                a2 && !a2.done && (r2 = i2.return) && r2.call(i2);
              } finally {
                if (t3) throw t3.error;
              }
            }
            return this;
          }, t2.prototype.up = function() {
            return this._serializeOpenTag(false), this._serializeCloseTag(), this;
          }, t2.prototype.end = function() {
            for (this._serializeOpenTag(false); this._openTags.length > 0; ) this._serializeCloseTag();
            return this._push(null), this;
          }, t2.prototype._serializeOpenTag = function(e3) {
            if (!this._currentElementSerialized && void 0 !== this._currentElement) {
              var r2 = this._currentElement.node;
              if (!this._options.wellFormed || -1 === r2.localName.indexOf(":") && c.xml_isName(r2.localName)) {
                var n2 = "", i2 = false, o2 = this._prefixMap.copy(), a2 = {}, s2 = this._recordNamespaceInformation(r2, o2, a2), u2 = 0 === this._openTags.length ? null : this._openTags[this._openTags.length - 1][1], l2 = r2.namespaceURI;
                if (null === l2 && (l2 = u2), u2 === l2) null !== s2 && (i2 = true), n2 = l2 === h.namespace.XML ? "xml:" + r2.localName : r2.localName, this._writer.beginElement(n2), this._push(this._writer.openTagBegin(n2));
                else {
                  var p2 = r2.prefix, f2 = null;
                  if (null === p2 && l2 === s2 || (f2 = o2.get(p2, l2)), "xmlns" === p2) {
                    if (this._options.wellFormed) return void this.emit("error", new Error("An element cannot have the 'xmlns' prefix (well-formed required)."));
                    f2 = p2;
                  }
                  null !== f2 ? (n2 = f2 + ":" + r2.localName, null !== s2 && s2 !== h.namespace.XML && (u2 = s2 || null), this._writer.beginElement(n2), this._push(this._writer.openTagBegin(n2))) : null !== p2 ? (p2 in a2 && (p2 = this._generatePrefix(l2, o2, this._prefixIndex)), o2.set(p2, l2), n2 += p2 + ":" + r2.localName, this._writer.beginElement(n2), this._push(this._writer.openTagBegin(n2)), this._push(this._writer.attribute("xmlns:" + p2, this._serializeAttributeValue(l2, this._options.wellFormed))), null !== s2 && (u2 = s2 || null)) : null === s2 || null !== s2 && s2 !== l2 ? (i2 = true, n2 += r2.localName, u2 = l2, this._writer.beginElement(n2), this._push(this._writer.openTagBegin(n2)), this._push(this._writer.attribute("xmlns", this._serializeAttributeValue(l2, this._options.wellFormed)))) : (n2 += r2.localName, u2 = l2, this._writer.beginElement(n2), this._push(this._writer.openTagBegin(n2)));
                }
                this._serializeAttributes(r2, o2, this._prefixIndex, a2, i2, this._options.wellFormed);
                var d2 = l2 === h.namespace.HTML;
                d2 && !e3 && t2._VoidElementNames.has(r2.localName) ? (this._push(this._writer.openTagEnd(n2, true, true)), this._writer.endElement(n2)) : d2 || e3 ? this._push(this._writer.openTagEnd(n2, false, false)) : (this._push(this._writer.openTagEnd(n2, true, false)), this._writer.endElement(n2)), this._currentElementSerialized = true, this._openTags.push([n2, u2, this._prefixMap, e3]), this._isPrefixMapModified(this._prefixMap, o2) && (this._prefixMap = o2), this._writer.level++;
              } else this.emit("error", new Error("Node local name contains invalid characters (well-formed required)."));
            }
          }, t2.prototype._serializeCloseTag = function() {
            this._writer.level--;
            var e3 = this._openTags.pop();
            if (void 0 !== e3) {
              var t3 = a(e3, 4), r2 = t3[0], n2 = (t3[1], t3[2]), i2 = t3[3];
              this._prefixMap = n2, i2 && (this._push(this._writer.closeTag(r2)), this._writer.endElement(r2));
            } else this.emit("error", new Error("Last element is undefined."));
          }, t2.prototype._push = function(e3) {
            null === e3 ? (this._ended = true, this.emit("end")) : this._ended ? this.emit("error", new Error("Cannot push to ended stream.")) : 0 !== e3.length && (this._writer.hasData = true, this.emit("data", e3, this._writer.level));
          }, t2.prototype._fromNode = function(e3) {
            var t3, r2, n2, i2;
            if (d.Guard.isElementNode(e3)) {
              var a2 = e3.prefix ? e3.prefix + ":" + e3.localName : e3.localName;
              null !== e3.namespaceURI ? this.ele(e3.namespaceURI, a2) : this.ele(a2);
              try {
                for (var s2 = o(e3.attributes), u2 = s2.next(); !u2.done; u2 = s2.next()) {
                  var l2 = u2.value, c2 = l2.prefix ? l2.prefix + ":" + l2.localName : l2.localName;
                  null !== l2.namespaceURI ? this.att(l2.namespaceURI, c2, l2.value) : this.att(c2, l2.value);
                }
              } catch (e4) {
                t3 = { error: e4 };
              } finally {
                try {
                  u2 && !u2.done && (r2 = s2.return) && r2.call(s2);
                } finally {
                  if (t3) throw t3.error;
                }
              }
              try {
                for (var h2 = o(e3.childNodes), p2 = h2.next(); !p2.done; p2 = h2.next()) {
                  var f2 = p2.value;
                  this._fromNode(f2);
                }
              } catch (e4) {
                n2 = { error: e4 };
              } finally {
                try {
                  p2 && !p2.done && (i2 = h2.return) && i2.call(h2);
                } finally {
                  if (n2) throw n2.error;
                }
              }
              this.up();
            } else d.Guard.isExclusiveTextNode(e3) && e3.data ? this.txt(e3.data) : d.Guard.isCommentNode(e3) ? this.com(e3.data) : d.Guard.isCDATASectionNode(e3) ? this.dat(e3.data) : d.Guard.isProcessingInstructionNode(e3) && this.ins(e3.target, e3.data);
          }, t2.prototype._serializeAttributes = function(e3, t3, r2, n2, i2, a2) {
            var s2, u2, l2 = a2 ? new f.LocalNameSet() : void 0;
            try {
              for (var p2 = o(e3.attributes), d2 = p2.next(); !d2.done; d2 = p2.next()) {
                var m2 = d2.value;
                if (a2 || i2 || null !== m2.namespaceURI) {
                  if (a2 && l2 && l2.has(m2.namespaceURI, m2.localName)) return void this.emit("error", new Error("Element contains duplicate attributes (well-formed required)."));
                  a2 && l2 && l2.set(m2.namespaceURI, m2.localName);
                  var y2 = m2.namespaceURI, v2 = null;
                  if (null !== y2) if (v2 = t3.get(m2.prefix, y2), y2 === h.namespace.XMLNS) {
                    if (m2.value === h.namespace.XML || null === m2.prefix && i2 || null !== m2.prefix && (!(m2.localName in n2) || n2[m2.localName] !== m2.value) && t3.has(m2.localName, m2.value)) continue;
                    if (a2 && m2.value === h.namespace.XMLNS) return void this.emit("error", new Error("XMLNS namespace is reserved (well-formed required)."));
                    if (a2 && "" === m2.value) return void this.emit("error", new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required)."));
                    "xmlns" === m2.prefix && (v2 = "xmlns");
                  } else null === v2 && (v2 = null === m2.prefix || t3.hasPrefix(m2.prefix) && !t3.has(m2.prefix, y2) ? this._generatePrefix(y2, t3, r2) : m2.prefix, this._push(this._writer.attribute("xmlns:" + v2, this._serializeAttributeValue(y2, this._options.wellFormed))));
                  if (a2 && (-1 !== m2.localName.indexOf(":") || !c.xml_isName(m2.localName) || "xmlns" === m2.localName && null === y2)) return void this.emit("error", new Error("Attribute local name contains invalid characters (well-formed required)."));
                  this._push(this._writer.attribute((null !== v2 ? v2 + ":" : "") + m2.localName, this._serializeAttributeValue(m2.value, this._options.wellFormed)));
                } else this._push(this._writer.attribute(m2.localName, this._serializeAttributeValue(m2.value, this._options.wellFormed)));
              }
            } catch (e4) {
              s2 = { error: e4 };
            } finally {
              try {
                d2 && !d2.done && (u2 = p2.return) && u2.call(p2);
              } finally {
                if (s2) throw s2.error;
              }
            }
          }, t2.prototype._serializeAttributeValue = function(e3, t3) {
            return t3 && null !== e3 && !c.xml_isLegalChar(e3) ? (this.emit("error", new Error("Invalid characters in attribute value.")), "") : null === e3 ? "" : e3.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
          }, t2.prototype._recordNamespaceInformation = function(e3, t3, r2) {
            var n2, i2, a2 = null;
            try {
              for (var s2 = o(e3.attributes), u2 = s2.next(); !u2.done; u2 = s2.next()) {
                var l2 = u2.value, c2 = l2.namespaceURI, p2 = l2.prefix;
                if (c2 === h.namespace.XMLNS) {
                  if (null === p2) {
                    a2 = l2.value;
                    continue;
                  }
                  var f2 = l2.localName, d2 = l2.value;
                  if (d2 === h.namespace.XML) continue;
                  if ("" === d2 && (d2 = null), t3.has(f2, d2)) continue;
                  t3.set(f2, d2), r2[f2] = d2 || "";
                }
              }
            } catch (e4) {
              n2 = { error: e4 };
            } finally {
              try {
                u2 && !u2.done && (i2 = s2.return) && i2.call(s2);
              } finally {
                if (n2) throw n2.error;
              }
            }
            return a2;
          }, t2.prototype._generatePrefix = function(e3, t3, r2) {
            var n2 = "ns" + r2.value;
            return r2.value++, t3.set(n2, e3), n2;
          }, t2.prototype._isPrefixMapModified = function(e3, t3) {
            var r2 = e3._items, n2 = t3._items, i2 = e3._nullItems, o2 = t3._nullItems;
            for (var a2 in n2) {
              var s2 = r2[a2];
              if (void 0 === s2) return true;
              var u2 = n2[a2];
              if (s2.length !== u2.length) return true;
              for (var l2 = 0; l2 < s2.length; l2++) if (s2[l2] !== u2[l2]) return true;
            }
            if (i2.length !== o2.length) return true;
            for (l2 = 0; l2 < i2.length; l2++) if (i2[l2] !== o2[l2]) return true;
            return false;
          }, t2._VoidElementNames = /* @__PURE__ */ new Set(["area", "base", "basefont", "bgsound", "br", "col", "embed", "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"]), t2;
        }(r(308).EventEmitter);
        t.XMLBuilderCBImpl = _;
      }, function(e, t, r) {
        "use strict";
        r(74);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this, t3) || this;
            return r2._lineLength = 0, r2;
          }
          return i(t2, e2), t2.prototype.frontMatter = function() {
            return "";
          }, t2.prototype.declaration = function(e3, t3, r2) {
            var n2 = this._beginLine() + "<?xml";
            return n2 += ' version="' + e3 + '"', void 0 !== t3 && (n2 += ' encoding="' + t3 + '"'), void 0 !== r2 && (n2 += ' standalone="' + (r2 ? "yes" : "no") + '"'), n2 += "?>";
          }, t2.prototype.docType = function(e3, t3, r2) {
            var n2 = this._beginLine();
            return n2 += t3 && r2 ? "<!DOCTYPE " + e3 + ' PUBLIC "' + t3 + '" "' + r2 + '">' : t3 ? "<!DOCTYPE " + e3 + ' PUBLIC "' + t3 + '">' : r2 ? "<!DOCTYPE " + e3 + ' SYSTEM "' + r2 + '">' : "<!DOCTYPE " + e3 + ">";
          }, t2.prototype.comment = function(e3) {
            return this._beginLine() + "<!--" + e3 + "-->";
          }, t2.prototype.text = function(e3) {
            return this._beginLine() + e3;
          }, t2.prototype.instruction = function(e3, t3) {
            return t3 ? this._beginLine() + "<?" + e3 + " " + t3 + "?>" : this._beginLine() + "<?" + e3 + "?>";
          }, t2.prototype.cdata = function(e3) {
            return this._beginLine() + "<![CDATA[" + e3 + "]]>";
          }, t2.prototype.openTagBegin = function(e3) {
            return this._lineLength += 1 + e3.length, this._beginLine() + "<" + e3;
          }, t2.prototype.openTagEnd = function(e3, t3, r2) {
            return r2 ? " />" : t3 ? this._writerOptions.allowEmptyTags ? "></" + e3 + ">" : this._writerOptions.spaceBeforeSlash ? " />" : "/>" : ">";
          }, t2.prototype.closeTag = function(e3) {
            return this._beginLine() + "</" + e3 + ">";
          }, t2.prototype.attribute = function(e3, t3) {
            var r2 = e3 + '="' + t3 + '"';
            return this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._lineLength + 1 + r2.length > this._writerOptions.width ? (r2 = this._beginLine() + this._indent(1) + r2, this._lineLength = r2.length, r2) : (this._lineLength += 1 + r2.length, " " + r2);
          }, t2.prototype.beginElement = function(e3) {
          }, t2.prototype.endElement = function(e3) {
          }, t2.prototype._beginLine = function() {
            if (this._writerOptions.prettyPrint) {
              var e3 = (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level);
              return this._lineLength = e3.length, e3;
            }
            return "";
          }, t2.prototype._indent = function(e3) {
            return e3 <= 0 ? "" : this._writerOptions.indent.repeat(e3);
          }, t2;
        }(r(114).BaseCBWriter);
        t.XMLCBWriter = o;
      }, function(e, t, r) {
        "use strict";
        r(74);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this, t3) || this;
            return r2._hasChildren = [], r2._additionalLevel = 0, r2;
          }
          return i(t2, e2), t2.prototype.frontMatter = function() {
            return "";
          }, t2.prototype.declaration = function(e3, t3, r2) {
            return "";
          }, t2.prototype.docType = function(e3, t3, r2) {
            return "";
          }, t2.prototype.comment = function(e3) {
            return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.comment) + this._sep() + this._val(e3) + this._sep() + "}";
          }, t2.prototype.text = function(e3) {
            return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.text) + this._sep() + this._val(e3) + this._sep() + "}";
          }, t2.prototype.instruction = function(e3, t3) {
            return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.ins) + this._sep() + this._val(t3 ? e3 + " " + t3 : e3) + this._sep() + "}";
          }, t2.prototype.cdata = function(e3) {
            return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.cdata) + this._sep() + this._val(e3) + this._sep() + "}";
          }, t2.prototype.attribute = function(e3, t3) {
            return this._comma() + this._beginLine(1) + "{" + this._sep() + this._key(this._builderOptions.convert.att + e3) + this._sep() + this._val(t3) + this._sep() + "}";
          }, t2.prototype.openTagBegin = function(e3) {
            var t3 = this._comma() + this._beginLine() + "{" + this._sep() + this._key(e3) + this._sep() + "{";
            return this._additionalLevel++, this.hasData = true, t3 += this._beginLine() + this._key(this._builderOptions.convert.text) + this._sep() + "[", this._hasChildren.push(false), t3;
          }, t2.prototype.openTagEnd = function(e3, t3, r2) {
            if (t3) {
              var n2 = this._sep() + "]";
              return this._additionalLevel--, n2 += this._beginLine() + "}" + this._sep() + "}";
            }
            return "";
          }, t2.prototype.closeTag = function(e3) {
            var t3 = this._beginLine() + "]";
            return this._additionalLevel--, t3 += this._beginLine() + "}" + this._sep() + "}";
          }, t2.prototype.beginElement = function(e3) {
          }, t2.prototype.endElement = function(e3) {
            this._hasChildren.pop();
          }, t2.prototype._beginLine = function(e3) {
            return void 0 === e3 && (e3 = 0), this._writerOptions.prettyPrint ? (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level + e3) : "";
          }, t2.prototype._indent = function(e3) {
            return e3 + this._additionalLevel <= 0 ? "" : this._writerOptions.indent.repeat(e3 + this._additionalLevel);
          }, t2.prototype._comma = function() {
            var e3 = this._hasChildren[this._hasChildren.length - 1] ? "," : "";
            return this._hasChildren.length > 0 && (this._hasChildren[this._hasChildren.length - 1] = true), e3;
          }, t2.prototype._sep = function() {
            return this._writerOptions.prettyPrint ? " " : "";
          }, t2.prototype._key = function(e3) {
            return '"' + e3 + '":';
          }, t2.prototype._val = function(e3) {
            return JSON.stringify(e3);
          }, t2;
        }(r(114).BaseCBWriter);
        t.JSONCBWriter = o;
      }, function(e, t, r) {
        "use strict";
        r(74);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3) t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this, t3) || this;
            if (r2._rootWritten = false, r2._additionalLevel = 0, t3.indent.length < 2) throw new Error("YAML indententation string must be at least two characters long.");
            if (t3.offset < 0) throw new Error("YAML offset should be zero or a positive number.");
            return r2;
          }
          return i(t2, e2), t2.prototype.frontMatter = function() {
            return this._beginLine() + "---";
          }, t2.prototype.declaration = function(e3, t3, r2) {
            return "";
          }, t2.prototype.docType = function(e3, t3, r2) {
            return "";
          }, t2.prototype.comment = function(e3) {
            return this._beginLine() + this._key(this._builderOptions.convert.comment) + " " + this._val(e3);
          }, t2.prototype.text = function(e3) {
            return this._beginLine() + this._key(this._builderOptions.convert.text) + " " + this._val(e3);
          }, t2.prototype.instruction = function(e3, t3) {
            return this._beginLine() + this._key(this._builderOptions.convert.ins) + " " + this._val(t3 ? e3 + " " + t3 : e3);
          }, t2.prototype.cdata = function(e3) {
            return this._beginLine() + this._key(this._builderOptions.convert.cdata) + " " + this._val(e3);
          }, t2.prototype.attribute = function(e3, t3) {
            this._additionalLevel++;
            var r2 = this._beginLine() + this._key(this._builderOptions.convert.att + e3) + " " + this._val(t3);
            return this._additionalLevel--, r2;
          }, t2.prototype.openTagBegin = function(e3) {
            var t3 = this._beginLine() + this._key(e3);
            return this._rootWritten || (this._rootWritten = true), this.hasData = true, this._additionalLevel++, t3 += this._beginLine(true) + this._key(this._builderOptions.convert.text);
          }, t2.prototype.openTagEnd = function(e3, t3, r2) {
            return t3 ? " " + this._val("") : "";
          }, t2.prototype.closeTag = function(e3) {
            return this._additionalLevel--, "";
          }, t2.prototype.beginElement = function(e3) {
          }, t2.prototype.endElement = function(e3) {
          }, t2.prototype._beginLine = function(e3) {
            return void 0 === e3 && (e3 = false), (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level, e3);
          }, t2.prototype._indent = function(e3, t3) {
            if (e3 + this._additionalLevel <= 0) return "";
            var r2 = this._writerOptions.indent.repeat(e3 + this._additionalLevel);
            return !t3 && this._rootWritten ? r2.substr(0, r2.length - 2) + "-" + r2.substr(-1, 1) : r2;
          }, t2.prototype._key = function(e3) {
            return '"' + e3 + '":';
          }, t2.prototype._val = function(e3) {
            return JSON.stringify(e3);
          }, t2;
        }(r(114).BaseCBWriter);
        t.YAMLCBWriter = o;
      }, function(e, t, r) {
        "use strict";
        var n, i = "object" == typeof Reflect ? Reflect : null, o = i && "function" == typeof i.apply ? i.apply : function(e2, t2, r2) {
          return Function.prototype.apply.call(e2, t2, r2);
        };
        n = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
          return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
        } : function(e2) {
          return Object.getOwnPropertyNames(e2);
        };
        var a = Number.isNaN || function(e2) {
          return e2 != e2;
        };
        function s() {
          s.init.call(this);
        }
        e.exports = s, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
        var u = 10;
        function l(e2) {
          if ("function" != typeof e2) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
        }
        function c(e2) {
          return void 0 === e2._maxListeners ? s.defaultMaxListeners : e2._maxListeners;
        }
        function h(e2, t2, r2, n2) {
          var i2, o2, a2, s2;
          if (l(r2), void 0 === (o2 = e2._events) ? (o2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== o2.newListener && (e2.emit("newListener", t2, r2.listener ? r2.listener : r2), o2 = e2._events), a2 = o2[t2]), void 0 === a2) a2 = o2[t2] = r2, ++e2._eventsCount;
          else if ("function" == typeof a2 ? a2 = o2[t2] = n2 ? [r2, a2] : [a2, r2] : n2 ? a2.unshift(r2) : a2.push(r2), (i2 = c(e2)) > 0 && a2.length > i2 && !a2.warned) {
            a2.warned = true;
            var u2 = new Error("Possible EventEmitter memory leak detected. " + a2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            u2.name = "MaxListenersExceededWarning", u2.emitter = e2, u2.type = t2, u2.count = a2.length, s2 = u2, console && console.warn && console.warn(s2);
          }
          return e2;
        }
        function p() {
          if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function f(e2, t2, r2) {
          var n2 = { fired: false, wrapFn: void 0, target: e2, type: t2, listener: r2 }, i2 = p.bind(n2);
          return i2.listener = r2, n2.wrapFn = i2, i2;
        }
        function d(e2, t2, r2) {
          var n2 = e2._events;
          if (void 0 === n2) return [];
          var i2 = n2[t2];
          return void 0 === i2 ? [] : "function" == typeof i2 ? r2 ? [i2.listener || i2] : [i2] : r2 ? function(e3) {
            for (var t3 = new Array(e3.length), r3 = 0; r3 < t3.length; ++r3) t3[r3] = e3[r3].listener || e3[r3];
            return t3;
          }(i2) : y(i2, i2.length);
        }
        function m(e2) {
          var t2 = this._events;
          if (void 0 !== t2) {
            var r2 = t2[e2];
            if ("function" == typeof r2) return 1;
            if (void 0 !== r2) return r2.length;
          }
          return 0;
        }
        function y(e2, t2) {
          for (var r2 = new Array(t2), n2 = 0; n2 < t2; ++n2) r2[n2] = e2[n2];
          return r2;
        }
        Object.defineProperty(s, "defaultMaxListeners", { enumerable: true, get: function() {
          return u;
        }, set: function(e2) {
          if ("number" != typeof e2 || e2 < 0 || a(e2)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          u = e2;
        } }), s.init = function() {
          void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, s.prototype.setMaxListeners = function(e2) {
          if ("number" != typeof e2 || e2 < 0 || a(e2)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          return this._maxListeners = e2, this;
        }, s.prototype.getMaxListeners = function() {
          return c(this);
        }, s.prototype.emit = function(e2) {
          for (var t2 = [], r2 = 1; r2 < arguments.length; r2++) t2.push(arguments[r2]);
          var n2 = "error" === e2, i2 = this._events;
          if (void 0 !== i2) n2 = n2 && void 0 === i2.error;
          else if (!n2) return false;
          if (n2) {
            var a2;
            if (t2.length > 0 && (a2 = t2[0]), a2 instanceof Error) throw a2;
            var s2 = new Error("Unhandled error." + (a2 ? " (" + a2.message + ")" : ""));
            throw s2.context = a2, s2;
          }
          var u2 = i2[e2];
          if (void 0 === u2) return false;
          if ("function" == typeof u2) o(u2, this, t2);
          else {
            var l2 = u2.length, c2 = y(u2, l2);
            for (r2 = 0; r2 < l2; ++r2) o(c2[r2], this, t2);
          }
          return true;
        }, s.prototype.addListener = function(e2, t2) {
          return h(this, e2, t2, false);
        }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(e2, t2) {
          return h(this, e2, t2, true);
        }, s.prototype.once = function(e2, t2) {
          return l(t2), this.on(e2, f(this, e2, t2)), this;
        }, s.prototype.prependOnceListener = function(e2, t2) {
          return l(t2), this.prependListener(e2, f(this, e2, t2)), this;
        }, s.prototype.removeListener = function(e2, t2) {
          var r2, n2, i2, o2, a2;
          if (l(t2), void 0 === (n2 = this._events)) return this;
          if (void 0 === (r2 = n2[e2])) return this;
          if (r2 === t2 || r2.listener === t2) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete n2[e2], n2.removeListener && this.emit("removeListener", e2, r2.listener || t2));
          else if ("function" != typeof r2) {
            for (i2 = -1, o2 = r2.length - 1; o2 >= 0; o2--) if (r2[o2] === t2 || r2[o2].listener === t2) {
              a2 = r2[o2].listener, i2 = o2;
              break;
            }
            if (i2 < 0) return this;
            0 === i2 ? r2.shift() : function(e3, t3) {
              for (; t3 + 1 < e3.length; t3++) e3[t3] = e3[t3 + 1];
              e3.pop();
            }(r2, i2), 1 === r2.length && (n2[e2] = r2[0]), void 0 !== n2.removeListener && this.emit("removeListener", e2, a2 || t2);
          }
          return this;
        }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(e2) {
          var t2, r2, n2;
          if (void 0 === (r2 = this._events)) return this;
          if (void 0 === r2.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== r2[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete r2[e2]), this;
          if (0 === arguments.length) {
            var i2, o2 = Object.keys(r2);
            for (n2 = 0; n2 < o2.length; ++n2) "removeListener" !== (i2 = o2[n2]) && this.removeAllListeners(i2);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if ("function" == typeof (t2 = r2[e2])) this.removeListener(e2, t2);
          else if (void 0 !== t2) for (n2 = t2.length - 1; n2 >= 0; n2--) this.removeListener(e2, t2[n2]);
          return this;
        }, s.prototype.listeners = function(e2) {
          return d(this, e2, true);
        }, s.prototype.rawListeners = function(e2) {
          return d(this, e2, false);
        }, s.listenerCount = function(e2, t2) {
          return "function" == typeof e2.listenerCount ? e2.listenerCount(t2) : m.call(e2, t2);
        }, s.prototype.listenerCount = m, s.prototype.eventNames = function() {
          return this._eventsCount > 0 ? n(this._events) : [];
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(77);
        t.createCB = function(e2) {
          return new n.XMLBuilderCBImpl(e2);
        }, t.fragmentCB = function(e2) {
          return new n.XMLBuilderCBImpl(e2, true);
        };
      }]);
    });
  }
});

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js
var annotationState_exports = {};
__export(annotationState_exports, {
  addAnnotation: () => addAnnotation,
  addChildAnnotation: () => addChildAnnotation,
  clearParentAnnotation: () => clearParentAnnotation,
  getAllAnnotations: () => getAllAnnotations,
  getAnnotation: () => getAnnotation,
  getAnnotationManager: () => getAnnotationManager,
  getAnnotations: () => getAnnotations,
  getChildAnnotations: () => getChildAnnotations,
  getNumberOfAnnotations: () => getNumberOfAnnotations,
  getParentAnnotation: () => getParentAnnotation,
  invalidateAnnotation: () => invalidateAnnotation,
  removeAllAnnotations: () => removeAllAnnotations,
  removeAnnotation: () => removeAnnotation,
  removeAnnotations: () => removeAnnotations,
  setAnnotationManager: () => setAnnotationManager
});

// node_modules/@cornerstonejs/tools/dist/esm/enums/index.js
var enums_exports2 = {};
__export(enums_exports2, {
  AnnotationStyleStates: () => AnnotationStyleStates_default,
  ChangeTypes: () => ChangeTypes_default,
  Events: () => Events_default,
  KeyboardBindings: () => KeyboardBindings,
  MouseBindings: () => MouseBindings,
  SegmentationRepresentations: () => SegmentationRepresentations_default,
  StrategyCallbacks: () => StrategyCallbacks_default,
  Swipe: () => Swipe,
  ToolModes: () => ToolModes_default,
  WorkerTypes: () => WorkerTypes_default
});

// node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js
var MouseBindings;
(function(MouseBindings2) {
  MouseBindings2[MouseBindings2["Primary"] = 1] = "Primary";
  MouseBindings2[MouseBindings2["Secondary"] = 2] = "Secondary";
  MouseBindings2[MouseBindings2["Primary_And_Secondary"] = 3] = "Primary_And_Secondary";
  MouseBindings2[MouseBindings2["Auxiliary"] = 4] = "Auxiliary";
  MouseBindings2[MouseBindings2["Primary_And_Auxiliary"] = 5] = "Primary_And_Auxiliary";
  MouseBindings2[MouseBindings2["Secondary_And_Auxiliary"] = 6] = "Secondary_And_Auxiliary";
  MouseBindings2[MouseBindings2["Primary_And_Secondary_And_Auxiliary"] = 7] = "Primary_And_Secondary_And_Auxiliary";
  MouseBindings2[MouseBindings2["Fourth_Button"] = 8] = "Fourth_Button";
  MouseBindings2[MouseBindings2["Fifth_Button"] = 16] = "Fifth_Button";
  MouseBindings2[MouseBindings2["Wheel"] = 524288] = "Wheel";
  MouseBindings2[MouseBindings2["Wheel_Primary"] = 524289] = "Wheel_Primary";
})(MouseBindings || (MouseBindings = {}));
var KeyboardBindings;
(function(KeyboardBindings2) {
  KeyboardBindings2[KeyboardBindings2["Shift"] = 16] = "Shift";
  KeyboardBindings2[KeyboardBindings2["Ctrl"] = 17] = "Ctrl";
  KeyboardBindings2[KeyboardBindings2["Alt"] = 18] = "Alt";
  KeyboardBindings2[KeyboardBindings2["Meta"] = 91] = "Meta";
  KeyboardBindings2[KeyboardBindings2["ShiftCtrl"] = 1617] = "ShiftCtrl";
  KeyboardBindings2[KeyboardBindings2["ShiftAlt"] = 1618] = "ShiftAlt";
  KeyboardBindings2[KeyboardBindings2["ShiftMeta"] = 1691] = "ShiftMeta";
  KeyboardBindings2[KeyboardBindings2["CtrlAlt"] = 1718] = "CtrlAlt";
  KeyboardBindings2[KeyboardBindings2["CtrlMeta"] = 1791] = "CtrlMeta";
  KeyboardBindings2[KeyboardBindings2["AltMeta"] = 1891] = "AltMeta";
})(KeyboardBindings || (KeyboardBindings = {}));

// node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js
var ToolModes;
(function(ToolModes2) {
  ToolModes2["Active"] = "Active";
  ToolModes2["Passive"] = "Passive";
  ToolModes2["Enabled"] = "Enabled";
  ToolModes2["Disabled"] = "Disabled";
})(ToolModes || (ToolModes = {}));
var ToolModes_default = ToolModes;

// node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js
var AnnotationStyleStates;
(function(AnnotationStyleStates2) {
  AnnotationStyleStates2["Default"] = "";
  AnnotationStyleStates2["Highlighted"] = "Highlighted";
  AnnotationStyleStates2["Selected"] = "Selected";
  AnnotationStyleStates2["Locked"] = "Locked";
  AnnotationStyleStates2["AutoGenerated"] = "AutoGenerated";
})(AnnotationStyleStates || (AnnotationStyleStates = {}));
var AnnotationStyleStates_default = AnnotationStyleStates;

// node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js
var Events;
(function(Events4) {
  Events4["TOOL_ACTIVATED"] = "CORNERSTONE_TOOLS_TOOL_ACTIVATED";
  Events4["TOOLGROUP_VIEWPORT_ADDED"] = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED";
  Events4["TOOLGROUP_VIEWPORT_REMOVED"] = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED";
  Events4["TOOL_MODE_CHANGED"] = "CORNERSTONE_TOOLS_TOOL_MODE_CHANGED";
  Events4["ANNOTATION_ADDED"] = "CORNERSTONE_TOOLS_ANNOTATION_ADDED";
  Events4["ANNOTATION_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED";
  Events4["ANNOTATION_MODIFIED"] = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED";
  Events4["ANNOTATION_REMOVED"] = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED";
  Events4["ANNOTATION_SELECTION_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE";
  Events4["ANNOTATION_LOCK_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE";
  Events4["ANNOTATION_VISIBILITY_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE";
  Events4["ANNOTATION_RENDERED"] = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED";
  Events4["ANNOTATION_INTERPOLATION_PROCESS_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED";
  Events4["INTERPOLATED_ANNOTATIONS_REMOVED"] = "CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED";
  Events4["SEGMENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED";
  Events4["SEGMENTATION_RENDERED"] = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED";
  Events4["SEGMENTATION_REPRESENTATION_ADDED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED";
  Events4["SEGMENTATION_ADDED"] = "CORNERSTONE_TOOLS_SEGMENTATION_ADDED";
  Events4["SEGMENTATION_REPRESENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED";
  Events4["SEGMENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED";
  Events4["SEGMENTATION_REPRESENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED";
  Events4["SEGMENTATION_DATA_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED";
  Events4["KEY_DOWN"] = "CORNERSTONE_TOOLS_KEY_DOWN";
  Events4["KEY_UP"] = "CORNERSTONE_TOOLS_KEY_UP";
  Events4["MOUSE_DOWN"] = "CORNERSTONE_TOOLS_MOUSE_DOWN";
  Events4["MOUSE_UP"] = "CORNERSTONE_TOOLS_MOUSE_UP";
  Events4["MOUSE_DOWN_ACTIVATE"] = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE";
  Events4["MOUSE_DRAG"] = "CORNERSTONE_TOOLS_MOUSE_DRAG";
  Events4["MOUSE_MOVE"] = "CORNERSTONE_TOOLS_MOUSE_MOVE";
  Events4["MOUSE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_CLICK";
  Events4["MOUSE_DOUBLE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK";
  Events4["MOUSE_WHEEL"] = "CORNERSTONE_TOOLS_MOUSE_WHEEL";
  Events4["TOUCH_START"] = "CORNERSTONE_TOOLS_TOUCH_START";
  Events4["TOUCH_START_ACTIVATE"] = "CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE";
  Events4["TOUCH_PRESS"] = "CORNERSTONE_TOOLS_TOUCH_PRESS";
  Events4["TOUCH_DRAG"] = "CORNERSTONE_TOOLS_TOUCH_DRAG";
  Events4["TOUCH_END"] = "CORNERSTONE_TOOLS_TOUCH_END";
  Events4["TOUCH_TAP"] = "CORNERSTONE_TOOLS_TAP";
  Events4["TOUCH_SWIPE"] = "CORNERSTONE_TOOLS_SWIPE";
})(Events || (Events = {}));
var Events_default = Events;

// node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js
var SegmentationRepresentations;
(function(SegmentationRepresentations2) {
  SegmentationRepresentations2["Labelmap"] = "Labelmap";
  SegmentationRepresentations2["Contour"] = "Contour";
  SegmentationRepresentations2["Surface"] = "Surface";
})(SegmentationRepresentations || (SegmentationRepresentations = {}));
var SegmentationRepresentations_default = SegmentationRepresentations;

// node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js
var Swipe;
(function(Swipe2) {
  Swipe2["UP"] = "UP";
  Swipe2["DOWN"] = "DOWN";
  Swipe2["LEFT"] = "LEFT";
  Swipe2["RIGHT"] = "RIGHT";
})(Swipe || (Swipe = {}));

// node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js
var StrategyCallbacks;
(function(StrategyCallbacks2) {
  StrategyCallbacks2["OnInteractionStart"] = "onInteractionStart";
  StrategyCallbacks2["OnInteractionEnd"] = "onInteractionEnd";
  StrategyCallbacks2["Preview"] = "preview";
  StrategyCallbacks2["RejectPreview"] = "rejectPreview";
  StrategyCallbacks2["AcceptPreview"] = "acceptPreview";
  StrategyCallbacks2["Fill"] = "fill";
  StrategyCallbacks2["StrategyFunction"] = "strategyFunction";
  StrategyCallbacks2["CreateIsInThreshold"] = "createIsInThreshold";
  StrategyCallbacks2["Initialize"] = "initialize";
  StrategyCallbacks2["INTERNAL_setValue"] = "setValue";
  StrategyCallbacks2["AddPreview"] = "addPreview";
  StrategyCallbacks2["ComputeInnerCircleRadius"] = "computeInnerCircleRadius";
  StrategyCallbacks2["GetStatistics"] = "getStatistics";
})(StrategyCallbacks || (StrategyCallbacks = {}));
var StrategyCallbacks_default = StrategyCallbacks;

// node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js
var ChangeTypes;
(function(ChangeTypes3) {
  ChangeTypes3["Interaction"] = "Interaction";
  ChangeTypes3["HandlesUpdated"] = "HandlesUpdated";
  ChangeTypes3["StatsUpdated"] = "StatsUpdated";
  ChangeTypes3["InitialSetup"] = "InitialSetup";
  ChangeTypes3["Completed"] = "Completed";
  ChangeTypes3["InterpolationUpdated"] = "InterpolationUpdated";
  ChangeTypes3["History"] = "History";
})(ChangeTypes || (ChangeTypes = {}));
var ChangeTypes_default = ChangeTypes;

// node_modules/@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js
var ChangeTypes2;
(function(ChangeTypes3) {
  ChangeTypes3["POLYSEG_CONTOUR_TO_LABELMAP"] = "Converting Contour to Labelmap";
  ChangeTypes3["POLYSEG_SURFACE_TO_LABELMAP"] = "Converting Surfaces to Labelmap";
  ChangeTypes3["POLYSEG_CONTOUR_TO_SURFACE"] = "Converting Contour to Surface";
  ChangeTypes3["POLYSEG_LABELMAP_TO_SURFACE"] = "Converting Labelmap to Surface";
  ChangeTypes3["SURFACE_CLIPPING"] = "Clipping Surfaces";
})(ChangeTypes2 || (ChangeTypes2 = {}));
var WorkerTypes_default = ChangeTypes2;

// node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js
var ToolGroupManager_exports = {};
__export(ToolGroupManager_exports, {
  createToolGroup: () => createToolGroup_default,
  destroy: () => destroy_default,
  destroyToolGroup: () => destroyToolGroup_default,
  getAllToolGroups: () => getAllToolGroups_default,
  getToolGroup: () => getToolGroup_default,
  getToolGroupForViewport: () => getToolGroupForViewport_default,
  getToolGroupsWithToolName: () => getToolGroupsWithToolName_default
});

// node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js
var svgNodeCache = {};
function resetSvgNodeCache() {
  svgNodeCache = {};
}
var svgNodeCache_default = svgNodeCache;

// node_modules/@cornerstonejs/tools/dist/esm/store/state.js
var defaultState = {
  isInteractingWithTool: false,
  isMultiPartToolActive: false,
  tools: {},
  toolGroups: [],
  synchronizers: [],
  svgNodeCache: svgNodeCache_default,
  enabledElements: [],
  handleRadius: 6
};
var state = {
  isInteractingWithTool: false,
  isMultiPartToolActive: false,
  tools: {},
  toolGroups: [],
  synchronizers: [],
  svgNodeCache: svgNodeCache_default,
  enabledElements: [],
  handleRadius: 6
};
function resetCornerstoneToolsState() {
  resetSvgNodeCache();
  state = {
    ...structuredClone({
      ...defaultState,
      svgNodeCache: {}
    }),
    svgNodeCache: {
      ...defaultState.svgNodeCache
    }
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js
var import_lodash = __toESM(require_lodash());

// node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js
var cursors_exports = {};
__export(cursors_exports, {
  CursorNames: () => CursorNames,
  CursorSVG: () => CursorSVG,
  ImageMouseCursor: () => ImageMouseCursor,
  MouseCursor: () => MouseCursor,
  SVGMouseCursor: () => SVGMouseCursor,
  elementCursor: () => elementCursor_exports,
  registerCursor: () => registerCursor,
  setCursorForElement: () => setCursorForElement_default
});

// node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js
var DEFINED_CURSORS = Symbol("DefinedCursors");
var STANDARD_CURSORS = /* @__PURE__ */ new Set([
  "alias",
  "all-scroll",
  "auto",
  "cell",
  "col-resize",
  "context-menu",
  "copy",
  "crosshair",
  "default",
  "e-resize",
  "ew-resize",
  "grab",
  "grabbing",
  "help",
  "move",
  "ne-resize",
  "nesw-resize",
  "no-drop",
  "none",
  "not-allowed",
  "n-resize",
  "ns-resize",
  "nw-resize",
  "nwse-resize",
  "pointer",
  "progress",
  "row-resize",
  "se-resize",
  "s-resize",
  "sw-resize",
  "text",
  "vertical-text",
  "wait",
  "w-resize",
  "zoom-in",
  "zoom-out"
]);
var MouseCursor = class _MouseCursor {
  constructor(name, fallback) {
    this.name = name + "";
    this.fallback = fallback;
  }
  getName() {
    return this.name + "";
  }
  addFallbackStyleProperty(style) {
    const { fallback } = this;
    if (fallback instanceof _MouseCursor) {
      return `${style}, ${fallback.getStyleProperty()}`;
    }
    return style + "";
  }
  getStyleProperty() {
    return this.addFallbackStyleProperty(this.name) + "";
  }
  static getDefinedCursor(name) {
    const definedCursors = getDefinedCursors(_MouseCursor, DEFINED_CURSORS);
    let mouseCursor = definedCursors.get(name);
    if (mouseCursor instanceof _MouseCursor) {
      return mouseCursor;
    }
    if (STANDARD_CURSORS.has(name)) {
      mouseCursor = new _MouseCursor(name);
      definedCursors.set(name, mouseCursor);
      return mouseCursor;
    }
  }
  static setDefinedCursor(name, cursor) {
    if (cursor instanceof _MouseCursor) {
      const definedCursors = getDefinedCursors(_MouseCursor, DEFINED_CURSORS);
      definedCursors.set(name, cursor);
      return true;
    }
    return false;
  }
};
function getDefinedCursors(context, symbol) {
  let definedCursors = context[symbol];
  if (!(definedCursors instanceof Map)) {
    definedCursors = /* @__PURE__ */ new Map();
    Object.defineProperty(context, symbol, { value: definedCursors });
  }
  return definedCursors;
}
var standardCursorNames = STANDARD_CURSORS.values();

// node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js
var DEFAULT_NAME = "image-cursor";
var ImageMouseCursor = class _ImageMouseCursor extends MouseCursor {
  constructor(url, x, y, name, fallback) {
    super(name || _ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME), fallback);
    this.url = url;
    this.x = Number(x) || 0;
    this.y = Number(y) || 0;
  }
  getStyleProperty() {
    const { url, x, y } = this;
    let style = `url('${url}')`;
    if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {
      style += ` ${x} ${y}`;
    }
    return this.addFallbackStyleProperty(style);
  }
  static getUniqueInstanceName(prefix) {
    return `${prefix}-${utilities_exports.getRuntimeId(_ImageMouseCursor)}`;
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js
var BASE = {
  iconContent: "",
  iconSize: 16,
  viewBox: {
    x: 16,
    y: 16
  },
  mousePoint: {
    x: 8,
    y: 8
  },
  mousePointerGroupString: `
    <path stroke="{{color}}" d="M8 16L8 0"></path>
    <path stroke="{{color}}" d="M16 8L0 8"></path>
  `
};
var SEGMENTATION_CURSOR_BOUNDARIES = {
  x: 127,
  y: 60
};
var MINUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
`;
var PLUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
<rect fill="{{color}}" x="95.84" y="9.38" width="15.85" height="47.14"/>
`;
var SCISSOR_ICON = `<path fill="{{color}}" d="M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z" transform="translate(-1.17 -0.96)"/>`;
var RECTANGLE_ICON = `<path fill="{{color}}" d="M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z" transform="translate(-8.86 -2.25)"/>`;
var CIRCLE_ICON = `<path fill="{{color}}" d="M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z" transform="translate(-8.86 -2.25)"/>`;
var CursorSVG = {
  Angle: extend(BASE, {
    name: "Angle",
    iconContent: `<path fill="{{color}}" d="M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50
    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23
    10l50 50q10 10 10 23z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  ArrowAnnotate: extend(BASE, {
    name: "ArrowAnnotate",
    iconContent: `<g id="arrowAnnotate-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="arrowAnnotate-arrow" d="M23,7 l-15,15 M7,17 l0,6 6,0" stroke-width="2" />
  </g>`,
    viewBox: {
      x: 24,
      y: 24
    }
  }),
  Bidirectional: extend(BASE, {
    name: "Bidirectional",
    iconContent: `<g fill="{{color}}" stroke-width="3" stroke="{{color}}">
    <path d="M27.63 3.21L3.12 28.81"></path>
    <path d="M27.63 15.75L15.27 4.43"></path>
    <path d="M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z" ></path>
    <path d="M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z"></path>
    <path d="M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z"></path>
    <path d="M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z"></path>
  </g>`,
    viewBox: {
      x: 48,
      y: 48
    }
  }),
  CobbAngle: extend(BASE, {
    name: "CobbAngle",
    iconContent: `<g stroke="{{color}}" stroke-width="3">
    <path d="M28.59 2.34L3.82 12.32"></path>
    <path d="M28.59 29.66L3.82 19.68"></path>
    <path stroke-dasharray="2" fill-opacity="0" d="M12.37
      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15
      9.33C13.11 9.24 13.02 9 12.88 8.63">
    </path>
  </g>`,
    viewBox: {
      x: 32,
      y: 32
    }
  }),
  CircleROI: extend(BASE, {
    name: "CircleROI",
    iconContent: `<circle stroke="{{color}}" fill="none" stroke-width="3" cx="16" cy="16" r="14" />`,
    viewBox: {
      x: 32,
      y: 32
    }
  }),
  EllipticalROI: extend(BASE, {
    name: "EllipticalROI",
    iconContent: `<path stroke="{{color}}" fill="none" stroke-width="3" d="M30.74 15.76C30.74 20.99 24.14 25.23 16
    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14
    6.3 30.74 10.54 30.74 15.76Z" />`,
    viewBox: {
      x: 32,
      y: 32
    }
  }),
  FreehandROI: extend(BASE, {
    name: "FreehandROI",
    iconContent: `<g fill="{{color}}" stroke="{{color}}" stroke-width="2">
    <ellipse ry="1" rx="1" id="svg_3" cy="4.240343" cx="14.306499"/>
    <line id="svg_4" y2="3.58462" x2="12.242186" y1="3.997482" x1="13.432202"/>
    <line id="svg_5" y2="3.268901" x2="10.857882" y1="3.608906" x1="12.387902"/>
    <line id="svg_6" y2="3.147471" x2="9.740724" y1="3.293187" x1="10.955026"/>
    <line id="svg_7" y2="3.147471" x2="8.089274" y1="3.196043" x1="9.983585"/>
    <line id="svg_8" y2="3.268901" x2="6.874972" y1="3.123185" x1="8.307848"/>
    <line id="svg_9" y2="3.657478" x2="5.587812" y1="3.220329" x1="7.020688"/>
    <line id="svg_10" y2="4.046054" x2="4.737801" y1="3.560334" x1="5.854959"/>
    <line id="svg_11" y2="4.337487" x2="4.300652" y1="3.997482" x1="4.834945"/>
    <line id="svg_12" y2="4.726063" x2="3.88779" y1="4.191771" x1="4.470655"/>
    <line id="svg_15" y2="5.3575" x2="3.377783" y1="4.604633" x1="3.960648"/>
    <line id="svg_16" y2="6.183226" x2="2.916348" y1="5.138926" x1="3.547785"/>
    <line id="svg_17" y2="6.960379" x2="2.770632" y1="5.867507" x1="3.037779"/>
    <line id="svg_18" y2="7.713246" x2="2.673488" y1="6.741804" x1="2.819204"/>
    <line id="svg_19" y2="8.684687" x2="2.697774" y1="7.616102" x1="2.673488"/>
    <line id="svg_20" y2="9.753273" x2="2.892062" y1="8.611829" x1="2.697774"/>
    <line id="svg_21" y2="10.724714" x2="3.134923" y1="9.534698" x1="2.84349"/>
    <line id="svg_23" y2="11.647583" x2="3.596357" y1="10.578998" x1="3.086351"/>
    <line id="svg_25" y2="12.521881" x2="4.276366" y1="11.501867" x1="3.499213"/>
    <line id="svg_26" y2="13.930471" x2="5.830673" y1="12.376165" x1="4.13065"/>
    <line id="svg_28" y2="14.707624" x2="7.263549" y1="13.881899" x1="5.733528"/>
    <line id="svg_29" y2="15.339061" x2="8.963571" y1="14.61048" x1="7.06926"/>
    <line id="svg_30" y2="15.581921" x2="10.882168" y1="15.314775" x1="8.817855"/>
    <line id="svg_31" y2="15.460491" x2="12.023612" y1="15.581921" x1="10.785024"/>
    <line id="svg_33" y2="15.120487" x2="13.092197" y1="15.484777" x1="11.877895"/>
    <line id="svg_34" y2="14.586194" x2="13.86935" y1="15.217631" x1="12.897909"/>
    <line id="svg_35" y2="13.833327" x2="14.597931" y1="14.756196" x1="13.699348"/>
    <line id="svg_37" y2="12.716169" x2="15.180796" y1="13.881899" x1="14.549359"/>
    <line id="svg_39" y2="11.429009" x2="15.520801" y1="12.813313" x1="15.15651"/>
    <ellipse ry="1" rx="1" id="svg_40" cy="10.967574" cx="15.520801"/>
  </g>`,
    viewBox: {
      x: 18,
      y: 18
    }
  }),
  FreehandROISculptor: extend(BASE, {
    name: "FreehandROISculptor",
    iconContent: `<g id="icon-freehand-sculpt" fill="none" stroke-width="1.5" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <line id="svg_1" y2="2.559367" x2="10.184807" y1="4.467781" x1="8.81711"/>
    <line id="svg_4" y2="1.493836" x2="11.727442" y1="2.766112" x1="10.089386"/>
    <line id="svg_7" y2="1.080346" x2="13.047428" y1="1.748291" x1="11.345759"/>
    <line id="svg_8" y2="1.000829" x2="14.351511" y1="1.112153" x1="12.77707"/>
    <line id="svg_9" y2="1.350705" x2="15.242104" y1="0.905408" x1="13.969828"/>
    <line id="svg_10" y2="2.098167" x2="15.862339" y1="1.14396" x1="14.955842"/>
    <line id="svg_11" y2="3.195505" x2="16.41896" y1="1.939133" x1="15.766918"/>
    <line id="svg_12" y2="4.292843" x2="16.530284" y1="2.925147" x1="16.387153"/>
    <line id="svg_16" y2="5.644637" x2="16.196311" y1="3.831643" x1="16.593898"/>
    <line id="svg_18" y2="7.266789" x2="15.623787" y1="5.19934" x1="16.275829"/>
    <line id="svg_19" y2="10.813258" x2="14.526449" y1="6.726071" x1="15.766918"/>
    <line id="svg_20" y2="5.056209" x2="8.085552" y1="4.181519" x1="8.976145"/>
    <line id="svg_23" y2="5.326568" x2="7.481221" y1="4.78585" x1="8.403621"/>
    <line id="svg_24" y2="5.565119" x2="6.749662" y1="5.294761" x1="7.624352"/>
    <line id="svg_25" y2="5.994512" x2="5.429675" y1="5.533312" x1="6.956407"/>
    <line id="svg_27" y2="6.551133" x2="4.284627" y1="5.962706" x1="5.572807"/>
    <line id="svg_28" y2="7.584858" x2="3.044158" y1="6.392099" x1="4.427758"/>
    <line id="svg_29" y2="8.84123" x2="2.185372" y1="7.489437" x1="3.219096"/>
    <line id="svg_31" y2="10.606513" x2="1.644654" y1="8.602678" x1="2.280792"/>
    <line id="svg_32" y2="13.214679" x2="1.48562" y1="10.352058" x1="1.724171"/>
    <line id="svg_33" y2="14.375631" x2="1.676461" y1="12.992031" x1="1.453813"/>
    <line id="svg_34" y2="15.298031" x2="2.264889" y1="14.152983" x1="1.517427"/>
    <line id="svg_35" y2="16.172721" x2="3.521261" y1="14.948155" x1="1.915013"/>
    <line id="svg_36" y2="16.824762" x2="5.207027" y1="15.997783" x1="3.28271"/>
    <line id="svg_38" y2="17.063314" x2="7.035924" y1="16.745245" x1="4.968475"/>
    <line id="svg_39" y2="16.888376" x2="9.278311" y1="17.047411" x1="6.733758"/>
    <line id="svg_40" y2="16.284045" x2="10.661911" y1="16.983797" x1="8.992048"/>
    <line id="svg_41" y2="15.313934" x2="11.647925" y1="16.395369" x1="10.455166"/>
    <line id="svg_44" y2="13.898527" x2="12.82478" y1="15.425259" x1="11.504794"/>
    <line id="svg_45" y2="12.037824" x2="14.144766" y1="14.312017" x1="12.522614"/>
    <line id="svg_47" y2="10.59061" x2="14.605966" y1="12.228665" x1="13.953925"/>
    <ellipse ry="1" rx="1" id="svg_48" cy="3.982726" cx="13.460918"/>
  </g>`,
    viewBox: {
      x: 18,
      y: 18
    }
  }),
  Length: extend(BASE, {
    name: "Length",
    iconContent: `<g id="length-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="length-dashes" d="m22.5,6 -16.5,16.5" stroke-width="3" stroke-dasharray="0.6666,5" />
  </g>`,
    viewBox: {
      x: 24,
      y: 24
    }
  }),
  Height: extend(BASE, {
    name: "Height",
    iconContent: `<path d="m 6 22 l 8.5 0 v -16 h 8" stroke-width="3" fill="none" stroke="{{color}}" />`,
    viewBox: {
      x: 24,
      y: 24
    }
  }),
  Probe: extend(BASE, {
    name: "Probe",
    iconContent: `<path fill="{{color}}" d="M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75
    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73
    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5
    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5
    385.5-103 385.5 103 279.5 279.5 103 385.5z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  RectangleROI: extend(BASE, {
    name: "RectangleROI",
    iconContent: `<path fill="{{color}}" d="M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47
    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0
    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119
    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  TextMarker: extend(BASE, {
    name: "TextMarker",
    iconContent: `<path fill="{{color}}" d="M789 559l-170 450q33 0 136.5 2t160.5 2q19 0
    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29
    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15
    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5
    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0
    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11
    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0
    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58
    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  Crosshairs: extend(BASE, {
    name: "Crosshairs",
    iconContent: `<path fill="{{color}}" d="M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26
    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45
    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26
    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5
    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32
    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5
    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26
    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26
    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161
    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161
    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  Eraser: extend(BASE, {
    name: "Eraser",
    iconContent: `<path transform="translate(0,1792) scale(1,-1)" fill="{{color}}" d="M960 1408l336-384h-768l-336 384h768zm1013-1077q15
    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38
    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38
    0 69.5 20.5t47.5 54.5z" />`,
    viewBox: {
      x: 2048,
      y: 1792
    }
  }),
  Magnify: extend(BASE, {
    name: "Magnify",
    iconContent: `<path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />`,
    viewBox: {
      x: 512,
      y: 512
    }
  }),
  Pan: extend(BASE, {
    name: "Pan",
    iconContent: `<path fill="{{color}}" d="M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17
    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355
    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59
    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12
    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144
    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19
    45v448q0 42-39 59-13 5-25 5-26 0-45-19z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  Rotate: extend(BASE, {
    name: "Rotate",
    iconContent: `<path fill="{{color}}" d="M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39
    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5
    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0
    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109
    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298
    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14
    39 17 39 59z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  StackScroll: extend(BASE, {
    name: "StackScroll",
    iconContent: `<path fill="{{color}}" d="M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0
    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547
    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z" />`,
    viewBox: {
      x: 24,
      y: 28
    }
  }),
  WindowLevelRegion: extend(BASE, {
    name: "WindowLevelRegion",
    iconContent: `<path fill="{{color}}" d="M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119
    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5
    84.5t84.5 203.5z" />`,
    viewBox: {
      x: 1792,
      y: 1792
    }
  }),
  WindowLevel: extend(BASE, {
    name: "WindowLevel",
    iconContent: `
    <path fill="{{color}}" d="M14.5,3.5 a1 1 0 0 1 -11,11 Z" stroke="none" opacity="0.8" />
    <circle cx="9" cy="9" r="8" fill="none" stroke-width="2" stroke="{{color}}" />`,
    viewBox: {
      x: 18,
      y: 18
    }
  }),
  Zoom: extend(BASE, {
    name: "Zoom",
    iconContent: `
  <path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />
  <path fill="{{color}}" transform="scale(0.22,0.22) translate(1400,0)" d="M1216
    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19
    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26
    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z" />`,
    viewBox: {
      x: 640,
      y: 512
    }
  }),
  SegmentationFreeHandEraseInside: extend(BASE, {
    name: "SegmentationFreeHandEraseInside",
    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  SegmentationFreeHandFillInside: extend(BASE, {
    name: "SegmentationFreeHandFillInside",
    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  SegmentationFreeHandEraseOutside: extend(BASE, {
    name: "SegmentationFreeHandEraseOutside",
    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  SegmentationFreeHandFillOutside: extend(BASE, {
    name: "SegmentationFreeHandFillOutside",
    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  SegmentationRectangleEraseInside: extend(BASE, {
    name: "SegmentationRectangleEraseInside",
    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  RectangleScissor: extend(BASE, {
    name: "RectangleScissor",
    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "RectangleScissor.FILL_INSIDE": extend(BASE, {
    name: "RectangleScissor.FILL_INSIDE",
    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "RectangleScissor.FILL_OUTSIDE": extend(BASE, {
    name: "RectangleScissor.FILL_OUTSIDE",
    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "RectangleScissor.ERASE_OUTSIDE": extend(BASE, {
    name: "RectangleScissor.ERASE_OUTSIDE",
    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "RectangleScissor.ERASE_INSIDE": extend(BASE, {
    name: "RectangleScissor.ERASE_INSIDE",
    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  CircleScissor: extend(BASE, {
    name: "CircleScissor",
    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "CircleScissor.FILL_INSIDE": extend(BASE, {
    name: "CircleScissor.FILL_INSIDE",
    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "CircleScissor.ERASE_OUTSIDE": extend(BASE, {
    name: "CircleScissor.ERASE_OUTSIDE",
    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  }),
  "CircleScissor.FILL_OUTSIDE": extend(BASE, {
    name: "CircleScissor.FILL_OUTSIDE",
    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
    viewBox: SEGMENTATION_CURSOR_BOUNDARIES
  })
};
function extend(base, values) {
  return Object.assign(Object.create(base), {
    ...values,
    name: values.name || base.name
  });
}
function registerCursor(toolName, iconContent, viewBox) {
  CursorSVG[toolName] = extend(BASE, {
    iconContent,
    viewBox
  });
}
function getDefinedSVGCursorDescriptor(name) {
  return CursorSVG[name];
}
var svgCursorNames = Object.keys(CursorSVG);

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js
var ToolStyle = class {
  constructor() {
    const defaultConfig = {
      color: "rgb(255, 255, 0)",
      colorHighlighted: "rgb(0, 255, 0)",
      colorSelected: "rgb(0, 220, 0)",
      colorLocked: "rgb(209, 193, 90)",
      lineWidth: "1",
      lineDash: "",
      shadow: true,
      textBoxVisibility: true,
      textBoxFontFamily: "Helvetica Neue, Helvetica, Arial, sans-serif",
      textBoxFontSize: "14px",
      textBoxColor: "rgb(255, 255, 0)",
      textBoxColorHighlighted: "rgb(0, 255, 0)",
      textBoxColorSelected: "rgb(0, 255, 0)",
      textBoxColorLocked: "rgb(209, 193, 90)",
      textBoxBackground: "",
      textBoxLinkLineWidth: "1",
      textBoxLinkLineDash: "2,3",
      textBoxShadow: true
    };
    this._initializeConfig(defaultConfig);
  }
  getAnnotationToolStyles(annotationUID) {
    return this.config.annotations && this.config.annotations[annotationUID];
  }
  getViewportToolStyles(viewportId) {
    return this.config.viewports && this.config.viewports[viewportId];
  }
  getToolGroupToolStyles(toolGroupId) {
    return this.config.toolGroups && this.config.toolGroups[toolGroupId];
  }
  getDefaultToolStyles() {
    return this.config.default;
  }
  setAnnotationStyles(annotationUID, styles) {
    let annotationSpecificStyles = this.config.annotations;
    if (!annotationSpecificStyles) {
      this.config = {
        ...this.config,
        annotations: {}
      };
      annotationSpecificStyles = this.config.annotations;
    }
    annotationSpecificStyles[annotationUID] = styles;
  }
  setViewportToolStyles(viewportId, styles) {
    let viewportSpecificStyles = this.config.viewports;
    if (!viewportSpecificStyles) {
      this.config = {
        ...this.config,
        viewports: {}
      };
      viewportSpecificStyles = this.config.viewports;
    }
    viewportSpecificStyles[viewportId] = styles;
  }
  setToolGroupToolStyles(toolGroupId, styles) {
    let toolGroupSpecificStyles = this.config.toolGroups;
    if (!toolGroupSpecificStyles) {
      this.config = {
        ...this.config,
        toolGroups: {}
      };
      toolGroupSpecificStyles = this.config.toolGroups;
    }
    toolGroupSpecificStyles[toolGroupId] = styles;
  }
  setDefaultToolStyles(styles) {
    this.config.default = styles;
  }
  getStyleProperty(toolStyle2, specifications) {
    const { annotationUID, viewportId, toolGroupId, toolName } = specifications;
    return this._getToolStyle(toolStyle2, annotationUID, viewportId, toolGroupId, toolName);
  }
  _getToolStyle(property, annotationUID, viewportId, toolGroupId, toolName) {
    if (annotationUID) {
      const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);
      if (annotationToolStyles) {
        if (annotationToolStyles[property] !== void 0) {
          return annotationToolStyles[property];
        }
      }
    }
    if (viewportId) {
      const viewportToolStyles = this.getViewportToolStyles(viewportId);
      if (viewportToolStyles) {
        if (viewportToolStyles[toolName] && viewportToolStyles[toolName][property] !== void 0) {
          return viewportToolStyles[toolName][property];
        }
        if (viewportToolStyles.global && viewportToolStyles.global[property] !== void 0) {
          return viewportToolStyles.global[property];
        }
      }
    }
    if (toolGroupId) {
      const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);
      if (toolGroupToolStyles) {
        if (toolGroupToolStyles[toolName] && toolGroupToolStyles[toolName][property] !== void 0) {
          return toolGroupToolStyles[toolName][property];
        }
        if (toolGroupToolStyles.global && toolGroupToolStyles.global[property] !== void 0) {
          return toolGroupToolStyles.global[property];
        }
      }
    }
    const globalStyles = this.getDefaultToolStyles();
    if (globalStyles[toolName] && globalStyles[toolName][property] !== void 0) {
      return globalStyles[toolName][property];
    }
    if (globalStyles.global && globalStyles.global[property] !== void 0) {
      return globalStyles.global[property];
    }
  }
  _initializeConfig(config) {
    const toolStyles = {};
    for (const name in config) {
      toolStyles[name] = config[name];
    }
    this.config = {
      default: {
        global: toolStyles
      }
    };
  }
};
var toolStyle = new ToolStyle();
var ToolStyle_default = toolStyle;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js
function getHierarchalPropertyStyles(property, state8, mode) {
  const list = [`${property}`];
  if (state8) {
    list.push(`${list[0]}${state8}`);
  }
  if (mode) {
    list.push(`${list[list.length - 1]}${mode}`);
  }
  return list;
}
function getStyleProperty(property, styleSpecifier, state8, mode) {
  const alternatives = getHierarchalPropertyStyles(property, state8, mode);
  for (let i = alternatives.length - 1; i >= 0; --i) {
    const style = ToolStyle_default.getStyleProperty(alternatives[i], styleSpecifier);
    if (style !== void 0) {
      return style;
    }
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js
var PROPERTY = "color";
var STATE = AnnotationStyleStates_default.Highlighted;
var MODE = ToolModes_default.Active;
var SVGMouseCursor = class extends ImageMouseCursor {
  constructor(url, x, y, name, fallback) {
    super(url, x, y, name, fallback);
  }
  static getDefinedCursor(name, pointer = false, color) {
    if (!color) {
      color = getStyleProperty(PROPERTY, {}, STATE, MODE);
    }
    const urn = getCursorURN(name, pointer, color);
    let cursor = super.getDefinedCursor(urn);
    if (!cursor) {
      const descriptor = getDefinedSVGCursorDescriptor(name);
      if (descriptor) {
        cursor = createSVGMouseCursor(descriptor, urn, pointer, color, super.getDefinedCursor("default"));
        super.setDefinedCursor(urn, cursor);
      }
    }
    return cursor;
  }
};
function format(template, dictionary) {
  const dict = Object(dictionary);
  const defined = Object.prototype.hasOwnProperty.bind(dict);
  return (template + "").replace(/\{\{(\w+)\}\}/g, (match, key) => {
    return defined(key) ? dict[key] + "" : "";
  });
}
function getCursorURN(name, pointer, color) {
  const type = pointer ? "pointer" : "cursor";
  return `${type}:${name}/${color}`;
}
function createSVGMouseCursor(descriptor, name, pointer, color, fallback) {
  const { x, y } = descriptor.mousePoint;
  return new SVGMouseCursor(createSVGIconUrl(descriptor, pointer, { color }), x, y, name, fallback);
}
function createSVGIconUrl(descriptor, pointer, options) {
  const blob = createSVGIconBlob(descriptor, pointer, options);
  const url = URL.createObjectURL(blob);
  const urn = `${url}#${descriptor.name || "unknown"}-${pointer ? "pointer" : "cursor"}`;
  return urn;
}
function createSVGIconBlob(descriptor, pointer, options) {
  const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(descriptor, options);
  return new Blob([svgString], { type: "image/svg+xml" });
}
function createSVGIcon(descriptor, options) {
  const { iconContent, iconSize, viewBox } = descriptor;
  const svgString = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${iconSize}" height="${iconSize}" viewBox="0 0
      ${viewBox.x} ${viewBox.y}">
      ${iconContent}
    </svg>`;
  return format(svgString, options);
}
function createSVGIconWithPointer(descriptor, options) {
  const { iconContent, iconSize, viewBox, mousePointerGroupString } = descriptor;
  const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);
  const svgSize = 16 + iconSize;
  const svgString = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}">
      <g>${mousePointerGroupString}</g>
      <g transform="translate(16, 16) scale(${scale})">${iconContent}</g>
    </svg>`;
  return format(svgString, options);
}

// node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js
var elementCursor_exports = {};
__export(elementCursor_exports, {
  hideElementCursor: () => hideElementCursor,
  initElementCursor: () => initElementCursor,
  resetElementCursor: () => resetElementCursor,
  setElementCursor: () => _setElementCursor
});
var ELEMENT_CURSORS_MAP = Symbol("ElementCursorsMap");
function initElementCursor(element, cursor) {
  _getElementCursors(element)[0] = cursor;
  _setElementCursor(element, cursor);
}
function _setElementCursor(element, cursor) {
  const cursors = _getElementCursors(element);
  cursors[1] = cursors[0];
  cursors[0] = cursor;
  element.style.cursor = (cursor instanceof MouseCursor ? cursor : MouseCursor.getDefinedCursor("auto")).getStyleProperty();
}
function resetElementCursor(element) {
  _setElementCursor(element, _getElementCursors(element)[1]);
}
function hideElementCursor(element) {
  _setElementCursor(element, MouseCursor.getDefinedCursor("none"));
}
function _getElementCursors(element) {
  let map = _getElementCursors[ELEMENT_CURSORS_MAP];
  if (!(map instanceof WeakMap)) {
    map = /* @__PURE__ */ new WeakMap();
    Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {
      value: map
    });
  }
  let cursors = map.get(element);
  if (!cursors) {
    cursors = [null, null];
    map.set(element, cursors);
  }
  return cursors;
}

// node_modules/@cornerstonejs/tools/dist/esm/cursors/setCursorForElement.js
function setCursorForElement(element, cursorName) {
  let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);
  if (!cursor) {
    cursor = MouseCursor.getDefinedCursor(cursorName);
  }
  if (!cursor) {
    console.log(`Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`);
    cursor = MouseCursor.getDefinedCursor(cursorName);
  }
  _setElementCursor(element, cursor);
}
var setCursorForElement_default = setCursorForElement;

// node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js
var CursorNames = [...svgCursorNames, ...standardCursorNames];

// node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js
function getToolGroup(toolGroupId) {
  return state.toolGroups.find((s) => s.id === toolGroupId);
}
var getToolGroup_default = getToolGroup;

// node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js
var { Active, Passive, Enabled, Disabled } = ToolModes_default;
var PRIMARY_BINDINGS = [{ mouseButton: MouseBindings.Primary }];
var ToolGroup = class _ToolGroup {
  constructor(id) {
    this.viewportsInfo = [];
    this.toolOptions = {};
    this.currentActivePrimaryToolName = null;
    this.prevActivePrimaryToolName = null;
    this.restoreToolOptions = {};
    this._toolInstances = {};
    this.id = id;
  }
  getViewportIds() {
    return this.viewportsInfo.map(({ viewportId }) => viewportId);
  }
  getViewportsInfo() {
    return this.viewportsInfo.slice();
  }
  getToolInstance(toolInstanceName) {
    const toolInstance = this._toolInstances[toolInstanceName];
    if (!toolInstance) {
      console.warn(`'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`);
      return;
    }
    return toolInstance;
  }
  getToolInstances() {
    return this._toolInstances;
  }
  hasTool(toolName) {
    return !!this._toolInstances[toolName];
  }
  addTool(toolName, configuration3 = {}) {
    const toolDefinition = state.tools[toolName];
    const hasToolName = typeof toolName !== "undefined" && toolName !== "";
    const localToolInstance = this.toolOptions[toolName];
    if (!hasToolName) {
      console.warn("Tool with configuration did not produce a toolName: ", configuration3);
      return;
    }
    if (!toolDefinition) {
      console.warn(`'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);
      return;
    }
    if (localToolInstance) {
      console.warn(`'${toolName}' is already registered for ToolGroup ${this.id}.`);
      return;
    }
    const { toolClass: ToolClass } = toolDefinition;
    const toolProps = {
      name: toolName,
      toolGroupId: this.id,
      configuration: configuration3
    };
    const instantiatedTool = new ToolClass(toolProps);
    this._toolInstances[toolName] = instantiatedTool;
  }
  addToolInstance(toolName, parentClassName, configuration3 = {}) {
    var _a2;
    let ToolClassToUse = (_a2 = state.tools[toolName]) == null ? void 0 : _a2.toolClass;
    if (!ToolClassToUse) {
      const ParentClass = state.tools[parentClassName].toolClass;
      class ToolInstance extends ParentClass {
      }
      ToolInstance.toolName = toolName;
      ToolClassToUse = ToolInstance;
      state.tools[toolName] = {
        toolClass: ToolInstance
      };
    }
    this.addTool(ToolClassToUse.toolName, configuration3);
  }
  addViewport(viewportId, renderingEngineId) {
    if (typeof viewportId !== "string") {
      throw new Error("viewportId must be defined and be a string");
    }
    const renderingEngineUIDToUse = this._findRenderingEngine(viewportId, renderingEngineId);
    if (!this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)) {
      this.viewportsInfo.push({
        viewportId,
        renderingEngineId: renderingEngineUIDToUse
      });
    }
    const toolName = this.getActivePrimaryMouseButtonTool();
    const runtimeSettings2 = Settings.getRuntimeSettings();
    if (runtimeSettings2.get("useCursors")) {
      this.setViewportsCursorByToolName(toolName);
    }
    const eventDetail = {
      toolGroupId: this.id,
      viewportId,
      renderingEngineId: renderingEngineUIDToUse
    };
    triggerEvent(eventTarget_default, Events_default.TOOLGROUP_VIEWPORT_ADDED, eventDetail);
  }
  removeViewports(renderingEngineId, viewportId) {
    const indices = [];
    this.viewportsInfo.forEach((vpInfo, index) => {
      let match = false;
      if (vpInfo.renderingEngineId === renderingEngineId) {
        match = true;
        if (viewportId && vpInfo.viewportId !== viewportId) {
          match = false;
        }
      }
      if (match) {
        indices.push(index);
      }
    });
    if (indices.length) {
      for (let i = indices.length - 1; i >= 0; i--) {
        this.viewportsInfo.splice(indices[i], 1);
      }
    }
    const eventDetail = {
      toolGroupId: this.id,
      viewportId,
      renderingEngineId
    };
    triggerEvent(eventTarget_default, Events_default.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);
  }
  setActiveStrategy(toolName, strategyName) {
    const toolInstance = this._toolInstances[toolName];
    if (toolInstance === void 0) {
      console.warn(`Tool ${toolName} not added to toolGroup, can't set tool configuration.`);
      return;
    }
    toolInstance.setActiveStrategy(strategyName);
  }
  setToolMode(toolName, mode, options = {}) {
    if (!toolName) {
      console.warn("setToolMode: toolName must be defined");
      return;
    }
    if (mode === ToolModes_default.Active) {
      this.setToolActive(toolName, options || this.restoreToolOptions[toolName]);
      return;
    }
    if (mode === ToolModes_default.Passive) {
      this.setToolPassive(toolName);
      return;
    }
    if (mode === ToolModes_default.Enabled) {
      this.setToolEnabled(toolName);
      return;
    }
    if (mode === ToolModes_default.Disabled) {
      this.setToolDisabled(toolName);
      return;
    }
    console.warn("setToolMode: mode must be defined");
  }
  setToolActive(toolName, toolBindingsOptions = {}) {
    const toolInstance = this._toolInstances[toolName];
    if (toolInstance === void 0) {
      console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
      return;
    }
    if (!toolInstance) {
      console.warn(`'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`);
      return;
    }
    const prevBindings = this.toolOptions[toolName] ? this.toolOptions[toolName].bindings : [];
    const newBindings = toolBindingsOptions.bindings ? toolBindingsOptions.bindings : [];
    const bindingsToUse = [...prevBindings, ...newBindings].reduce((unique, binding) => {
      const TouchBinding = binding.numTouchPoints !== void 0;
      const MouseBinding = binding.mouseButton !== void 0;
      if (!unique.some((obj) => hasSameBinding(obj, binding)) && (TouchBinding || MouseBinding)) {
        unique.push(binding);
      }
      return unique;
    }, []);
    const toolOptions = {
      bindings: bindingsToUse,
      mode: Active
    };
    this.toolOptions[toolName] = toolOptions;
    this._toolInstances[toolName].mode = Active;
    const runtimeSettings2 = Settings.getRuntimeSettings();
    const useCursor = runtimeSettings2.get("useCursors");
    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {
      this.setViewportsCursorByToolName(toolName);
    } else {
      const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();
      if (!activeToolIdentifier && useCursor) {
        const cursor = MouseCursor.getDefinedCursor("default");
        this._setCursorForViewports(cursor);
      }
    }
    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {
      if (this.prevActivePrimaryToolName === null) {
        this.prevActivePrimaryToolName = toolName;
      } else {
        this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;
      }
      this.currentActivePrimaryToolName = toolName;
    }
    if (typeof toolInstance.onSetToolActive === "function") {
      toolInstance.onSetToolActive();
    }
    this._renderViewports();
    const eventDetail = {
      toolGroupId: this.id,
      toolName,
      toolBindingsOptions
    };
    triggerEvent(eventTarget_default, Events_default.TOOL_ACTIVATED, eventDetail);
    this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);
  }
  setToolPassive(toolName, options) {
    const toolInstance = this._toolInstances[toolName];
    if (toolInstance === void 0) {
      console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
      return;
    }
    const prevToolOptions = this.getToolOptions(toolName);
    const toolOptions = Object.assign({
      bindings: prevToolOptions ? prevToolOptions.bindings : []
    }, prevToolOptions, {
      mode: Passive
    });
    const matchBindings = Array.isArray(options == null ? void 0 : options.removeAllBindings) ? options.removeAllBindings : this.getDefaultPrimaryBindings();
    toolOptions.bindings = toolOptions.bindings.filter((binding) => (options == null ? void 0 : options.removeAllBindings) !== true && !matchBindings.some((matchBinding) => hasSameBinding(binding, matchBinding)));
    let mode = Passive;
    if (toolOptions.bindings.length !== 0) {
      mode = Active;
      toolOptions.mode = mode;
    }
    this.toolOptions[toolName] = toolOptions;
    toolInstance.mode = mode;
    if (typeof toolInstance.onSetToolPassive === "function") {
      toolInstance.onSetToolPassive();
    }
    this._renderViewports();
    this._triggerToolModeChangedEvent(toolName, Passive);
  }
  setToolEnabled(toolName) {
    const toolInstance = this._toolInstances[toolName];
    if (toolInstance === void 0) {
      console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
      return;
    }
    const toolOptions = {
      bindings: [],
      mode: Enabled
    };
    this.toolOptions[toolName] = toolOptions;
    toolInstance.mode = Enabled;
    if (typeof toolInstance.onSetToolEnabled === "function") {
      toolInstance.onSetToolEnabled();
    }
    this._renderViewports();
    this._triggerToolModeChangedEvent(toolName, Enabled);
  }
  setToolDisabled(toolName) {
    const toolInstance = this._toolInstances[toolName];
    if (toolInstance === void 0) {
      console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
      return;
    }
    const toolOptions = {
      bindings: [],
      mode: Disabled
    };
    this.restoreToolOptions[toolName] = this.toolOptions[toolName];
    this.toolOptions[toolName] = toolOptions;
    toolInstance.mode = Disabled;
    if (typeof toolInstance.onSetToolDisabled === "function") {
      toolInstance.onSetToolDisabled();
    }
    this._renderViewports();
    this._triggerToolModeChangedEvent(toolName, Disabled);
  }
  getToolOptions(toolName) {
    const toolOptionsForTool = this.toolOptions[toolName];
    if (toolOptionsForTool === void 0) {
      return;
    }
    return toolOptionsForTool;
  }
  getActivePrimaryMouseButtonTool() {
    return Object.keys(this.toolOptions).find((toolName) => {
      const toolOptions = this.toolOptions[toolName];
      return toolOptions.mode === Active && this._hasMousePrimaryButtonBinding(toolOptions);
    });
  }
  setViewportsCursorByToolName(toolName, strategyName) {
    const cursor = this._getCursor(toolName, strategyName);
    this._setCursorForViewports(cursor);
  }
  _getCursor(toolName, strategyName) {
    let cursorName;
    let cursor;
    if (strategyName) {
      cursorName = `${toolName}.${strategyName}`;
      cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);
      if (cursor) {
        return cursor;
      }
    }
    cursorName = `${toolName}`;
    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);
    if (cursor) {
      return cursor;
    }
    cursorName = toolName;
    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);
    if (cursor) {
      return cursor;
    }
    return MouseCursor.getDefinedCursor("default");
  }
  _setCursorForViewports(cursor) {
    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
      const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);
      if (!enabledElement) {
        return;
      }
      const { viewport } = enabledElement;
      initElementCursor(viewport.element, cursor);
    });
  }
  setToolConfiguration(toolName, configuration3, overwrite) {
    const toolInstance = this._toolInstances[toolName];
    if (toolInstance === void 0) {
      console.warn(`Tool ${toolName} not present, can't set tool configuration.`);
      return false;
    }
    let _configuration;
    if (overwrite) {
      _configuration = configuration3;
    } else {
      _configuration = Object.assign(toolInstance.configuration, configuration3);
    }
    toolInstance.configuration = _configuration;
    if (typeof toolInstance.onSetToolConfiguration === "function") {
      toolInstance.onSetToolConfiguration();
    }
    this._renderViewports();
    return true;
  }
  getDefaultMousePrimary() {
    return MouseBindings.Primary;
  }
  getDefaultPrimaryBindings() {
    return PRIMARY_BINDINGS;
  }
  getToolConfiguration(toolName, configurationPath) {
    if (this._toolInstances[toolName] === void 0) {
      console.warn(`Tool ${toolName} not present, can't set tool configuration.`);
      return;
    }
    const _configuration = (0, import_lodash.default)(this._toolInstances[toolName].configuration, configurationPath) || this._toolInstances[toolName].configuration;
    return utilities_exports.deepClone(_configuration);
  }
  getPrevActivePrimaryToolName() {
    return this.prevActivePrimaryToolName;
  }
  setActivePrimaryTool(toolName) {
    const activeToolName = this.getCurrentActivePrimaryToolName();
    this.setToolDisabled(activeToolName);
    this.setToolActive(toolName, {
      bindings: [{ mouseButton: MouseBindings.Primary }]
    });
  }
  getCurrentActivePrimaryToolName() {
    return this.currentActivePrimaryToolName;
  }
  clone(newToolGroupId, fnToolFilter = null) {
    let toolGroup = getToolGroup_default(newToolGroupId);
    if (toolGroup) {
      console.debug(`ToolGroup ${newToolGroupId} already exists`);
      return toolGroup;
    }
    toolGroup = new _ToolGroup(newToolGroupId);
    state.toolGroups.push(toolGroup);
    fnToolFilter = fnToolFilter ?? (() => true);
    Object.keys(this._toolInstances).filter(fnToolFilter).forEach((toolName) => {
      const sourceToolInstance = this._toolInstances[toolName];
      const sourceToolOptions = this.toolOptions[toolName];
      const sourceToolMode = sourceToolInstance.mode;
      toolGroup.addTool(toolName);
      toolGroup.setToolMode(toolName, sourceToolMode, {
        bindings: sourceToolOptions.bindings ?? []
      });
    });
    return toolGroup;
  }
  _hasMousePrimaryButtonBinding(toolOptions) {
    var _a2;
    const primaryBindings = this.getDefaultPrimaryBindings();
    return (_a2 = toolOptions == null ? void 0 : toolOptions.bindings) == null ? void 0 : _a2.some((binding) => primaryBindings.some((primary) => hasSameBinding(binding, primary)));
  }
  _renderViewports() {
    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
      getRenderingEngine(renderingEngineId).renderViewport(viewportId);
    });
  }
  _triggerToolModeChangedEvent(toolName, mode, toolBindingsOptions) {
    const eventDetail = {
      toolGroupId: this.id,
      toolName,
      mode,
      toolBindingsOptions
    };
    triggerEvent(eventTarget_default, Events_default.TOOL_MODE_CHANGED, eventDetail);
  }
  _findRenderingEngine(viewportId, renderingEngineId) {
    const renderingEngines = getRenderingEngines();
    if ((renderingEngines == null ? void 0 : renderingEngines.length) === 0) {
      throw new Error("No rendering engines found.");
    }
    if (renderingEngineId) {
      return renderingEngineId;
    }
    const matchingEngines = renderingEngines.filter((engine) => engine.getViewport(viewportId));
    if (matchingEngines.length === 0) {
      if (renderingEngines.length === 1) {
        return renderingEngines[0].id;
      }
      throw new Error("No rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.");
    }
    if (matchingEngines.length > 1) {
      throw new Error("Multiple rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.");
    }
    return matchingEngines[0].id;
  }
};
function hasSameBinding(binding1, binding2) {
  if (binding1.mouseButton !== binding2.mouseButton) {
    return false;
  }
  if (binding1.numTouchPoints !== binding2.numTouchPoints) {
    return false;
  }
  return binding1.modifierKey === binding2.modifierKey;
}

// node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/createToolGroup.js
function createToolGroup(toolGroupId) {
  const toolGroupWithIdExists = state.toolGroups.some((tg) => tg.id === toolGroupId);
  if (toolGroupWithIdExists) {
    console.warn(`'${toolGroupId}' already exists.`);
    return;
  }
  const toolGroup = new ToolGroup(toolGroupId);
  state.toolGroups.push(toolGroup);
  return toolGroup;
}
var createToolGroup_default = createToolGroup;

// node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js
function destroyToolGroup(toolGroupId) {
  const toolGroupIndex = state.toolGroups.findIndex((tg) => tg.id === toolGroupId);
  if (toolGroupIndex > -1) {
    state.toolGroups.splice(toolGroupIndex, 1);
  }
}
var destroyToolGroup_default = destroyToolGroup;

// node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroy.js
function destroy() {
  const toolGroups = [...state.toolGroups];
  for (const toolGroup of toolGroups) {
    destroyToolGroup_default(toolGroup.id);
  }
  state.toolGroups = [];
}
var destroy_default = destroy;

// node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js
function getToolGroupForViewport(viewportId, renderingEngineId) {
  var _a2;
  if (!renderingEngineId) {
    renderingEngineId = (_a2 = getRenderingEngines().find((re) => re.getViewports().find((vp) => vp.id === viewportId))) == null ? void 0 : _a2.id;
  }
  const toolGroupFilteredByIds = state.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId && (!vp.viewportId || vp.viewportId === viewportId)));
  if (!toolGroupFilteredByIds.length) {
    return;
  }
  if (toolGroupFilteredByIds.length > 1) {
    throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only
      have one tool group per viewport in a renderingEngine.`);
  }
  return toolGroupFilteredByIds[0];
}
var getToolGroupForViewport_default = getToolGroupForViewport;

// node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js
function getAllToolGroups() {
  return state.toolGroups;
}
var getAllToolGroups_default = getAllToolGroups;

// node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js
var MODES = [ToolModes_default.Active, ToolModes_default.Passive, ToolModes_default.Enabled];
function getToolGroupsWithToolName(toolName) {
  return state.toolGroups.filter(({ toolOptions }) => {
    const toolGroupToolNames = Object.keys(toolOptions);
    for (let i = 0; i < toolGroupToolNames.length; i++) {
      if (toolName !== toolGroupToolNames[i]) {
        continue;
      }
      if (!toolOptions[toolName]) {
        continue;
      }
      if (MODES.includes(toolOptions[toolName].mode)) {
        return true;
      }
    }
    return false;
  });
}
var getToolGroupsWithToolName_default = getToolGroupsWithToolName;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js
function triggerAnnotationAddedForElement(annotation, element) {
  const enabledElement = getEnabledElement(element);
  const { renderingEngine, viewportId } = enabledElement;
  const eventType = Events_default.ANNOTATION_ADDED;
  const eventDetail = {
    annotation,
    viewportId,
    renderingEngineId: renderingEngine.id
  };
  triggerEvent(eventTarget_default, eventType, eventDetail);
}
function triggerAnnotationAddedForFOR(annotation) {
  const { toolName } = annotation.metadata;
  const toolGroups = getToolGroupsWithToolName_default(toolName);
  if (!toolGroups.length) {
    return;
  }
  const viewportsToRender = [];
  toolGroups.forEach((toolGroup) => {
    toolGroup.viewportsInfo.forEach((viewportInfo) => {
      const { renderingEngineId, viewportId } = viewportInfo;
      const { FrameOfReferenceUID } = getEnabledElementByIds(viewportId, renderingEngineId);
      if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {
        viewportsToRender.push(viewportInfo);
      }
    });
  });
  const eventType = Events_default.ANNOTATION_ADDED;
  const eventDetail = { annotation };
  if (!viewportsToRender.length) {
    triggerEvent(eventTarget_default, eventType, eventDetail);
    return;
  }
  viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {
    eventDetail.viewportId = viewportId;
    eventDetail.renderingEngineId = renderingEngineId;
    triggerEvent(eventTarget_default, eventType, eventDetail);
  });
}
function triggerAnnotationRemoved(eventDetail) {
  const eventType = Events_default.ANNOTATION_REMOVED;
  triggerEvent(eventTarget_default, eventType, eventDetail);
}
function triggerAnnotationModified(annotation, element, changeType = ChangeTypes_default.HandlesUpdated) {
  const enabledElement = getEnabledElement(element);
  const { viewportId, renderingEngineId } = enabledElement;
  const eventType = Events_default.ANNOTATION_MODIFIED;
  const eventDetail = {
    annotation,
    viewportId,
    renderingEngineId,
    changeType
  };
  triggerEvent(eventTarget_default, eventType, eventDetail);
}
function triggerAnnotationCompleted(annotation) {
  const eventDetail = {
    annotation
  };
  _triggerAnnotationCompleted(eventDetail);
}
function triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled = false) {
  const eventDetail = {
    annotation,
    contourHoleProcessingEnabled
  };
  _triggerAnnotationCompleted(eventDetail);
}
function _triggerAnnotationCompleted(eventDetail) {
  const eventType = Events_default.ANNOTATION_COMPLETED;
  triggerEvent(eventTarget_default, eventType, eventDetail);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js
var defaultManager;
function getAnnotationManager() {
  return defaultManager;
}
function setAnnotationManager(annotationManager) {
  defaultManager = annotationManager;
}
function getAnnotations(toolName, annotationGroupSelector) {
  const manager = getAnnotationManager();
  const groupKey = manager.getGroupKey(annotationGroupSelector);
  return manager.getAnnotations(groupKey, toolName);
}
function getAnnotation(annotationUID) {
  const manager = getAnnotationManager();
  return manager.getAnnotation(annotationUID);
}
function getAllAnnotations() {
  const manager = getAnnotationManager();
  return manager.getAllAnnotations();
}
function clearParentAnnotation(annotation) {
  const { annotationUID: childUID, parentAnnotationUID } = annotation;
  if (!parentAnnotationUID) {
    return;
  }
  const parentAnnotation = getAnnotation(parentAnnotationUID);
  const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);
  parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);
  annotation.parentAnnotationUID = void 0;
}
function addChildAnnotation(parentAnnotation, childAnnotation) {
  const { annotationUID: parentUID } = parentAnnotation;
  const { annotationUID: childUID } = childAnnotation;
  clearParentAnnotation(childAnnotation);
  if (!parentAnnotation.childAnnotationUIDs) {
    parentAnnotation.childAnnotationUIDs = [];
  }
  if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {
    return;
  }
  parentAnnotation.childAnnotationUIDs.push(childUID);
  childAnnotation.parentAnnotationUID = parentUID;
}
function getParentAnnotation(annotation) {
  return annotation.parentAnnotationUID ? getAnnotation(annotation.parentAnnotationUID) : void 0;
}
function getChildAnnotations(annotation) {
  var _a2;
  return ((_a2 = annotation.childAnnotationUIDs) == null ? void 0 : _a2.map((childAnnotationUID) => getAnnotation(childAnnotationUID))) ?? [];
}
function addAnnotation(annotation, annotationGroupSelector) {
  if (!annotation.annotationUID) {
    annotation.annotationUID = utilities_exports.uuidv4();
  }
  const manager = getAnnotationManager();
  if (annotationGroupSelector instanceof HTMLDivElement) {
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    manager.addAnnotation(annotation, groupKey);
    triggerAnnotationAddedForElement(annotation, annotationGroupSelector);
  } else {
    manager.addAnnotation(annotation, void 0);
    triggerAnnotationAddedForFOR(annotation);
  }
  return annotation.annotationUID;
}
function getNumberOfAnnotations(toolName, annotationGroupSelector) {
  const manager = getAnnotationManager();
  const groupKey = manager.getGroupKey(annotationGroupSelector);
  return manager.getNumberOfAnnotations(groupKey, toolName);
}
function removeAnnotation(annotationUID) {
  var _a2;
  if (!annotationUID) {
    return;
  }
  const manager = getAnnotationManager();
  const annotation = manager.getAnnotation(annotationUID);
  if (!annotation) {
    return;
  }
  (_a2 = annotation.childAnnotationUIDs) == null ? void 0 : _a2.forEach((childAnnotationUID) => removeAnnotation(childAnnotationUID));
  manager.removeAnnotation(annotationUID);
  triggerAnnotationRemoved({ annotation, annotationManagerUID: manager.uid });
}
function removeAllAnnotations() {
  const manager = getAnnotationManager();
  const removedAnnotations = manager.removeAllAnnotations();
  for (const annotation of removedAnnotations) {
    triggerAnnotationRemoved({
      annotation,
      annotationManagerUID: manager.uid
    });
  }
}
function removeAnnotations(toolName, annotationGroupSelector) {
  const manager = getAnnotationManager();
  const groupKey = manager.getGroupKey(annotationGroupSelector);
  const removedAnnotations = manager.removeAnnotations(groupKey, toolName);
  for (const annotation of removedAnnotations) {
    triggerAnnotationRemoved({
      annotation,
      annotationManagerUID: manager.uid
    });
  }
}
function invalidateAnnotation(annotation) {
  let currAnnotation = annotation;
  while (currAnnotation) {
    currAnnotation.invalidated = true;
    currAnnotation = currAnnotation.parentAnnotationUID ? getAnnotation(currAnnotation.parentAnnotationUID) : void 0;
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js
function addTool(ToolClass) {
  const toolName = ToolClass.toolName;
  const toolAlreadyAdded = state.tools[toolName] !== void 0;
  if (!toolName) {
    throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);
  }
  state.tools[toolName] = {
    toolClass: ToolClass
  };
}
function hasToolByName(toolName) {
  return !!(toolName && state.tools[toolName]);
}
function removeTool(ToolClass) {
  const toolName = ToolClass.toolName;
  if (!toolName) {
    throw new Error(`No tool found for: ${ToolClass.name}`);
  }
  if (!state.tools[toolName] !== void 0) {
    delete state.tools[toolName];
  } else {
    throw new Error(`${toolName} cannot be removed because it has not been added`);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/getMouseEventPoints.js
function getMouseEventPoints(evt, element) {
  const elementToUse = element || evt.currentTarget;
  const { viewport } = getEnabledElement(elementToUse) || {};
  if (!viewport) {
    return;
  }
  const clientPoint = _clientToPoint(evt);
  const pagePoint = _pageToPoint(evt);
  const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);
  const worldPoint = viewport.canvasToWorld(canvasPoint);
  return {
    page: pagePoint,
    client: clientPoint,
    canvas: canvasPoint,
    world: worldPoint
  };
}
function _pagePointsToCanvasPoints(element, pagePoint) {
  const rect = element.getBoundingClientRect();
  return [
    pagePoint[0] - rect.left - window.pageXOffset,
    pagePoint[1] - rect.top - window.pageYOffset
  ];
}
function _pageToPoint(evt) {
  return [evt.pageX, evt.pageY];
}
function _clientToPoint(evt) {
  return [evt.clientX, evt.clientY];
}

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDoubleClickListener.js
function mouseDoubleClickListener(evt) {
  const element = evt.currentTarget;
  const { viewportId, renderingEngineId } = getEnabledElement(element);
  const startPoints = getMouseEventPoints(evt, element);
  const deltaPoints = {
    page: [0, 0],
    client: [0, 0],
    canvas: [0, 0],
    world: [0, 0, 0]
  };
  const eventDetail = {
    event: evt,
    eventName: Events_default.MOUSE_DOUBLE_CLICK,
    viewportId,
    renderingEngineId,
    camera: {},
    element,
    startPoints,
    lastPoints: startPoints,
    currentPoints: startPoints,
    deltaPoints
  };
  const consumed = !triggerEvent(element, Events_default.MOUSE_DOUBLE_CLICK, eventDetail);
  if (consumed) {
    evt.stopImmediatePropagation();
    evt.preventDefault();
  }
}
var mouseDoubleClickListener_default = mouseDoubleClickListener;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseMoveListener.js
var eventName = Events_default.MOUSE_MOVE;
function mouseMoveListener(evt) {
  const element = evt.currentTarget;
  const enabledElement = getEnabledElement(element);
  if (!enabledElement) {
    return;
  }
  const { renderingEngineId, viewportId } = enabledElement;
  const currentPoints = getMouseEventPoints(evt);
  const eventDetail = {
    renderingEngineId,
    viewportId,
    camera: {},
    element,
    currentPoints,
    eventName,
    event: evt
  };
  const consumed = !triggerEvent(element, eventName, eventDetail);
  if (consumed) {
    evt.stopImmediatePropagation();
    evt.preventDefault();
  }
}
var mouseMoveListener_default = mouseMoveListener;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDownListener.js
var { MOUSE_DOWN, MOUSE_DOWN_ACTIVATE, MOUSE_CLICK, MOUSE_UP, MOUSE_DRAG } = Events_default;
var DOUBLE_CLICK_TOLERANCE_MS = 400;
var MULTI_BUTTON_TOLERANCE_MS = 150;
var DOUBLE_CLICK_DRAG_TOLERANCE = 3;
var defaultState2 = {
  mouseButton: void 0,
  element: null,
  renderingEngineId: void 0,
  viewportId: void 0,
  isClickEvent: true,
  clickDelay: 200,
  preventClickTimeout: null,
  startPoints: {
    page: [0, 0],
    client: [0, 0],
    canvas: [0, 0],
    world: [0, 0, 0]
  },
  lastPoints: {
    page: [0, 0],
    client: [0, 0],
    canvas: [0, 0],
    world: [0, 0, 0]
  }
};
var state2 = {
  mouseButton: void 0,
  renderingEngineId: void 0,
  viewportId: void 0,
  isClickEvent: true,
  clickDelay: 200,
  element: null,
  preventClickTimeout: null,
  startPoints: {
    page: [0, 0],
    client: [0, 0],
    canvas: [0, 0],
    world: [0, 0, 0]
  },
  lastPoints: {
    page: [0, 0],
    client: [0, 0],
    canvas: [0, 0],
    world: [0, 0, 0]
  }
};
var doubleClickState = {
  doubleClickTimeout: null,
  mouseDownEvent: null,
  mouseUpEvent: null,
  ignoreDoubleClick: false
};
function mouseDownListener(evt) {
  if (doubleClickState.doubleClickTimeout) {
    if (evt.buttons === doubleClickState.mouseDownEvent.buttons) {
      return;
    }
    doubleClickState.mouseDownEvent = evt;
    _doStateMouseDownAndUp();
    return;
  }
  doubleClickState.doubleClickTimeout = setTimeout(_doStateMouseDownAndUp, evt.buttons === 1 ? DOUBLE_CLICK_TOLERANCE_MS : MULTI_BUTTON_TOLERANCE_MS);
  doubleClickState.mouseDownEvent = evt;
  doubleClickState.ignoreDoubleClick = false;
  state2.element = evt.currentTarget;
  state2.mouseButton = evt.buttons;
  const enabledElement = getEnabledElement(state2.element);
  const { renderingEngineId, viewportId } = enabledElement;
  state2.renderingEngineId = renderingEngineId;
  state2.viewportId = viewportId;
  state2.preventClickTimeout = setTimeout(_preventClickHandler, state2.clickDelay);
  state2.element.removeEventListener("mousemove", mouseMoveListener_default);
  const startPoints = getMouseEventPoints(evt, state2.element);
  state2.startPoints = _copyPoints(startPoints);
  state2.lastPoints = _copyPoints(startPoints);
  document.addEventListener("mouseup", _onMouseUp);
  document.addEventListener("mousemove", _onMouseDrag);
}
function _doMouseDown(evt) {
  const deltaPoints = _getDeltaPoints(state2.startPoints, state2.startPoints);
  const eventDetail = {
    event: evt,
    eventName: MOUSE_DOWN,
    element: state2.element,
    mouseButton: state2.mouseButton,
    renderingEngineId: state2.renderingEngineId,
    viewportId: state2.viewportId,
    camera: {},
    startPoints: state2.startPoints,
    lastPoints: state2.startPoints,
    currentPoints: state2.startPoints,
    deltaPoints
  };
  state2.lastPoints = _copyPoints(eventDetail.lastPoints);
  const notConsumed = triggerEvent(eventDetail.element, MOUSE_DOWN, eventDetail);
  if (notConsumed) {
    triggerEvent(eventDetail.element, MOUSE_DOWN_ACTIVATE, eventDetail);
  }
}
function _onMouseDrag(evt) {
  const enabledElement = getEnabledElement(state2.element);
  if (!(enabledElement == null ? void 0 : enabledElement.viewport)) {
    return;
  }
  const currentPoints = getMouseEventPoints(evt, state2.element);
  const lastPoints = _updateMouseEventsLastPoints(state2.element, state2.lastPoints);
  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);
  if (doubleClickState.doubleClickTimeout) {
    if (_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {
      _doStateMouseDownAndUp();
    } else {
      return;
    }
  }
  const eventDetail = {
    event: evt,
    eventName: MOUSE_DRAG,
    mouseButton: state2.mouseButton,
    renderingEngineId: state2.renderingEngineId,
    viewportId: state2.viewportId,
    camera: {},
    element: state2.element,
    startPoints: _copyPoints(state2.startPoints),
    lastPoints: _copyPoints(lastPoints),
    currentPoints,
    deltaPoints
  };
  const consumed = !triggerEvent(state2.element, MOUSE_DRAG, eventDetail);
  if (consumed) {
    evt.stopImmediatePropagation();
    evt.preventDefault();
  }
  state2.lastPoints = _copyPoints(currentPoints);
}
function _onMouseUp(evt) {
  clearTimeout(state2.preventClickTimeout);
  if (doubleClickState.doubleClickTimeout) {
    if (!doubleClickState.mouseUpEvent) {
      doubleClickState.mouseUpEvent = evt;
      state2.element.addEventListener("mousemove", _onMouseMove);
    } else {
      _cleanUp();
    }
  } else {
    const eventName2 = state2.isClickEvent ? MOUSE_CLICK : MOUSE_UP;
    const currentPoints = getMouseEventPoints(evt, state2.element);
    const deltaPoints = _getDeltaPoints(currentPoints, state2.lastPoints);
    const eventDetail = {
      event: evt,
      eventName: eventName2,
      mouseButton: state2.mouseButton,
      element: state2.element,
      renderingEngineId: state2.renderingEngineId,
      viewportId: state2.viewportId,
      camera: {},
      startPoints: _copyPoints(state2.startPoints),
      lastPoints: _copyPoints(state2.lastPoints),
      currentPoints,
      deltaPoints
    };
    triggerEvent(eventDetail.element, eventName2, eventDetail);
    _cleanUp();
  }
  document.removeEventListener("mousemove", _onMouseDrag);
}
function _onMouseMove(evt) {
  const currentPoints = getMouseEventPoints(evt, state2.element);
  const lastPoints = _updateMouseEventsLastPoints(state2.element, state2.lastPoints);
  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);
  if (!_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {
    return;
  }
  _doStateMouseDownAndUp();
  mouseMoveListener_default(evt);
}
function _isDragPastDoubleClickTolerance(delta) {
  return Math.abs(delta[0]) + Math.abs(delta[1]) > DOUBLE_CLICK_DRAG_TOLERANCE;
}
function _preventClickHandler() {
  state2.isClickEvent = false;
}
function _doStateMouseDownAndUp() {
  doubleClickState.ignoreDoubleClick = true;
  const mouseDownEvent = doubleClickState.mouseDownEvent;
  const mouseUpEvent = doubleClickState.mouseUpEvent;
  _clearDoubleClickTimeoutAndEvents();
  _doMouseDown(mouseDownEvent);
  if (mouseUpEvent) {
    _onMouseUp(mouseUpEvent);
  }
}
function _clearDoubleClickTimeoutAndEvents() {
  if (doubleClickState.doubleClickTimeout) {
    clearTimeout(doubleClickState.doubleClickTimeout);
    doubleClickState.doubleClickTimeout = null;
  }
  doubleClickState.mouseDownEvent = null;
  doubleClickState.mouseUpEvent = null;
}
function _cleanUp() {
  var _a2, _b2;
  document.removeEventListener("mouseup", _onMouseUp);
  (_a2 = state2.element) == null ? void 0 : _a2.removeEventListener("mousemove", _onMouseMove);
  (_b2 = state2.element) == null ? void 0 : _b2.addEventListener("mousemove", mouseMoveListener_default);
  _clearDoubleClickTimeoutAndEvents();
  state2 = JSON.parse(JSON.stringify(defaultState2));
}
function _copyPoints(points) {
  return JSON.parse(JSON.stringify(points));
}
function _updateMouseEventsLastPoints(element, lastPoints) {
  const { viewport } = getEnabledElement(element) || {};
  if (!viewport) {
    return lastPoints;
  }
  const world = viewport.canvasToWorld(lastPoints.canvas);
  return {
    page: lastPoints.page,
    client: lastPoints.client,
    canvas: lastPoints.canvas,
    world
  };
}
function _getDeltaPoints(currentPoints, lastPoints) {
  if (!currentPoints || !lastPoints) {
    return {
      page: [0, 0],
      client: [0, 0],
      canvas: [0, 0],
      world: [0, 0, 0]
    };
  }
  return {
    page: _subtractPoints2D(currentPoints.page, lastPoints.page),
    client: _subtractPoints2D(currentPoints.client, lastPoints.client),
    canvas: _subtractPoints2D(currentPoints.canvas, lastPoints.canvas),
    world: _subtractPoints3D(currentPoints.world, lastPoints.world)
  };
}
function _subtractPoints2D(point0, point1) {
  return [point0[0] - point1[0], point0[1] - point1[1]];
}
function _subtractPoints3D(point0, point1) {
  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];
}
function getMouseButton() {
  return state2.mouseButton;
}
function mouseDoubleClickIgnoreListener(evt) {
  if (doubleClickState.ignoreDoubleClick) {
    doubleClickState.ignoreDoubleClick = false;
    evt.stopImmediatePropagation();
    evt.preventDefault();
  } else {
    _cleanUp();
  }
}
var mouseDownListener_default = mouseDownListener;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/index.js
function disable(element) {
  element.removeEventListener("dblclick", mouseDoubleClickListener_default);
  element.removeEventListener("mousedown", mouseDownListener_default);
  element.removeEventListener("mousemove", mouseMoveListener_default);
  element.removeEventListener("dblclick", mouseDoubleClickIgnoreListener, {
    capture: true
  });
}
function enable(element) {
  disable(element);
  element.addEventListener("dblclick", mouseDoubleClickListener_default);
  element.addEventListener("mousedown", mouseDownListener_default);
  element.addEventListener("mousemove", mouseMoveListener_default);
  element.addEventListener("dblclick", mouseDoubleClickIgnoreListener, {
    capture: true
  });
}
var mouse_default = {
  enable,
  disable
};

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/preventGhostClick.js
var antiGhostDelay = 2e3;
var pointerType = {
  mouse: 0,
  touch: 1
};
var lastInteractionType;
var lastInteractionTime;
function handleTap(type, e) {
  const now = Date.now();
  if (type !== lastInteractionType) {
    if (now - lastInteractionTime <= antiGhostDelay) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      return false;
    }
    lastInteractionType = type;
  }
  lastInteractionTime = now;
}
var handleTapMouse = handleTap.bind(null, pointerType.mouse);
var handleTapTouch = handleTap.bind(null, pointerType.touch);
function attachEvents(element, eventList, interactionType) {
  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;
  eventList.forEach(function(eventName2) {
    element.addEventListener(eventName2, tapHandler, { passive: false });
  });
}
function removeEvents(element, eventList, interactionType) {
  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;
  eventList.forEach(function(eventName2) {
    element.removeEventListener(eventName2, tapHandler);
  });
}
var mouseEvents = ["mousedown", "mouseup", "mousemove"];
var touchEvents = ["touchstart", "touchend"];
function disable2(element) {
  removeEvents(element, mouseEvents, pointerType.mouse);
  removeEvents(element, touchEvents, pointerType.touch);
}
function enable2(element) {
  disable2(element);
  attachEvents(element, mouseEvents, pointerType.mouse);
  attachEvents(element, touchEvents, pointerType.touch);
}
var preventGhostClick_default = {
  enable: enable2,
  disable: disable2
};

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/getTouchEventPoints.js
function getTouchEventPoints(evt, element) {
  const elementToUse = element || evt.currentTarget;
  const touches = evt.type === "touchend" ? evt.changedTouches : evt.touches;
  return Object.keys(touches).map((i) => {
    const clientPoint = _clientToPoint2(touches[i]);
    const pagePoint = _pageToPoint2(touches[i]);
    const canvasPoint = _pagePointsToCanvasPoints2(elementToUse, pagePoint);
    const { viewport } = getEnabledElement(elementToUse);
    const worldPoint = viewport.canvasToWorld(canvasPoint);
    return {
      page: pagePoint,
      client: clientPoint,
      canvas: canvasPoint,
      world: worldPoint,
      touch: {
        identifier: i,
        radiusX: touches[i].radiusX,
        radiusY: touches[i].radiusY,
        force: touches[i].force,
        rotationAngle: touches[i].rotationAngle
      }
    };
  });
}
function _pagePointsToCanvasPoints2(element, pagePoint) {
  const rect = element.getBoundingClientRect();
  return [
    pagePoint[0] - rect.left - window.pageXOffset,
    pagePoint[1] - rect.top - window.pageYOffset
  ];
}
function _pageToPoint2(touch) {
  return [touch.pageX, touch.pageY];
}
function _clientToPoint2(touch) {
  return [touch.clientX, touch.clientY];
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js
var touch_exports = {};
__export(touch_exports, {
  copyPoints: () => copyPoints,
  copyPointsList: () => copyPointsList,
  getDeltaDistance: () => getDeltaDistance,
  getDeltaDistanceBetweenIPoints: () => getDeltaDistanceBetweenIPoints,
  getDeltaPoints: () => getDeltaPoints,
  getDeltaRotation: () => getDeltaRotation,
  getMeanPoints: () => getMeanPoints,
  getMeanTouchPoints: () => getMeanTouchPoints
});
function getDeltaPoints(currentPoints, lastPoints) {
  const curr = getMeanPoints(currentPoints);
  const last = getMeanPoints(lastPoints);
  return {
    page: _subtractPoints2D2(curr.page, last.page),
    client: _subtractPoints2D2(curr.client, last.client),
    canvas: _subtractPoints2D2(curr.canvas, last.canvas),
    world: _subtractPoints3D2(curr.world, last.world)
  };
}
function getDeltaDistance(currentPoints, lastPoints) {
  const curr = getMeanPoints(currentPoints);
  const last = getMeanPoints(lastPoints);
  return {
    page: _getDistance2D(curr.page, last.page),
    client: _getDistance2D(curr.client, last.client),
    canvas: _getDistance2D(curr.canvas, last.canvas),
    world: _getDistance3D(curr.world, last.world)
  };
}
function getDeltaRotation(currentPoints, lastPoints) {
}
function getDeltaDistanceBetweenIPoints(currentPoints, lastPoints) {
  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);
  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);
  const deltaDistance = {
    page: currentDistance.page - lastDistance.page,
    client: currentDistance.client - lastDistance.client,
    canvas: currentDistance.canvas - lastDistance.canvas,
    world: currentDistance.world - lastDistance.world
  };
  return deltaDistance;
}
function copyPointsList(points) {
  return JSON.parse(JSON.stringify(points));
}
function copyPoints(points) {
  return JSON.parse(JSON.stringify(points));
}
function getMeanPoints(points) {
  return points.reduce((prev, curr) => {
    return {
      page: [
        prev.page[0] + curr.page[0] / points.length,
        prev.page[1] + curr.page[1] / points.length
      ],
      client: [
        prev.client[0] + curr.client[0] / points.length,
        prev.client[1] + curr.client[1] / points.length
      ],
      canvas: [
        prev.canvas[0] + curr.canvas[0] / points.length,
        prev.canvas[1] + curr.canvas[1] / points.length
      ],
      world: [
        prev.world[0] + curr.world[0] / points.length,
        prev.world[1] + curr.world[1] / points.length,
        prev.world[2] + curr.world[2] / points.length
      ]
    };
  }, {
    page: [0, 0],
    client: [0, 0],
    canvas: [0, 0],
    world: [0, 0, 0]
  });
}
function getMeanTouchPoints(points) {
  return points.reduce((prev, curr) => {
    return {
      page: [
        prev.page[0] + curr.page[0] / points.length,
        prev.page[1] + curr.page[1] / points.length
      ],
      client: [
        prev.client[0] + curr.client[0] / points.length,
        prev.client[1] + curr.client[1] / points.length
      ],
      canvas: [
        prev.canvas[0] + curr.canvas[0] / points.length,
        prev.canvas[1] + curr.canvas[1] / points.length
      ],
      world: [
        prev.world[0] + curr.world[0] / points.length,
        prev.world[1] + curr.world[1] / points.length,
        prev.world[2] + curr.world[2] / points.length
      ],
      touch: {
        identifier: null,
        radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,
        radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,
        force: prev.touch.force + curr.touch.force / points.length,
        rotationAngle: prev.touch.rotationAngle + curr.touch.rotationAngle / points.length
      }
    };
  }, {
    page: [0, 0],
    client: [0, 0],
    canvas: [0, 0],
    world: [0, 0, 0],
    touch: {
      identifier: null,
      radiusX: 0,
      radiusY: 0,
      force: 0,
      rotationAngle: 0
    }
  });
}
function _subtractPoints2D2(point0, point1) {
  return [point0[0] - point1[0], point0[1] - point1[1]];
}
function _subtractPoints3D2(point0, point1) {
  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];
}
function _getMeanDistanceBetweenAllIPoints(points) {
  const pairedDistance = [];
  for (let i = 0; i < points.length; i++) {
    for (let j = 0; j < points.length; j++) {
      if (i < j) {
        pairedDistance.push({
          page: _getDistance2D(points[i].page, points[j].page),
          client: _getDistance2D(points[i].client, points[j].client),
          canvas: _getDistance2D(points[i].canvas, points[j].canvas),
          world: _getDistance3D(points[i].world, points[j].world)
        });
      }
    }
  }
  return pairedDistance.reduce((prev, curr) => {
    return {
      page: prev.page + curr.page / pairedDistance.length,
      client: prev.client + curr.client / pairedDistance.length,
      canvas: prev.canvas + curr.canvas / pairedDistance.length,
      world: prev.world + curr.world / pairedDistance.length
    };
  }, {
    page: 0,
    client: 0,
    canvas: 0,
    world: 0
  });
}
function _getDistance2D(point0, point1) {
  return Math.sqrt(Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2));
}
function _getDistance3D(point0, point1) {
  return Math.sqrt(Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2) + Math.pow(point0[2] - point1[2], 2));
}

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/touchStartListener.js
var runtimeSettings = Settings.getRuntimeSettings();
var { TOUCH_START, TOUCH_START_ACTIVATE, TOUCH_PRESS, TOUCH_DRAG, TOUCH_END, TOUCH_TAP, TOUCH_SWIPE } = Events_default;
var zeroIPoint = {
  page: [0, 0],
  client: [0, 0],
  canvas: [0, 0],
  world: [0, 0, 0]
};
var zeroIDistance = {
  page: 0,
  client: 0,
  canvas: 0,
  world: 0
};
var defaultState3 = {
  renderingEngineId: void 0,
  viewportId: void 0,
  element: null,
  startPointsList: [
    {
      ...zeroIPoint,
      touch: null
    }
  ],
  lastPointsList: [
    {
      ...zeroIPoint,
      touch: null
    }
  ],
  isTouchStart: false,
  startTime: null,
  pressTimeout: null,
  pressDelay: 700,
  pressMaxDistance: 5,
  accumulatedDistance: zeroIDistance,
  swipeDistanceThreshold: 48,
  swiped: false,
  swipeToleranceMs: 300
};
var defaultTapState = {
  renderingEngineId: void 0,
  viewportId: void 0,
  element: null,
  startPointsList: [
    {
      ...zeroIPoint,
      touch: null
    }
  ],
  taps: 0,
  tapTimeout: null,
  tapMaxDistance: 24,
  tapToleranceMs: 300
};
var state3 = JSON.parse(JSON.stringify(defaultState3));
var tapState = JSON.parse(JSON.stringify(defaultTapState));
function triggerEventCallback(ele, name, eventDetail) {
  return triggerEvent(ele, name, eventDetail);
}
function touchStartListener(evt) {
  state3.element = evt.currentTarget;
  const enabledElement = getEnabledElement(state3.element);
  const { renderingEngineId, viewportId } = enabledElement;
  state3.renderingEngineId = renderingEngineId;
  state3.viewportId = viewportId;
  if (state3.isTouchStart) {
    return;
  }
  clearTimeout(state3.pressTimeout);
  state3.pressTimeout = setTimeout(() => _onTouchPress(evt), state3.pressDelay);
  _onTouchStart(evt);
  document.addEventListener("touchmove", _onTouchDrag);
  document.addEventListener("touchend", _onTouchEnd);
}
function _onTouchPress(evt) {
  const totalDistance = state3.accumulatedDistance.canvas;
  if (totalDistance > state3.pressMaxDistance) {
    return;
  }
  const eventDetail = {
    event: evt,
    eventName: TOUCH_PRESS,
    renderingEngineId: state3.renderingEngineId,
    viewportId: state3.viewportId,
    camera: {},
    element: state3.element,
    startPointsList: copyPointsList(state3.startPointsList),
    lastPointsList: copyPointsList(state3.lastPointsList),
    startPoints: copyPoints(getMeanTouchPoints(state3.startPointsList)),
    lastPoints: copyPoints(getMeanTouchPoints(state3.lastPointsList))
  };
  triggerEventCallback(eventDetail.element, TOUCH_PRESS, eventDetail);
}
function _onTouchStart(evt) {
  state3.isTouchStart = true;
  state3.startTime = /* @__PURE__ */ new Date();
  const startPointsList = getTouchEventPoints(evt, state3.element);
  const startPoints = getMeanTouchPoints(startPointsList);
  const deltaPoints = zeroIPoint;
  const deltaDistance = zeroIDistance;
  const eventDetail = {
    event: evt,
    eventName: TOUCH_START,
    element: state3.element,
    renderingEngineId: state3.renderingEngineId,
    viewportId: state3.viewportId,
    camera: {},
    startPointsList,
    lastPointsList: startPointsList,
    currentPointsList: startPointsList,
    startPoints,
    lastPoints: startPoints,
    currentPoints: startPoints,
    deltaPoints,
    deltaDistance
  };
  state3.startPointsList = copyPointsList(eventDetail.startPointsList);
  state3.lastPointsList = copyPointsList(eventDetail.lastPointsList);
  const eventDidPropagate = triggerEventCallback(eventDetail.element, TOUCH_START, eventDetail);
  if (eventDidPropagate) {
    triggerEventCallback(eventDetail.element, TOUCH_START_ACTIVATE, eventDetail);
  }
}
function _onTouchDrag(evt) {
  const currentPointsList = getTouchEventPoints(evt, state3.element);
  const lastPointsList = _updateTouchEventsLastPoints(state3.element, state3.lastPointsList);
  const deltaPoints = currentPointsList.length === lastPointsList.length ? getDeltaPoints(currentPointsList, lastPointsList) : zeroIPoint;
  const deltaDistance = currentPointsList.length === lastPointsList.length ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList) : zeroIDistance;
  const totalDistance = currentPointsList.length === lastPointsList.length ? getDeltaDistance(currentPointsList, state3.lastPointsList) : zeroIDistance;
  state3.accumulatedDistance = {
    page: state3.accumulatedDistance.page + totalDistance.page,
    client: state3.accumulatedDistance.client + totalDistance.client,
    canvas: state3.accumulatedDistance.canvas + totalDistance.canvas,
    world: state3.accumulatedDistance.world + totalDistance.world
  };
  const eventDetail = {
    event: evt,
    eventName: TOUCH_DRAG,
    renderingEngineId: state3.renderingEngineId,
    viewportId: state3.viewportId,
    camera: {},
    element: state3.element,
    startPoints: getMeanTouchPoints(state3.startPointsList),
    lastPoints: getMeanTouchPoints(lastPointsList),
    currentPoints: getMeanTouchPoints(currentPointsList),
    startPointsList: copyPointsList(state3.startPointsList),
    lastPointsList: copyPointsList(lastPointsList),
    currentPointsList,
    deltaPoints,
    deltaDistance
  };
  triggerEventCallback(state3.element, TOUCH_DRAG, eventDetail);
  _checkTouchSwipe(evt, deltaPoints);
  state3.lastPointsList = copyPointsList(currentPointsList);
}
function _onTouchEnd(evt) {
  clearTimeout(state3.pressTimeout);
  const currentPointsList = getTouchEventPoints(evt, state3.element);
  const lastPointsList = _updateTouchEventsLastPoints(state3.element, state3.lastPointsList);
  const deltaPoints = currentPointsList.length === lastPointsList.length ? getDeltaPoints(currentPointsList, lastPointsList) : getDeltaPoints(currentPointsList, currentPointsList);
  const deltaDistance = currentPointsList.length === lastPointsList.length ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList) : getDeltaDistanceBetweenIPoints(currentPointsList, currentPointsList);
  const eventDetail = {
    event: evt,
    eventName: TOUCH_END,
    element: state3.element,
    renderingEngineId: state3.renderingEngineId,
    viewportId: state3.viewportId,
    camera: {},
    startPointsList: copyPointsList(state3.startPointsList),
    lastPointsList: copyPointsList(lastPointsList),
    currentPointsList,
    startPoints: getMeanTouchPoints(state3.startPointsList),
    lastPoints: getMeanTouchPoints(lastPointsList),
    currentPoints: getMeanTouchPoints(currentPointsList),
    deltaPoints,
    deltaDistance
  };
  triggerEventCallback(eventDetail.element, TOUCH_END, eventDetail);
  _checkTouchTap(evt);
  state3 = JSON.parse(JSON.stringify(defaultState3));
  document.removeEventListener("touchmove", _onTouchDrag);
  document.removeEventListener("touchend", _onTouchEnd);
}
function _checkTouchTap(evt) {
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  const startTime = state3.startTime.getTime();
  if (currentTime - startTime > tapState.tapToleranceMs) {
    return;
  }
  if (tapState.taps === 0) {
    tapState.element = state3.element;
    tapState.renderingEngineId = state3.renderingEngineId;
    tapState.viewportId = state3.viewportId;
    tapState.startPointsList = state3.startPointsList;
  }
  if (tapState.taps > 0 && !(tapState.element == state3.element && tapState.renderingEngineId == state3.renderingEngineId && tapState.viewportId == state3.viewportId)) {
    return;
  }
  const currentPointsList = getTouchEventPoints(evt, tapState.element);
  const distanceFromStart = getDeltaDistance(currentPointsList, tapState.startPointsList).canvas;
  if (distanceFromStart > tapState.tapMaxDistance) {
    return;
  }
  clearTimeout(tapState.tapTimeout);
  tapState.taps += 1;
  tapState.tapTimeout = setTimeout(() => {
    const eventDetail = {
      event: evt,
      eventName: TOUCH_TAP,
      element: tapState.element,
      renderingEngineId: tapState.renderingEngineId,
      viewportId: tapState.viewportId,
      camera: {},
      currentPointsList,
      currentPoints: getMeanTouchPoints(currentPointsList),
      taps: tapState.taps
    };
    triggerEventCallback(eventDetail.element, TOUCH_TAP, eventDetail);
    tapState = JSON.parse(JSON.stringify(defaultTapState));
  }, tapState.tapToleranceMs);
}
function _checkTouchSwipe(evt, deltaPoints) {
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  const startTime = state3.startTime.getTime();
  if (state3.swiped || currentTime - startTime > state3.swipeToleranceMs) {
    return;
  }
  const [x, y] = deltaPoints.canvas;
  const eventDetail = {
    event: evt,
    eventName: TOUCH_SWIPE,
    renderingEngineId: state3.renderingEngineId,
    viewportId: state3.viewportId,
    camera: {},
    element: state3.element,
    swipe: null
  };
  if (Math.abs(x) > state3.swipeDistanceThreshold) {
    eventDetail.swipe = x > 0 ? Swipe.RIGHT : Swipe.LEFT;
    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);
    state3.swiped = true;
  }
  if (Math.abs(y) > state3.swipeDistanceThreshold) {
    eventDetail.swipe = y > 0 ? Swipe.DOWN : Swipe.UP;
    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);
    state3.swiped = true;
  }
}
function _updateTouchEventsLastPoints(element, lastPoints) {
  const { viewport } = getEnabledElement(element);
  return lastPoints.map((lp) => {
    const world = viewport.canvasToWorld(lp.canvas);
    return {
      page: lp.page,
      client: lp.client,
      canvas: lp.canvas,
      world,
      touch: lp.touch
    };
  });
}
var touchStartListener_default = touchStartListener;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/index.js
function disable3(element) {
  preventGhostClick_default.disable(element);
  element.removeEventListener("touchstart", touchStartListener_default);
}
function enable3(element) {
  disable3(element);
  preventGhostClick_default.enable(element);
  element.addEventListener("touchstart", touchStartListener_default, {
    passive: false
  });
}
var touch_default = {
  enable: enable3,
  disable: disable3
};

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/normalizeWheel.js
var PIXEL_STEP = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function normalizeWheel(event) {
  let spinX = 0, spinY = 0, pixelX = 0, pixelY = 0;
  if ("detail" in event) {
    spinY = event.detail;
  }
  if ("wheelDelta" in event) {
    spinY = -event.wheelDelta / 120;
  }
  if ("wheelDeltaY" in event) {
    spinY = -event.wheelDeltaY / 120;
  }
  if ("wheelDeltaX" in event) {
    spinX = -event.wheelDeltaX / 120;
  }
  pixelX = spinX * PIXEL_STEP;
  pixelY = spinY * PIXEL_STEP;
  if ("deltaY" in event) {
    pixelY = event.deltaY;
  }
  if ("deltaX" in event) {
    pixelX = event.deltaX;
  }
  if ((pixelX || pixelY) && event.deltaMode) {
    if (event.deltaMode === 1) {
      pixelX *= LINE_HEIGHT;
      pixelY *= LINE_HEIGHT;
    } else {
      pixelX *= PAGE_HEIGHT;
      pixelY *= PAGE_HEIGHT;
    }
  }
  if (pixelX && !spinX) {
    spinX = pixelX < 1 ? -1 : 1;
  }
  if (pixelY && !spinY) {
    spinY = pixelY < 1 ? -1 : 1;
  }
  return {
    spinX,
    spinY,
    pixelX,
    pixelY
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/wheelListener.js
function wheelListener(evt) {
  const element = evt.currentTarget;
  const enabledElement = getEnabledElement(element);
  const { renderingEngineId, viewportId } = enabledElement;
  if (evt.deltaY > -1 && evt.deltaY < 1) {
    return;
  }
  evt.preventDefault();
  const { spinX, spinY, pixelX, pixelY } = normalizeWheel(evt);
  const direction = spinY < 0 ? -1 : 1;
  const eventDetail = {
    event: evt,
    eventName: Events_default.MOUSE_WHEEL,
    renderingEngineId,
    viewportId,
    element,
    camera: {},
    detail: evt,
    wheel: {
      spinX,
      spinY,
      pixelX,
      pixelY,
      direction
    },
    points: getMouseEventPoints(evt)
  };
  triggerEvent(element, Events_default.MOUSE_WHEEL, eventDetail);
}
var wheelListener_default = wheelListener;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/index.js
function enable4(element) {
  disable4(element);
  element.addEventListener("wheel", wheelListener_default, { passive: false });
}
function disable4(element) {
  element.removeEventListener("wheel", wheelListener_default);
}
var wheel_default = {
  enable: enable4,
  disable: disable4
};

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/keyDownListener.js
var defaultState4 = {
  renderingEngineId: void 0,
  viewportId: void 0,
  key: void 0,
  keyCode: void 0,
  element: null
};
var state4 = {
  renderingEngineId: void 0,
  viewportId: void 0,
  key: void 0,
  keyCode: void 0,
  element: null
};
function keyListener(evt) {
  state4.element = evt.currentTarget;
  const enabledElement = getEnabledElement(state4.element);
  const { renderingEngineId, viewportId } = enabledElement;
  state4.renderingEngineId = renderingEngineId;
  state4.viewportId = viewportId;
  state4.key = evt.key;
  state4.keyCode = evt.keyCode;
  evt.preventDefault();
  const eventDetail = {
    renderingEngineId: state4.renderingEngineId,
    viewportId: state4.viewportId,
    element: state4.element,
    key: state4.key,
    keyCode: state4.keyCode
  };
  triggerEvent(eventDetail.element, Events_default.KEY_DOWN, eventDetail);
  document.addEventListener("keyup", _onKeyUp);
  document.addEventListener("visibilitychange", _onVisibilityChange);
  state4.element.removeEventListener("keydown", keyListener);
}
function _onVisibilityChange() {
  document.removeEventListener("visibilitychange", _onVisibilityChange);
  if (document.visibilityState === "hidden") {
    resetModifierKey();
  }
}
function _onKeyUp(evt) {
  const eventDetail = {
    renderingEngineId: state4.renderingEngineId,
    viewportId: state4.viewportId,
    element: state4.element,
    key: state4.key,
    keyCode: state4.keyCode
  };
  document.removeEventListener("keyup", _onKeyUp);
  document.removeEventListener("visibilitychange", _onVisibilityChange);
  state4.element.addEventListener("keydown", keyListener);
  state4 = structuredClone(defaultState4);
  triggerEvent(eventDetail.element, Events_default.KEY_UP, eventDetail);
}
function getModifierKey() {
  return state4.keyCode;
}
function resetModifierKey() {
  state4.keyCode = void 0;
}
var keyDownListener_default = keyListener;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/index.js
function enable5(element) {
  disable5(element);
  element.addEventListener("keydown", keyDownListener_default);
}
function disable5(element) {
  element.removeEventListener("keydown", keyDownListener_default);
}
var keyboard_default = {
  enable: enable5,
  disable: disable5,
  getModifierKey
};

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js
var triggerSegmentationEvents_exports = {};
__export(triggerSegmentationEvents_exports, {
  triggerSegmentationDataModified: () => triggerSegmentationDataModified,
  triggerSegmentationModified: () => triggerSegmentationModified,
  triggerSegmentationRemoved: () => triggerSegmentationRemoved,
  triggerSegmentationRepresentationModified: () => triggerSegmentationRepresentationModified,
  triggerSegmentationRepresentationRemoved: () => triggerSegmentationRepresentationRemoved
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js
var { EPSILON } = constants_exports;
function calculateBoundingBox(points, dimensions, isWorld = false) {
  var _a2;
  let xMin = Infinity;
  let xMax = isWorld ? -Infinity : 0;
  let yMin = Infinity;
  let yMax = isWorld ? -Infinity : 0;
  let zMin = Infinity;
  let zMax = isWorld ? -Infinity : 0;
  const is3D = ((_a2 = points[0]) == null ? void 0 : _a2.length) === 3;
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    xMin = Math.min(p[0], xMin);
    xMax = Math.max(p[0], xMax);
    yMin = Math.min(p[1], yMin);
    yMax = Math.max(p[1], yMax);
    if (is3D) {
      zMin = Math.min(p[2] ?? zMin, zMin);
      zMax = Math.max(p[2] ?? zMax, zMax);
    }
  }
  if (dimensions) {
    xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);
    xMax = Math.min(isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1, xMax);
    yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);
    yMax = Math.min(isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1, yMax);
    if (is3D && dimensions.length === 3) {
      zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);
      zMax = Math.min(isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1, zMax);
    }
  } else if (!isWorld) {
    xMin = Math.max(0, xMin);
    xMax = Math.min(Infinity, xMax);
    yMin = Math.max(0, yMin);
    yMax = Math.min(Infinity, yMax);
    if (is3D) {
      zMin = Math.max(0, zMin);
      zMax = Math.min(Infinity, zMax);
    }
  }
  return is3D ? [
    [xMin, xMax],
    [yMin, yMax],
    [zMin, zMax]
  ] : [[xMin, xMax], [yMin, yMax], null];
}
function getBoundingBoxAroundShapeIJK(points, dimensions) {
  return calculateBoundingBox(points, dimensions, false);
}
function getBoundingBoxAroundShapeWorld(points, clipBounds) {
  return calculateBoundingBox(points, clipBounds, true);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js
var equalsCheck = (a, b) => {
  return JSON.stringify(a) === JSON.stringify(b);
};
function getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter) {
  const halfSpacingX = voxelSpacing[0] / 2;
  const halfSpacingY = voxelSpacing[1] / 2;
  const halfSpacingZ = voxelSpacing[2] / 2;
  const voxelCornersIJK = new Array(8);
  voxelCornersIJK[0] = utilities_exports.transformWorldToIndex(imageData, [
    voxelCenter[0] - halfSpacingX,
    voxelCenter[1] - halfSpacingY,
    voxelCenter[2] - halfSpacingZ
  ]);
  const offsets = [
    [1, -1, -1],
    [-1, 1, -1],
    [1, 1, -1],
    [-1, -1, 1],
    [1, -1, 1],
    [-1, 1, 1],
    [1, 1, 1]
  ];
  for (let i = 0; i < 7; i++) {
    const [xOff, yOff, zOff] = offsets[i];
    voxelCornersIJK[i + 1] = utilities_exports.transformWorldToIndex(imageData, [
      voxelCenter[0] + xOff * halfSpacingX,
      voxelCenter[1] + yOff * halfSpacingY,
      voxelCenter[2] + zOff * halfSpacingZ
    ]);
  }
  return getBoundingBoxAroundShapeIJK(voxelCornersIJK, dimensions);
}
function processVolumes(segmentationVolume, thresholdVolumeInformation) {
  const { spacing: segmentationSpacing } = segmentationVolume;
  const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
  const volumeInfoList = [];
  let baseVolumeIdx = 0;
  for (let i = 0; i < thresholdVolumeInformation.length; i++) {
    const { imageData, spacing, dimensions, voxelManager } = thresholdVolumeInformation[i].volume;
    const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();
    if (volumeSize === scalarDataLength && equalsCheck(spacing, segmentationSpacing)) {
      baseVolumeIdx = i;
    }
    const lower = thresholdVolumeInformation[i].lower;
    const upper = thresholdVolumeInformation[i].upper;
    volumeInfoList.push({
      imageData,
      lower,
      upper,
      spacing,
      dimensions,
      volumeSize,
      voxelManager
    });
  }
  return {
    volumeInfoList,
    baseVolumeIdx
  };
}
var segmentIndicesCache = /* @__PURE__ */ new Map();
var setSegmentationDirty = (segmentationId) => {
  const cached = segmentIndicesCache.get(segmentationId);
  if (cached) {
    cached.isDirty = true;
  }
};
var getCachedSegmentIndices = (segmentationId) => {
  const cached = segmentIndicesCache.get(segmentationId);
  if (cached && !cached.isDirty) {
    return cached.indices;
  }
  return null;
};
var setCachedSegmentIndices = (segmentationId, indices) => {
  segmentIndicesCache.set(segmentationId, { indices, isDirty: false });
};

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js
function triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse, segmentIndex) {
  const eventDetail = {
    segmentationId,
    modifiedSlicesToUse,
    segmentIndex
  };
  setSegmentationDirty(segmentationId);
  triggerEvent(eventTarget_default, Events_default.SEGMENTATION_DATA_MODIFIED, eventDetail);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationModified.js
function triggerSegmentationModified(segmentationId) {
  const eventDetail = {
    segmentationId
  };
  triggerEvent(eventTarget_default, Events_default.SEGMENTATION_MODIFIED, eventDetail);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRemoved.js
function triggerSegmentationRemoved(segmentationId) {
  const eventDetail = {
    segmentationId
  };
  triggerEvent(eventTarget_default, Events_default.SEGMENTATION_REMOVED, eventDetail);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationModified.js
function triggerSegmentationRepresentationModified(viewportId, segmentationId, type) {
  const eventDetail = {
    segmentationId,
    type,
    viewportId
  };
  triggerEvent(eventTarget_default, Events_default.SEGMENTATION_REPRESENTATION_MODIFIED, eventDetail);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationRemoved.js
function triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type) {
  const eventDetail = {
    viewportId,
    segmentationId,
    type
  };
  triggerEvent(eventTarget_default, Events_default.SEGMENTATION_REPRESENTATION_REMOVED, eventDetail);
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfig.js
var defaultContourConfig = {
  renderOutline: true,
  outlineWidthAutoGenerated: 3,
  outlineWidth: 1,
  outlineWidthInactive: 1,
  outlineOpacity: 1,
  outlineOpacityInactive: 0.85,
  outlineDash: void 0,
  outlineDashInactive: void 0,
  outlineDashAutoGenerated: "5,3",
  activeSegmentOutlineWidthDelta: 0,
  renderFill: true,
  fillAlpha: 0.5,
  fillAlphaInactive: 0.3,
  fillAlphaAutoGenerated: 0.3
};
function getDefaultContourStyle() {
  return defaultContourConfig;
}
var contourConfig_default = getDefaultContourStyle;

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapConfig.js
var defaultLabelmapConfig = {
  renderOutline: true,
  renderOutlineInactive: true,
  outlineWidth: 3,
  outlineWidthInactive: 2,
  activeSegmentOutlineWidthDelta: 0,
  renderFill: true,
  renderFillInactive: true,
  fillAlpha: 0.5,
  fillAlphaInactive: 0.4,
  outlineOpacity: 1,
  outlineOpacityInactive: 0.85
};
function getDefaultLabelmapStyle() {
  return defaultLabelmapConfig;
}
var labelmapConfig_default = getDefaultLabelmapStyle;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js
var SegmentationStyle = class {
  constructor() {
    this.config = {
      global: {},
      segmentations: {},
      viewportsStyle: {}
    };
  }
  setStyle(specifier, styles) {
    const { viewportId, segmentationId, type, segmentIndex } = specifier;
    const currentStyles = this.getStyle(specifier);
    let updatedStyles;
    if (!viewportId && !segmentationId) {
      updatedStyles = {
        ...currentStyles,
        ...styles
      };
    } else {
      updatedStyles = this.copyActiveToInactiveIfNotProvided({
        ...currentStyles,
        ...styles
      }, type);
    }
    if (!type) {
      throw new Error("Type is required to set a style");
    }
    if (viewportId) {
      if (!this.config.viewportsStyle[viewportId]) {
        this.config.viewportsStyle[viewportId] = {
          renderInactiveSegmentations: false,
          representations: {}
        };
      }
      const representations = this.config.viewportsStyle[viewportId].representations;
      if (segmentationId) {
        if (!representations[segmentationId]) {
          representations[segmentationId] = {};
        }
        if (!representations[segmentationId][type]) {
          representations[segmentationId][type] = {};
        }
        const repConfig = representations[segmentationId][type];
        if (segmentIndex !== void 0) {
          if (!repConfig.perSegment) {
            repConfig.perSegment = {};
          }
          repConfig.perSegment[segmentIndex] = updatedStyles;
        } else {
          repConfig.allSegments = updatedStyles;
        }
      } else {
        const ALL_SEGMENTATIONS_KEY = "__allSegmentations__";
        if (!representations[ALL_SEGMENTATIONS_KEY]) {
          representations[ALL_SEGMENTATIONS_KEY] = {};
        }
        if (!representations[ALL_SEGMENTATIONS_KEY][type]) {
          representations[ALL_SEGMENTATIONS_KEY][type] = {};
        }
        representations[ALL_SEGMENTATIONS_KEY][type].allSegments = updatedStyles;
      }
    } else if (segmentationId) {
      if (!this.config.segmentations[segmentationId]) {
        this.config.segmentations[segmentationId] = {};
      }
      if (!this.config.segmentations[segmentationId][type]) {
        this.config.segmentations[segmentationId][type] = {};
      }
      const segConfig = this.config.segmentations[segmentationId][type];
      if (segmentIndex !== void 0) {
        if (!segConfig.perSegment) {
          segConfig.perSegment = {};
        }
        segConfig.perSegment[segmentIndex] = updatedStyles;
      } else {
        segConfig.allSegments = updatedStyles;
      }
    } else {
      this.config.global[type] = updatedStyles;
    }
  }
  copyActiveToInactiveIfNotProvided(styles, type) {
    const processedStyles = { ...styles };
    if (type === SegmentationRepresentations_default.Labelmap) {
      const labelmapStyles = processedStyles;
      labelmapStyles.renderOutlineInactive = labelmapStyles.renderOutline;
      labelmapStyles.outlineWidthInactive = labelmapStyles.outlineWidth;
      labelmapStyles.renderFillInactive = labelmapStyles.renderFill;
      labelmapStyles.fillAlphaInactive = labelmapStyles.fillAlpha;
      labelmapStyles.outlineOpacityInactive = labelmapStyles.outlineOpacity;
    } else if (type === SegmentationRepresentations_default.Contour) {
      const contourStyles = processedStyles;
      contourStyles.outlineWidthInactive = contourStyles.outlineWidth;
      contourStyles.outlineOpacityInactive = contourStyles.outlineOpacity;
      contourStyles.outlineDashInactive = contourStyles.outlineDash;
      contourStyles.renderOutlineInactive = contourStyles.renderOutline;
      contourStyles.renderFillInactive = contourStyles.renderFill;
      contourStyles.fillAlphaInactive = contourStyles.fillAlpha;
    }
    return processedStyles;
  }
  getStyle(specifier) {
    var _a2, _b2, _c, _d, _e;
    const { viewportId, segmentationId, type, segmentIndex } = specifier;
    let combinedStyle = this.getDefaultStyle(type);
    let renderInactiveSegmentations = false;
    if (this.config.global[type]) {
      combinedStyle = {
        ...combinedStyle,
        ...this.config.global[type]
      };
    }
    if ((_a2 = this.config.segmentations[segmentationId]) == null ? void 0 : _a2[type]) {
      combinedStyle = {
        ...combinedStyle,
        ...this.config.segmentations[segmentationId][type].allSegments
      };
      if (segmentIndex !== void 0 && ((_b2 = this.config.segmentations[segmentationId][type].perSegment) == null ? void 0 : _b2[segmentIndex])) {
        combinedStyle = {
          ...combinedStyle,
          ...this.config.segmentations[segmentationId][type].perSegment[segmentIndex]
        };
      }
    }
    if (viewportId && this.config.viewportsStyle[viewportId]) {
      renderInactiveSegmentations = this.config.viewportsStyle[viewportId].renderInactiveSegmentations;
      const allSegmentationsKey = "__allSegmentations__";
      if ((_c = this.config.viewportsStyle[viewportId].representations[allSegmentationsKey]) == null ? void 0 : _c[type]) {
        combinedStyle = {
          ...combinedStyle,
          ...this.config.viewportsStyle[viewportId].representations[allSegmentationsKey][type].allSegments
        };
      }
      if (segmentationId && ((_d = this.config.viewportsStyle[viewportId].representations[segmentationId]) == null ? void 0 : _d[type])) {
        combinedStyle = {
          ...combinedStyle,
          ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].allSegments
        };
        if (segmentIndex !== void 0 && ((_e = this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment) == null ? void 0 : _e[segmentIndex])) {
          combinedStyle = {
            ...combinedStyle,
            ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment[segmentIndex]
          };
        }
      }
    }
    return combinedStyle;
  }
  getRenderInactiveSegmentations(viewportId) {
    var _a2;
    return (_a2 = this.config.viewportsStyle[viewportId]) == null ? void 0 : _a2.renderInactiveSegmentations;
  }
  setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {
    if (!this.config.viewportsStyle[viewportId]) {
      this.config.viewportsStyle[viewportId] = {
        renderInactiveSegmentations: false,
        representations: {}
      };
    }
    this.config.viewportsStyle[viewportId].renderInactiveSegmentations = renderInactiveSegmentations;
  }
  getDefaultStyle(type) {
    switch (type) {
      case SegmentationRepresentations_default.Labelmap:
        return labelmapConfig_default();
      case SegmentationRepresentations_default.Contour:
        return contourConfig_default();
      case SegmentationRepresentations_default.Surface:
        return {};
      default:
        throw new Error(`Unknown representation type: ${type}`);
    }
  }
  clearSegmentationStyle(segmentationId) {
    if (this.config.segmentations[segmentationId]) {
      delete this.config.segmentations[segmentationId];
    }
  }
  clearAllSegmentationStyles() {
    this.config.segmentations = {};
  }
  clearViewportStyle(viewportId) {
    if (this.config.viewportsStyle[viewportId]) {
      delete this.config.viewportsStyle[viewportId];
    }
  }
  clearAllViewportStyles() {
    for (const viewportId in this.config.viewportsStyle) {
      const viewportStyle = this.config.viewportsStyle[viewportId];
      const renderInactiveSegmentations = viewportStyle.renderInactiveSegmentations;
      this.config.viewportsStyle[viewportId] = {
        renderInactiveSegmentations,
        representations: {}
      };
    }
  }
  resetToGlobalStyle() {
    this.clearAllSegmentationStyles();
    this.clearAllViewportStyles();
  }
  hasCustomStyle(specifier) {
    const { type } = specifier;
    const style = this.getStyle(specifier);
    const defaultStyle = this.getDefaultStyle(type);
    return !utilities_exports.deepEqual(style, defaultStyle);
  }
};
var segmentationStyle = new SegmentationStyle();

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationAdded.js
function triggerSegmentationAdded(segmentationId) {
  const eventDetail = {
    segmentationId
  };
  triggerEvent(eventTarget_default, Events_default.SEGMENTATION_ADDED, eventDetail);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var initialDefaultState = {
  colorLUT: [],
  segmentations: [],
  viewportSegRepresentations: {}
};
var SegmentationStateManager = class {
  constructor(uid) {
    this._stackLabelmapImageIdReferenceMap = /* @__PURE__ */ new Map();
    uid || (uid = utilities_exports.uuidv4());
    this.state = Object.freeze(utilities_exports.deepClone(initialDefaultState));
    this.uid = uid;
  }
  getState() {
    return this.state;
  }
  updateState(updater) {
    const newState = utilities_exports.deepClone(this.state);
    updater(newState);
    this.state = Object.freeze(newState);
  }
  getColorLUT(lutIndex) {
    return this.state.colorLUT[lutIndex];
  }
  getNextColorLUTIndex() {
    return this.state.colorLUT.length;
  }
  resetState() {
    this.state = Object.freeze(utilities_exports.deepClone(initialDefaultState));
  }
  getSegmentation(segmentationId) {
    return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
  }
  updateSegmentation(segmentationId, payload) {
    this.updateState((draftState) => {
      const segmentation = draftState.segmentations.find((segmentation2) => segmentation2.segmentationId === segmentationId);
      if (!segmentation) {
        console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);
        return;
      }
      Object.assign(segmentation, payload);
    });
    triggerSegmentationModified(segmentationId);
  }
  addSegmentation(segmentation) {
    if (this.getSegmentation(segmentation.segmentationId)) {
      throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);
    }
    this.updateState((state8) => {
      const newSegmentation = utilities_exports.deepClone(segmentation);
      if (newSegmentation.representationData.Labelmap && "volumeId" in newSegmentation.representationData.Labelmap && !("imageIds" in newSegmentation.representationData.Labelmap)) {
        const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);
        newSegmentation.representationData.Labelmap.imageIds = imageIds;
      }
      state8.segmentations.push(newSegmentation);
    });
    triggerSegmentationAdded(segmentation.segmentationId);
  }
  removeSegmentation(segmentationId) {
    this.updateState((state8) => {
      const filteredSegmentations = state8.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);
      state8.segmentations.splice(0, state8.segmentations.length, ...filteredSegmentations);
    });
    triggerSegmentationRemoved(segmentationId);
  }
  addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {
    const enabledElement = getEnabledElementByViewportId(viewportId);
    if (!enabledElement) {
      return;
    }
    const existingRepresentations = this.getSegmentationRepresentations(viewportId, {
      type,
      segmentationId
    });
    if (existingRepresentations.length > 0) {
      console.debug("A segmentation representation of type", type, "already exists in viewport", viewportId, "for segmentation", segmentationId);
      return;
    }
    this.updateState((state8) => {
      if (!state8.viewportSegRepresentations[viewportId]) {
        state8.viewportSegRepresentations[viewportId] = [];
        segmentationStyle.setRenderInactiveSegmentations(viewportId, true);
      }
      if (type !== SegmentationRepresentations_default.Labelmap) {
        this.addDefaultSegmentationRepresentation(state8, viewportId, segmentationId, type, renderingConfig);
      } else {
        this.addLabelmapRepresentation(state8, viewportId, segmentationId, renderingConfig);
      }
    });
    triggerSegmentationRepresentationModified(viewportId, segmentationId, type);
  }
  addDefaultSegmentationRepresentation(state8, viewportId, segmentationId, type, renderingConfig) {
    const segmentation = state8.segmentations.find((segmentation2) => segmentation2.segmentationId === segmentationId);
    if (!segmentation) {
      return;
    }
    const segmentReps = {};
    Object.keys(segmentation.segments).forEach((segmentIndex) => {
      segmentReps[Number(segmentIndex)] = {
        visible: true
      };
    });
    state8.viewportSegRepresentations[viewportId].push({
      segmentationId,
      type,
      active: true,
      visible: true,
      colorLUTIndex: (renderingConfig == null ? void 0 : renderingConfig.colorLUTIndex) || 0,
      segments: segmentReps,
      config: {
        ...getDefaultRenderingConfig(type),
        ...renderingConfig
      }
    });
    this._setActiveSegmentation(state8, viewportId, segmentationId);
  }
  addLabelmapRepresentation(state8, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(SegmentationRepresentations_default.Labelmap)) {
    const enabledElement = getEnabledElementByViewportId(viewportId);
    if (!enabledElement) {
      return;
    }
    const segmentation = this.getSegmentation(segmentationId);
    if (!segmentation) {
      return;
    }
    const { representationData } = segmentation;
    if (!representationData.Labelmap) {
      return this.addDefaultSegmentationRepresentation(state8, viewportId, segmentationId, SegmentationRepresentations_default.Labelmap, renderingConfig);
    }
    this.processLabelmapRepresentationAddition(viewportId, segmentationId);
    this.addDefaultSegmentationRepresentation(state8, viewportId, segmentationId, SegmentationRepresentations_default.Labelmap, renderingConfig);
  }
  async processLabelmapRepresentationAddition(viewportId, segmentationId) {
    const enabledElement = getEnabledElementByViewportId(viewportId);
    if (!enabledElement) {
      return;
    }
    const segmentation = this.getSegmentation(segmentationId);
    if (!segmentation) {
      return;
    }
    const volumeViewport = enabledElement.viewport instanceof BaseVolumeViewport_default;
    const { representationData } = segmentation;
    const isBaseVolumeSegmentation = "volumeId" in representationData.Labelmap;
    const viewport = enabledElement.viewport;
    if (!volumeViewport && !isBaseVolumeSegmentation) {
      !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);
    }
  }
  _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {
    const currentImageId = viewport.getCurrentImageId();
    let viewableLabelmapImageIdFound = false;
    for (const labelmapImageId of labelmapImageIds) {
      const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });
      if (viewableImageId) {
        viewableLabelmapImageIdFound = true;
        this._stackLabelmapImageIdReferenceMap.get(segmentationId).set(currentImageId, labelmapImageId);
      }
    }
    if (updateCallback) {
      updateCallback(viewport, segmentationId, labelmapImageIds);
    }
    return viewableLabelmapImageIdFound ? this._stackLabelmapImageIdReferenceMap.get(segmentationId).get(currentImageId) : void 0;
  }
  updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {
    const segmentation = this.getSegmentation(segmentationId);
    if (!segmentation) {
      return;
    }
    if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
      this._stackLabelmapImageIdReferenceMap.set(segmentationId, /* @__PURE__ */ new Map());
    }
    const { representationData } = segmentation;
    if (!representationData.Labelmap) {
      return;
    }
    const labelmapImageIds = this.getLabelmapImageIds(representationData);
    const enabledElement = getEnabledElementByViewportId(viewportId);
    const stackViewport = enabledElement.viewport;
    return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);
  }
  _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {
    const segmentation = this.getSegmentation(segmentationId);
    if (!segmentation) {
      return;
    }
    if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
      this._stackLabelmapImageIdReferenceMap.set(segmentationId, /* @__PURE__ */ new Map());
    }
    const { representationData } = segmentation;
    if (!representationData.Labelmap) {
      return;
    }
    const labelmapImageIds = this.getLabelmapImageIds(representationData);
    const enabledElement = getEnabledElementByViewportId(viewportId);
    const stackViewport = enabledElement.viewport;
    this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport2, segmentationId2, labelmapImageIds2) => {
      const imageIds = stackViewport2.getImageIds();
      imageIds.forEach((imageId, index) => {
        for (const labelmapImageId of labelmapImageIds2) {
          const viewableImageId = stackViewport2.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });
          if (viewableImageId) {
            this._stackLabelmapImageIdReferenceMap.get(segmentationId2).set(imageId, labelmapImageId);
          }
        }
      });
    });
  }
  getLabelmapImageIds(representationData) {
    const labelmapData = representationData.Labelmap;
    let labelmapImageIds;
    if (labelmapData.imageIds) {
      labelmapImageIds = labelmapData.imageIds;
    } else if (!labelmapImageIds && labelmapData.volumeId) {
      const volumeId = labelmapData.volumeId;
      const volume = cache_default.getVolume(volumeId);
      labelmapImageIds = volume.imageIds;
    }
    return labelmapImageIds;
  }
  getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {
    const enabledElement = getEnabledElementByViewportId(viewportId);
    if (!enabledElement) {
      return;
    }
    if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
      return;
    }
    const stackViewport = enabledElement.viewport;
    const currentImageId = stackViewport.getCurrentImageId();
    const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);
    return imageIdReferenceMap.get(currentImageId);
  }
  getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {
    const segmentation = this.getSegmentation(segmentationId);
    if (!segmentation) {
      return [];
    }
    this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);
    const { viewport } = getEnabledElementByViewportId(viewportId);
    const imageIds = viewport.getImageIds();
    const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);
    return imageIds.map((imageId) => {
      return associatedReferenceImageAndLabelmapImageIds.get(imageId);
    });
  }
  removeSegmentationRepresentationsInternal(viewportId, specifier) {
    const removedRepresentations = [];
    this.updateState((state8) => {
      if (!state8.viewportSegRepresentations[viewportId]) {
        return;
      }
      const currentRepresentations = state8.viewportSegRepresentations[viewportId];
      let activeRepresentationRemoved = false;
      if (!specifier || Object.values(specifier).every((value) => value === void 0)) {
        removedRepresentations.push(...currentRepresentations);
        delete state8.viewportSegRepresentations[viewportId];
      } else {
        const { segmentationId, type } = specifier;
        state8.viewportSegRepresentations[viewportId] = currentRepresentations.filter((representation) => {
          const shouldRemove = segmentationId && type && representation.segmentationId === segmentationId && representation.type === type || segmentationId && !type && representation.segmentationId === segmentationId || !segmentationId && type && representation.type === type;
          if (shouldRemove) {
            removedRepresentations.push(representation);
            if (representation.active) {
              activeRepresentationRemoved = true;
            }
          }
          return !shouldRemove;
        });
        if (state8.viewportSegRepresentations[viewportId].length === 0) {
          delete state8.viewportSegRepresentations[viewportId];
        } else if (activeRepresentationRemoved) {
          state8.viewportSegRepresentations[viewportId][0].active = true;
        }
      }
    });
    return removedRepresentations;
  }
  removeSegmentationRepresentations(viewportId, specifier) {
    const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);
    removedRepresentations.forEach((representation) => {
      triggerSegmentationRepresentationRemoved(viewportId, representation.segmentationId, representation.type);
    });
    const remainingRepresentations = this.getSegmentationRepresentations(viewportId);
    if (remainingRepresentations.length > 0 && remainingRepresentations[0].active) {
      triggerSegmentationRepresentationModified(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);
    }
    return removedRepresentations;
  }
  removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {
    const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);
    if (!suppressEvent) {
      removedRepresentations.forEach(({ segmentationId, type }) => {
        triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type);
      });
    }
    return removedRepresentations;
  }
  _setActiveSegmentation(state8, viewportId, segmentationId) {
    const viewport = state8.viewportSegRepresentations[viewportId];
    if (!viewport) {
      return;
    }
    viewport.forEach((value) => {
      value.active = value.segmentationId === segmentationId;
    });
  }
  setActiveSegmentation(viewportId, segmentationId) {
    this.updateState((state8) => {
      const viewport = state8.viewportSegRepresentations[viewportId];
      if (!viewport) {
        return;
      }
      viewport.forEach((value) => {
        value.active = value.segmentationId === segmentationId;
      });
    });
    triggerSegmentationRepresentationModified(viewportId, segmentationId);
  }
  getActiveSegmentation(viewportId) {
    if (!this.state.viewportSegRepresentations[viewportId]) {
      return;
    }
    const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);
    if (!activeSegRep) {
      return;
    }
    return this.getSegmentation(activeSegRep.segmentationId);
  }
  getSegmentationRepresentations(viewportId, specifier = {}) {
    const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];
    if (!viewportRepresentations) {
      return [];
    }
    if (!specifier.type && !specifier.segmentationId) {
      return viewportRepresentations;
    }
    return viewportRepresentations.filter((representation) => {
      const typeMatch = specifier.type ? representation.type === specifier.type : true;
      const idMatch = specifier.segmentationId ? representation.segmentationId === specifier.segmentationId : true;
      return typeMatch && idMatch;
    });
  }
  getSegmentationRepresentation(viewportId, specifier) {
    return this.getSegmentationRepresentations(viewportId, specifier)[0];
  }
  getSegmentationRepresentationVisibility(viewportId, specifier) {
    const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);
    return viewportRepresentation == null ? void 0 : viewportRepresentation.visible;
  }
  setSegmentationRepresentationVisibility(viewportId, specifier, visible) {
    this.updateState((state8) => {
      const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);
      if (!viewportRepresentations) {
        return;
      }
      viewportRepresentations.forEach((representation) => {
        representation.visible = visible;
        Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {
          segment.visible = visible;
        });
      });
    });
    triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId, specifier.type);
  }
  addColorLUT(colorLUT, lutIndex) {
    this.updateState((state8) => {
      if (state8.colorLUT[lutIndex]) {
        console.warn("Color LUT table already exists, overwriting");
      }
      state8.colorLUT[lutIndex] = utilities_exports.deepClone(colorLUT);
    });
  }
  removeColorLUT(colorLUTIndex) {
    this.updateState((state8) => {
      delete state8.colorLUT[colorLUTIndex];
    });
  }
  _getStackIdForImageIds(imageIds) {
    return imageIds.map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15))).join("_");
  }
  getAllViewportSegmentationRepresentations() {
    return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({
      viewportId,
      representations
    }));
  }
  getSegmentationRepresentationsBySegmentationId(segmentationId) {
    const result = [];
    Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {
      const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);
      if (filteredReps.length > 0) {
        result.push({ viewportId, representations: filteredReps });
      }
    });
    return result;
  }
};
async function internalComputeVolumeLabelmapFromStack({ imageIds, options }) {
  const segmentationImageIds = imageIds;
  const volumeId = (options == null ? void 0 : options.volumeId) || utilities_exports.uuidv4();
  await volumeLoader_exports.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);
  return { volumeId };
}
async function internalConvertStackToVolumeLabelmap({ segmentationId, options }) {
  const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);
  const data = segmentation.representationData.Labelmap;
  const { volumeId } = await internalComputeVolumeLabelmapFromStack({
    imageIds: data.imageIds,
    options
  });
  segmentation.representationData.Labelmap.volumeId = volumeId;
}
function getDefaultRenderingConfig(type) {
  const cfun = vtkColorTransferFunction$1.newInstance();
  const ofun = vtkPiecewiseFunction$1.newInstance();
  ofun.addPoint(0, 0);
  if (type === SegmentationRepresentations_default.Labelmap) {
    return {
      cfun,
      ofun
    };
  } else {
    return {};
  }
}
var defaultSegmentationStateManager = new SegmentationStateManager("DEFAULT");

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
function getSegmentationRepresentations(viewportId, specifier = {}) {
  const segmentationStateManager = defaultSegmentationStateManager;
  return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);
}
function getSegmentationRepresentation(viewportId, specifier) {
  const segmentationStateManager = defaultSegmentationStateManager;
  if (!specifier.segmentationId || !specifier.type) {
    throw new Error("getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them");
  }
  const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);
  return representations == null ? void 0 : representations[0];
}
function getSegmentationRepresentationsBySegmentationId(segmentationId) {
  const segmentationStateManager = defaultSegmentationStateManager;
  return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js
function getActorEntry(viewportId, segmentationId, filterFn) {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  if (!enabledElement) {
    return;
  }
  const { renderingEngine, viewport } = enabledElement;
  if (!renderingEngine || !viewport) {
    return;
  }
  const actors = viewport.getActors();
  const filteredActors = actors.filter(filterFn);
  return filteredActors.length > 0 ? filteredActors[0] : void 0;
}
function getLabelmapActorUID(viewportId, segmentationId) {
  const actorEntry = getLabelmapActorEntry(viewportId, segmentationId);
  return actorEntry == null ? void 0 : actorEntry.uid;
}
function getLabelmapActorEntry(viewportId, segmentationId) {
  return getActorEntry(viewportId, segmentationId, (actor) => {
    var _a2;
    return (_a2 = actor.representationUID) == null ? void 0 : _a2.startsWith(`${segmentationId}-${SegmentationRepresentations_default.Labelmap}`);
  });
}
function getSurfaceActorEntry(viewportId, segmentationId, segmentIndex) {
  return getActorEntry(viewportId, segmentationId, (actor) => {
    var _a2;
    return (_a2 = actor.representationUID) == null ? void 0 : _a2.startsWith(getSurfaceRepresentationUID(segmentationId, segmentIndex));
  });
}
function getSurfaceActorUID(viewportId, segmentationId, segmentIndex) {
  const segIndex = segmentIndex ? segmentIndex.toString() : "";
  const actorEntry = getSurfaceActorEntry(viewportId, segmentationId, segIndex);
  return actorEntry == null ? void 0 : actorEntry.uid;
}
function getSurfaceRepresentationUID(segmentationId, segmentIndex) {
  return `${segmentationId}-${SegmentationRepresentations_default.Surface}-${segmentIndex}`;
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/removeSurfaceFromElement.js
function removeSurfaceFromElement(element, segmentationId) {
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  const actorEntries = viewport.getActors();
  const filteredSurfaceActors = actorEntries.filter((actor) => actor.uid.startsWith(getSurfaceActorUID(viewport.id, segmentationId, "")));
  viewport.removeActors(filteredSurfaceActors.map((actor) => actor.uid));
}
var removeSurfaceFromElement_default = removeSurfaceFromElement;

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/addOrUpdateSurfaceToElement.js
function addOrUpdateSurfaceToElement(element, surface, segmentationId) {
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  const surfaceActorEntry = getSurfaceActorEntry(viewport.id, segmentationId, surface.segmentIndex);
  const surfaceActor = surfaceActorEntry == null ? void 0 : surfaceActorEntry.actor;
  if (surfaceActor) {
    const surfaceMapper = surfaceActor.getMapper();
    const currentPolyData = surfaceMapper.getInputData();
    const newPoints = surface.points;
    const newPolys = surface.polys;
    const currentPoints = currentPolyData.getPoints().getData();
    const currentPolys = currentPolyData.getPolys().getData();
    if (newPoints.length === currentPoints.length && newPolys.length === currentPolys.length) {
      return;
    }
    const polyData = vtkPolyData$1.newInstance();
    polyData.getPoints().setData(newPoints, 3);
    const triangles2 = vtkCellArray$1.newInstance({
      values: Float32Array.from(newPolys)
    });
    polyData.setPolys(triangles2);
    surfaceMapper.setInputData(polyData);
    surfaceMapper.modified();
    viewport.getRenderer().resetCameraClippingRange();
    return;
  }
  const points = surface.points;
  const polys = surface.polys;
  const color = surface.color;
  const surfacePolyData = vtkPolyData$1.newInstance();
  surfacePolyData.getPoints().setData(points, 3);
  const triangles = vtkCellArray$1.newInstance({
    values: Float32Array.from(polys)
  });
  surfacePolyData.setPolys(triangles);
  const mapper = vtkMapper$1.newInstance({});
  let clippingFilter;
  mapper.setInputData(surfacePolyData);
  const actor = vtkActor$1.newInstance();
  actor.setMapper(mapper);
  actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);
  actor.getProperty().setLineWidth(2);
  const representationUID = getSurfaceRepresentationUID(segmentationId, surface.segmentIndex);
  viewport.addActor({
    uid: utilities_exports.uuidv4(),
    actor,
    clippingFilter,
    representationUID
  });
  viewport.resetCamera();
  viewport.getRenderer().resetCameraClippingRange();
  viewport.render();
}
var addOrUpdateSurfaceToElement_default = addOrUpdateSurfaceToElement;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
function getSegmentation(segmentationId) {
  const segmentationStateManager = defaultSegmentationStateManager;
  return segmentationStateManager.getSegmentation(segmentationId);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js
function getColorLUT(index) {
  const segmentationStateManager = defaultSegmentationStateManager;
  return segmentationStateManager.getColorLUT(index);
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/validateLabelmap.js
function validateRepresentationData(segmentationRepresentationData) {
  if ("volumeId" in segmentationRepresentationData) {
    segmentationRepresentationData = segmentationRepresentationData;
    const cachedVolume = cache_default.getVolume(segmentationRepresentationData.volumeId);
    if (!cachedVolume) {
      throw new Error(`volumeId of ${segmentationRepresentationData.volumeId} not found in cache, you should load and cache volume before adding segmentation`);
    }
  } else if ("imageIds" in segmentationRepresentationData) {
    segmentationRepresentationData = segmentationRepresentationData;
    if (!segmentationRepresentationData.imageIds) {
      throw new Error("The segmentationInput.representationData.imageIds is undefined, please provide a valid representationData.imageIds for stack data");
    }
  } else {
    throw new Error("The segmentationInput.representationData is undefined, please provide a valid representationData");
  }
}
function validate(segmentationRepresentationData) {
  validateRepresentationData(segmentationRepresentationData);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/canComputeRequestedRepresentation.js
var conversionPaths = /* @__PURE__ */ new Map([
  [
    SegmentationRepresentations_default.Labelmap,
    /* @__PURE__ */ new Set([
      SegmentationRepresentations_default.Surface,
      SegmentationRepresentations_default.Contour
    ])
  ],
  [
    SegmentationRepresentations_default.Contour,
    /* @__PURE__ */ new Set([
      SegmentationRepresentations_default.Labelmap,
      SegmentationRepresentations_default.Surface
    ])
  ],
  [
    SegmentationRepresentations_default.Surface,
    /* @__PURE__ */ new Set([SegmentationRepresentations_default.Labelmap])
  ]
]);
function canComputeRequestedRepresentation(segmentationId, type) {
  const { representationData } = getSegmentation(segmentationId);
  const existingRepresentationTypes = getExistingRepresentationTypes(representationData);
  return existingRepresentationTypes.some((existingRepresentationType) => canConvertFromTo(existingRepresentationType, type));
}
function getExistingRepresentationTypes(representationData) {
  const supportedTypes = [];
  Object.keys(representationData).forEach((representationType) => {
    const representationTypeData = representationData[representationType];
    let validateFn;
    switch (representationType) {
      case SegmentationRepresentations_default.Labelmap:
        validateFn = validate;
        break;
    }
    if (validateFn) {
      try {
        validateFn(representationTypeData);
        supportedTypes.push(representationType);
      } catch (error) {
        console.warn(`Validation failed for labelmap of type ${representationType}`);
      }
    } else {
      supportedTypes.push(representationType);
    }
  });
  return supportedTypes;
}
async function canConvertFromTo(fromRepresentationType, toRepresentationType) {
  var _a2;
  return ((_a2 = conversionPaths.get(fromRepresentationType)) == null ? void 0 : _a2.has(toRepresentationType)) || false;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js
function internalAddRepresentationData({ segmentationId, type, data }) {
  const segmentation = getSegmentation(segmentationId);
  if (!segmentation) {
    throw new Error(`Segmentation ${segmentationId} not found`);
  }
  if (segmentation.representationData[type]) {
    console.warn(`Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`);
  }
  switch (type) {
    case SegmentationRepresentations_default.Labelmap:
      if (data) {
        segmentation.representationData[type] = data;
      }
      break;
    case SegmentationRepresentations_default.Contour:
      if (data) {
        segmentation.representationData[type] = data;
      }
      break;
    case SegmentationRepresentations_default.Surface:
      if (data) {
        segmentation.representationData[type] = data;
      }
      break;
    default:
      throw new Error(`Invalid representation type ${type}`);
  }
}
var internalAddRepresentationData_default = internalAddRepresentationData;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js
function isObject(value) {
  const type = typeof value;
  return value !== null && (type === "object" || type === "function");
}
var isObject_default = isObject;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js
function debounce(func, wait, options) {
  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;
  let lastInvokeTime = 0;
  let leading = false;
  let maxing = false;
  let trailing = true;
  const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === "function";
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  wait = Number(wait) || 0;
  if (isObject_default(options)) {
    leading = Boolean(options.leading);
    maxing = "maxWait" in options;
    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? Boolean(options.trailing) : trailing;
  }
  function invokeFunc(time) {
    const args = lastArgs;
    const thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function startTimer(pendingFunc, wait2) {
    if (useRAF) {
      return window.requestAnimationFrame(pendingFunc);
    }
    return setTimeout(pendingFunc, wait2);
  }
  function cancelTimer(id) {
    if (useRAF) {
      return window.cancelAnimationFrame(id);
    }
    clearTimeout(id);
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = startTimer(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    const timeWaiting = wait - timeSinceLastCall;
    return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    const time = Date.now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = startTimer(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      cancelTimer(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(Date.now());
  }
  function pending() {
    return timerId !== void 0;
  }
  function debounced2(...args) {
    const time = Date.now();
    const isInvoking = shouldInvoke(time);
    lastArgs = args;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = startTimer(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = startTimer(timerExpired, wait);
    }
    return result;
  }
  debounced2.cancel = cancel;
  debounced2.flush = flush;
  debounced2.pending = pending;
  return debounced2;
}
var debounce_default = debounce;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/registerPolySegWorker.js
var registered = false;
function registerPolySegWorker() {
  if (registered) {
    return;
  }
  registered = true;
  const workerFn = () => {
    return new Worker(new URL("../../../workers/polySegConverters", import.meta.url), {
      name: "polySeg",
      type: "module"
    });
  };
  const workerManager6 = getWebWorkerManager();
  const options = {
    maxWorkerInstances: 1,
    autoTerminateOnIdle: {
      enabled: true,
      idleTimeThreshold: 2e3
    }
  };
  workerManager6.registerWorker("polySeg", workerFn, options);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/computeAndAddRepresentation.js
var computedRepresentations = /* @__PURE__ */ new Map();
async function computeAndAddRepresentation(segmentationId, type, computeFunction, updateFunction, onComputationComplete) {
  registerPolySegWorker();
  const data = await computeFunction();
  internalAddRepresentationData_default({
    segmentationId,
    type,
    data
  });
  onComputationComplete == null ? void 0 : onComputationComplete();
  if (!computedRepresentations.has(segmentationId)) {
    computedRepresentations.set(segmentationId, []);
  }
  const representations = computedRepresentations.get(segmentationId);
  if (!representations.includes(type)) {
    representations.push(type);
  }
  subscribeToSegmentationChanges(updateFunction);
  triggerSegmentationModified(segmentationId);
  return data;
}
function subscribeToSegmentationChanges(updateFunction) {
  const debouncedUpdateFunction = (event) => {
    _debouncedSegmentationModified(event, updateFunction);
  };
  updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;
  eventTarget_default.removeEventListener(Events_default.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);
  eventTarget_default.addEventListener(Events_default.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);
}
var _debouncedSegmentationModified = debounce_default((event, updateFunction) => {
  const segmentationId = event.detail.segmentationId;
  const representations = computedRepresentations.get(segmentationId);
  if (!representations || !representations.length) {
    return;
  }
  updateFunction(segmentationId);
  if (representations.length) {
    triggerSegmentationModified(segmentationId);
  }
}, 300);

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getUniqueSegmentIndices.js
function getUniqueSegmentIndices(segmentationId) {
  const cachedResult = getCachedSegmentIndices(segmentationId);
  if (cachedResult) {
    return cachedResult;
  }
  const segmentation = getSegmentation(segmentationId);
  if (!segmentation) {
    throw new Error(`No segmentation found for segmentationId ${segmentationId}`);
  }
  let indices;
  if (segmentation.representationData.Labelmap) {
    indices = handleLabelmapSegmentation(segmentation, segmentationId);
  } else if (segmentation.representationData.Contour) {
    indices = handleContourSegmentation(segmentation);
  } else if (segmentation.representationData.Surface) {
    indices = handleSurfaceSegmentation(segmentation);
  } else {
    throw new Error(`Unsupported segmentation type: ${segmentation.representationData}`);
  }
  setCachedSegmentIndices(segmentationId, indices);
  return indices;
}
function handleLabelmapSegmentation(segmentation, segmentationId) {
  const labelmapData = segmentation.representationData[SegmentationRepresentations_default.Labelmap];
  const keySet = /* @__PURE__ */ new Set();
  if (labelmapData.imageIds) {
    addImageSegmentIndices(keySet, labelmapData.imageIds);
  } else {
    addVolumeSegmentIndices(keySet, segmentationId);
  }
  return Array.from(keySet).map(Number).sort((a, b) => a - b);
}
function addVolumeSegmentIndices(keySet, segmentationId) {
  const volume = cache_default.getVolume(segmentationId);
  volume.voxelManager.forEach(({ value }) => {
    if (value !== 0) {
      keySet.add(value);
    }
  });
}
function addImageSegmentIndices(keySet, imageIds) {
  imageIds.forEach((segmentationImageId) => {
    const image = cache_default.getImage(segmentationImageId);
    const scalarData = image.voxelManager.getScalarData();
    scalarData.forEach((segmentIndex) => {
      if (segmentIndex !== 0) {
        keySet.add(segmentIndex);
      }
    });
  });
}
function handleContourSegmentation(segmentation) {
  const { annotationUIDsMap, geometryIds } = segmentation.representationData.Contour || {};
  if (!geometryIds) {
    throw new Error(`No geometryIds found for segmentationId ${segmentation.segmentationId}`);
  }
  const indices = /* @__PURE__ */ new Set([...annotationUIDsMap.keys()]);
  geometryIds.forEach((geometryId) => {
    const geometry = cache_default.getGeometry(geometryId);
    indices.add(geometry.data.segmentIndex);
  });
  return Array.from(indices).sort((a, b) => a - b);
}
function handleSurfaceSegmentation(segmentation) {
  var _a2;
  const geometryIds = ((_a2 = segmentation.representationData.Surface) == null ? void 0 : _a2.geometryIds) ?? [];
  return Array.from(geometryIds.keys()).map(Number).sort((a, b) => a - b);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/convertContourToSurface.js
var workerManager = getWebWorkerManager();
var triggerWorkerProgress = (eventTarget, progress, id) => {
  triggerEvent(eventTarget, enums_exports.Events.WEB_WORKER_PROGRESS, {
    progress,
    type: WorkerTypes_default.POLYSEG_CONTOUR_TO_SURFACE,
    id
  });
};
async function convertContourToSurface(contourRepresentationData, segmentIndex) {
  const { annotationUIDsMap } = contourRepresentationData;
  const polylines = [];
  const numPointsArray = [];
  const annotationUIDs = annotationUIDsMap.get(segmentIndex);
  for (const annotationUID of annotationUIDs) {
    const annotation = getAnnotation(annotationUID);
    const { polyline } = annotation.data.contour;
    numPointsArray.push(polyline.length);
    polyline.forEach((polyline2) => polylines.push(...polyline2));
  }
  triggerWorkerProgress(eventTarget_default, 0, segmentIndex);
  const results = await workerManager.executeTask("polySeg", "convertContourToSurface", {
    polylines,
    numPointsArray
  }, {
    callbacks: [
      (progress) => {
        triggerWorkerProgress(eventTarget_default, progress, segmentIndex);
      }
    ]
  });
  triggerWorkerProgress(eventTarget_default, 100, segmentIndex);
  return results;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js
var segmentationColor_exports = {};
__export(segmentationColor_exports, {
  addColorLUT: () => addColorLUT2,
  getSegmentIndexColor: () => getSegmentIndexColor,
  setColorLUT: () => setColorLUT,
  setSegmentIndexColor: () => setSegmentIndexColor
});

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js
function getNextColorLUTIndex() {
  const segmentationStateManager = defaultSegmentationStateManager;
  return segmentationStateManager.getNextColorLUTIndex();
}

// node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js
var CORNERSTONE_COLOR_LUT = [
  [0, 0, 0, 0],
  [221, 84, 84, 255],
  [77, 228, 121, 255],
  [166, 70, 235, 255],
  [189, 180, 116, 255],
  [109, 182, 196, 255],
  [204, 101, 157, 255],
  [123, 211, 94, 255],
  [93, 87, 218, 255],
  [225, 128, 80, 255],
  [73, 232, 172, 255],
  [181, 119, 186, 255],
  [176, 193, 112, 255],
  [105, 153, 200, 255],
  [208, 97, 120, 255],
  [90, 215, 101, 255],
  [135, 83, 222, 255],
  [229, 178, 76, 255],
  [122, 183, 181, 255],
  [190, 115, 171, 255],
  [149, 197, 108, 255],
  [100, 118, 205, 255],
  [212, 108, 93, 255],
  [86, 219, 141, 255],
  [183, 79, 226, 255],
  [233, 233, 72, 255],
  [118, 167, 187, 255],
  [194, 111, 146, 255],
  [116, 201, 104, 255],
  [115, 96, 209, 255],
  [216, 147, 89, 255],
  [82, 223, 188, 255],
  [230, 75, 224, 255],
  [163, 184, 121, 255],
  [114, 143, 191, 255],
  [198, 107, 114, 255],
  [99, 206, 122, 255],
  [153, 92, 213, 255],
  [220, 192, 85, 255],
  [78, 215, 227, 255],
  [234, 71, 173, 255],
  [141, 188, 117, 255],
  [110, 113, 195, 255],
  [202, 128, 103, 255],
  [95, 210, 157, 255],
  [195, 88, 217, 255],
  [206, 224, 81, 255],
  [74, 166, 231, 255],
  [185, 120, 139, 255],
  [113, 192, 113, 255],
  [133, 106, 199, 255],
  [207, 162, 98, 255],
  [91, 214, 198, 255],
  [221, 84, 198, 255],
  [159, 228, 77, 255],
  [70, 111, 235, 255],
  [189, 119, 116, 255],
  [109, 196, 138, 255],
  [165, 101, 204, 255],
  [211, 201, 94, 255],
  [87, 191, 218, 255],
  [225, 80, 153, 255],
  [106, 232, 73, 255],
  [124, 119, 186, 255],
  [193, 142, 112, 255],
  [105, 200, 168, 255],
  [203, 97, 208, 255],
  [184, 215, 90, 255],
  [83, 147, 222, 255],
  [229, 76, 101, 255],
  [122, 183, 130, 255],
  [146, 115, 190, 255],
  [197, 171, 108, 255],
  [100, 205, 205, 255],
  [212, 93, 177, 255],
  [141, 219, 86, 255],
  [79, 97, 226, 255],
  [233, 99, 72, 255],
  [118, 187, 150, 255],
  [173, 111, 194, 255],
  [197, 201, 104, 255],
  [96, 171, 209, 255],
  [216, 89, 137, 255],
  [94, 223, 82, 255],
  [107, 75, 230, 255],
  [184, 153, 121, 255],
  [114, 191, 175, 255],
  [198, 107, 191, 255],
  [166, 206, 99, 255],
  [92, 132, 213, 255],
  [220, 85, 91, 255],
  [78, 227, 115, 255],
  [159, 71, 234, 255],
  [188, 176, 117, 255],
  [110, 185, 195, 255],
  [202, 103, 161, 255],
  [129, 210, 95, 255],
  [88, 88, 217, 255],
  [224, 123, 81, 255],
  [74, 231, 166, 255],
  [177, 120, 185, 255],
  [179, 192, 113, 255],
  [106, 156, 199, 255],
  [207, 98, 125, 255],
  [91, 214, 96, 255],
  [130, 84, 221, 255],
  [228, 171, 77, 255],
  [70, 235, 221, 255],
  [189, 116, 174, 255],
  [153, 196, 109, 255],
  [101, 123, 204, 255],
  [211, 104, 94, 255],
  [87, 218, 136, 255],
  [177, 80, 225, 255],
  [232, 225, 73, 255],
  [119, 169, 186, 255],
  [193, 112, 149, 255],
  [121, 200, 105, 255],
  [111, 97, 208, 255],
  [215, 142, 90, 255],
  [83, 222, 181, 255],
  [229, 76, 229, 255],
  [165, 183, 122, 255],
  [115, 146, 190, 255],
  [197, 108, 119, 255],
  [100, 205, 118, 255],
  [148, 93, 212, 255],
  [219, 186, 86, 255],
  [79, 220, 226, 255],
  [233, 72, 179, 255],
  [144, 187, 118, 255],
  [111, 118, 194, 255],
  [201, 124, 104, 255],
  [96, 209, 153, 255],
  [189, 89, 216, 255],
  [211, 223, 82, 255],
  [75, 172, 230, 255],
  [184, 121, 142, 255],
  [117, 191, 114, 255],
  [130, 107, 198, 255],
  [206, 157, 99, 255],
  [92, 213, 193, 255],
  [220, 85, 203, 255],
  [165, 227, 78, 255],
  [71, 118, 234, 255],
  [188, 117, 117, 255],
  [110, 195, 135, 255],
  [161, 103, 202, 255],
  [210, 195, 95, 255],
  [88, 195, 217, 255],
  [224, 81, 158, 255],
  [113, 231, 74, 255],
  [123, 120, 185, 255],
  [192, 139, 113, 255],
  [106, 199, 164, 255],
  [198, 98, 207, 255],
  [188, 214, 91, 255],
  [84, 153, 221, 255],
  [228, 77, 108, 255],
  [70, 235, 84, 255],
  [143, 116, 189, 255],
  [196, 167, 109, 255],
  [101, 204, 199, 255],
  [211, 94, 182, 255],
  [147, 218, 87, 255],
  [80, 104, 225, 255],
  [232, 93, 73, 255],
  [119, 186, 147, 255],
  [170, 112, 193, 255],
  [200, 200, 105, 255],
  [97, 175, 208, 255],
  [215, 90, 142, 255],
  [100, 222, 83, 255],
  [101, 76, 229, 255],
  [183, 150, 122, 255],
  [115, 190, 171, 255],
  [197, 108, 194, 255],
  [170, 205, 100, 255],
  [93, 138, 212, 255],
  [219, 86, 97, 255],
  [79, 226, 110, 255],
  [153, 72, 233, 255],
  [187, 173, 118, 255],
  [111, 187, 194, 255],
  [201, 104, 165, 255],
  [134, 209, 96, 255],
  [89, 95, 216, 255],
  [223, 117, 82, 255],
  [75, 230, 159, 255],
  [174, 121, 184, 255],
  [182, 191, 114, 255],
  [107, 160, 198, 255],
  [206, 99, 130, 255],
  [92, 213, 92, 255],
  [124, 85, 220, 255],
  [227, 165, 78, 255],
  [71, 234, 214, 255],
  [188, 117, 176, 255],
  [156, 195, 110, 255],
  [103, 128, 202, 255],
  [210, 100, 95, 255],
  [88, 217, 131, 255],
  [170, 81, 224, 255],
  [231, 218, 74, 255],
  [120, 172, 185, 255],
  [192, 113, 153, 255],
  [125, 199, 106, 255],
  [107, 98, 207, 255],
  [214, 137, 91, 255],
  [84, 221, 175, 255],
  [222, 77, 228, 255],
  [194, 235, 70, 255],
  [116, 149, 189, 255],
  [196, 109, 123, 255],
  [101, 204, 114, 255],
  [143, 94, 211, 255],
  [218, 180, 87, 255],
  [80, 225, 225, 255],
  [232, 73, 186, 255],
  [147, 186, 119, 255],
  [112, 122, 193, 255],
  [200, 121, 105, 255],
  [97, 208, 148, 255],
  [184, 90, 215, 255],
  [216, 222, 83, 255],
  [76, 178, 229, 255],
  [183, 122, 145, 255],
  [121, 190, 115, 255],
  [126, 108, 197, 255],
  [205, 153, 100, 255],
  [93, 212, 187, 255],
  [219, 86, 208, 255],
  [171, 226, 79, 255],
  [72, 126, 233, 255],
  [187, 118, 121, 255],
  [111, 194, 132, 255],
  [157, 104, 201, 255],
  [209, 190, 96, 255],
  [89, 200, 216, 255],
  [223, 82, 164, 255],
  [120, 230, 75, 255],
  [121, 121, 184, 255],
  [191, 136, 114, 255],
  [107, 198, 160, 255],
  [192, 99, 206, 255],
  [193, 213, 92, 255],
  [85, 158, 220, 255],
  [227, 78, 115, 255],
  [71, 234, 78, 255],
  [141, 117, 188, 255],
  [195, 163, 110, 255],
  [103, 202, 194, 255],
  [210, 95, 186, 255],
  [153, 217, 88, 255],
  [81, 111, 224, 255]
];
var COLOR_LUT_default = CORNERSTONE_COLOR_LUT;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js
function addColorLUT(colorLUT, index) {
  const segmentationStateManager = defaultSegmentationStateManager;
  const indexToUse = index ?? getNextColorLUTIndex();
  let colorLUTToUse = [...colorLUT];
  if (!utilities_exports.isEqual(colorLUTToUse[0], [0, 0, 0, 0])) {
    console.warn("addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it");
    colorLUTToUse = [[0, 0, 0, 0], ...colorLUTToUse];
  }
  colorLUTToUse = colorLUTToUse.map((color) => {
    if (color.length === 3) {
      return [color[0], color[1], color[2], 255];
    }
    return color;
  });
  if (colorLUTToUse.length < 255) {
    const missingColorLUTs = COLOR_LUT_default.slice(colorLUTToUse.length);
    colorLUTToUse = [...colorLUTToUse, ...missingColorLUTs];
  }
  segmentationStateManager.addColorLUT(colorLUTToUse, indexToUse);
  return indexToUse;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js
function addColorLUT2(colorLUT, colorLUTIndex) {
  if (!colorLUT) {
    throw new Error("addColorLUT: colorLUT is required");
  }
  return addColorLUT(colorLUT, colorLUTIndex);
}
function setColorLUT(viewportId, segmentationId, colorLUTsIndex) {
  if (!getColorLUT(colorLUTsIndex)) {
    throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);
  }
  const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });
  if (!segmentationRepresentations) {
    throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);
  }
  segmentationRepresentations.forEach((segmentationRepresentation) => {
    segmentationRepresentation.colorLUTIndex = colorLUTsIndex;
  });
  triggerSegmentationRepresentationModified(viewportId, segmentationId);
}
function getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {
  const representations = getSegmentationRepresentations(viewportId, {
    segmentationId
  });
  if (!representations || representations.length === 0) {
    return null;
  }
  const representation = representations[0];
  const { colorLUTIndex } = representation;
  const colorLUT = getColorLUT(colorLUTIndex);
  let colorValue = colorLUT[segmentIndex];
  if (!colorValue) {
    if (typeof segmentIndex !== "number") {
      throw new Error(`Can't create colour for LUT index ${segmentIndex}`);
    }
    colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];
  }
  return colorValue;
}
function setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {
  const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);
  for (let i = 0; i < color.length; i++) {
    colorReference[i] = color[i];
  }
  triggerSegmentationRepresentationModified(viewportId, segmentationId);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/createAndCacheSurfacesFromRaw.js
async function createAndCacheSurfacesFromRaw(segmentationId, rawSurfacesData, options = {}) {
  const segmentation = getSegmentation(segmentationId);
  const geometryIds = /* @__PURE__ */ new Map();
  const promises = Object.keys(rawSurfacesData).map(async (index) => {
    const rawSurfaceData = rawSurfacesData[index];
    const segmentIndex = rawSurfaceData.segmentIndex;
    const color = getSegmentIndexColor(options.viewport.id, segmentation.segmentationId, segmentIndex).slice(0, 3);
    if (!color) {
      throw new Error("No color found for segment index, unable to create surface");
    }
    const closedSurface = {
      id: `segmentation_${segmentation.segmentationId}_surface_${segmentIndex}`,
      color,
      frameOfReferenceUID: "test-frameOfReferenceUID",
      points: rawSurfaceData.data.points,
      polys: rawSurfaceData.data.polys,
      segmentIndex
    };
    const geometryId = closedSurface.id;
    geometryIds.set(segmentIndex, geometryId);
    return geometryLoader_exports.createAndCacheGeometry(geometryId, {
      type: enums_exports.GeometryType.SURFACE,
      geometryData: closedSurface
    });
  });
  await Promise.all(promises);
  return {
    geometryIds
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js
async function computeVolumeLabelmapFromStack(args) {
  return internalComputeVolumeLabelmapFromStack(args);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/convertLabelmapToSurface.js
var workerManager2 = getWebWorkerManager();
var triggerWorkerProgress2 = (eventTarget, progress, id) => {
  triggerEvent(eventTarget, enums_exports.Events.WEB_WORKER_PROGRESS, {
    progress,
    type: WorkerTypes_default.POLYSEG_LABELMAP_TO_SURFACE,
    id
  });
};
async function convertLabelmapToSurface(labelmapRepresentationData, segmentIndex) {
  let volumeId;
  if (labelmapRepresentationData.volumeId) {
    volumeId = labelmapRepresentationData.volumeId;
  } else {
    const { imageIds } = labelmapRepresentationData;
    ({ volumeId } = await computeVolumeLabelmapFromStack({
      imageIds
    }));
  }
  const volume = cache_default.getVolume(volumeId);
  const scalarData = volume.voxelManager.getCompleteScalarDataArray();
  const { dimensions, spacing, origin, direction } = volume;
  triggerWorkerProgress2(eventTarget_default, 0, segmentIndex);
  const results = await workerManager2.executeTask("polySeg", "convertLabelmapToSurface", {
    scalarData,
    dimensions,
    spacing,
    origin,
    direction,
    segmentIndex
  }, {
    callbacks: [
      (progress) => {
        triggerWorkerProgress2(eventTarget_default, progress, segmentIndex);
      }
    ]
  });
  triggerWorkerProgress2(eventTarget_default, 100, segmentIndex);
  return results;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/surfaceComputationStrategies.js
async function computeSurfaceData(segmentationId, options = {}) {
  var _a2;
  const segmentIndices = ((_a2 = options.segmentIndices) == null ? void 0 : _a2.length) ? options.segmentIndices : getUniqueSegmentIndices(segmentationId);
  let rawSurfacesData;
  const segmentation = getSegmentation(segmentationId);
  const representationData = segmentation.representationData;
  try {
    if (representationData.Contour) {
      rawSurfacesData = await computeSurfaceFromContourSegmentation(segmentationId, {
        segmentIndices,
        ...options
      });
    } else if (representationData.Labelmap) {
      rawSurfacesData = await computeSurfaceFromLabelmapSegmentation(segmentation.segmentationId, {
        segmentIndices,
        ...options
      });
    }
  } catch (error) {
    console.error(error);
    throw error;
  }
  if (!rawSurfacesData) {
    throw new Error("Not enough data to convert to surface, currently only support converting volume labelmap to surface if available");
  }
  const surfacesData = await createAndCacheSurfacesFromRaw(segmentationId, rawSurfacesData, options);
  return surfacesData;
}
async function computeSurfaceFromLabelmapSegmentation(segmentationId, options = {}) {
  var _a2;
  const segmentation = getSegmentation(segmentationId);
  if (!((_a2 = segmentation == null ? void 0 : segmentation.representationData) == null ? void 0 : _a2.Labelmap)) {
    console.warn("Only support surface update from labelmaps");
    return;
  }
  const labelmapRepresentationData = segmentation.representationData.Labelmap;
  const segmentIndices = options.segmentIndices || getUniqueSegmentIndices(segmentationId);
  const promises = segmentIndices.map((index) => {
    const surface = convertLabelmapToSurface(labelmapRepresentationData, index);
    return surface;
  });
  const surfaces = await Promise.allSettled(promises);
  const errors = surfaces.filter((p) => p.status === "rejected");
  if (errors.length > 0) {
    console.error(errors);
    throw new Error("Failed to convert labelmap to surface");
  }
  const rawSurfacesData = surfaces.map((surface, index) => {
    if (surface.status === "fulfilled") {
      return { segmentIndex: segmentIndices[index], data: surface.value };
    }
  }).filter(Boolean);
  return rawSurfacesData;
}
async function computeSurfaceFromContourSegmentation(segmentationId, options = {}) {
  const segmentation = getSegmentation(segmentationId);
  const contourRepresentationData = segmentation.representationData.Contour;
  const segmentIndices = options.segmentIndices || getUniqueSegmentIndices(segmentationId);
  const promises = segmentIndices.map(async (index) => {
    const surface = await convertContourToSurface(contourRepresentationData, index);
    return { segmentIndex: index, data: surface };
  });
  const surfaces = await Promise.all(promises);
  return surfaces;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js
function getViewportIdsWithSegmentation(segmentationId) {
  const segmentationStateManager = defaultSegmentationStateManager;
  const state8 = segmentationStateManager.getState();
  const viewportSegRepresentations = state8.viewportSegRepresentations;
  const viewportIdsWithSegmentation = Object.entries(viewportSegRepresentations).filter(([, viewportSegmentations]) => viewportSegmentations.some((segRep) => segRep.segmentationId === segmentationId)).map(([viewportId]) => viewportId);
  return viewportIdsWithSegmentation;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/updateSurfaceData.js
async function updateSurfaceData(segmentationId) {
  const surfacesObj = await computeSurfaceFromLabelmapSegmentation(segmentationId);
  if (!surfacesObj) {
    return;
  }
  const segmentation = getSegmentation(segmentationId);
  const indices = getUniqueSegmentIndices(segmentationId);
  if (!indices.length) {
    const geometryIds = segmentation.representationData.Surface.geometryIds;
    geometryIds.forEach((geometryId) => {
      const geometry = cache_default.getGeometry(geometryId);
      const surface = geometry.data;
      surface.points = [];
      surface.polys = [];
    });
    triggerSegmentationModified(segmentationId);
    return;
  }
  const promises = surfacesObj.map(({ data, segmentIndex }) => {
    const geometryId = `segmentation_${segmentationId}_surface_${segmentIndex}`;
    const geometry = cache_default.getGeometry(geometryId);
    if (!geometry) {
      const viewportIds = getViewportIdsWithSegmentation(segmentationId);
      return viewportIds.map((viewportId) => {
        const surfaceRepresentation = getSegmentationRepresentation(viewportId, {
          segmentationId,
          type: SegmentationRepresentations_default.Surface
        });
        return [surfaceRepresentation].map((surfaceRepresentation2) => {
          segmentation.representationData.Surface.geometryIds.set(segmentIndex, geometryId);
          return createAndCacheSurfacesFromRaw(segmentationId, [{ segmentIndex, data }], {
            segmentationId: surfaceRepresentation2.segmentationId
          });
        });
      });
    } else if (indices.includes(segmentIndex)) {
      const surface = geometry.data;
      surface.points = data.points;
      surface.polys = data.polys;
    } else {
      const surface = geometry.data;
      surface.points = [];
      surface.polys = [];
    }
  });
  await Promise.all(promises);
  triggerSegmentationModified(segmentationId);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/computeAndAddSurfaceRepresentation.js
function computeAndAddSurfaceRepresentation(segmentationId, options = {}) {
  return computeAndAddRepresentation(segmentationId, SegmentationRepresentations_default.Surface, () => computeSurfaceData(segmentationId, options), () => updateSurfaceData(segmentationId));
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js
var { ViewportType } = enums_exports;
function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  removeSurfaceFromElement_default(viewport.element, segmentationId);
  if (!renderImmediate) {
    return;
  }
  viewport.render();
}
async function render(viewport, representation) {
  const { segmentationId } = representation;
  const segmentation = getSegmentation(segmentationId);
  if (!segmentation) {
    return;
  }
  let SurfaceData = segmentation.representationData[SegmentationRepresentations_default.Surface];
  if (!SurfaceData && canComputeRequestedRepresentation(segmentationId, SegmentationRepresentations_default.Surface)) {
    SurfaceData = await computeAndAddSurfaceRepresentation(segmentationId, {
      viewport
    });
    if (!SurfaceData) {
      throw new Error(`No Surface data found for segmentationId ${segmentationId}.`);
    }
  }
  const { geometryIds } = SurfaceData;
  if (!(geometryIds == null ? void 0 : geometryIds.size)) {
    console.warn(`No Surfaces found for segmentationId ${segmentationId}. Skipping render.`);
  }
  const { colorLUTIndex } = representation;
  const colorLUT = getColorLUT(colorLUTIndex);
  const surfaces = [];
  geometryIds.forEach((geometryId) => {
    const geometry = cache_default.getGeometry(geometryId);
    if (!(geometry == null ? void 0 : geometry.data)) {
      console.warn(`No Surfaces found for geometryId ${geometryId}. Skipping render.`);
      return;
    }
    const segmentIndex = geometry.data.segmentIndex;
    const surface = geometry.data;
    const color = colorLUT[segmentIndex];
    surface.color = color.slice(0, 3);
    surfaces.push(surface);
    addOrUpdateSurfaceToElement_default(viewport.element, surface, segmentationId);
  });
  viewport.render();
}
var surfaceDisplay_default = {
  render,
  removeRepresentation
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js
function annotationHydration(viewport, toolName, worldPoints, options) {
  const viewReference = viewport.getViewReference();
  const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;
  const annotation = {
    annotationUID: (options == null ? void 0 : options.annotationUID) || utilities_exports.uuidv4(),
    data: {
      handles: {
        points: worldPoints
      }
    },
    highlighted: false,
    autoGenerated: false,
    invalidated: false,
    isLocked: false,
    isVisible: true,
    metadata: {
      toolName,
      viewPlaneNormal,
      FrameOfReferenceUID,
      referencedImageId: getReferencedImageId(viewport, worldPoints[0], viewPlaneNormal),
      ...options
    }
  };
  addAnnotation(annotation, viewport.element);
  return annotation;
}
function getReferencedImageId(viewport, worldPos, viewPlaneNormal) {
  let referencedImageId;
  if (viewport instanceof StackViewport_default) {
    referencedImageId = getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal);
  } else if (viewport instanceof BaseVolumeViewport_default) {
    const targetId = getTargetId(viewport);
    const volumeId = utilities_exports.getVolumeId(targetId);
    const imageVolume = cache_default.getVolume(volumeId);
    referencedImageId = utilities_exports.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
  } else {
    throw new Error("getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport");
  }
  return referencedImageId;
}
function getTargetId(viewport) {
  var _a2;
  const targetId = (_a2 = viewport.getViewReferenceId) == null ? void 0 : _a2.call(viewport);
  if (targetId) {
    return targetId;
  }
  if (viewport instanceof BaseVolumeViewport_default) {
    return `volumeId:${getTargetVolumeId(viewport)}`;
  }
  throw new Error("getTargetId: viewport must have a getTargetId method");
}
function getTargetVolumeId(viewport) {
  var _a2;
  const actorEntries = viewport.getActors();
  if (!actorEntries) {
    return;
  }
  return (_a2 = actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === "vtkVolume")) == null ? void 0 : _a2.uid;
}
function getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal) {
  const imageIds = viewport.getImageIds();
  if (!imageIds || !imageIds.length) {
    return;
  }
  const distanceImagePairs = imageIds.map((imageId) => {
    const { imagePositionPatient } = metaData_exports.get("imagePlaneModule", imageId);
    const distance = calculateDistanceToImage(worldPos, imagePositionPatient, viewPlaneNormal);
    return { imageId, distance };
  });
  distanceImagePairs.sort((a, b) => a.distance - b.distance);
  return distanceImagePairs[0].imageId;
}
function calculateDistanceToImage(worldPos, ImagePositionPatient, viewPlaneNormal) {
  const dir = vec3_exports.create();
  vec3_exports.sub(dir, worldPos, ImagePositionPatient);
  const dot = vec3_exports.dot(dir, viewPlaneNormal);
  return Math.abs(dot);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js
var contourSegmentation_exports = {};
__export(contourSegmentation_exports, {
  addContourSegmentationAnnotation: () => addContourSegmentationAnnotation,
  areSameSegment: () => areSameSegment,
  isContourSegmentationAnnotation: () => isContourSegmentationAnnotation,
  removeContourSegmentationAnnotation: () => removeContourSegmentationAnnotation
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/areSameSegment.js
function areSameSegment(firstAnnotation, secondAnnotation) {
  const { segmentation: firstSegmentation } = firstAnnotation.data;
  const { segmentation: secondSegmentation } = secondAnnotation.data;
  return firstSegmentation.segmentationId === secondSegmentation.segmentationId && firstSegmentation.segmentIndex === secondSegmentation.segmentIndex;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/isContourSegmentationAnnotation.js
function isContourSegmentationAnnotation(annotation) {
  var _a2;
  return !!((_a2 = annotation.data) == null ? void 0 : _a2.segmentation);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addContourSegmentationAnnotation.js
function addContourSegmentationAnnotation(annotation) {
  if (annotation.parentAnnotationUID) {
    return;
  }
  if (!annotation.data.segmentation) {
    throw new Error("addContourSegmentationAnnotation: annotation does not have a segmentation data");
  }
  const { segmentationId, segmentIndex } = annotation.data.segmentation;
  const segmentation = getSegmentation(segmentationId);
  if (!segmentation.representationData.Contour) {
    segmentation.representationData.Contour = { annotationUIDsMap: /* @__PURE__ */ new Map() };
  }
  let { annotationUIDsMap } = segmentation.representationData.Contour;
  if (!annotationUIDsMap) {
    annotationUIDsMap = /* @__PURE__ */ new Map();
  }
  let annotationsUIDsSet = annotationUIDsMap == null ? void 0 : annotationUIDsMap.get(segmentIndex);
  if (!annotationsUIDsSet) {
    annotationsUIDsSet = /* @__PURE__ */ new Set();
    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);
  }
  annotationUIDsMap.set(segmentIndex, annotationsUIDsSet.add(annotation.annotationUID));
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/removeContourSegmentationAnnotation.js
function removeContourSegmentationAnnotation(annotation) {
  if (!annotation.data.segmentation) {
    throw new Error("removeContourSegmentationAnnotation: annotation does not have a segmentation data");
  }
  const { segmentationId, segmentIndex } = annotation.data.segmentation;
  const segmentation = getSegmentation(segmentationId);
  const { annotationUIDsMap } = (segmentation == null ? void 0 : segmentation.representationData.Contour) || {};
  const annotationsUIDsSet = annotationUIDsMap == null ? void 0 : annotationUIDsMap.get(segmentIndex);
  if (!annotationsUIDsSet) {
    return;
  }
  annotationsUIDsSet.delete(annotation.annotationUID);
  if (!annotationsUIDsSet.size) {
    annotationUIDsMap.delete(segmentIndex);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/utils.js
function validateGeometry(geometry) {
  if (!geometry) {
    throw new Error(`No contours found for geometryId ${geometry.id}`);
  }
  const geometryId = geometry.id;
  if (geometry.type !== enums_exports.GeometryType.CONTOUR) {
    throw new Error(`Geometry type ${geometry.type} not supported for rendering.`);
  }
  if (!geometry.data) {
    console.warn(`No contours found for geometryId ${geometryId}. Skipping render.`);
    return;
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/handleContourSegmentation.js
function handleContourSegmentation2(viewport, geometryIds, annotationUIDsMap, contourRepresentation) {
  if (annotationUIDsMap.size) {
    viewport.render();
  } else {
    addContourSetsToElement(viewport, geometryIds, contourRepresentation);
  }
}
function addContourSetsToElement(viewport, geometryIds, contourRepresentation) {
  const { segmentationId } = contourRepresentation;
  const segmentSpecificMap = /* @__PURE__ */ new Map();
  geometryIds.forEach((geometryId) => {
    const geometry = cache_default.getGeometry(geometryId);
    if (!geometry) {
      console.warn(`No geometry found for geometryId ${geometryId}. Skipping render.`);
      return;
    }
    const segmentIndex = geometry.data.segmentIndex;
    validateGeometry(geometry);
    const segmentSpecificConfig = segmentationStyle.getStyle({
      viewportId: viewport.id,
      segmentationId,
      type: SegmentationRepresentations_default.Contour,
      segmentIndex
    });
    const contourSet = geometry.data;
    const viewPlaneNormal = viewport.getCamera().viewPlaneNormal;
    contourSet.contours.forEach((contour) => {
      const { points, color, id } = contour;
      const referencedImageId = getClosestImageIdForStackViewport(viewport, points[0], viewPlaneNormal);
      const contourSegmentationAnnotation = {
        annotationUID: utilities_exports.uuidv4(),
        data: {
          contour: {
            closed: true,
            polyline: points
          },
          segmentation: {
            segmentationId,
            segmentIndex,
            color,
            id
          },
          handles: {}
        },
        handles: {},
        highlighted: false,
        autoGenerated: false,
        invalidated: false,
        isLocked: true,
        isVisible: true,
        metadata: {
          referencedImageId,
          toolName: "PlanarFreehandContourSegmentationTool",
          FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
          viewPlaneNormal: viewport.getCamera().viewPlaneNormal
        }
      };
      const annotationGroupSelector = viewport.element;
      addAnnotation(contourSegmentationAnnotation, annotationGroupSelector);
      addContourSegmentationAnnotation(contourSegmentationAnnotation);
    });
    if (segmentSpecificConfig) {
      segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);
    }
  });
  viewport.resetCamera();
  viewport.render();
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js
function pointToString(point, decimals = 5) {
  return parseFloat(point[0]).toFixed(decimals) + "," + parseFloat(point[1]).toFixed(decimals) + "," + parseFloat(point[2]).toFixed(decimals) + ",";
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clipAndCacheSurfacesForViewport.js
var workerManager3 = getWebWorkerManager();
var polyDataCache = /* @__PURE__ */ new Map();
var surfacesAABBCache = /* @__PURE__ */ new Map();
var triggerWorkerProgress3 = (eventTarget, progress) => {
  triggerEvent(eventTarget, enums_exports.Events.WEB_WORKER_PROGRESS, {
    progress,
    type: WorkerTypes_default.SURFACE_CLIPPING
  });
};
async function clipAndCacheSurfacesForViewport(surfacesInfo, viewport) {
  var _a2;
  registerPolySegWorker();
  const planesInfo = (_a2 = viewport.getSlicesClippingPlanes) == null ? void 0 : _a2.call(viewport);
  if (!planesInfo) {
    return;
  }
  const currentSliceIndex = viewport.getSliceIndex();
  planesInfo.sort((a, b) => {
    const diffA = Math.abs(a.sliceIndex - currentSliceIndex);
    const diffB = Math.abs(b.sliceIndex - currentSliceIndex);
    return diffA - diffB;
  });
  triggerWorkerProgress3(eventTarget_default, 0);
  await updateSurfacesAABBCache(surfacesInfo);
  const surfacesAABB = /* @__PURE__ */ new Map();
  surfacesInfo.forEach((surface) => {
    surfacesAABB.set(surface.id, surfacesAABBCache.get(surface.id));
  });
  const camera = viewport.getCamera();
  await workerManager3.executeTask("polySeg", "cutSurfacesIntoPlanes", {
    surfacesInfo,
    planesInfo,
    surfacesAABB
  }, {
    callbacks: [
      ({ progress }) => {
        triggerWorkerProgress3(eventTarget_default, progress);
      },
      ({ sliceIndex, polyDataResults }) => {
        polyDataResults.forEach((polyDataResult, segmentIndex) => {
          const segmentIndexNumber = Number(segmentIndex);
          const cacheId = generateCacheId(viewport, camera.viewPlaneNormal, sliceIndex);
          updatePolyDataCache(segmentIndexNumber, cacheId, polyDataResult);
        });
      }
    ]
  }).catch((error) => {
    console.error(error);
  });
  triggerWorkerProgress3(eventTarget_default, 100);
  return polyDataCache;
}
async function updateSurfacesAABBCache(surfacesInfo) {
  const surfacesWithoutAABB = surfacesInfo.filter((surface) => !surfacesAABBCache.has(surface.id));
  if (!surfacesWithoutAABB.length) {
    return;
  }
  const surfacesAABB = await workerManager3.executeTask("polySeg", "getSurfacesAABBs", {
    surfacesInfo: surfacesWithoutAABB
  }, {
    callbacks: [
      ({ progress }) => {
        triggerWorkerProgress3(eventTarget_default, progress);
      }
    ]
  });
  surfacesAABB.forEach((aabb, id) => {
    surfacesAABBCache.set(id, aabb);
  });
}
function generateCacheId(viewport, viewPlaneNormal, sliceIndex) {
  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${sliceIndex}`;
}
function updatePolyDataCache(segmentIndex, cacheId, polyDataResult) {
  const { points, lines, numberOfCells } = polyDataResult;
  let segmentCache = polyDataCache.get(segmentIndex);
  if (!segmentCache) {
    segmentCache = /* @__PURE__ */ new Map();
    polyDataCache.set(segmentIndex, segmentCache);
  }
  segmentCache.set(cacheId, { points, lines, numberOfCells });
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Contour/utils/extractContourData.js
function extractContourData(polyDataCache2) {
  const rawResults = /* @__PURE__ */ new Map();
  for (const [segmentIndex, intersectionInfo] of polyDataCache2) {
    const segmentIndexNumber = Number(segmentIndex);
    for (const [_, result] of intersectionInfo) {
      if (!result) {
        continue;
      }
      if (!rawResults.has(segmentIndexNumber)) {
        rawResults.set(segmentIndexNumber, []);
      }
      rawResults.get(segmentIndexNumber).push(result);
    }
  }
  return rawResults;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js
var { CalibrationTypes } = enums_exports;
var PIXEL_UNITS = "px";
var SUPPORTED_REGION_DATA_TYPES = [
  1
];
var SUPPORTED_LENGTH_VARIANT = [
  "3,3"
];
var SUPPORTED_PROBE_VARIANT = [
  "4,3"
];
var UNIT_MAPPING = {
  0: "px",
  1: "percent",
  2: "dB",
  3: "cm",
  4: "seconds",
  5: "hertz",
  6: "dB/seconds",
  7: "cm/sec",
  8: "cm",
  9: "cm/s",
  12: "degrees"
};
var EPS = 1e-3;
var SQUARE = "";
var getCalibratedLengthUnitsAndScale = (image, handles) => {
  const { calibration, hasPixelSpacing } = image;
  let unit = hasPixelSpacing ? "mm" : PIXEL_UNITS;
  let areaUnit = unit + SQUARE;
  let scale = 1;
  let calibrationType = "";
  if (!calibration || !calibration.type && !calibration.sequenceOfUltrasoundRegions) {
    return { unit, areaUnit, scale };
  }
  if (calibration.type === CalibrationTypes.UNCALIBRATED) {
    return { unit: PIXEL_UNITS, areaUnit: PIXEL_UNITS + SQUARE, scale };
  }
  if (calibration.sequenceOfUltrasoundRegions) {
    let imageIndex1, imageIndex2;
    if (Array.isArray(handles) && handles.length === 2) {
      [imageIndex1, imageIndex2] = handles;
    } else if (typeof handles === "function") {
      const points = handles();
      imageIndex1 = points[0];
      imageIndex2 = points[1];
    }
    let regions = calibration.sequenceOfUltrasoundRegions.filter((region2) => imageIndex1[0] >= region2.regionLocationMinX0 && imageIndex1[0] <= region2.regionLocationMaxX1 && imageIndex1[1] >= region2.regionLocationMinY0 && imageIndex1[1] <= region2.regionLocationMaxY1 && imageIndex2[0] >= region2.regionLocationMinX0 && imageIndex2[0] <= region2.regionLocationMaxX1 && imageIndex2[1] >= region2.regionLocationMinY0 && imageIndex2[1] <= region2.regionLocationMaxY1);
    if (!(regions == null ? void 0 : regions.length)) {
      return { unit, areaUnit, scale };
    }
    regions = regions.filter((region2) => SUPPORTED_REGION_DATA_TYPES.includes(region2.regionDataType) && SUPPORTED_LENGTH_VARIANT.includes(`${region2.physicalUnitsXDirection},${region2.physicalUnitsYDirection}`));
    if (!regions.length) {
      return {
        unit: PIXEL_UNITS,
        areaUnit: PIXEL_UNITS + SQUARE,
        scale
      };
    }
    const region = regions[0];
    const physicalDeltaX = Math.abs(region.physicalDeltaX);
    const physicalDeltaY = Math.abs(region.physicalDeltaY);
    const isSamePhysicalDelta = utilities_exports.isEqual(physicalDeltaX, physicalDeltaY, EPS);
    if (isSamePhysicalDelta) {
      scale = 1 / physicalDeltaX;
      calibrationType = "US Region";
      unit = UNIT_MAPPING[region.physicalUnitsXDirection] || "unknown";
      areaUnit = unit + SQUARE;
    } else {
      return {
        unit: PIXEL_UNITS,
        areaUnit: PIXEL_UNITS + SQUARE,
        scale
      };
    }
  } else if (calibration.scale) {
    scale = calibration.scale;
  }
  const types = [
    CalibrationTypes.ERMF,
    CalibrationTypes.USER,
    CalibrationTypes.ERROR,
    CalibrationTypes.PROJECTION
  ];
  if (types.includes(calibration == null ? void 0 : calibration.type)) {
    calibrationType = calibration.type;
  }
  return {
    unit: unit + (calibrationType ? ` ${calibrationType}` : ""),
    areaUnit: areaUnit + (calibrationType ? ` ${calibrationType}` : ""),
    scale
  };
};
var getCalibratedProbeUnitsAndValue = (image, handles) => {
  const [imageIndex] = handles;
  const { calibration } = image;
  let units = ["raw"];
  let values = [null];
  let calibrationType = "";
  if (!calibration || !calibration.type && !calibration.sequenceOfUltrasoundRegions) {
    return { units, values };
  }
  if (calibration.sequenceOfUltrasoundRegions) {
    const supportedRegionsMetadata = calibration.sequenceOfUltrasoundRegions.filter((region2) => SUPPORTED_REGION_DATA_TYPES.includes(region2.regionDataType) && SUPPORTED_PROBE_VARIANT.includes(`${region2.physicalUnitsXDirection},${region2.physicalUnitsYDirection}`));
    if (!(supportedRegionsMetadata == null ? void 0 : supportedRegionsMetadata.length)) {
      return { units, values };
    }
    const region = supportedRegionsMetadata.find((region2) => imageIndex[0] >= region2.regionLocationMinX0 && imageIndex[0] <= region2.regionLocationMaxX1 && imageIndex[1] >= region2.regionLocationMinY0 && imageIndex[1] <= region2.regionLocationMaxY1);
    if (!region) {
      return { units, values };
    }
    const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;
    const { physicalDeltaX, physicalDeltaY } = region;
    const yValue = (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) * physicalDeltaY;
    const xValue = (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) * physicalDeltaX;
    calibrationType = "US Region";
    values = [xValue, yValue];
    units = [
      UNIT_MAPPING[region.physicalUnitsXDirection],
      UNIT_MAPPING[region.physicalUnitsYDirection]
    ];
  }
  return {
    units,
    values,
    calibrationType
  };
};
var getCalibratedAspect = (image) => {
  var _a2;
  return ((_a2 = image.calibration) == null ? void 0 : _a2.aspect) || 1;
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js
var math_exports = {};
__export(math_exports, {
  BasicStatsCalculator: () => basic_exports,
  aabb: () => aabb_exports,
  circle: () => circle_exports,
  ellipse: () => ellipse_exports,
  lineSegment: () => line_exports,
  point: () => point_exports,
  polyline: () => polyline_exports,
  rectangle: () => rectangle_exports,
  vec2: () => vec2_exports2
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/index.js
var aabb_exports = {};
__export(aabb_exports, {
  distanceToPoint: () => distanceToPoint,
  distanceToPointSquared: () => distanceToPointSquared,
  intersectAABB: () => intersectAABB
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/intersectAABB.js
function intersectAABB(aabb1, aabb2) {
  return aabb1.minX <= aabb2.maxX && aabb1.maxX >= aabb2.minX && aabb1.minY <= aabb2.maxY && aabb1.maxY >= aabb2.minY;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/distanceToPointSquared.js
function distanceToPointSquared(aabb, point) {
  const aabbWidth = aabb.maxX - aabb.minX;
  const aabbHeight = aabb.maxY - aabb.minY;
  const aabbSize = [aabbWidth, aabbHeight];
  const aabbCenter = [
    aabb.minX + aabbWidth / 2,
    aabb.minY + aabbHeight / 2
  ];
  const translatedPoint = [
    Math.abs(point[0] - aabbCenter[0]),
    Math.abs(point[1] - aabbCenter[1])
  ];
  const dx = translatedPoint[0] - aabbSize[0] * 0.5;
  const dy = translatedPoint[1] - aabbSize[1] * 0.5;
  if (dx > 0 && dy > 0) {
    return dx * dx + dy * dy;
  }
  const dist = Math.max(dx, 0) + Math.max(dy, 0);
  return dist * dist;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/aabb/distanceToPoint.js
function distanceToPoint(aabb, point) {
  return Math.sqrt(distanceToPointSquared(aabb, point));
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js
var basic_exports = {};
__export(basic_exports, {
  BasicStatsCalculator: () => BasicStatsCalculator,
  Calculator: () => Calculator_default
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/Calculator.js
var Calculator = class {
};
var Calculator_default = Calculator;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/BasicStatsCalculator.js
var { PointsManager } = utilities_exports;
var _BasicStatsCalculator = class _BasicStatsCalculator extends Calculator_default {
  static statsInit(options) {
    if (!options.storePointData) {
      _BasicStatsCalculator.pointsInShape = null;
    }
  }
};
_BasicStatsCalculator.max = [-Infinity];
_BasicStatsCalculator.min = [Infinity];
_BasicStatsCalculator.sum = [0];
_BasicStatsCalculator.count = 0;
_BasicStatsCalculator.runMean = [0];
_BasicStatsCalculator.m2 = [0];
_BasicStatsCalculator.pointsInShape = PointsManager.create3(1024);
_BasicStatsCalculator.statsCallback = ({ value: newValue, pointLPS = null }) => {
  var _a2;
  if (Array.isArray(newValue) && newValue.length > 1 && _BasicStatsCalculator.max.length === 1) {
    _BasicStatsCalculator.max.push(_BasicStatsCalculator.max[0], _BasicStatsCalculator.max[0]);
    _BasicStatsCalculator.min.push(_BasicStatsCalculator.min[0], _BasicStatsCalculator.min[0]);
    _BasicStatsCalculator.sum.push(_BasicStatsCalculator.sum[0], _BasicStatsCalculator.sum[0]);
    _BasicStatsCalculator.runMean.push(0, 0);
    _BasicStatsCalculator.m2.push(_BasicStatsCalculator.m2[0], _BasicStatsCalculator.m2[0]);
  }
  if (_BasicStatsCalculator.pointsInShape && pointLPS) {
    (_a2 = _BasicStatsCalculator.pointsInShape) == null ? void 0 : _a2.push(pointLPS);
  }
  const newArray = Array.isArray(newValue) ? newValue : [newValue];
  _BasicStatsCalculator.count += 1;
  _BasicStatsCalculator.max.map((it, idx) => {
    const value = newArray[idx];
    const delta = value - _BasicStatsCalculator.runMean[idx];
    _BasicStatsCalculator.sum[idx] += value;
    _BasicStatsCalculator.runMean[idx] += delta / _BasicStatsCalculator.count;
    const delta2 = value - _BasicStatsCalculator.runMean[idx];
    _BasicStatsCalculator.m2[idx] += delta * delta2;
    _BasicStatsCalculator.min[idx] = Math.min(_BasicStatsCalculator.min[idx], value);
    _BasicStatsCalculator.max[idx] = Math.max(it, value);
  });
};
_BasicStatsCalculator.getStatistics = (options) => {
  const mean = _BasicStatsCalculator.sum.map((sum) => sum / _BasicStatsCalculator.count);
  const stdDev = _BasicStatsCalculator.m2.map((squaredDiffSum) => Math.sqrt(squaredDiffSum / _BasicStatsCalculator.count));
  const unit = (options == null ? void 0 : options.unit) || null;
  const named = {
    max: {
      name: "max",
      label: "Max Pixel",
      value: singleArrayAsNumber(_BasicStatsCalculator.max),
      unit
    },
    min: {
      name: "min",
      label: "Min Pixel",
      value: singleArrayAsNumber(_BasicStatsCalculator.min),
      unit
    },
    mean: {
      name: "mean",
      label: "Mean Pixel",
      value: singleArrayAsNumber(mean),
      unit
    },
    stdDev: {
      name: "stdDev",
      label: "Standard Deviation",
      value: singleArrayAsNumber(stdDev),
      unit
    },
    count: {
      name: "count",
      label: "Pixel Count",
      value: _BasicStatsCalculator.count,
      unit: null
    },
    pointsInShape: _BasicStatsCalculator.pointsInShape,
    array: []
  };
  named.array.push(named.max, named.mean, named.stdDev, named.stdDev, named.count);
  _BasicStatsCalculator.max = [-Infinity];
  _BasicStatsCalculator.min = [Infinity];
  _BasicStatsCalculator.sum = [0];
  _BasicStatsCalculator.m2 = [0];
  _BasicStatsCalculator.runMean = [0];
  _BasicStatsCalculator.count = 0;
  _BasicStatsCalculator.pointsInShape = PointsManager.create3(1024);
  return named;
};
var BasicStatsCalculator = _BasicStatsCalculator;
function singleArrayAsNumber(val) {
  return val.length === 1 ? val[0] : val;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js
var circle_exports = {};
__export(circle_exports, {
  getCanvasCircleCorners: () => getCanvasCircleCorners,
  getCanvasCircleRadius: () => getCanvasCircleRadius
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js
var point_exports = {};
__export(point_exports, {
  distanceToPoint: () => distanceToPoint2,
  distanceToPointSquared: () => distanceToPointSquared2,
  mirror: () => mirror
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPointSquared.js
function distanceToPointSquared2(p1, p2) {
  if (p1.length !== p2.length) {
    throw Error("Both points should have the same dimensionality");
  }
  const [x1, y1, z1 = 0] = p1;
  const [x2, y2, z2 = 0] = p2;
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dz = z2 - z1;
  return dx * dx + dy * dy + dz * dz;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPoint.js
function distanceToPoint2(p1, p2) {
  return Math.sqrt(distanceToPointSquared2(p1, p2));
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/mirror.js
function mirror(mirrorPoint, staticPoint) {
  const [x1, y1] = mirrorPoint;
  const [x2, y2] = staticPoint;
  const newX = 2 * x2 - x1;
  const newY = 2 * y2 - y1;
  return [newX, newY];
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleRadius.js
function getCanvasCircleRadius(circleCanvasPoints) {
  const [center, end] = circleCanvasPoints;
  return distanceToPoint2(center, end);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleCorners.js
function getCanvasCircleCorners(circleCanvasPoints) {
  const [center, end] = circleCanvasPoints;
  const radius = distanceToPoint2(center, end);
  const topLeft = [center[0] - radius, center[1] - radius];
  const bottomRight = [center[0] + radius, center[1] + radius];
  return [topLeft, bottomRight];
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js
var ellipse_exports = {};
__export(ellipse_exports, {
  getCanvasEllipseCorners: () => getCanvasEllipseCorners,
  pointInEllipse: () => pointInEllipse,
  precalculatePointInEllipse: () => precalculatePointInEllipse
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/pointInEllipse.js
function pointInEllipse(ellipse, pointLPS, inverts = {}) {
  if (!inverts.precalculated) {
    precalculatePointInEllipse(ellipse, inverts);
  }
  return inverts.precalculated(pointLPS);
}
var precalculatePointInEllipse = (ellipse, inverts = {}) => {
  const { xRadius, yRadius, zRadius } = ellipse;
  if (inverts.invXRadiusSq === void 0 || inverts.invYRadiusSq === void 0 || inverts.invZRadiusSq === void 0) {
    inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;
    inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;
    inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;
  }
  const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;
  const { center } = ellipse;
  const [centerL, centerP, centerS] = center;
  inverts.precalculated = (pointLPS) => {
    const dx = pointLPS[0] - centerL;
    let inside = dx * dx * invXRadiusSq;
    if (inside > 1) {
      return false;
    }
    const dy = pointLPS[1] - centerP;
    inside += dy * dy * invYRadiusSq;
    if (inside > 1) {
      return false;
    }
    const dz = pointLPS[2] - centerS;
    inside += dz * dz * invZRadiusSq;
    return inside <= 1;
  };
  return inverts;
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/getCanvasEllipseCorners.js
function getCanvasEllipseCorners(ellipseCanvasPoints) {
  const [bottom, top, left, right] = ellipseCanvasPoints;
  const topLeft = [left[0], top[1]];
  const bottomRight = [right[0], bottom[1]];
  return [topLeft, bottomRight];
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js
var line_exports = {};
__export(line_exports, {
  distanceToPoint: () => distanceToPoint3,
  distanceToPointSquared: () => distanceToPointSquared3,
  distanceToPointSquaredInfo: () => distanceToPointSquaredInfo,
  intersectLine: () => intersectLine,
  isPointOnLineSegment: () => isPointOnLineSegment
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquaredInfo.js
function distanceToPointSquaredInfo(lineStart, lineEnd, point) {
  let closestPoint;
  const distanceSquared = distanceToPointSquared2(lineStart, lineEnd);
  if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {
    closestPoint = lineStart;
  }
  if (!closestPoint) {
    const dotProduct = ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) + (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) / distanceSquared;
    if (dotProduct < 0) {
      closestPoint = lineStart;
    } else if (dotProduct > 1) {
      closestPoint = lineEnd;
    } else {
      closestPoint = [
        lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),
        lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1])
      ];
    }
  }
  return {
    point: [...closestPoint],
    distanceSquared: distanceToPointSquared2(point, closestPoint)
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquared.js
function distanceToPointSquared3(lineStart, lineEnd, point) {
  return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPoint.js
function distanceToPoint3(lineStart, lineEnd, point) {
  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {
    throw Error("lineStart, lineEnd, and point should have 2 elements of [x, y]");
  }
  return Math.sqrt(distanceToPointSquared3(lineStart, lineEnd, point));
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js
function sign(x) {
  return typeof x === "number" ? x ? x < 0 ? -1 : 1 : x === x ? 0 : NaN : NaN;
}
function intersectLine(line1Start, line1End, line2Start, line2End) {
  const [x1, y1] = line1Start;
  const [x2, y2] = line1End;
  const [x3, y3] = line2Start;
  const [x4, y4] = line2End;
  const a1 = y2 - y1;
  const b1 = x1 - x2;
  const c1 = x2 * y1 - x1 * y2;
  const r3 = a1 * x3 + b1 * y3 + c1;
  const r4 = a1 * x4 + b1 * y4 + c1;
  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {
    return;
  }
  const a2 = y4 - y3;
  const b22 = x3 - x4;
  const c2 = x4 * y3 - x3 * y4;
  const r1 = a2 * x1 + b22 * y1 + c2;
  const r2 = a2 * x2 + b22 * y2 + c2;
  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {
    return;
  }
  const denom = a1 * b22 - a2 * b1;
  let num;
  num = b1 * c2 - b22 * c1;
  const x = num / denom;
  num = a2 * c1 - a1 * c2;
  const y = num / denom;
  const intersectionPoint = [x, y];
  return intersectionPoint;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/isPointOnLineSegment.js
var ORIENTATION_TOLERANCE = 0.01;
function isPointOnLineSegment(lineStart, lineEnd, point) {
  const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];
  const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];
  const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];
  const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];
  const aabbContainsPoint = point[0] >= minX - ORIENTATION_TOLERANCE && point[0] <= maxX + ORIENTATION_TOLERANCE && point[1] >= minY - ORIENTATION_TOLERANCE && point[1] <= maxY + ORIENTATION_TOLERANCE;
  if (!aabbContainsPoint) {
    return false;
  }
  const orientation2 = (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) - (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);
  const absOrientation = orientation2 >= 0 ? orientation2 : -orientation2;
  return absOrientation <= ORIENTATION_TOLERANCE;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/index.js
var polyline_exports = {};
__export(polyline_exports, {
  addCanvasPointsToArray: () => addCanvasPointsToArray_default,
  containsPoint: () => containsPoint,
  containsPoints: () => containsPoints,
  decimate: () => decimate,
  getAABB: () => getAABB,
  getArea: () => getArea,
  getClosestLineSegmentIntersection: () => getClosestLineSegmentIntersection,
  getFirstLineSegmentIntersectionIndexes: () => getFirstLineSegmentIntersectionIndexes,
  getLineSegmentIntersectionsCoordinates: () => getLineSegmentIntersectionsCoordinates,
  getLineSegmentIntersectionsIndexes: () => getLineSegmentIntersectionsIndexes,
  getNormal2: () => getNormal2,
  getNormal3: () => getNormal3,
  getSignedArea: () => getSignedArea,
  getSubPixelSpacingAndXYDirections: () => getSubPixelSpacingAndXYDirections_default,
  getWindingDirection: () => getWindingDirection,
  intersectPolyline: () => intersectPolyline,
  isClosed: () => isClosed,
  isPointInsidePolyline3D: () => isPointInsidePolyline3D,
  mergePolylines: () => mergePolylines,
  pointCanProjectOnLine: () => pointCanProjectOnLine_default,
  pointsAreWithinCloseContourProximity: () => pointsAreWithinCloseContourProximity_default,
  projectTo2D: () => projectTo2D,
  subtractPolylines: () => subtractPolylines
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isClosed.js
function isClosed(polyline) {
  if (polyline.length < 3) {
    return false;
  }
  const numPolylinePoints = polyline.length;
  const firstPoint = polyline[0];
  const lastPoint = polyline[numPolylinePoints - 1];
  const distFirstToLastPoints = distanceToPointSquared2(firstPoint, lastPoint);
  return common_exports.equals(0, distFirstToLastPoints);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoint.js
function containsPoint(polyline, point, options = {
  closed: void 0
}) {
  if (polyline.length < 3) {
    return false;
  }
  const numPolylinePoints = polyline.length;
  let numIntersections = 0;
  const { closed: closed2, holes } = options;
  if (holes == null ? void 0 : holes.length) {
    for (const hole of holes) {
      if (containsPoint(hole, point)) {
        return false;
      }
    }
  }
  const shouldClose = !(closed2 === void 0 ? isClosed(polyline) : closed2);
  const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);
  for (let i = 0; i <= maxSegmentIndex; i++) {
    const p1 = polyline[i];
    const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;
    const p2 = polyline[p2Index];
    const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];
    const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];
    const minY = p1[1] <= p2[1] ? p1[1] : p2[1];
    const mayIntersectLineSegment = point[0] <= maxX && point[1] >= minY && point[1] < maxY;
    if (mayIntersectLineSegment) {
      const isVerticalLine = p1[0] === p2[0];
      let intersects = isVerticalLine;
      if (!intersects) {
        const xIntersection = (point[1] - p1[1]) * (p2[0] - p1[0]) / (p2[1] - p1[1]) + p1[0];
        intersects = point[0] <= xIntersection;
      }
      numIntersections += intersects ? 1 : 0;
    }
  }
  return !!(numIntersections % 2);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoints.js
function containsPoints(polyline, points) {
  for (let i = 0, numPoint = points.length; i < numPoint; i++) {
    if (!containsPoint(polyline, points[i])) {
      return false;
    }
  }
  return true;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getAABB.js
function getAABB(polyline, options) {
  let polylineToUse = polyline;
  const numDimensions = (options == null ? void 0 : options.numDimensions) || 2;
  const is3D = numDimensions === 3;
  if (!Array.isArray(polyline[0])) {
    const currentPolyline = polyline;
    const totalPoints = currentPolyline.length / numDimensions;
    polylineToUse = new Array(currentPolyline.length / numDimensions);
    for (let i = 0, len = totalPoints; i < len; i++) {
      polylineToUse[i] = [
        currentPolyline[i * numDimensions],
        currentPolyline[i * numDimensions + 1]
      ];
      if (is3D) {
        polylineToUse[i].push(currentPolyline[i * numDimensions + 2]);
      }
    }
  }
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let minZ = Infinity;
  let maxZ = -Infinity;
  polylineToUse = polylineToUse;
  for (let i = 0, len = polylineToUse.length; i < len; i++) {
    const [x, y, z] = polylineToUse[i];
    minX = minX < x ? minX : x;
    minY = minY < y ? minY : y;
    maxX = maxX > x ? maxX : x;
    maxY = maxY > y ? maxY : y;
    if (is3D) {
      minZ = minZ < z ? minZ : z;
      maxZ = maxZ > z ? maxZ : z;
    }
  }
  return is3D ? { minX, maxX, minY, maxY, minZ, maxZ } : { minX, maxX, minY, maxY };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getArea.js
function getArea(points) {
  const n = points.length;
  let area = 0;
  let j = n - 1;
  for (let i = 0; i < n; i++) {
    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);
    j = i;
  }
  return Math.abs(area / 2);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSignedArea.js
function getSignedArea(polyline) {
  if (polyline.length < 3) {
    return 0;
  }
  const refPoint = polyline[0];
  let area = 0;
  for (let i = 0, len = polyline.length; i < len; i++) {
    const p1 = polyline[i];
    const p2Index = i === len - 1 ? 0 : i + 1;
    const p2 = polyline[p2Index];
    const aX = p1[0] - refPoint[0];
    const aY = p1[1] - refPoint[1];
    const bX = p2[0] - refPoint[0];
    const bY = p2[1] - refPoint[1];
    area += aX * bY - aY * bX;
  }
  area *= 0.5;
  return area;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getWindingDirection.js
function getWindingDirection(polyline) {
  const signedArea = getSignedArea(polyline);
  return signedArea >= 0 ? 1 : -1;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal3.js
function _getAreaVector(polyline) {
  const vecArea = vec3_exports.create();
  const refPoint = polyline[0];
  for (let i = 0, len = polyline.length; i < len; i++) {
    const p1 = polyline[i];
    const p2Index = i === len - 1 ? 0 : i + 1;
    const p2 = polyline[p2Index];
    const aX = p1[0] - refPoint[0];
    const aY = p1[1] - refPoint[1];
    const aZ = p1[2] - refPoint[2];
    const bX = p2[0] - refPoint[0];
    const bY = p2[1] - refPoint[1];
    const bZ = p2[2] - refPoint[2];
    vecArea[0] += aY * bZ - aZ * bY;
    vecArea[1] += aZ * bX - aX * bZ;
    vecArea[2] += aX * bY - aY * bX;
  }
  vec3_exports.scale(vecArea, vecArea, 0.5);
  return vecArea;
}
function getNormal3(polyline) {
  const vecArea = _getAreaVector(polyline);
  return vec3_exports.normalize(vecArea, vecArea);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal2.js
function getNormal2(polyline) {
  const area = getSignedArea(polyline);
  return [0, 0, area / Math.abs(area)];
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/areLineSegmentsIntersecting.js
function areLineSegmentsIntersecting(p1, q1, p2, q2) {
  let result = false;
  const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];
  const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];
  const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];
  const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];
  const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];
  const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];
  const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];
  const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];
  if (line1MinX > line2MaxX || line1MaxX < line2MinX || line1MinY > line2MaxY || line1MaxY < line2MinY) {
    return false;
  }
  const orient = [
    orientation(p1, q1, p2),
    orientation(p1, q1, q2),
    orientation(p2, q2, p1),
    orientation(p2, q2, q1)
  ];
  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {
    return true;
  }
  if (orient[0] === 0 && onSegment(p1, p2, q1)) {
    result = true;
  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {
    result = true;
  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {
    result = true;
  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {
    result = true;
  }
  return result;
}
function orientation(p, q, r) {
  const orientationValue = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
  if (orientationValue === 0) {
    return 0;
  }
  return orientationValue > 0 ? 1 : 2;
}
function onSegment(p, q, r) {
  if (q[0] <= Math.max(p[0], r[0]) && q[0] >= Math.min(p[0], r[0]) && q[1] <= Math.max(p[1], r[1]) && q[1] >= Math.min(p[1], r[1])) {
    return true;
  }
  return false;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsIndexes.js
function getLineSegmentIntersectionsIndexes(polyline, p1, q1, closed2 = true) {
  const intersections = [];
  const numPoints = polyline.length;
  const maxI = numPoints - (closed2 ? 1 : 2);
  for (let i = 0; i <= maxI; i++) {
    const p2 = polyline[i];
    const j = i === numPoints - 1 ? 0 : i + 1;
    const q2 = polyline[j];
    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {
      intersections.push([i, j]);
    }
  }
  return intersections;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLinesIntersection.js
var PARALLEL_LINES_TOLERANCE = 0.01;
function getLinesIntersection(p1, q1, p2, q2) {
  const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];
  const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];
  const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];
  const absDenominator = denominator >= 0 ? denominator : -denominator;
  if (absDenominator < PARALLEL_LINES_TOLERANCE) {
    const line1AABB = [
      p1[0] < q1[0] ? p1[0] : q1[0],
      p1[0] > q1[0] ? p1[0] : q1[0],
      p1[1] < q1[1] ? p1[1] : q1[1],
      p1[1] > q1[1] ? p1[1] : q1[1]
    ];
    const line2AABB = [
      p2[0] < q2[0] ? p2[0] : q2[0],
      p2[0] > q2[0] ? p2[0] : q2[0],
      p2[1] < q2[1] ? p2[1] : q2[1],
      p2[1] > q2[1] ? p2[1] : q2[1]
    ];
    const aabbIntersects = line1AABB[0] <= line2AABB[1] && line1AABB[1] >= line2AABB[0] && line1AABB[2] <= line2AABB[3] && line1AABB[3] >= line2AABB[2];
    if (!aabbIntersects) {
      return;
    }
    const overlap = isPointOnLineSegment(p1, q1, p2) || isPointOnLineSegment(p1, q1, q2) || isPointOnLineSegment(p2, q2, p1);
    if (!overlap) {
      return;
    }
    const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];
    const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];
    const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];
    const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];
    const midX = (minX + maxX) * 0.5;
    const midY = (minY + maxY) * 0.5;
    return [midX, midY];
  }
  let a = p1[1] - p2[1];
  let b = p1[0] - p2[0];
  const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;
  const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;
  a = numerator1 / denominator;
  b = numerator2 / denominator;
  const resultX = p1[0] + a * diffQ1P1[0];
  const resultY = p1[1] + a * diffQ1P1[1];
  return [resultX, resultY];
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/combinePolyline.js
var PolylinePointType;
(function(PolylinePointType2) {
  PolylinePointType2[PolylinePointType2["Vertex"] = 0] = "Vertex";
  PolylinePointType2[PolylinePointType2["Intersection"] = 1] = "Intersection";
})(PolylinePointType || (PolylinePointType = {}));
var PolylinePointPosition;
(function(PolylinePointPosition2) {
  PolylinePointPosition2[PolylinePointPosition2["Outside"] = -1] = "Outside";
  PolylinePointPosition2[PolylinePointPosition2["Edge"] = 0] = "Edge";
  PolylinePointPosition2[PolylinePointPosition2["Inside"] = 1] = "Inside";
})(PolylinePointPosition || (PolylinePointPosition = {}));
var PolylinePointDirection;
(function(PolylinePointDirection2) {
  PolylinePointDirection2[PolylinePointDirection2["Exiting"] = -1] = "Exiting";
  PolylinePointDirection2[PolylinePointDirection2["Unknown"] = 0] = "Unknown";
  PolylinePointDirection2[PolylinePointDirection2["Entering"] = 1] = "Entering";
})(PolylinePointDirection || (PolylinePointDirection = {}));
function ensuresNextPointers(polylinePoints) {
  for (let i = 0, len = polylinePoints.length; i < len; i++) {
    const currentPoint = polylinePoints[i];
    if (!currentPoint.next) {
      currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];
    }
  }
}
function getSourceAndTargetPointsList(targetPolyline, sourcePolyline) {
  const targetPolylinePoints = [];
  const sourcePolylinePoints = [];
  const sourceIntersectionsCache = /* @__PURE__ */ new Map();
  const isFirstPointInside = containsPoint(sourcePolyline, targetPolyline[0]);
  let intersectionPointDirection = isFirstPointInside ? PolylinePointDirection.Exiting : PolylinePointDirection.Entering;
  for (let i = 0, len = targetPolyline.length; i < len; i++) {
    const p1 = targetPolyline[i];
    const pointInside = containsPoint(sourcePolyline, p1);
    const vertexPoint = {
      type: PolylinePointType.Vertex,
      coordinates: p1,
      position: pointInside ? PolylinePointPosition.Inside : PolylinePointPosition.Outside,
      visited: false,
      next: null
    };
    targetPolylinePoints.push(vertexPoint);
    const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];
    const intersectionsInfo = getLineSegmentIntersectionsIndexes(sourcePolyline, p1, q1).map((intersectedLineSegment) => {
      const sourceLineSegmentId = intersectedLineSegment[0];
      const p2 = sourcePolyline[intersectedLineSegment[0]];
      const q2 = sourcePolyline[intersectedLineSegment[1]];
      const intersectionCoordinate = getLinesIntersection(p1, q1, p2, q2);
      const targetStartPointDistSquared = distanceToPointSquared2(p1, intersectionCoordinate);
      return {
        sourceLineSegmentId,
        coordinate: intersectionCoordinate,
        targetStartPointDistSquared
      };
    });
    intersectionsInfo.sort((left, right) => left.targetStartPointDistSquared - right.targetStartPointDistSquared);
    intersectionsInfo.forEach((intersectionInfo) => {
      const { sourceLineSegmentId, coordinate: intersectionCoordinate } = intersectionInfo;
      const targetEdgePoint = {
        type: PolylinePointType.Intersection,
        coordinates: intersectionCoordinate,
        position: PolylinePointPosition.Edge,
        direction: intersectionPointDirection,
        visited: false,
        next: null
      };
      const sourceEdgePoint = {
        ...targetEdgePoint,
        direction: PolylinePointDirection.Unknown,
        cloned: true
      };
      if (intersectionPointDirection === PolylinePointDirection.Entering) {
        targetEdgePoint.next = sourceEdgePoint;
      } else {
        sourceEdgePoint.next = targetEdgePoint;
      }
      let sourceIntersectionPoints = sourceIntersectionsCache.get(sourceLineSegmentId);
      if (!sourceIntersectionPoints) {
        sourceIntersectionPoints = [];
        sourceIntersectionsCache.set(sourceLineSegmentId, sourceIntersectionPoints);
      }
      targetPolylinePoints.push(targetEdgePoint);
      sourceIntersectionPoints.push(sourceEdgePoint);
      intersectionPointDirection *= -1;
    });
  }
  for (let i = 0, len = sourcePolyline.length; i < len; i++) {
    const lineSegmentId = i;
    const p1 = sourcePolyline[i];
    const vertexPoint = {
      type: PolylinePointType.Vertex,
      coordinates: p1,
      visited: false,
      next: null
    };
    sourcePolylinePoints.push(vertexPoint);
    const sourceIntersectionPoints = sourceIntersectionsCache.get(lineSegmentId);
    if (!(sourceIntersectionPoints == null ? void 0 : sourceIntersectionPoints.length)) {
      continue;
    }
    sourceIntersectionPoints.map((intersectionPoint) => ({
      intersectionPoint,
      lineSegStartDistSquared: distanceToPointSquared2(p1, intersectionPoint.coordinates)
    })).sort((left, right) => left.lineSegStartDistSquared - right.lineSegStartDistSquared).map(({ intersectionPoint }) => intersectionPoint).forEach((intersectionPoint) => sourcePolylinePoints.push(intersectionPoint));
  }
  ensuresNextPointers(targetPolylinePoints);
  ensuresNextPointers(sourcePolylinePoints);
  return { targetPolylinePoints, sourcePolylinePoints };
}
function getUnvisitedOutsidePoint(polylinePoints) {
  for (let i = 0, len = polylinePoints.length; i < len; i++) {
    const point = polylinePoints[i];
    if (!point.visited && point.position === PolylinePointPosition.Outside) {
      return point;
    }
  }
}
function mergePolylines(targetPolyline, sourcePolyline) {
  const targetNormal = getNormal2(targetPolyline);
  const sourceNormal = getNormal2(sourcePolyline);
  const dotNormals = vec3_exports.dot(sourceNormal, targetNormal);
  if (!common_exports.equals(1, dotNormals)) {
    sourcePolyline = sourcePolyline.slice().reverse();
  }
  const { targetPolylinePoints } = getSourceAndTargetPointsList(targetPolyline, sourcePolyline);
  const startPoint = getUnvisitedOutsidePoint(targetPolylinePoints);
  if (!startPoint) {
    return targetPolyline.slice();
  }
  const mergedPolyline = [startPoint.coordinates];
  let currentPoint = startPoint.next;
  while (currentPoint !== startPoint) {
    if (currentPoint.type === PolylinePointType.Intersection && currentPoint.cloned) {
      currentPoint = currentPoint.next;
      continue;
    }
    mergedPolyline.push(currentPoint.coordinates);
    currentPoint = currentPoint.next;
  }
  return mergedPolyline;
}
function subtractPolylines(targetPolyline, sourcePolyline) {
  const targetNormal = getNormal2(targetPolyline);
  const sourceNormal = getNormal2(sourcePolyline);
  const dotNormals = vec3_exports.dot(sourceNormal, targetNormal);
  if (!common_exports.equals(-1, dotNormals)) {
    sourcePolyline = sourcePolyline.slice().reverse();
  }
  const { targetPolylinePoints } = getSourceAndTargetPointsList(targetPolyline, sourcePolyline);
  let startPoint = null;
  const subtractedPolylines = [];
  while (startPoint = getUnvisitedOutsidePoint(targetPolylinePoints)) {
    const subtractedPolyline = [startPoint.coordinates];
    let currentPoint = startPoint.next;
    startPoint.visited = true;
    while (currentPoint !== startPoint) {
      currentPoint.visited = true;
      if (currentPoint.type === PolylinePointType.Intersection && currentPoint.cloned) {
        currentPoint = currentPoint.next;
        continue;
      }
      subtractedPolyline.push(currentPoint.coordinates);
      currentPoint = currentPoint.next;
    }
    subtractedPolylines.push(subtractedPolyline);
  }
  return subtractedPolylines;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.js
function getFirstLineSegmentIntersectionIndexes(points, p1, q1, closed2 = true) {
  let initialI;
  let j;
  if (closed2) {
    j = points.length - 1;
    initialI = 0;
  } else {
    j = 0;
    initialI = 1;
  }
  for (let i = initialI; i < points.length; i++) {
    const p2 = points[j];
    const q2 = points[i];
    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {
      return [j, i];
    }
    j = i;
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/intersectPolyline.js
function intersectPolyline(sourcePolyline, targetPolyline) {
  for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {
    const sourceP1 = sourcePolyline[i];
    const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;
    const sourceP2 = sourcePolyline[sourceP2Index];
    const intersectionPointIndexes = getFirstLineSegmentIntersectionIndexes(targetPolyline, sourceP1, sourceP2);
    if ((intersectionPointIndexes == null ? void 0 : intersectionPointIndexes.length) === 2) {
      return true;
    }
  }
  return false;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/decimate.js
var DEFAULT_EPSILON = 0.1;
function decimate(polyline, epsilon2 = DEFAULT_EPSILON) {
  const numPoints = polyline.length;
  if (numPoints < 3) {
    return polyline;
  }
  const epsilonSquared = epsilon2 * epsilon2;
  const partitionQueue = [[0, numPoints - 1]];
  const polylinePointFlags = new Array(numPoints).fill(false);
  let numDecimatedPoints = 2;
  polylinePointFlags[0] = true;
  polylinePointFlags[numPoints - 1] = true;
  while (partitionQueue.length) {
    const [startIndex, endIndex] = partitionQueue.pop();
    if (endIndex - startIndex === 1) {
      continue;
    }
    const startPoint = polyline[startIndex];
    const endPoint = polyline[endIndex];
    let maxDistSquared = -Infinity;
    let maxDistIndex = -1;
    for (let i = startIndex + 1; i < endIndex; i++) {
      const currentPoint = polyline[i];
      const distSquared = distanceToPointSquared3(startPoint, endPoint, currentPoint);
      if (distSquared > maxDistSquared) {
        maxDistSquared = distSquared;
        maxDistIndex = i;
      }
    }
    if (maxDistSquared < epsilonSquared) {
      continue;
    }
    polylinePointFlags[maxDistIndex] = true;
    numDecimatedPoints++;
    partitionQueue.push([maxDistIndex, endIndex]);
    partitionQueue.push([startIndex, maxDistIndex]);
  }
  const decimatedPolyline = new Array(numDecimatedPoints);
  for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {
    if (polylinePointFlags[srcIndex]) {
      decimatedPolyline[dstIndex++] = polyline[srcIndex];
    }
  }
  return decimatedPolyline;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.js
function getLineSegmentIntersectionsCoordinates(points, p1, q1, closed2 = true) {
  const result = [];
  const polylineIndexes = getLineSegmentIntersectionsIndexes(points, p1, q1, closed2);
  for (let i = 0; i < polylineIndexes.length; i++) {
    const p2 = points[polylineIndexes[i][0]];
    const q2 = points[polylineIndexes[i][1]];
    const intersection = getLinesIntersection(p1, q1, p2, q2);
    result.push(intersection);
  }
  return result;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getClosestLineSegmentIntersection.js
function getClosestLineSegmentIntersection(points, p1, q1, closed2 = true) {
  let initialQ2Index;
  let p2Index;
  if (closed2) {
    p2Index = points.length - 1;
    initialQ2Index = 0;
  } else {
    p2Index = 0;
    initialQ2Index = 1;
  }
  const intersections = [];
  for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {
    const p2 = points[p2Index];
    const q2 = points[q2Index];
    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {
      intersections.push([p2Index, q2Index]);
    }
    p2Index = q2Index;
  }
  if (intersections.length === 0) {
    return;
  }
  const distances = [];
  intersections.forEach((intersection) => {
    const intersectionPoints = [
      points[intersection[0]],
      points[intersection[1]]
    ];
    const midpoint = [
      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,
      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2
    ];
    distances.push(vec2_exports.distance(midpoint, p1));
  });
  const minDistance = Math.min(...distances);
  const indexOfMinDistance = distances.indexOf(minDistance);
  return {
    segment: intersections[indexOfMinDistance],
    distance: minDistance
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSubPixelSpacingAndXYDirections.js
var EPSILON2 = 1e-3;
var getSubPixelSpacingAndXYDirections = (viewport, subPixelResolution) => {
  let spacing;
  let xDir;
  let yDir;
  if (viewport instanceof StackViewport_default) {
    const imageData = viewport.getImageData();
    xDir = imageData.direction.slice(0, 3);
    yDir = imageData.direction.slice(3, 6);
    spacing = imageData.spacing;
  } else {
    const imageData = viewport.getImageData();
    const { direction, spacing: volumeSpacing } = imageData;
    const { viewPlaneNormal, viewUp } = viewport.getCamera();
    const iVector = direction.slice(0, 3);
    const jVector = direction.slice(3, 6);
    const kVector = direction.slice(6, 9);
    const viewRight = vec3_exports.create();
    vec3_exports.cross(viewRight, viewUp, viewPlaneNormal);
    const absViewRightDotI = Math.abs(vec3_exports.dot(viewRight, iVector));
    const absViewRightDotJ = Math.abs(vec3_exports.dot(viewRight, jVector));
    const absViewRightDotK = Math.abs(vec3_exports.dot(viewRight, kVector));
    let xSpacing;
    if (Math.abs(1 - absViewRightDotI) < EPSILON2) {
      xSpacing = volumeSpacing[0];
      xDir = iVector;
    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON2) {
      xSpacing = volumeSpacing[1];
      xDir = jVector;
    } else if (Math.abs(1 - absViewRightDotK) < EPSILON2) {
      xSpacing = volumeSpacing[2];
      xDir = kVector;
    } else {
      throw new Error("No support yet for oblique plane planar contours");
    }
    const absViewUpDotI = Math.abs(vec3_exports.dot(viewUp, iVector));
    const absViewUpDotJ = Math.abs(vec3_exports.dot(viewUp, jVector));
    const absViewUpDotK = Math.abs(vec3_exports.dot(viewUp, kVector));
    let ySpacing;
    if (Math.abs(1 - absViewUpDotI) < EPSILON2) {
      ySpacing = volumeSpacing[0];
      yDir = iVector;
    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON2) {
      ySpacing = volumeSpacing[1];
      yDir = jVector;
    } else if (Math.abs(1 - absViewUpDotK) < EPSILON2) {
      ySpacing = volumeSpacing[2];
      yDir = kVector;
    } else {
      throw new Error("No support yet for oblique plane planar contours");
    }
    spacing = [xSpacing, ySpacing];
  }
  const subPixelSpacing = [
    spacing[0] / subPixelResolution,
    spacing[1] / subPixelResolution
  ];
  return { spacing: subPixelSpacing, xDir, yDir };
};
var getSubPixelSpacingAndXYDirections_default = getSubPixelSpacingAndXYDirections;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointsAreWithinCloseContourProximity.js
var pointsAreWithinCloseContourProximity = (p1, p2, closeContourProximity) => {
  return vec2_exports.dist(p1, p2) < closeContourProximity;
};
var pointsAreWithinCloseContourProximity_default = pointsAreWithinCloseContourProximity;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/addCanvasPointsToArray.js
var addCanvasPointsToArray = (element, canvasPoints, newCanvasPoint, commonData) => {
  const { xDir, yDir, spacing } = commonData;
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  if (!canvasPoints.length) {
    canvasPoints.push(newCanvasPoint);
    console.log(">>>>> !canvasPoints. :: RETURN");
    return 1;
  }
  const lastWorldPos = viewport.canvasToWorld(canvasPoints[canvasPoints.length - 1]);
  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);
  const worldPosDiff = vec3_exports.create();
  vec3_exports.subtract(worldPosDiff, newWorldPos, lastWorldPos);
  const xDist = Math.abs(vec3_exports.dot(worldPosDiff, xDir));
  const yDist = Math.abs(vec3_exports.dot(worldPosDiff, yDir));
  const numPointsToAdd = Math.max(Math.floor(xDist / spacing[0]), Math.floor(yDist / spacing[0]));
  if (numPointsToAdd > 1) {
    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];
    const canvasDist = vec2_exports.dist(lastCanvasPoint, newCanvasPoint);
    const canvasDir = vec2_exports.create();
    vec2_exports.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);
    vec2_exports.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);
    const distPerPoint = canvasDist / numPointsToAdd;
    for (let i = 1; i <= numPointsToAdd; i++) {
      canvasPoints.push([
        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,
        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i
      ]);
    }
  } else {
    canvasPoints.push(newCanvasPoint);
  }
  return numPointsToAdd;
};
var addCanvasPointsToArray_default = addCanvasPointsToArray;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointCanProjectOnLine.js
var pointCanProjectOnLine = (p, p1, p2, proximity) => {
  const p1p = [p[0] - p1[0], p[1] - p1[1]];
  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];
  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];
  if (dot < 0) {
    return false;
  }
  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);
  if (p1p2Mag === 0) {
    return false;
  }
  const projectionVectorMag = dot / p1p2Mag;
  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];
  const projectionVector = [
    p1p2UnitVector[0] * projectionVectorMag,
    p1p2UnitVector[1] * projectionVectorMag
  ];
  const projectionPoint = [
    p1[0] + projectionVector[0],
    p1[1] + projectionVector[1]
  ];
  const distance = vec2_exports.distance(p, projectionPoint);
  if (distance > proximity) {
    return false;
  }
  if (vec2_exports.distance(p1, projectionPoint) > vec2_exports.distance(p1, p2)) {
    return false;
  }
  return true;
};
var pointCanProjectOnLine_default = pointCanProjectOnLine;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/projectTo2D.js
var epsilon = 1e-6;
function projectTo2D(polyline) {
  let sharedDimensionIndex;
  const testPoints = utilities_exports.getRandomSampleFromArray(polyline, 50);
  for (let i = 0; i < 3; i++) {
    if (testPoints.every((point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon)) {
      sharedDimensionIndex = i;
      break;
    }
  }
  if (sharedDimensionIndex === void 0) {
    throw new Error("Cannot find a shared dimension index for polyline, probably oblique plane");
  }
  const points2D = [];
  const firstDim = (sharedDimensionIndex + 1) % 3;
  const secondDim = (sharedDimensionIndex + 2) % 3;
  for (let i = 0; i < polyline.length; i++) {
    points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);
  }
  return {
    sharedDimensionIndex,
    projectedPolyline: points2D
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isPointInsidePolyline3D.js
function isPointInsidePolyline3D(point, polyline, options = {}) {
  const { sharedDimensionIndex, projectedPolyline } = projectTo2D(polyline);
  const { holes } = options;
  const projectedHoles = [];
  if (holes) {
    for (let i = 0; i < holes.length; i++) {
      const hole = holes[i];
      const hole2D = [];
      for (let j = 0; j < hole.length; j++) {
        hole2D.push([
          hole[j][(sharedDimensionIndex + 1) % 3],
          hole[j][(sharedDimensionIndex + 2) % 3]
        ]);
      }
      projectedHoles.push(hole2D);
    }
  }
  const point2D = [
    point[(sharedDimensionIndex + 1) % 3],
    point[(sharedDimensionIndex + 2) % 3]
  ];
  return containsPoint(projectedPolyline, point2D, { holes: projectedHoles });
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/index.js
var rectangle_exports = {};
__export(rectangle_exports, {
  distanceToPoint: () => distanceToPoint4
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/distanceToPoint.js
function rectToLineSegments(left, top, width, height) {
  const topLineStart = [left, top];
  const topLineEnd = [left + width, top];
  const rightLineStart = [left + width, top];
  const rightLineEnd = [left + width, top + height];
  const bottomLineStart = [left + width, top + height];
  const bottomLineEnd = [left, top + height];
  const leftLineStart = [left, top + height];
  const leftLineEnd = [left, top];
  const lineSegments = {
    top: [topLineStart, topLineEnd],
    right: [rightLineStart, rightLineEnd],
    bottom: [bottomLineStart, bottomLineEnd],
    left: [leftLineStart, leftLineEnd]
  };
  return lineSegments;
}
function distanceToPoint4(rect, point) {
  if (rect.length !== 4 || point.length !== 2) {
    throw Error("rectangle:[left, top, width, height] or point: [x,y] not defined correctly");
  }
  const [left, top, width, height] = rect;
  let minDistance = 655535;
  const lineSegments = rectToLineSegments(left, top, width, height);
  Object.keys(lineSegments).forEach((segment) => {
    const [lineStart, lineEnd] = lineSegments[segment];
    const distance = distanceToPoint3(lineStart, lineEnd, point);
    if (distance < minDistance) {
      minDistance = distance;
    }
  });
  return minDistance;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/index.js
var vec2_exports2 = {};
__export(vec2_exports2, {
  findClosestPoint: () => findClosestPoint,
  liangBarksyClip: () => clip
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js
function findClosestPoint(sourcePoints, targetPoint) {
  let minPoint = [0, 0];
  let minDistance = Number.MAX_SAFE_INTEGER;
  sourcePoints.forEach(function(sourcePoint) {
    const distance = _distanceBetween(targetPoint, sourcePoint);
    if (distance < minDistance) {
      minDistance = distance;
      minPoint = [...sourcePoint];
    }
  });
  return minPoint;
}
function _distanceBetween(p1, p2) {
  const [x1, y1] = p1;
  const [x2, y2] = p2;
  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/liangBarksyClip.js
var EPSILON3 = 1e-6;
var INSIDE = 1;
var OUTSIDE = 0;
function clipT(num, denom, c) {
  const [tE, tL] = c;
  if (Math.abs(denom) < EPSILON3) {
    return num < 0;
  }
  const t = num / denom;
  if (denom > 0) {
    if (t > tL) {
      return 0;
    }
    if (t > tE) {
      c[0] = t;
    }
  } else {
    if (t < tE) {
      return 0;
    }
    if (t < tL) {
      c[1] = t;
    }
  }
  return 1;
}
function clip(a, b, box, da, db) {
  const [x1, y1] = a;
  const [x2, y2] = b;
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (da === void 0 || db === void 0) {
    da = a;
    db = b;
  } else {
    da[0] = a[0];
    da[1] = a[1];
    db[0] = b[0];
    db[1] = b[1];
  }
  if (Math.abs(dx) < EPSILON3 && Math.abs(dy) < EPSILON3 && x1 >= box[0] && x1 <= box[2] && y1 >= box[1] && y1 <= box[3]) {
    return INSIDE;
  }
  const c = [0, 1];
  if (clipT(box[0] - x1, dx, c) && clipT(x1 - box[2], -dx, c) && clipT(box[1] - y1, dy, c) && clipT(y1 - box[3], -dy, c)) {
    const [tE, tL] = c;
    if (tL < 1) {
      db[0] = x1 + tL * dx;
      db[1] = y1 + tL * dy;
    }
    if (tE > 0) {
      da[0] += tE * dx;
      da[1] += tE * dy;
    }
    return INSIDE;
  }
  return OUTSIDE;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js
var planar_exports = {};
__export(planar_exports, {
  default: () => planar_default,
  filterAnnotationsForDisplay: () => filterAnnotationsForDisplay,
  filterAnnotationsWithinSamePlane: () => filterAnnotationsWithinSamePlane,
  filterAnnotationsWithinSlice: () => filterAnnotationsWithinSlice,
  getPointInLineOfSightWithCriteria: () => getPointInLineOfSightWithCriteria,
  getPointsInLineOfSight: () => getPointsInLineOfSight,
  getWorldWidthAndHeightFromCorners: () => getWorldWidthAndHeightFromCorners,
  isPlaneIntersectingAABB: () => isPlaneIntersectingAABB
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js
var { EPSILON: EPSILON4 } = constants_exports;
var PARALLEL_THRESHOLD = 1 - EPSILON4;
function filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {
  var _a2;
  const { viewPlaneNormal } = camera;
  const annotationsWithParallelNormals = annotations.filter((td2) => {
    let annotationViewPlaneNormal = td2.metadata.viewPlaneNormal;
    if (!annotationViewPlaneNormal) {
      const { referencedImageId } = td2.metadata;
      const { imageOrientationPatient } = metaData_exports.get("imagePlaneModule", referencedImageId);
      const rowCosineVec = vec3_exports.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
      const colCosineVec = vec3_exports.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
      annotationViewPlaneNormal = vec3_exports.create();
      vec3_exports.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);
      td2.metadata.viewPlaneNormal = annotationViewPlaneNormal;
    }
    const isParallel = Math.abs(vec3_exports.dot(viewPlaneNormal, annotationViewPlaneNormal)) > PARALLEL_THRESHOLD;
    return annotationViewPlaneNormal && isParallel;
  });
  if (!annotationsWithParallelNormals.length) {
    return [];
  }
  const halfSpacingInNormalDirection = spacingInNormalDirection / 2;
  const { focalPoint } = camera;
  const annotationsWithinSlice = [];
  for (const annotation of annotationsWithParallelNormals) {
    const data = annotation.data;
    const point = data.handles.points[0] || ((_a2 = data.contour) == null ? void 0 : _a2.polyline[0]);
    if (!annotation.isVisible) {
      continue;
    }
    const dir = vec3_exports.create();
    if (!point) {
      annotationsWithinSlice.push(annotation);
      continue;
    }
    vec3_exports.sub(dir, focalPoint, point);
    const dot = vec3_exports.dot(dir, viewPlaneNormal);
    if (Math.abs(dot) < halfSpacingInNormalDirection) {
      annotationsWithinSlice.push(annotation);
    }
  }
  return annotationsWithinSlice;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js
function getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, topLeftWorld, bottomRightWorld) {
  const viewRight = vec3_exports.create();
  vec3_exports.cross(viewRight, viewUp, viewPlaneNormal);
  const pos1 = vec3_exports.fromValues(...topLeftWorld);
  const pos2 = vec3_exports.fromValues(...bottomRightWorld);
  const diagonal = vec3_exports.create();
  vec3_exports.subtract(diagonal, pos1, pos2);
  const diagonalLength = vec3_exports.length(diagonal);
  if (diagonalLength < 1e-4) {
    return { worldWidth: 0, worldHeight: 0 };
  }
  const cosTheta = vec3_exports.dot(diagonal, viewRight) / (diagonalLength * vec3_exports.length(viewRight));
  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
  const worldWidth = sinTheta * diagonalLength;
  const worldHeight = cosTheta * diagonalLength;
  return { worldWidth, worldHeight };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js
function filterAnnotationsForDisplay(viewport, annotations, filterOptions = {}) {
  if (viewport instanceof VolumeViewport_default) {
    const camera = viewport.getCamera();
    const { spacingInNormalDirection } = utilities_exports.getTargetVolumeAndSpacingInNormalDir(viewport, camera);
    return filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);
  }
  if (viewport instanceof StackViewport_default) {
    const imageId = viewport.getCurrentImageId();
    if (!imageId) {
      return [];
    }
    const colonIndex = imageId.indexOf(":");
    filterOptions.imageURI = imageId.substring(colonIndex + 1);
  }
  return annotations.filter((annotation) => {
    if (!annotation.isVisible) {
      return false;
    }
    if (annotation.data.isCanvasAnnotation) {
      return true;
    }
    return viewport.isReferenceViewable(annotation.metadata, filterOptions);
  });
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getPointInLineOfSightWithCriteria.js
function getPointInLineOfSightWithCriteria(viewport, worldPos, targetVolumeId, criteriaFunction, stepSize = 0.25) {
  const points = getPointsInLineOfSight(viewport, worldPos, {
    targetVolumeId,
    stepSize
  });
  let pickedPoint;
  for (const point of points) {
    const intensity = viewport.getIntensityFromWorld(point);
    const pointToPick = criteriaFunction(intensity, point);
    if (pointToPick) {
      pickedPoint = pointToPick;
    }
  }
  return pickedPoint;
}
function getPointsInLineOfSight(viewport, worldPos, { targetVolumeId, stepSize }) {
  const camera = viewport.getCamera();
  const { viewPlaneNormal: normalDirection } = camera;
  const { spacingInNormalDirection } = utilities_exports.getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetVolumeId);
  const step = spacingInNormalDirection * stepSize || 1;
  const bounds = viewport.getBounds();
  const points = [];
  let currentPos = [...worldPos];
  while (_inBounds(currentPos, bounds)) {
    points.push([...currentPos]);
    currentPos[0] += normalDirection[0] * step;
    currentPos[1] += normalDirection[1] * step;
    currentPos[2] += normalDirection[2] * step;
  }
  currentPos = [...worldPos];
  while (_inBounds(currentPos, bounds)) {
    points.push([...currentPos]);
    currentPos[0] -= normalDirection[0] * step;
    currentPos[1] -= normalDirection[1] * step;
    currentPos[2] -= normalDirection[2] * step;
  }
  return points;
}
var _inBounds = function(point, bounds) {
  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
  const padding = 10;
  return point[0] > xMin + padding && point[0] < xMax - padding && point[1] > yMin + padding && point[1] < yMax - padding && point[2] > zMin + padding && point[2] < zMax - padding;
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/isPlaneIntersectingAABB.js
var isPlaneIntersectingAABB = (origin, normal, minX, minY, minZ, maxX, maxY, maxZ) => {
  const vertices = [
    vec3_exports.fromValues(minX, minY, minZ),
    vec3_exports.fromValues(maxX, minY, minZ),
    vec3_exports.fromValues(minX, maxY, minZ),
    vec3_exports.fromValues(maxX, maxY, minZ),
    vec3_exports.fromValues(minX, minY, maxZ),
    vec3_exports.fromValues(maxX, minY, maxZ),
    vec3_exports.fromValues(minX, maxY, maxZ),
    vec3_exports.fromValues(maxX, maxY, maxZ)
  ];
  const normalVec = vec3_exports.fromValues(normal[0], normal[1], normal[2]);
  const originVec = vec3_exports.fromValues(origin[0], origin[1], origin[2]);
  const planeDistance = -vec3_exports.dot(normalVec, originVec);
  let initialSign = null;
  for (const vertex of vertices) {
    const distance = vec3_exports.dot(normalVec, vertex) + planeDistance;
    if (initialSign === null) {
      initialSign = Math.sign(distance);
    } else if (Math.sign(distance) !== initialSign) {
      return true;
    }
  }
  return false;
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinPlane.js
var { EPSILON: EPSILON5 } = constants_exports;
var PARALLEL_THRESHOLD2 = 1 - EPSILON5;
function filterAnnotationsWithinSamePlane(annotations, camera) {
  const { viewPlaneNormal } = camera;
  const annotationsWithParallelNormals = annotations.filter((td2) => {
    let annotationViewPlaneNormal = td2.metadata.viewPlaneNormal;
    if (!annotationViewPlaneNormal) {
      const { referencedImageId } = td2.metadata;
      const { imageOrientationPatient } = metaData_exports.get("imagePlaneModule", referencedImageId);
      const rowCosineVec = vec3_exports.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
      const colCosineVec = vec3_exports.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
      annotationViewPlaneNormal = vec3_exports.create();
      vec3_exports.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);
      td2.metadata.viewPlaneNormal = annotationViewPlaneNormal;
    }
    const isParallel = Math.abs(vec3_exports.dot(viewPlaneNormal, annotationViewPlaneNormal)) > PARALLEL_THRESHOLD2;
    return annotationViewPlaneNormal && isParallel;
  });
  if (!annotationsWithParallelNormals.length) {
    return [];
  }
  return annotationsWithParallelNormals;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js
var planar_default = {
  filterAnnotationsWithinSlice,
  getWorldWidthAndHeightFromCorners,
  filterAnnotationsForDisplay,
  getPointInLineOfSightWithCriteria,
  isPlaneIntersectingAABB,
  filterAnnotationsWithinSamePlane,
  getPointsInLineOfSight
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js
function throttle(func, wait, options) {
  let leading = true;
  let trailing = true;
  if (typeof func !== "function") {
    throw new TypeError("Expected a function");
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? Boolean(options.leading) : leading;
    trailing = "trailing" in options ? Boolean(options.trailing) : trailing;
  }
  return debounce_default(func, wait, {
    leading,
    trailing,
    maxWait: wait
  });
}
var throttle_default = throttle;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js
var viewportFilters_exports = {};
__export(viewportFilters_exports, {
  filterViewportsWithFrameOfReferenceUID: () => filterViewportsWithFrameOfReferenceUID,
  filterViewportsWithParallelNormals: () => filterViewportsWithParallelNormals_default,
  filterViewportsWithToolEnabled: () => filterViewportsWithToolEnabled,
  getViewportIdsWithToolToRender: () => getViewportIdsWithToolToRender
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.js
function filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID) {
  const numViewports = viewports.length;
  const viewportsWithFrameOfReferenceUID = [];
  for (let vp = 0; vp < numViewports; vp++) {
    const viewport = viewports[vp];
    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {
      viewportsWithFrameOfReferenceUID.push(viewport);
    }
  }
  return viewportsWithFrameOfReferenceUID;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithToolEnabled.js
var { Active: Active2, Passive: Passive2, Enabled: Enabled2 } = ToolModes_default;
function filterViewportsWithToolEnabled(viewports, toolName) {
  const numViewports = viewports.length;
  const viewportsWithToolEnabled = [];
  for (let vp = 0; vp < numViewports; vp++) {
    const viewport = viewports[vp];
    const toolGroup = getToolGroupForViewport_default(viewport.id, viewport.renderingEngineId);
    if (!toolGroup) {
      continue;
    }
    const hasTool2 = _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName);
    if (hasTool2) {
      viewportsWithToolEnabled.push(viewport);
    }
  }
  return viewportsWithToolEnabled;
}
function _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName) {
  const { toolOptions } = toolGroup;
  const tool = toolOptions[toolName];
  if (!tool) {
    return false;
  }
  const toolMode = tool.mode;
  return toolMode === Active2 || toolMode === Passive2 || toolMode === Enabled2;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithParallelNormals.js
function filterViewportsWithParallelNormals(viewports, camera, EPS2 = 0.999) {
  return viewports.filter((viewport) => {
    const vpCamera = viewport.getCamera();
    const isParallel = Math.abs(vec3_exports.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) > EPS2;
    return isParallel;
  });
}
var filterViewportsWithParallelNormals_default = filterViewportsWithParallelNormals;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/getViewportIdsWithToolToRender.js
function getViewportIdsWithToolToRender(element, toolName, requireParallelNormals = true) {
  const enabledElement = getEnabledElement(element);
  const { renderingEngine, FrameOfReferenceUID } = enabledElement;
  let viewports = renderingEngine.getViewports();
  viewports = filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID);
  viewports = filterViewportsWithToolEnabled(viewports, toolName);
  const viewport = renderingEngine.getViewport(enabledElement.viewportId);
  if (requireParallelNormals) {
    viewports = filterViewportsWithParallelNormals_default(viewports, viewport.getCamera());
  }
  const viewportIds = viewports.map((vp) => vp.id);
  return viewportIds;
}

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js
var drawingSvg_exports = {};
__export(drawingSvg_exports, {
  draw: () => draw_default,
  drawArrow: () => drawArrow,
  drawCircle: () => drawCircle_default,
  drawEllipse: () => drawEllipse_default,
  drawEllipseByCoordinates: () => drawEllipseByCoordinates_default,
  drawHandle: () => drawHandle_default,
  drawHandles: () => drawHandles_default,
  drawHeight: () => drawHeight,
  drawLine: () => drawLine,
  drawLinkedTextBox: () => drawLinkedTextBox_default,
  drawPath: () => drawPath,
  drawPolyline: () => drawPolyline,
  drawRect: () => drawRect,
  drawRectByCoordinates: () => drawRectByCoordinates,
  drawRedactionRect: () => drawRedactionRect,
  drawTextBox: () => drawTextBox_default,
  setAttributesIfNecessary: () => setAttributesIfNecessary_default,
  setNewAttributesIfValid: () => setNewAttributesIfValid_default
});

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js
var VIEWPORT_ELEMENT = "viewport-element";
function getSvgDrawingHelper(element) {
  const enabledElement = getEnabledElement(element);
  const { viewportId, renderingEngineId } = enabledElement;
  const canvasHash = `${viewportId}:${renderingEngineId}`;
  const svgLayerElement = _getSvgLayer(element);
  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {
    state.svgNodeCache[canvasHash][cacheKey].touched = false;
  });
  return {
    svgLayerElement,
    svgNodeCacheForCanvas: state.svgNodeCache,
    getSvgNode: getSvgNode.bind(this, canvasHash),
    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),
    setNodeTouched: setNodeTouched.bind(this, canvasHash),
    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash)
  };
}
function _getSvgLayer(element) {
  const viewportElement = `.${VIEWPORT_ELEMENT}`;
  const internalDivElement = element.querySelector(viewportElement);
  const svgLayer = internalDivElement == null ? void 0 : internalDivElement.querySelector(":scope > .svg-layer");
  return svgLayer;
}
function getSvgNode(canvasHash, cacheKey) {
  if (!state.svgNodeCache[canvasHash]) {
    return;
  }
  if (state.svgNodeCache[canvasHash][cacheKey]) {
    return state.svgNodeCache[canvasHash][cacheKey].domRef;
  }
}
function appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {
  if (!state.svgNodeCache[canvasHash]) {
    return null;
  }
  state.svgNodeCache[canvasHash][cacheKey] = {
    touched: true,
    domRef: svgNode
  };
  svgLayerElement.appendChild(svgNode);
}
function setNodeTouched(canvasHash, cacheKey) {
  if (!state.svgNodeCache[canvasHash]) {
    return;
  }
  if (state.svgNodeCache[canvasHash][cacheKey]) {
    state.svgNodeCache[canvasHash][cacheKey].touched = true;
  }
}
function clearUntouched(svgLayerElement, canvasHash) {
  if (!state.svgNodeCache[canvasHash]) {
    return;
  }
  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {
    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];
    if (!cacheEntry.touched && cacheEntry.domRef) {
      svgLayerElement.removeChild(cacheEntry.domRef);
      delete state.svgNodeCache[canvasHash][cacheKey];
    }
  });
}
var getSvgDrawingHelper_default = getSvgDrawingHelper;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js
function draw(element, fn) {
  const svgDrawingHelper = getSvgDrawingHelper_default(element);
  fn(svgDrawingHelper);
  svgDrawingHelper.clearUntouched();
}
var draw_default = draw;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js
function _getHash(annotationUID, drawingElementType, nodeUID) {
  return `${annotationUID}::${drawingElementType}::${nodeUID}`;
}
var getHash_default = _getHash;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js
function setAttributesIfNecessary(attributes, svgNode) {
  Object.keys(attributes).forEach((key) => {
    const currentValue = svgNode.getAttribute(key);
    const newValue = attributes[key];
    if (newValue === void 0 || newValue === "") {
      svgNode.removeAttribute(key);
    } else if (currentValue !== newValue) {
      svgNode.setAttribute(key, newValue);
    }
  });
}
var setAttributesIfNecessary_default = setAttributesIfNecessary;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js
function setNewAttributesIfValid(attributes, svgNode) {
  Object.keys(attributes).forEach((key) => {
    const newValue = attributes[key];
    if (newValue !== void 0 && newValue !== "") {
      svgNode.setAttribute(key, newValue);
    }
  });
}
var setNewAttributesIfValid_default = setNewAttributesIfValid;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js
function drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = "") {
  const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity } = Object.assign({
    color: "rgb(0, 255, 0)",
    fill: "transparent",
    width: "2",
    lineDash: void 0,
    lineWidth: void 0,
    strokeOpacity: 1,
    fillOpacity: 1
  }, options);
  const strokeWidth = lineWidth || width;
  const svgns = "http://www.w3.org/2000/svg";
  const svgNodeHash = getHash_default(annotationUID, "circle", circleUID);
  const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);
  const attributes = {
    cx: `${center[0]}`,
    cy: `${center[1]}`,
    r: `${radius}`,
    stroke: color,
    fill,
    "stroke-width": strokeWidth,
    "stroke-dasharray": lineDash,
    "fill-opacity": fillOpacity,
    "stroke-opacity": strokeOpacity
  };
  if (existingCircleElement) {
    setAttributesIfNecessary_default(attributes, existingCircleElement);
    svgDrawingHelper.setNodeTouched(svgNodeHash);
  } else {
    const newCircleElement = document.createElementNS(svgns, "circle");
    if (dataId !== "") {
      newCircleElement.setAttribute("data-id", dataId);
    }
    setNewAttributesIfValid_default(attributes, newCircleElement);
    svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);
  }
}
var drawCircle_default = drawCircle;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js
function drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, options = {}, dataId = "") {
  const { color, width, lineWidth, lineDash } = Object.assign({
    color: "rgb(0, 255, 0)",
    width: "2",
    lineWidth: void 0,
    lineDash: void 0
  }, options);
  const strokeWidth = lineWidth || width;
  const svgns = "http://www.w3.org/2000/svg";
  const svgNodeHash = getHash_default(annotationUID, "ellipse", ellipseUID);
  const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);
  const [bottom, top, left, right] = canvasCoordinates;
  const w = Math.hypot(left[0] - right[0], left[1] - right[1]);
  const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);
  const angle = Math.atan2(left[1] - right[1], left[0] - right[0]) * 180 / Math.PI;
  const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];
  const radiusX = w / 2;
  const radiusY = h / 2;
  const attributes = {
    cx: `${center[0]}`,
    cy: `${center[1]}`,
    rx: `${radiusX}`,
    ry: `${radiusY}`,
    stroke: color,
    fill: "transparent",
    transform: `rotate(${angle} ${center[0]} ${center[1]})`,
    "stroke-width": strokeWidth,
    "stroke-dasharray": lineDash
  };
  if (existingEllipse) {
    setAttributesIfNecessary_default(attributes, existingEllipse);
    svgDrawingHelper.setNodeTouched(svgNodeHash);
  } else {
    const svgEllipseElement = document.createElementNS(svgns, "ellipse");
    if (dataId !== "") {
      svgEllipseElement.setAttribute("data-id", dataId);
    }
    setNewAttributesIfValid_default(attributes, svgEllipseElement);
    svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);
  }
}
var drawEllipseByCoordinates_default = drawEllipseByCoordinates;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js
function drawEllipse(svgDrawingHelper, annotationUID, ellipseUID, corner1, corner2, options = {}, dataId = "") {
  const top = [(corner1[0] + corner2[0]) / 2, corner1[1]];
  const bottom = [(corner1[0] + corner2[0]) / 2, corner2[1]];
  const left = [corner1[0], (corner1[1] + corner2[1]) / 2];
  const right = [corner2[0], (corner1[1] + corner2[1]) / 2];
  drawEllipseByCoordinates_default(svgDrawingHelper, annotationUID, ellipseUID, [bottom, top, left, right], options = {}, dataId = "");
}
var drawEllipse_default = drawEllipse;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js
function drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options = {}, uniqueIndex) {
  const { color, handleRadius, width, lineWidth, fill, type, opacity } = Object.assign({
    color: "rgb(0, 255, 0)",
    handleRadius: "6",
    width: "2",
    lineWidth: void 0,
    fill: "transparent",
    type: "circle",
    opacity: 1
  }, options);
  const strokeWidth = lineWidth || width;
  const svgns = "http://www.w3.org/2000/svg";
  const svgNodeHash = getHash_default(annotationUID, "handle", `hg-${handleGroupUID}-index-${uniqueIndex}`);
  let attributes;
  if (type === "circle") {
    attributes = {
      cx: `${handle[0]}`,
      cy: `${handle[1]}`,
      r: handleRadius,
      stroke: color,
      fill,
      "stroke-width": strokeWidth,
      opacity
    };
  } else if (type === "rect") {
    const handleRadiusFloat = parseFloat(handleRadius);
    const side = handleRadiusFloat * 1.5;
    const x = handle[0] - side * 0.5;
    const y = handle[1] - side * 0.5;
    attributes = {
      x: `${x}`,
      y: `${y}`,
      width: `${side}`,
      height: `${side}`,
      stroke: color,
      fill,
      "stroke-width": strokeWidth,
      rx: `${side * 0.1}`,
      opacity
    };
  } else {
    throw new Error(`Unsupported handle type: ${type}`);
  }
  const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);
  if (existingHandleElement) {
    setAttributesIfNecessary_default(attributes, existingHandleElement);
    svgDrawingHelper.setNodeTouched(svgNodeHash);
  } else {
    const newHandleElement = document.createElementNS(svgns, type);
    setNewAttributesIfValid_default(attributes, newHandleElement);
    svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);
  }
}
var drawHandle_default = drawHandle;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js
function drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {
  handlePoints.forEach((handle, i) => {
    drawHandle_default(svgDrawingHelper, annotationUID, handleGroupUID, handle, options, i);
  });
}
var drawHandles_default = drawHandles;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js
function drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, options = {}, dataId = "") {
  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
    return;
  }
  const { color, width, lineWidth, lineDash, shadow } = Object.assign({
    color: "rgb(0, 255, 0)",
    width: "2",
    lineWidth: void 0,
    lineDash: void 0,
    shadow: void 0
  }, options);
  const strokeWidth = lineWidth || width;
  const svgns = "http://www.w3.org/2000/svg";
  const svgNodeHash = getHash_default(annotationUID, "line", lineUID);
  const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);
  const dropShadowStyle = shadow ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});` : "";
  const attributes = {
    x1: `${start[0]}`,
    y1: `${start[1]}`,
    x2: `${end[0]}`,
    y2: `${end[1]}`,
    stroke: color,
    style: dropShadowStyle,
    "stroke-width": strokeWidth,
    "stroke-dasharray": lineDash
  };
  if (existingLine) {
    setAttributesIfNecessary_default(attributes, existingLine);
    svgDrawingHelper.setNodeTouched(svgNodeHash);
  } else {
    const newLine = document.createElementNS(svgns, "line");
    if (dataId !== "") {
      newLine.setAttribute("data-id", dataId);
    }
    setNewAttributesIfValid_default(attributes, newLine);
    svgDrawingHelper.appendNode(newLine, svgNodeHash);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js
function drawHeight(svgDrawingHelper, annotationUID, heightUID, start, end, options = {}) {
  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
    return;
  }
  const { color, width, lineWidth, lineDash } = Object.assign({
    color: "rgb(0, 255, 0)",
    width: "2",
    lineWidth: void 0,
    lineDash: void 0
  }, options);
  const midX = end[0] + (start[0] - end[0]) / 2;
  const endfirstLine = [midX, start[1]];
  const endsecondLine = [midX, end[1]];
  const firstLine = {
    start,
    end: endfirstLine
  };
  const secondLine = {
    start: endfirstLine,
    end: endsecondLine
  };
  const threeLine = {
    start: endsecondLine,
    end
  };
  drawLine(svgDrawingHelper, annotationUID, "1", firstLine.start, firstLine.end, {
    color,
    width,
    lineWidth
  });
  drawLine(svgDrawingHelper, annotationUID, "2", secondLine.start, secondLine.end, {
    color,
    width,
    lineWidth
  });
  drawLine(svgDrawingHelper, annotationUID, "3", threeLine.start, threeLine.end, {
    color,
    width,
    lineWidth
  });
}

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js
function drawPolyline(svgDrawingHelper, annotationUID, polylineUID, points, options) {
  if (points.length < 2) {
    return;
  }
  const { color = "rgb(0, 255, 0)", width = 10, fillColor = "none", fillOpacity = 0, lineWidth, lineDash, closePath = false } = options;
  const strokeWidth = lineWidth || width;
  const svgns = "http://www.w3.org/2000/svg";
  const svgNodeHash = getHash_default(annotationUID, "polyline", polylineUID);
  const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);
  let pointsAttribute = "";
  for (const point of points) {
    pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;
  }
  if (closePath) {
    const firstPoint = points[0];
    pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;
  }
  const attributes = {
    points: pointsAttribute,
    stroke: color,
    fill: fillColor,
    "fill-opacity": fillOpacity,
    "stroke-width": strokeWidth,
    "stroke-dasharray": lineDash
  };
  if (existingPolyLine) {
    setAttributesIfNecessary_default(attributes, existingPolyLine);
    svgDrawingHelper.setNodeTouched(svgNodeHash);
  } else {
    const newPolyLine = document.createElementNS(svgns, "polyline");
    setNewAttributesIfValid_default(attributes, newPolyLine);
    svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPath.js
function drawPath(svgDrawingHelper, annotationUID, pathUID, points, options) {
  const hasSubArrays = points.length && points[0].length && Array.isArray(points[0][0]);
  const pointsArrays = hasSubArrays ? points : [points];
  const { color = "rgb(0, 255, 0)", width = 10, fillColor = "none", fillOpacity = 0, lineWidth, lineDash, closePath = false } = options;
  const strokeWidth = lineWidth || width;
  const svgns = "http://www.w3.org/2000/svg";
  const svgNodeHash = getHash_default(annotationUID, "path", pathUID);
  const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);
  let pointsAttribute = "";
  for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {
    const points2 = pointsArrays[i];
    const numPoints = points2.length;
    if (numPoints < 2) {
      continue;
    }
    for (let j = 0; j < numPoints; j++) {
      const point = points2[j];
      const cmd = j ? "L" : "M";
      pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;
    }
    if (closePath) {
      pointsAttribute += "Z ";
    }
  }
  if (!pointsAttribute) {
    return;
  }
  const attributes = {
    d: pointsAttribute,
    stroke: color,
    fill: fillColor,
    "fill-opacity": fillOpacity,
    "stroke-width": strokeWidth,
    "stroke-dasharray": lineDash
  };
  if (existingNode) {
    setAttributesIfNecessary_default(attributes, existingNode);
    svgDrawingHelper.setNodeTouched(svgNodeHash);
  } else {
    const newNode = document.createElementNS(svgns, "path");
    setNewAttributesIfValid_default(attributes, newNode);
    svgDrawingHelper.appendNode(newNode, svgNodeHash);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js
function drawTextBox(svgDrawingHelper, annotationUID, textUID, textLines, position, options = {}) {
  const mergedOptions = Object.assign({
    fontFamily: "Helvetica, Arial, sans-serif",
    fontSize: "14px",
    color: "rgb(255, 255, 0)",
    background: "",
    padding: 25,
    centerX: false,
    centerY: true
  }, options);
  const textGroupBoundingBox = _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines, position, mergedOptions);
  return textGroupBoundingBox;
}
function _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines = [""], position, options) {
  const { padding, color, fontFamily, fontSize, background } = options;
  let textGroupBoundingBox;
  const [x, y] = [position[0] + padding, position[1] + padding];
  const svgns = "http://www.w3.org/2000/svg";
  const svgNodeHash = getHash_default(annotationUID, "text", textUID);
  const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);
  if (existingTextGroup) {
    const textElement = existingTextGroup.querySelector("text");
    const textSpans = Array.from(textElement.children);
    for (let i = 0; i < textSpans.length; i++) {
      const textSpanElement = textSpans[i];
      const text = textLines[i] || "";
      textSpanElement.textContent = text;
    }
    if (textLines.length > textSpans.length) {
      for (let i = 0; i < textLines.length - textSpans.length; i++) {
        const textLine = textLines[i + textSpans.length];
        const textSpan = _createTextSpan(textLine);
        textElement.appendChild(textSpan);
      }
      existingTextGroup.appendChild(textElement);
      svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);
    }
    const textAttributes = {
      fill: color,
      "font-size": fontSize,
      "font-family": fontFamily
    };
    const textGroupAttributes = {
      transform: `translate(${x} ${y})`
    };
    setAttributesIfNecessary_default(textAttributes, textElement);
    setAttributesIfNecessary_default(textGroupAttributes, existingTextGroup);
    textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);
    svgDrawingHelper.setNodeTouched(svgNodeHash);
  } else {
    const textGroup = document.createElementNS(svgns, "g");
    textGroup.setAttribute("transform", `translate(${x} ${y})`);
    const textElement = _createTextElement(svgDrawingHelper, options);
    for (let i = 0; i < textLines.length; i++) {
      const textLine = textLines[i];
      const textSpan = _createTextSpan(textLine);
      textElement.appendChild(textSpan);
    }
    textGroup.appendChild(textElement);
    svgDrawingHelper.appendNode(textGroup, svgNodeHash);
    textGroupBoundingBox = _drawTextBackground(textGroup, background);
  }
  return Object.assign({}, textGroupBoundingBox, {
    x,
    y,
    height: textGroupBoundingBox.height + padding,
    width: textGroupBoundingBox.width + padding
  });
}
function _createTextElement(svgDrawingHelper, options) {
  const { color, fontFamily, fontSize } = options;
  const svgns = "http://www.w3.org/2000/svg";
  const textElement = document.createElementNS(svgns, "text");
  const noSelectStyle = "user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);";
  const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;
  const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;
  textElement.setAttribute("x", "0");
  textElement.setAttribute("y", "0");
  textElement.setAttribute("fill", color);
  textElement.setAttribute("font-family", fontFamily);
  textElement.setAttribute("font-size", fontSize);
  textElement.setAttribute("style", combinedStyle);
  return textElement;
}
function _createTextSpan(text) {
  const svgns = "http://www.w3.org/2000/svg";
  const textSpanElement = document.createElementNS(svgns, "tspan");
  textSpanElement.setAttribute("x", "0");
  textSpanElement.setAttribute("dy", "1.2em");
  textSpanElement.textContent = text;
  return textSpanElement;
}
function _drawTextBackground(group, color) {
  let element = group.querySelector("rect.background");
  if (!color) {
    if (element) {
      group.removeChild(element);
    }
    return group.getBBox();
  }
  if (!element) {
    element = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    element.setAttribute("class", "background");
    group.insertBefore(element, group.firstChild);
  }
  const bBox = group.getBBox();
  const attributes = {
    x: `${bBox.x}`,
    y: `${bBox.y}`,
    width: `${bBox.width}`,
    height: `${bBox.height}`,
    fill: color
  };
  setAttributesIfNecessary_default(attributes, element);
  return bBox;
}
var drawTextBox_default = drawTextBox;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js
function drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {
  const start = annotationAnchorPoints.length > 0 ? findClosestPoint(annotationAnchorPoints, refPoint) : refPoint;
  const boundingBoxPoints = _boundingBoxPoints(boundingBox);
  const end = findClosestPoint(boundingBoxPoints, start);
  const mergedOptions = Object.assign({
    color: "rgb(255, 255, 0)",
    lineWidth: "1",
    lineDash: "2,3"
  }, options);
  drawLine(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);
}
function _boundingBoxPoints(boundingBox) {
  const { x: left, y: top, height, width } = boundingBox;
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  const topMiddle = [left + halfWidth, top];
  const leftMiddle = [left, top + halfHeight];
  const bottomMiddle = [left + halfWidth, top + height];
  const rightMiddle = [left + width, top + halfHeight];
  return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];
}
var drawLink_default = drawLink;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js
function drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {
  const mergedOptions = Object.assign({
    handleRadius: "6",
    centering: {
      x: false,
      y: true
    }
  }, options);
  const canvasBoundingBox = drawTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);
  drawLink_default(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);
  return canvasBoundingBox;
}
var drawLinkedTextBox_default = drawLinkedTextBox;

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js
function drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, options = {}, dataId = "") {
  const { color, width: _width, lineWidth, lineDash } = Object.assign({
    color: "rgb(0, 255, 0)",
    width: "2",
    lineWidth: void 0,
    lineDash: void 0
  }, options);
  const strokeWidth = lineWidth || _width;
  const svgns = "http://www.w3.org/2000/svg";
  const svgNodeHash = getHash_default(annotationUID, "rect", rectangleUID);
  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);
  const [topLeft, topRight, bottomLeft, bottomRight] = canvasCoordinates;
  const width = Math.hypot(topLeft[0] - topRight[0], topLeft[1] - topRight[1]);
  const height = Math.hypot(topLeft[0] - bottomLeft[0], topLeft[1] - bottomLeft[1]);
  const center = [
    (bottomRight[0] + topLeft[0]) / 2,
    (bottomRight[1] + topLeft[1]) / 2
  ];
  const leftEdgeCenter = [
    (bottomLeft[0] + topLeft[0]) / 2,
    (bottomLeft[1] + topLeft[1]) / 2
  ];
  const angle = Math.atan2(center[1] - leftEdgeCenter[1], center[0] - leftEdgeCenter[0]) * 180 / Math.PI;
  const attributes = {
    x: `${center[0] - width / 2}`,
    y: `${center[1] - height / 2}`,
    width: `${width}`,
    height: `${height}`,
    stroke: color,
    fill: "transparent",
    transform: `rotate(${angle} ${center[0]} ${center[1]})`,
    "stroke-width": strokeWidth,
    "stroke-dasharray": lineDash
  };
  if (existingRect) {
    setAttributesIfNecessary_default(attributes, existingRect);
    svgDrawingHelper.setNodeTouched(svgNodeHash);
  } else {
    const svgRectElement = document.createElementNS(svgns, "rect");
    if (dataId !== "") {
      svgRectElement.setAttribute("data-id", dataId);
    }
    setNewAttributesIfValid_default(attributes, svgRectElement);
    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js
function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = "") {
  const topLeft = [start[0], start[1]];
  const topRight = [end[0], start[1]];
  const bottomLeft = [start[0], end[1]];
  const bottomRight = [end[0], end[1]];
  drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, [topLeft, topRight, bottomLeft, bottomRight], options, dataId);
}

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js
function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {
  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
    return;
  }
  const { color, width, lineWidth, lineDash } = Object.assign({
    color: "rgb(0, 255, 0)",
    width: "2",
    lineWidth: void 0,
    lineDash: void 0
  }, options);
  drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {
    color,
    width,
    lineWidth,
    lineDash
  });
  const headLength = 10;
  const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);
  const firstLine = {
    start: [
      end[0] - headLength * Math.cos(angle - Math.PI / 7),
      end[1] - headLength * Math.sin(angle - Math.PI / 7)
    ],
    end
  };
  const secondLine = {
    start: [
      end[0] - headLength * Math.cos(angle + Math.PI / 7),
      end[1] - headLength * Math.sin(angle + Math.PI / 7)
    ],
    end
  };
  drawLine(svgDrawingHelper, annotationUID, "2", firstLine.start, firstLine.end, {
    color,
    width,
    lineWidth
  });
  drawLine(svgDrawingHelper, annotationUID, "3", secondLine.start, secondLine.end, {
    color,
    width,
    lineWidth
  });
}

// node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js
function drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}) {
  const { color, width: _width, lineWidth, lineDash } = Object.assign({
    color: "rgb(0, 255, 0)",
    width: "2",
    lineWidth: void 0,
    lineDash: void 0
  }, options);
  const strokeWidth = lineWidth || _width;
  const svgns = "http://www.w3.org/2000/svg";
  const svgNodeHash = getHash_default(annotationUID, "rect", rectangleUID);
  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);
  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];
  const width = Math.abs(start[0] - end[0]);
  const height = Math.abs(start[1] - end[1]);
  const attributes = {
    x: `${tlhc[0]}`,
    y: `${tlhc[1]}`,
    width: `${width}`,
    height: `${height}`,
    stroke: color,
    fill: "black",
    "stroke-width": strokeWidth,
    "stroke-dasharray": lineDash
  };
  if (existingRect) {
    setAttributesIfNecessary_default(attributes, existingRect);
    svgDrawingHelper.setNodeTouched(svgNodeHash);
  } else {
    const svgRectElement = document.createElementNS(svgns, "rect");
    setNewAttributesIfValid_default(attributes, svgRectElement);
    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/getToolsWithModesForElement.js
function getToolsWithModesForElement(element, modesFilter) {
  const enabledElement = getEnabledElement(element);
  const { renderingEngineId, viewportId } = enabledElement;
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  if (!toolGroup) {
    return [];
  }
  const enabledTools = [];
  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
  for (let j = 0; j < toolGroupToolNames.length; j++) {
    const toolName = toolGroupToolNames[j];
    const toolOptions = toolGroup.toolOptions[toolName];
    if (!toolOptions) {
      continue;
    }
    if (modesFilter.includes(toolOptions.mode)) {
      const toolInstance = toolGroup.getToolInstance(toolName);
      enabledTools.push(toolInstance);
    }
  }
  return enabledTools;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js
var { Active: Active3, Passive: Passive3, Enabled: Enabled3 } = ToolModes_default;
var AnnotationRenderingEngine = class {
  constructor() {
    this._needsRender = /* @__PURE__ */ new Set();
    this._animationFrameSet = false;
    this._animationFrameHandle = null;
    this._renderFlaggedViewports = () => {
      this._throwIfDestroyed();
      const elements = Array.from(this._viewportElements.values());
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        if (this._needsRender.has(element)) {
          this._triggerRender(element);
          this._needsRender.delete(element);
          if (this._needsRender.size === 0) {
            break;
          }
        }
      }
      this._animationFrameSet = false;
      this._animationFrameHandle = null;
      this._render();
    };
    this._viewportElements = /* @__PURE__ */ new Map();
  }
  addViewportElement(viewportId, element) {
    this._viewportElements.set(viewportId, element);
  }
  removeViewportElement(viewportId, element) {
    this._viewportElements.delete(viewportId);
    this._needsRender.delete(element);
    this._reset();
  }
  renderViewport(element) {
    this._setViewportsToBeRenderedNextFrame([element]);
  }
  _throwIfDestroyed() {
    if (this.hasBeenDestroyed) {
      throw new Error("this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.");
    }
  }
  _setAllViewportsToBeRenderedNextFrame() {
    const elements = [...this._viewportElements.values()];
    elements.forEach((element) => {
      this._needsRender.add(element);
    });
    this._renderFlaggedViewports();
  }
  _setViewportsToBeRenderedNextFrame(elements) {
    const elementsEnabled = [...this._viewportElements.values()];
    elements.forEach((element) => {
      if (elementsEnabled.indexOf(element) !== -1) {
        this._needsRender.add(element);
      }
    });
    this._render();
  }
  _render() {
    if (this._needsRender.size > 0 && this._animationFrameSet === false) {
      this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);
      this._animationFrameSet = true;
    }
  }
  _triggerRender(element) {
    const enabledElement = getEnabledElement(element);
    if (!enabledElement) {
      return;
    }
    const renderingEngine = getRenderingEngine(enabledElement.renderingEngineId);
    if (!renderingEngine) {
      console.warn("rendering Engine has been destroyed");
      return;
    }
    const enabledTools = getToolsWithModesForElement(element, [
      Active3,
      Passive3,
      Enabled3
    ]);
    const { renderingEngineId, viewportId } = enabledElement;
    const eventDetail = {
      element,
      renderingEngineId,
      viewportId
    };
    draw_default(element, (svgDrawingHelper) => {
      let anyRendered = false;
      const handleDrawSvg = (tool) => {
        if (tool.renderAnnotation) {
          const rendered = tool.renderAnnotation(enabledElement, svgDrawingHelper);
          anyRendered = anyRendered || rendered;
        }
      };
      enabledTools.forEach(handleDrawSvg);
      if (anyRendered) {
        triggerEvent(element, Events_default.ANNOTATION_RENDERED, { ...eventDetail });
      }
    });
  }
  _reset() {
    window.cancelAnimationFrame(this._animationFrameHandle);
    this._needsRender.clear();
    this._animationFrameSet = false;
    this._animationFrameHandle = null;
    this._setAllViewportsToBeRenderedNextFrame();
  }
};
var annotationRenderingEngine = new AnnotationRenderingEngine();

// node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js
function triggerAnnotationRender(element) {
  annotationRenderingEngine.renderViewport(element);
}
var triggerAnnotationRender_default = triggerAnnotationRender;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js
function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {
  if (!viewportIdsToRender.length) {
    return;
  }
  viewportIdsToRender.forEach((viewportId) => {
    const enabledElement = getEnabledElementByViewportId(viewportId);
    if (!enabledElement) {
      console.warn(`Viewport not available for ${viewportId}`);
      return;
    }
    const { viewport } = enabledElement;
    if (!viewport) {
      console.warn(`Viewport not available for ${viewportId}`);
      return;
    }
    const element = viewport.element;
    triggerAnnotationRender_default(element);
  });
}
var triggerAnnotationRenderForViewportIds_default = triggerAnnotationRenderForViewportIds;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js
function isPoints3D(points) {
  var _a2;
  return ((_a2 = points[0]) == null ? void 0 : _a2.length) === 3;
}
function interpolatePoints(originalPoints, knotsIndexes) {
  if (!knotsIndexes || knotsIndexes.length === 0 || knotsIndexes.length === originalPoints.length) {
    return originalPoints;
  }
  const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;
  const xInterpolator = basis_default(knotsIndexes.map((k) => originalPoints[k][0]));
  const yInterpolator = basis_default(knotsIndexes.map((k) => originalPoints[k][1]));
  if (isPoints3D(originalPoints)) {
    const zInterpolator = basis_default(knotsIndexes.map((k) => originalPoints[k][2]));
    return zip(quantize_default(xInterpolator, n), quantize_default(yInterpolator, n), quantize_default(zInterpolator, n));
  } else {
    return zip(quantize_default(xInterpolator, n), quantize_default(yInterpolator, n));
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js
function getContinuousUniformDistributionValues(minDistributionDistance, closedInterval) {
  const result = [];
  const [intervalIni, intervalEnd] = closedInterval;
  const intervalSize = intervalEnd - intervalIni + 1;
  const intensity = Math.floor(intervalSize / minDistributionDistance);
  let x = 0;
  let continuosDistributionValue = Math.round((intervalSize - 1) / (intensity - 1) * x) + intervalIni;
  while (continuosDistributionValue <= intervalEnd) {
    result.push(continuosDistributionValue);
    x++;
    continuosDistributionValue = Math.round((intervalSize - 1) / (intensity - 1) * x) + intervalIni;
  }
  return result;
}
function interpolateSegmentPoints(points, iniIndex, endIndex, knotsRatioPercentage) {
  const segmentSize = endIndex - iniIndex + 1;
  const amountOfKnots = Math.floor(knotsRatioPercentage / 100 * segmentSize) ?? 1;
  const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;
  if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {
    return points;
  }
  if (segmentSize / minKnotDistance < 2) {
    return points;
  }
  const interpolationIniIndex = Math.max(0, iniIndex);
  const interpolationEndIndex = Math.min(points.length - 1, endIndex);
  const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);
  const segmentPointsUnchangedEnd = points.slice(interpolationEndIndex + 1, points.length);
  const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [
    interpolationIniIndex,
    interpolationEndIndex
  ]);
  const interpolatedPoints = interpolatePoints(points, knotsIndexes);
  return [
    ...segmentPointsUnchangedBeg,
    ...interpolatedPoints,
    ...segmentPointsUnchangedEnd
  ];
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js
function shouldSmooth(configuration3, annotation) {
  var _a2, _b2;
  if (annotation == null ? void 0 : annotation.autoGenerated) {
    return false;
  }
  const shouldSmooth2 = ((_a2 = configuration3 == null ? void 0 : configuration3.smoothing) == null ? void 0 : _a2.smoothOnAdd) === true || ((_b2 = configuration3 == null ? void 0 : configuration3.smoothing) == null ? void 0 : _b2.smoothOnEdit) === true;
  return shouldSmooth2;
}
function isEqualByProximity(pointA, pointB) {
  return point_exports.distanceToPoint(pointA, pointB) < 1e-3;
}
function isEqual(pointA, pointB) {
  return point_exports.distanceToPoint(pointA, pointB) === 0;
}
function findMatchIndexes(points, otherPoints) {
  for (let i = 0; i < points.length; i++) {
    for (let j = 0; j < otherPoints.length; j++) {
      if (isEqual(points[i], otherPoints[j])) {
        return [i, j];
      }
    }
  }
}
function followingIndex(index, size, direction) {
  return (index + size + direction) % size;
}
function circularFindNextIndexBy(listParams, otherListParams, criteria, direction) {
  const [, indexDelimiter, points] = listParams;
  const [, otherIndexDelimiter, otherPoints] = otherListParams;
  const pointsLength = points.length;
  const otherPointsLength = otherPoints.length;
  let startIndex = listParams[0];
  let otherStartIndex = otherListParams[0];
  if (!points[startIndex] || !otherPoints[otherStartIndex] || !points[indexDelimiter] || !otherPoints[otherIndexDelimiter]) {
    return [void 0, void 0];
  }
  while (startIndex !== indexDelimiter && otherStartIndex !== otherIndexDelimiter) {
    if (criteria(otherPoints[otherStartIndex], points[startIndex])) {
      return [startIndex, otherStartIndex];
    }
    startIndex = followingIndex(startIndex, pointsLength, direction);
    otherStartIndex = followingIndex(otherStartIndex, otherPointsLength, direction);
  }
  return [void 0, void 0];
}
function findChangedSegment(points, previousPoints) {
  const [firstMatchIndex, previousFirstMatchIndex] = findMatchIndexes(points, previousPoints) || [];
  const toBeNotEqualCriteria = (pointA, pointB) => isEqualByProximity(pointA, pointB) === false;
  const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy([
    followingIndex(firstMatchIndex, points.length, 1),
    firstMatchIndex,
    points
  ], [
    followingIndex(previousFirstMatchIndex, previousPoints.length, 1),
    previousFirstMatchIndex,
    previousPoints
  ], toBeNotEqualCriteria, 1);
  const [highIndex] = circularFindNextIndexBy([followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points], [
    followingIndex(lowOtherDiffIndex, previousPoints.length, -1),
    lowOtherDiffIndex,
    previousPoints
  ], toBeNotEqualCriteria, -1);
  return [lowDiffIndex, highIndex];
}
function getInterpolatedPoints(configuration3, points, pointsOfReference) {
  const { interpolation, smoothing } = configuration3;
  const result = points;
  if (interpolation) {
    const { knotsRatioPercentageOnAdd, knotsRatioPercentageOnEdit, smoothOnAdd = false, smoothOnEdit = false } = smoothing;
    const knotsRatioPercentage = pointsOfReference ? knotsRatioPercentageOnEdit : knotsRatioPercentageOnAdd;
    const isEnabled = pointsOfReference ? smoothOnEdit : smoothOnAdd;
    if (isEnabled) {
      const [changedIniIndex, changedEndIndex] = pointsOfReference ? findChangedSegment(points, pointsOfReference) : [0, points.length - 1];
      if (!points[changedIniIndex] || !points[changedEndIndex]) {
        return points;
      }
      return interpolateSegmentPoints(points, changedIniIndex, changedEndIndex, knotsRatioPercentage);
    }
  }
  return result;
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js
var getMouseModifierKey = (evt) => {
  if (evt.shiftKey) {
    if (evt.ctrlKey) {
      return KeyboardBindings.ShiftCtrl;
    }
    if (evt.altKey) {
      return KeyboardBindings.ShiftAlt;
    }
    if (evt.metaKey) {
      return KeyboardBindings.ShiftMeta;
    }
    return KeyboardBindings.Shift;
  }
  if (evt.ctrlKey) {
    if (evt.altKey) {
      return KeyboardBindings.CtrlAlt;
    }
    if (evt.metaKey) {
      return KeyboardBindings.CtrlMeta;
    }
    return KeyboardBindings.Ctrl;
  }
  if (evt.altKey) {
    return evt.metaKey && KeyboardBindings.AltMeta || KeyboardBindings.Alt;
  }
  if (evt.metaKey) {
    return KeyboardBindings.Meta;
  }
  return void 0;
};
var getMouseModifier_default = getMouseModifierKey;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js
function findOpenUShapedContourVectorToPeak(canvasPoints, viewport) {
  const first = canvasPoints[0];
  const last = canvasPoints[canvasPoints.length - 1];
  const firstToLastUnitVector = vec2_exports.create();
  vec2_exports.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);
  vec2_exports.normalize(firstToLastUnitVector, firstToLastUnitVector);
  const normalVector1 = vec2_exports.create();
  const normalVector2 = vec2_exports.create();
  vec2_exports.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);
  vec2_exports.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);
  const centerOfFirstToLast = [
    (first[0] + last[0]) / 2,
    (first[1] + last[1]) / 2
  ];
  const furthest = {
    dist: 0,
    index: null
  };
  for (let i = 0; i < canvasPoints.length; i++) {
    const canvasPoint = canvasPoints[i];
    const distance = vec2_exports.dist(canvasPoint, centerOfFirstToLast);
    if (distance > furthest.dist) {
      furthest.dist = distance;
      furthest.index = i;
    }
  }
  const toFurthest = [
    canvasPoints[furthest.index],
    centerOfFirstToLast
  ];
  const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);
  return toFurthestWorld;
}
function findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation) {
  const { viewport } = enabledElement;
  const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);
  return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);
}

// node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js
var ContourWindingDirection;
(function(ContourWindingDirection2) {
  ContourWindingDirection2[ContourWindingDirection2["CounterClockwise"] = -1] = "CounterClockwise";
  ContourWindingDirection2[ContourWindingDirection2["Unknown"] = 0] = "Unknown";
  ContourWindingDirection2[ContourWindingDirection2["Clockwise"] = 1] = "Clockwise";
})(ContourWindingDirection || (ContourWindingDirection = {}));

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js
var { addCanvasPointsToArray: addCanvasPointsToArray2, pointsAreWithinCloseContourProximity: pointsAreWithinCloseContourProximity2, getFirstLineSegmentIntersectionIndexes: getFirstLineSegmentIntersectionIndexes2, getSubPixelSpacingAndXYDirections: getSubPixelSpacingAndXYDirections2 } = polyline_exports;
function activateDraw(evt, annotation, viewportIdsToRender) {
  this.isDrawing = true;
  const eventDetail = evt.detail;
  const { currentPoints, element } = eventDetail;
  const canvasPos = currentPoints.canvas;
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  const contourHoleProcessingEnabled = getMouseModifier_default(evt.detail.event) === this.configuration.contourHoleAdditionModifierKey;
  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections2(viewport, this.configuration.subPixelResolution);
  this.drawData = {
    canvasPoints: [canvasPos],
    polylineIndex: 0,
    contourHoleProcessingEnabled,
    newAnnotation: true
  };
  this.commonData = {
    annotation,
    viewportIdsToRender,
    spacing,
    xDir,
    yDir,
    movingTextBox: false
  };
  state.isInteractingWithTool = true;
  element.addEventListener(Events_default.MOUSE_UP, this.mouseUpDrawCallback);
  element.addEventListener(Events_default.MOUSE_DRAG, this.mouseDragDrawCallback);
  element.addEventListener(Events_default.MOUSE_CLICK, this.mouseUpDrawCallback);
  element.addEventListener(Events_default.TOUCH_END, this.mouseUpDrawCallback);
  element.addEventListener(Events_default.TOUCH_DRAG, this.mouseDragDrawCallback);
  element.addEventListener(Events_default.TOUCH_TAP, this.mouseUpDrawCallback);
  hideElementCursor(element);
}
function deactivateDraw(element) {
  state.isInteractingWithTool = false;
  element.removeEventListener(Events_default.MOUSE_UP, this.mouseUpDrawCallback);
  element.removeEventListener(Events_default.MOUSE_DRAG, this.mouseDragDrawCallback);
  element.removeEventListener(Events_default.MOUSE_CLICK, this.mouseUpDrawCallback);
  element.removeEventListener(Events_default.TOUCH_END, this.mouseUpDrawCallback);
  element.removeEventListener(Events_default.TOUCH_DRAG, this.mouseDragDrawCallback);
  element.removeEventListener(Events_default.TOUCH_TAP, this.mouseUpDrawCallback);
  resetElementCursor(element);
}
function mouseDragDrawCallback(evt) {
  const eventDetail = evt.detail;
  const { currentPoints, element } = eventDetail;
  const worldPos = currentPoints.world;
  const canvasPos = currentPoints.canvas;
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  const { annotation, viewportIdsToRender, xDir, yDir, spacing, movingTextBox } = this.commonData;
  const { polylineIndex, canvasPoints, newAnnotation } = this.drawData;
  this.createMemo(element, annotation, { newAnnotation });
  const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];
  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);
  const worldPosDiff = vec3_exports.create();
  vec3_exports.subtract(worldPosDiff, worldPos, lastWorldPoint);
  const xDist = Math.abs(vec3_exports.dot(worldPosDiff, xDir));
  const yDist = Math.abs(vec3_exports.dot(worldPosDiff, yDir));
  if (xDist <= spacing[0] && yDist <= spacing[1]) {
    return;
  }
  if (movingTextBox) {
    this.isDrawing = false;
    const { deltaPoints } = eventDetail;
    const worldPosDelta = deltaPoints.world;
    const { textBox } = annotation.data.handles;
    const { worldPosition } = textBox;
    worldPosition[0] += worldPosDelta[0];
    worldPosition[1] += worldPosDelta[1];
    worldPosition[2] += worldPosDelta[2];
    textBox.hasMoved = true;
  } else {
    const crossingIndex = this.findCrossingIndexDuringCreate(evt);
    if (crossingIndex !== void 0) {
      this.applyCreateOnCross(evt, crossingIndex);
    } else {
      const numPointsAdded = addCanvasPointsToArray2(element, canvasPoints, canvasPos, this.commonData);
      this.drawData.polylineIndex = polylineIndex + numPointsAdded;
    }
  }
  triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
}
function mouseUpDrawCallback(evt) {
  const { allowOpenContours } = this.configuration;
  const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;
  const firstPoint = canvasPoints[0];
  const lastPoint = canvasPoints[canvasPoints.length - 1];
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  this.doneEditMemo();
  this.drawData.newAnnotation = false;
  if (allowOpenContours && !pointsAreWithinCloseContourProximity2(firstPoint, lastPoint, this.configuration.closeContourProximity)) {
    this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });
  } else {
    this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });
  }
}
function completeDrawClosedContour(element, options) {
  this.removeCrossedLinesOnCompleteDraw();
  const { canvasPoints } = this.drawData;
  const { contourHoleProcessingEnabled, minPointsToSave } = options ?? {};
  if (minPointsToSave && canvasPoints.length < minPointsToSave) {
    return false;
  }
  if (this.haltDrawing(element, canvasPoints)) {
    return false;
  }
  const { annotation, viewportIdsToRender } = this.commonData;
  const enabledElement = getEnabledElement(element);
  const { viewport, renderingEngine } = enabledElement;
  addCanvasPointsToArray2(element, canvasPoints, canvasPoints[0], this.commonData);
  canvasPoints.pop();
  const updatedPoints = shouldSmooth(this.configuration, annotation) ? getInterpolatedPoints(this.configuration, canvasPoints) : canvasPoints;
  this.updateContourPolyline(annotation, {
    points: updatedPoints,
    closed: true,
    targetWindingDirection: ContourWindingDirection.Clockwise
  }, viewport);
  const { textBox } = annotation.data.handles;
  if (!(textBox == null ? void 0 : textBox.hasMoved)) {
    triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);
  }
  this.isDrawing = false;
  this.drawData = void 0;
  this.commonData = void 0;
  triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
  this.deactivateDraw(element);
  return true;
}
function removeCrossedLinesOnCompleteDraw() {
  const { canvasPoints } = this.drawData;
  const numPoints = canvasPoints.length;
  const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];
  const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);
  const lineSegment = getFirstLineSegmentIntersectionIndexes2(canvasPointsMinusEnds, endToStart[0], endToStart[1], false);
  if (lineSegment) {
    const indexToRemoveUpTo = lineSegment[1];
    if (indexToRemoveUpTo === 1) {
      this.drawData.canvasPoints = canvasPoints.splice(1);
    } else {
      this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);
    }
  }
}
function completeDrawOpenContour(element, options) {
  const { canvasPoints } = this.drawData;
  const { contourHoleProcessingEnabled } = options ?? {};
  if (this.haltDrawing(element, canvasPoints)) {
    return false;
  }
  const { annotation, viewportIdsToRender } = this.commonData;
  const enabledElement = getEnabledElement(element);
  const { viewport, renderingEngine } = enabledElement;
  const updatedPoints = shouldSmooth(this.configuration, annotation) ? getInterpolatedPoints(this.configuration, canvasPoints) : canvasPoints;
  this.updateContourPolyline(annotation, {
    points: updatedPoints,
    closed: false
  }, viewport);
  const { textBox } = annotation.data.handles;
  const worldPoints = annotation.data.contour.polyline;
  annotation.data.handles.points = [
    worldPoints[0],
    worldPoints[worldPoints.length - 1]
  ];
  if (annotation.data.isOpenUShapeContour) {
    annotation.data.openUShapeContourVectorToPeak = findOpenUShapedContourVectorToPeak(canvasPoints, viewport);
  }
  if (!textBox.hasMoved) {
    triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);
  }
  this.isDrawing = false;
  this.drawData = void 0;
  this.commonData = void 0;
  triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
  this.deactivateDraw(element);
  return true;
}
function findCrossingIndexDuringCreate(evt) {
  const eventDetail = evt.detail;
  const { currentPoints, lastPoints } = eventDetail;
  const canvasPos = currentPoints.canvas;
  const lastCanvasPoint = lastPoints.canvas;
  const { canvasPoints } = this.drawData;
  const pointsLessLastOne = canvasPoints.slice(0, -1);
  const lineSegment = getFirstLineSegmentIntersectionIndexes2(pointsLessLastOne, canvasPos, lastCanvasPoint, false);
  if (lineSegment === void 0) {
    return;
  }
  const crossingIndex = lineSegment[0];
  return crossingIndex;
}
function applyCreateOnCross(evt, crossingIndex) {
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;
  const { annotation, viewportIdsToRender } = this.commonData;
  addCanvasPointsToArray2(element, canvasPoints, canvasPoints[crossingIndex], this.commonData);
  canvasPoints.pop();
  const remainingPoints = canvasPoints.slice(crossingIndex);
  const newArea = polyline_exports.getArea(remainingPoints);
  if (utilities_exports.isEqual(newArea, 0)) {
    canvasPoints.splice(crossingIndex + 1);
    return;
  }
  canvasPoints.splice(0, crossingIndex);
  const options = { contourHoleProcessingEnabled, minPointsToSave: 3 };
  if (this.completeDrawClosedContour(element, options)) {
    this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);
  }
}
function cancelDrawing(element) {
  const { allowOpenContours } = this.configuration;
  const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;
  const firstPoint = canvasPoints[0];
  const lastPoint = canvasPoints[canvasPoints.length - 1];
  if (allowOpenContours && !pointsAreWithinCloseContourProximity2(firstPoint, lastPoint, this.configuration.closeContourProximity)) {
    this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });
  } else {
    this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });
  }
}
function shouldHaltDrawing(canvasPoints, subPixelResolution) {
  const minPoints = Math.max(subPixelResolution * 3, 3);
  return canvasPoints.length < minPoints;
}
function haltDrawing(element, canvasPoints) {
  const { subPixelResolution } = this.configuration;
  if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {
    const { annotation, viewportIdsToRender } = this.commonData;
    const enabledElement = getEnabledElement(element);
    const { renderingEngine } = enabledElement;
    removeAnnotation(annotation.annotationUID);
    this.isDrawing = false;
    this.drawData = void 0;
    this.commonData = void 0;
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    this.deactivateDraw(element);
    return true;
  }
  return false;
}
function registerDrawLoop(toolInstance) {
  toolInstance.activateDraw = activateDraw.bind(toolInstance);
  toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);
  toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);
  toolInstance.findCrossingIndexDuringCreate = findCrossingIndexDuringCreate.bind(toolInstance);
  toolInstance.completeDrawOpenContour = completeDrawOpenContour.bind(toolInstance);
  toolInstance.removeCrossedLinesOnCompleteDraw = removeCrossedLinesOnCompleteDraw.bind(toolInstance);
  toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);
  toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);
  toolInstance.completeDrawClosedContour = completeDrawClosedContour.bind(toolInstance);
  toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);
  toolInstance.haltDrawing = haltDrawing.bind(toolInstance);
}
var drawLoop_default = registerDrawLoop;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js
var { addCanvasPointsToArray: addCanvasPointsToArray3, getFirstLineSegmentIntersectionIndexes: getFirstLineSegmentIntersectionIndexes3 } = polyline_exports;
function checkForFirstCrossing(evt, isClosedContour) {
  const eventDetail = evt.detail;
  const { element, currentPoints, lastPoints } = eventDetail;
  const canvasPos = currentPoints.canvas;
  const lastCanvasPoint = lastPoints.canvas;
  const { editCanvasPoints, prevCanvasPoints } = this.editData;
  const crossedLineSegment = getFirstLineSegmentIntersectionIndexes3(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);
  if (crossedLineSegment) {
    this.editData.startCrossingIndex = crossedLineSegment[0];
    this.removePointsUpUntilFirstCrossing(isClosedContour);
  } else if (prevCanvasPoints.length >= 2) {
    if (editCanvasPoints.length > this.configuration.checkCanvasEditFallbackProximity) {
      const firstEditCanvasPoint = editCanvasPoints[0];
      const distanceIndexPairs = [];
      for (let i = 0; i < prevCanvasPoints.length; i++) {
        const prevCanvasPoint = prevCanvasPoints[i];
        const distance = vec2_exports.distance(prevCanvasPoint, firstEditCanvasPoint);
        distanceIndexPairs.push({ distance, index: i });
      }
      distanceIndexPairs.sort((a, b) => a.distance - b.distance);
      const twoClosestDistanceIndexPairs = [
        distanceIndexPairs[0],
        distanceIndexPairs[1]
      ];
      const lowestIndex = Math.min(twoClosestDistanceIndexPairs[0].index, twoClosestDistanceIndexPairs[1].index);
      this.editData.startCrossingIndex = lowestIndex;
    } else {
      const dir = vec2_exports.create();
      vec2_exports.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);
      vec2_exports.normalize(dir, dir);
      const proximity = 6;
      const extendedPoint = [
        editCanvasPoints[0][0] - dir[0] * proximity,
        editCanvasPoints[0][1] - dir[1] * proximity
      ];
      const crossedLineSegmentFromExtendedPoint = getFirstLineSegmentIntersectionIndexes3(prevCanvasPoints, extendedPoint, editCanvasPoints[0], isClosedContour);
      if (crossedLineSegmentFromExtendedPoint) {
        const pointsToPrepend = [extendedPoint];
        addCanvasPointsToArray3(element, pointsToPrepend, editCanvasPoints[0], this.commonData);
        editCanvasPoints.unshift(...pointsToPrepend);
        this.removePointsUpUntilFirstCrossing(isClosedContour);
        this.editData.editIndex = editCanvasPoints.length - 1;
        this.editData.startCrossingIndex = crossedLineSegmentFromExtendedPoint[0];
      }
    }
  }
}
function removePointsUpUntilFirstCrossing(isClosedContour) {
  const { editCanvasPoints, prevCanvasPoints } = this.editData;
  let numPointsToRemove = 0;
  for (let i = 0; i < editCanvasPoints.length - 1; i++) {
    const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];
    const didCrossLine = !!getFirstLineSegmentIntersectionIndexes3(prevCanvasPoints, firstLine[0], firstLine[1], isClosedContour);
    numPointsToRemove++;
    if (didCrossLine) {
      break;
    }
  }
  editCanvasPoints.splice(0, numPointsToRemove);
  this.editData.editIndex = editCanvasPoints.length - 1;
}
function checkForSecondCrossing(evt, isClosedContour) {
  const eventDetail = evt.detail;
  const { currentPoints, lastPoints } = eventDetail;
  const canvasPos = currentPoints.canvas;
  const lastCanvasPoint = lastPoints.canvas;
  const { prevCanvasPoints } = this.editData;
  const crossedLineSegment = getFirstLineSegmentIntersectionIndexes3(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);
  if (!crossedLineSegment) {
    return false;
  }
  return true;
}
function removePointsAfterSecondCrossing(isClosedContour) {
  const { prevCanvasPoints, editCanvasPoints } = this.editData;
  for (let i = editCanvasPoints.length - 1; i > 0; i--) {
    const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];
    const didCrossLine = !!getFirstLineSegmentIntersectionIndexes3(prevCanvasPoints, lastLine[0], lastLine[1], isClosedContour);
    editCanvasPoints.pop();
    if (didCrossLine) {
      break;
    }
  }
}
function findSnapIndex() {
  const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } = this.editData;
  if (startCrossingIndex === void 0) {
    return;
  }
  const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];
  const distanceIndexPairs = [];
  for (let i = 0; i < prevCanvasPoints.length; i++) {
    const prevCanvasPoint = prevCanvasPoints[i];
    const distance = vec2_exports.distance(prevCanvasPoint, lastEditCanvasPoint);
    distanceIndexPairs.push({ distance, index: i });
  }
  distanceIndexPairs.sort((a, b) => a.distance - b.distance);
  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);
  for (let i = 0; i < distanceIndexPairs.length; i++) {
    const { index } = distanceIndexPairs[i];
    const snapCanvasPosition = prevCanvasPoints[index];
    const lastEditCanvasPoint2 = editCanvasPoints[editCanvasPoints.length - 1];
    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes3(editCanvasPointsLessLastOne, snapCanvasPosition, lastEditCanvasPoint2, false);
    if (!crossedLineSegment) {
      return index;
    }
  }
  return -1;
}
function checkAndRemoveCrossesOnEditLine(evt) {
  const eventDetail = evt.detail;
  const { currentPoints, lastPoints } = eventDetail;
  const canvasPos = currentPoints.canvas;
  const lastCanvasPoint = lastPoints.canvas;
  const { editCanvasPoints } = this.editData;
  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);
  const crossedLineSegment = getFirstLineSegmentIntersectionIndexes3(editCanvasPointsLessLastOne, canvasPos, lastCanvasPoint, false);
  if (!crossedLineSegment) {
    return;
  }
  const editIndexCrossed = crossedLineSegment[0];
  const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;
  for (let i = 0; i < numPointsToRemove; i++) {
    editCanvasPoints.pop();
  }
}
function registerEditLoopCommon(toolInstance) {
  toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);
  toolInstance.removePointsUpUntilFirstCrossing = removePointsUpUntilFirstCrossing.bind(toolInstance);
  toolInstance.checkForSecondCrossing = checkForSecondCrossing.bind(toolInstance);
  toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);
  toolInstance.removePointsAfterSecondCrossing = removePointsAfterSecondCrossing.bind(toolInstance);
  toolInstance.checkAndRemoveCrossesOnEditLine = checkAndRemoveCrossesOnEditLine.bind(toolInstance);
}
var editLoopCommon_default = registerEditLoopCommon;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js
function updateContourPolyline(annotation, polylineData, transforms, options) {
  var _a2, _b2;
  const { canvasToWorld, worldToCanvas } = transforms;
  const { data } = annotation;
  const { targetWindingDirection } = polylineData;
  let { points: polyline } = polylineData;
  let windingDirection = polyline_exports.getWindingDirection(polyline);
  if ((_a2 = options == null ? void 0 : options.decimate) == null ? void 0 : _a2.enabled) {
    polyline = polyline_exports.decimate(polylineData.points, (_b2 = options == null ? void 0 : options.decimate) == null ? void 0 : _b2.epsilon);
  }
  let { closed: closed2 } = polylineData;
  const numPoints = polyline.length;
  const polylineWorldPoints = new Array(numPoints);
  const currentPolylineWindingDirection = polyline_exports.getWindingDirection(polyline);
  const parentAnnotation = getParentAnnotation(annotation);
  if (closed2 === void 0) {
    let currentClosedState = false;
    if (polyline.length > 3) {
      const lastToFirstDist = point_exports.distanceToPointSquared(polyline[0], polyline[numPoints - 1]);
      currentClosedState = utilities_exports.isEqual(0, lastToFirstDist);
    }
    closed2 = currentClosedState;
  }
  if ((options == null ? void 0 : options.updateWindingDirection) !== false) {
    let updatedWindingDirection = parentAnnotation ? parentAnnotation.data.contour.windingDirection * -1 : targetWindingDirection;
    if (updatedWindingDirection === void 0) {
      updatedWindingDirection = windingDirection;
    }
    if (updatedWindingDirection !== windingDirection) {
      polyline.reverse();
    }
    const handlePoints = data.handles.points.map((p) => worldToCanvas(p));
    if (handlePoints.length > 2) {
      const currentHandlesWindingDirection = polyline_exports.getWindingDirection(handlePoints);
      if (currentHandlesWindingDirection !== updatedWindingDirection) {
        data.handles.points.reverse();
      }
    }
    windingDirection = updatedWindingDirection;
  }
  for (let i = 0; i < numPoints; i++) {
    polylineWorldPoints[i] = canvasToWorld(polyline[i]);
  }
  data.contour.polyline = polylineWorldPoints;
  data.contour.closed = closed2;
  data.contour.windingDirection = windingDirection;
  invalidateAnnotation(annotation);
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js
var { getSubPixelSpacingAndXYDirections: getSubPixelSpacingAndXYDirections3, addCanvasPointsToArray: addCanvasPointsToArray4, getArea: getArea2 } = polyline_exports;
function activateClosedContourEdit(evt, annotation, viewportIdsToRender) {
  this.isEditingClosed = true;
  const eventDetail = evt.detail;
  const { currentPoints, element } = eventDetail;
  const canvasPos = currentPoints.canvas;
  const enabledElement = getEnabledElement(element);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);
  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections3(viewport, this.configuration.subPixelResolution);
  this.editData = {
    prevCanvasPoints,
    editCanvasPoints: [canvasPos],
    startCrossingIndex: void 0,
    editIndex: 0,
    annotation
  };
  this.commonData = {
    annotation,
    viewportIdsToRender,
    spacing,
    xDir,
    yDir,
    movingTextBox: false
  };
  state.isInteractingWithTool = true;
  element.addEventListener(Events_default.MOUSE_UP, this.mouseUpClosedContourEditCallback);
  element.addEventListener(Events_default.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);
  element.addEventListener(Events_default.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);
  element.addEventListener(Events_default.TOUCH_END, this.mouseUpClosedContourEditCallback);
  element.addEventListener(Events_default.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);
  element.addEventListener(Events_default.TOUCH_TAP, this.mouseUpClosedContourEditCallback);
  hideElementCursor(element);
}
function deactivateClosedContourEdit(element) {
  state.isInteractingWithTool = false;
  element.removeEventListener(Events_default.MOUSE_UP, this.mouseUpClosedContourEditCallback);
  element.removeEventListener(Events_default.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);
  element.removeEventListener(Events_default.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);
  element.removeEventListener(Events_default.TOUCH_END, this.mouseUpClosedContourEditCallback);
  element.removeEventListener(Events_default.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);
  element.removeEventListener(Events_default.TOUCH_TAP, this.mouseUpClosedContourEditCallback);
  resetElementCursor(element);
}
function mouseDragClosedContourEditCallback(evt) {
  const eventDetail = evt.detail;
  const { currentPoints, element } = eventDetail;
  const worldPos = currentPoints.world;
  const canvasPos = currentPoints.canvas;
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;
  const { editIndex, editCanvasPoints, startCrossingIndex, annotation } = this.editData;
  this.createMemo(element, annotation);
  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];
  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);
  const worldPosDiff = vec3_exports.create();
  vec3_exports.subtract(worldPosDiff, worldPos, lastWorldPoint);
  const xDist = Math.abs(vec3_exports.dot(worldPosDiff, xDir));
  const yDist = Math.abs(vec3_exports.dot(worldPosDiff, yDir));
  if (xDist <= spacing[0] && yDist <= spacing[1]) {
    return;
  }
  if (startCrossingIndex !== void 0) {
    this.checkAndRemoveCrossesOnEditLine(evt);
  }
  const numPointsAdded = addCanvasPointsToArray4(element, editCanvasPoints, canvasPos, this.commonData);
  const currentEditIndex = editIndex + numPointsAdded;
  this.editData.editIndex = currentEditIndex;
  if (startCrossingIndex === void 0 && editCanvasPoints.length > 1) {
    this.checkForFirstCrossing(evt, true);
  }
  this.editData.snapIndex = this.findSnapIndex();
  if (this.editData.snapIndex === -1) {
    this.finishEditAndStartNewEdit(evt);
    return;
  }
  this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);
  if (startCrossingIndex !== void 0 && this.checkForSecondCrossing(evt, true)) {
    this.removePointsAfterSecondCrossing(true);
    this.finishEditAndStartNewEdit(evt);
  }
  triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
}
function finishEditAndStartNewEdit(evt) {
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  const enabledElement = getEnabledElement(element);
  const { viewport, renderingEngine } = enabledElement;
  const { annotation, viewportIdsToRender } = this.commonData;
  const { fusedCanvasPoints, editCanvasPoints } = this.editData;
  updateContourPolyline(annotation, {
    points: fusedCanvasPoints,
    closed: true,
    targetWindingDirection: ContourWindingDirection.Clockwise
  }, viewport);
  if (annotation.autoGenerated) {
    annotation.autoGenerated = false;
  }
  triggerAnnotationModified(annotation, element);
  const lastEditCanvasPoint = editCanvasPoints.pop();
  this.editData = {
    prevCanvasPoints: fusedCanvasPoints,
    editCanvasPoints: [lastEditCanvasPoint],
    startCrossingIndex: void 0,
    editIndex: 0,
    snapIndex: void 0,
    annotation
  };
  triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
}
function fuseEditPointsWithClosedContour(evt) {
  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;
  if (startCrossingIndex === void 0 || snapIndex === void 0) {
    return;
  }
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  const augmentedEditCanvasPoints = [...editCanvasPoints];
  addCanvasPointsToArray4(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);
  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {
    augmentedEditCanvasPoints.pop();
  }
  let lowIndex;
  let highIndex;
  if (startCrossingIndex > snapIndex) {
    lowIndex = snapIndex;
    highIndex = startCrossingIndex;
  } else {
    lowIndex = startCrossingIndex;
    highIndex = snapIndex;
  }
  const distanceBetweenLowAndFirstPoint = vec2_exports.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);
  const distanceBetweenLowAndLastPoint = vec2_exports.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);
  const distanceBetweenHighAndFirstPoint = vec2_exports.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);
  const distanceBetweenHighAndLastPoint = vec2_exports.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);
  const pointSet1 = [];
  for (let i = 0; i < lowIndex; i++) {
    const canvasPoint = prevCanvasPoints[i];
    pointSet1.push([canvasPoint[0], canvasPoint[1]]);
  }
  let inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;
  let reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;
  if (inPlaceDistance < reverseDistance) {
    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {
      const canvasPoint = augmentedEditCanvasPoints[i];
      pointSet1.push([canvasPoint[0], canvasPoint[1]]);
    }
  } else {
    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {
      const canvasPoint = augmentedEditCanvasPoints[i];
      pointSet1.push([canvasPoint[0], canvasPoint[1]]);
    }
  }
  for (let i = highIndex; i < prevCanvasPoints.length; i++) {
    const canvasPoint = prevCanvasPoints[i];
    pointSet1.push([canvasPoint[0], canvasPoint[1]]);
  }
  const pointSet2 = [];
  for (let i = lowIndex; i < highIndex; i++) {
    const canvasPoint = prevCanvasPoints[i];
    pointSet2.push([canvasPoint[0], canvasPoint[1]]);
  }
  inPlaceDistance = distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;
  reverseDistance = distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;
  if (inPlaceDistance < reverseDistance) {
    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {
      const canvasPoint = augmentedEditCanvasPoints[i];
      pointSet2.push([canvasPoint[0], canvasPoint[1]]);
    }
  } else {
    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {
      const canvasPoint = augmentedEditCanvasPoints[i];
      pointSet2.push([canvasPoint[0], canvasPoint[1]]);
    }
  }
  const areaPointSet1 = getArea2(pointSet1);
  const areaPointSet2 = getArea2(pointSet2);
  const pointsToRender = areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;
  return pointsToRender;
}
function mouseUpClosedContourEditCallback(evt) {
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  this.completeClosedContourEdit(element);
}
function completeClosedContourEdit(element) {
  var _a2;
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  const { annotation, viewportIdsToRender } = this.commonData;
  this.doneEditMemo();
  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;
  if (fusedCanvasPoints) {
    const updatedPoints = shouldSmooth(this.configuration, annotation) ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints) : fusedCanvasPoints;
    const decimateConfig = ((_a2 = this.configuration) == null ? void 0 : _a2.decimate) || {};
    updateContourPolyline(annotation, {
      points: updatedPoints,
      closed: true,
      targetWindingDirection: ContourWindingDirection.Clockwise
    }, viewport, {
      decimate: {
        enabled: !!decimateConfig.enabled,
        epsilon: decimateConfig.epsilon
      }
    });
    if (annotation.autoGenerated) {
      annotation.autoGenerated = false;
    }
    triggerAnnotationModified(annotation, element);
  }
  this.isEditingClosed = false;
  this.editData = void 0;
  this.commonData = void 0;
  triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
  this.deactivateClosedContourEdit(element);
}
function cancelClosedContourEdit(element) {
  this.completeClosedContourEdit(element);
}
function registerClosedContourEditLoop(toolInstance) {
  toolInstance.activateClosedContourEdit = activateClosedContourEdit.bind(toolInstance);
  toolInstance.deactivateClosedContourEdit = deactivateClosedContourEdit.bind(toolInstance);
  toolInstance.mouseDragClosedContourEditCallback = mouseDragClosedContourEditCallback.bind(toolInstance);
  toolInstance.mouseUpClosedContourEditCallback = mouseUpClosedContourEditCallback.bind(toolInstance);
  toolInstance.finishEditAndStartNewEdit = finishEditAndStartNewEdit.bind(toolInstance);
  toolInstance.fuseEditPointsWithClosedContour = fuseEditPointsWithClosedContour.bind(toolInstance);
  toolInstance.cancelClosedContourEdit = cancelClosedContourEdit.bind(toolInstance);
  toolInstance.completeClosedContourEdit = completeClosedContourEdit.bind(toolInstance);
}
var closedContourEditLoop_default = registerClosedContourEditLoop;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js
var { addCanvasPointsToArray: addCanvasPointsToArray5, getSubPixelSpacingAndXYDirections: getSubPixelSpacingAndXYDirections4 } = polyline_exports;
function activateOpenContourEdit(evt, annotation, viewportIdsToRender) {
  this.isEditingOpen = true;
  const eventDetail = evt.detail;
  const { currentPoints, element } = eventDetail;
  const canvasPos = currentPoints.canvas;
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  this.doneEditMemo();
  const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);
  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections4(viewport, this.configuration.subPixelResolution);
  this.editData = {
    prevCanvasPoints,
    editCanvasPoints: [canvasPos],
    startCrossingIndex: void 0,
    editIndex: 0
  };
  this.commonData = {
    annotation,
    viewportIdsToRender,
    spacing,
    xDir,
    yDir,
    movingTextBox: false
  };
  state.isInteractingWithTool = true;
  element.addEventListener(Events_default.MOUSE_UP, this.mouseUpOpenContourEditCallback);
  element.addEventListener(Events_default.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);
  element.addEventListener(Events_default.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);
  element.addEventListener(Events_default.TOUCH_END, this.mouseUpOpenContourEditCallback);
  element.addEventListener(Events_default.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);
  element.addEventListener(Events_default.TOUCH_TAP, this.mouseUpOpenContourEditCallback);
  hideElementCursor(element);
}
function deactivateOpenContourEdit(element) {
  state.isInteractingWithTool = false;
  element.removeEventListener(Events_default.MOUSE_UP, this.mouseUpOpenContourEditCallback);
  element.removeEventListener(Events_default.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);
  element.removeEventListener(Events_default.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);
  element.removeEventListener(Events_default.TOUCH_END, this.mouseUpOpenContourEditCallback);
  element.removeEventListener(Events_default.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);
  element.removeEventListener(Events_default.TOUCH_TAP, this.mouseUpOpenContourEditCallback);
  resetElementCursor(element);
}
function mouseDragOpenContourEditCallback(evt) {
  const eventDetail = evt.detail;
  const { currentPoints, element } = eventDetail;
  const worldPos = currentPoints.world;
  const canvasPos = currentPoints.canvas;
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;
  const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;
  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];
  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);
  const worldPosDiff = vec3_exports.create();
  this.createMemo(element, this.commonData.annotation);
  vec3_exports.subtract(worldPosDiff, worldPos, lastWorldPoint);
  const xDist = Math.abs(vec3_exports.dot(worldPosDiff, xDir));
  const yDist = Math.abs(vec3_exports.dot(worldPosDiff, yDir));
  if (xDist <= spacing[0] && yDist <= spacing[1]) {
    return;
  }
  if (startCrossingIndex !== void 0) {
    this.checkAndRemoveCrossesOnEditLine(evt);
  }
  const numPointsAdded = addCanvasPointsToArray5(element, editCanvasPoints, canvasPos, this.commonData);
  const currentEditIndex = editIndex + numPointsAdded;
  this.editData.editIndex = currentEditIndex;
  if (startCrossingIndex === void 0 && editCanvasPoints.length > 1) {
    this.checkForFirstCrossing(evt, false);
  }
  this.editData.snapIndex = this.findSnapIndex();
  this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);
  if (startCrossingIndex !== void 0 && this.checkForSecondCrossing(evt, false)) {
    this.removePointsAfterSecondCrossing(false);
    this.finishEditOpenOnSecondCrossing(evt);
  } else if (this.checkIfShouldOverwriteAnEnd(evt)) {
    this.openContourEditOverwriteEnd(evt);
  }
  triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
}
function openContourEditOverwriteEnd(evt) {
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  const { annotation, viewportIdsToRender } = this.commonData;
  const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();
  updateContourPolyline(annotation, {
    points: fusedCanvasPoints,
    closed: false
  }, viewport);
  const worldPoints = annotation.data.contour.polyline;
  annotation.data.handles.points = [
    worldPoints[0],
    worldPoints[worldPoints.length - 1]
  ];
  annotation.data.handles.activeHandleIndex = 1;
  triggerAnnotationModified(annotation, element);
  this.isEditingOpen = false;
  this.editData = void 0;
  this.commonData = void 0;
  this.doneEditMemo();
  this.deactivateOpenContourEdit(element);
  this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);
}
function checkIfShouldOverwriteAnEnd(evt) {
  const eventDetail = evt.detail;
  const { currentPoints, lastPoints } = eventDetail;
  const canvasPos = currentPoints.canvas;
  const lastCanvasPos = lastPoints.canvas;
  const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;
  if (startCrossingIndex === void 0 || snapIndex === void 0) {
    return false;
  }
  if (snapIndex === -1) {
    return true;
  }
  if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {
    return false;
  }
  const p1 = canvasPos;
  const p2 = lastCanvasPos;
  const p3 = prevCanvasPoints[snapIndex];
  const a = vec2_exports.create();
  const b = vec2_exports.create();
  vec2_exports.set(a, p1[0] - p2[0], p1[1] - p2[1]);
  vec2_exports.set(b, p1[0] - p3[0], p1[1] - p3[1]);
  const aDotb = vec2_exports.dot(a, b);
  const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);
  const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);
  const theta = Math.acos(aDotb / (magA * magB));
  if (theta < Math.PI / 2) {
    return true;
  }
  return false;
}
function fuseEditPointsForOpenContourEndEdit() {
  const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } = this.editData;
  const newCanvasPoints = [];
  if (snapIndex === 0) {
    for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {
      const canvasPoint = prevCanvasPoints[i];
      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);
    }
  } else {
    for (let i = 0; i < startCrossingIndex; i++) {
      const canvasPoint = prevCanvasPoints[i];
      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);
    }
  }
  const distanceBetweenCrossingIndexAndFirstPoint = vec2_exports.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[0]);
  const distanceBetweenCrossingIndexAndLastPoint = vec2_exports.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[editCanvasPoints.length - 1]);
  if (distanceBetweenCrossingIndexAndFirstPoint < distanceBetweenCrossingIndexAndLastPoint) {
    for (let i = 0; i < editCanvasPoints.length; i++) {
      const canvasPoint = editCanvasPoints[i];
      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);
    }
  } else {
    for (let i = editCanvasPoints.length - 1; i >= 0; i--) {
      const canvasPoint = editCanvasPoints[i];
      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);
    }
  }
  return newCanvasPoints;
}
function fuseEditPointsWithOpenContour(evt) {
  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;
  if (startCrossingIndex === void 0 || snapIndex === void 0) {
    return void 0;
  }
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  const augmentedEditCanvasPoints = [...editCanvasPoints];
  addCanvasPointsToArray5(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);
  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {
    augmentedEditCanvasPoints.pop();
  }
  let lowIndex;
  let highIndex;
  if (startCrossingIndex > snapIndex) {
    lowIndex = snapIndex;
    highIndex = startCrossingIndex;
  } else {
    lowIndex = startCrossingIndex;
    highIndex = snapIndex;
  }
  const distanceBetweenLowAndFirstPoint = vec2_exports.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);
  const distanceBetweenLowAndLastPoint = vec2_exports.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);
  const distanceBetweenHighAndFirstPoint = vec2_exports.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);
  const distanceBetweenHighAndLastPoint = vec2_exports.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);
  const pointsToRender = [];
  for (let i = 0; i < lowIndex; i++) {
    const canvasPoint = prevCanvasPoints[i];
    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);
  }
  const inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;
  const reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;
  if (inPlaceDistance < reverseDistance) {
    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {
      const canvasPoint = augmentedEditCanvasPoints[i];
      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);
    }
  } else {
    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {
      const canvasPoint = augmentedEditCanvasPoints[i];
      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);
    }
  }
  for (let i = highIndex; i < prevCanvasPoints.length; i++) {
    const canvasPoint = prevCanvasPoints[i];
    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);
  }
  return pointsToRender;
}
function finishEditOpenOnSecondCrossing(evt) {
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  const enabledElement = getEnabledElement(element);
  const { viewport, renderingEngine } = enabledElement;
  const { annotation, viewportIdsToRender } = this.commonData;
  const { fusedCanvasPoints, editCanvasPoints } = this.editData;
  updateContourPolyline(annotation, {
    points: fusedCanvasPoints,
    closed: false
  }, viewport);
  const worldPoints = annotation.data.contour.polyline;
  annotation.data.handles.points = [
    worldPoints[0],
    worldPoints[worldPoints.length - 1]
  ];
  triggerAnnotationModified(annotation, element);
  const lastEditCanvasPoint = editCanvasPoints.pop();
  this.editData = {
    prevCanvasPoints: fusedCanvasPoints,
    editCanvasPoints: [lastEditCanvasPoint],
    startCrossingIndex: void 0,
    editIndex: 0
  };
  triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
}
function mouseUpOpenContourEditCallback(evt) {
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  this.completeOpenContourEdit(element);
}
function completeOpenContourEdit(element) {
  var _a2;
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  const { annotation, viewportIdsToRender } = this.commonData;
  this.doneEditMemo();
  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;
  if (fusedCanvasPoints) {
    const updatedPoints = shouldSmooth(this.configuration) ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints) : fusedCanvasPoints;
    const decimateConfig = ((_a2 = this.configuration) == null ? void 0 : _a2.decimate) || {};
    updateContourPolyline(annotation, {
      points: updatedPoints,
      closed: false
    }, viewport, {
      decimate: {
        enabled: !!decimateConfig.enabled,
        epsilon: decimateConfig.epsilon
      }
    });
    const worldPoints = annotation.data.contour.polyline;
    annotation.data.handles.points = [
      worldPoints[0],
      worldPoints[worldPoints.length - 1]
    ];
    if (annotation.data.isOpenUShapeContour) {
      annotation.data.openUShapeContourVectorToPeak = findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);
    }
    triggerAnnotationModified(annotation, element);
  }
  this.isEditingOpen = false;
  this.editData = void 0;
  this.commonData = void 0;
  triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
  this.deactivateOpenContourEdit(element);
}
function cancelOpenContourEdit(element) {
  this.completeOpenContourEdit(element);
}
function registerOpenContourEditLoop(toolInstance) {
  toolInstance.activateOpenContourEdit = activateOpenContourEdit.bind(toolInstance);
  toolInstance.deactivateOpenContourEdit = deactivateOpenContourEdit.bind(toolInstance);
  toolInstance.mouseDragOpenContourEditCallback = mouseDragOpenContourEditCallback.bind(toolInstance);
  toolInstance.mouseUpOpenContourEditCallback = mouseUpOpenContourEditCallback.bind(toolInstance);
  toolInstance.fuseEditPointsWithOpenContour = fuseEditPointsWithOpenContour.bind(toolInstance);
  toolInstance.finishEditOpenOnSecondCrossing = finishEditOpenOnSecondCrossing.bind(toolInstance);
  toolInstance.checkIfShouldOverwriteAnEnd = checkIfShouldOverwriteAnEnd.bind(toolInstance);
  toolInstance.fuseEditPointsForOpenContourEndEdit = fuseEditPointsForOpenContourEndEdit.bind(toolInstance);
  toolInstance.openContourEditOverwriteEnd = openContourEditOverwriteEnd.bind(toolInstance);
  toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);
  toolInstance.completeOpenContourEdit = completeOpenContourEdit.bind(toolInstance);
}
var openContourEditLoop_default = registerOpenContourEditLoop;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js
var { getSubPixelSpacingAndXYDirections: getSubPixelSpacingAndXYDirections5 } = polyline_exports;
function activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle) {
  this.isDrawing = true;
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections5(viewport, this.configuration.subPixelResolution);
  const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);
  const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;
  if (handleIndexGrabbed === 0) {
    canvasPoints.reverse();
  }
  let movingTextBox = false;
  if (handle == null ? void 0 : handle.worldPosition) {
    movingTextBox = true;
  }
  this.drawData = {
    canvasPoints,
    polylineIndex: canvasPoints.length - 1
  };
  this.commonData = {
    annotation,
    viewportIdsToRender,
    spacing,
    xDir,
    yDir,
    movingTextBox
  };
  state.isInteractingWithTool = true;
  element.addEventListener(Events_default.MOUSE_UP, this.mouseUpDrawCallback);
  element.addEventListener(Events_default.MOUSE_DRAG, this.mouseDragDrawCallback);
  element.addEventListener(Events_default.MOUSE_CLICK, this.mouseUpDrawCallback);
  element.addEventListener(Events_default.TOUCH_END, this.mouseUpDrawCallback);
  element.addEventListener(Events_default.TOUCH_DRAG, this.mouseDragDrawCallback);
  element.addEventListener(Events_default.TOUCH_TAP, this.mouseUpDrawCallback);
  hideElementCursor(element);
}
function registerOpenContourEndEditLoop(toolInstance) {
  toolInstance.activateOpenContourEndEdit = activateOpenContourEndEdit.bind(toolInstance);
}
var openContourEndEditLoop_default = registerOpenContourEndEditLoop;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataWorld.js
function getContourHolesDataWorld(annotation) {
  const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];
  return childAnnotationUIDs.map((uid) => getAnnotation(uid).data.contour.polyline);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataCanvas.js
function getContourHolesDataCanvas(annotation, viewport) {
  const worldHoleContours = getContourHolesDataWorld(annotation);
  const canvasHoleContours = [];
  worldHoleContours.forEach((worldHoleContour) => {
    const numPoints = worldHoleContour.length;
    const canvasHoleContour = new Array(numPoints);
    for (let i = 0; i < numPoints; i++) {
      canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);
    }
    canvasHoleContours.push(canvasHoleContour);
  });
  return canvasHoleContours;
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js
var { pointsAreWithinCloseContourProximity: pointsAreWithinCloseContourProximity3 } = polyline_exports;
function _getRenderingOptions(enabledElement, annotation) {
  const styleSpecifier = {
    toolGroupId: this.toolGroupId,
    toolName: this.getToolName(),
    viewportId: enabledElement.viewport.id,
    annotationUID: annotation.annotationUID
  };
  const { lineWidth, lineDash, color, fillColor, fillOpacity } = this.getAnnotationStyle({
    annotation,
    styleSpecifier
  });
  const { closed: isClosedContour } = annotation.data.contour;
  const options = {
    color,
    width: lineWidth,
    lineDash,
    fillColor,
    fillOpacity,
    closePath: isClosedContour
  };
  return options;
}
function renderContour(enabledElement, svgDrawingHelper, annotation) {
  var _a2;
  if (!((_a2 = enabledElement == null ? void 0 : enabledElement.viewport) == null ? void 0 : _a2.getImageData())) {
    return;
  }
  if (annotation.data.contour.closed) {
    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);
  } else {
    if (annotation.data.isOpenUShapeContour) {
      calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation);
      this.renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation);
    } else {
      this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);
    }
  }
}
function calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation) {
  if (!annotation.data.openUShapeContourVectorToPeak) {
    annotation.data.openUShapeContourVectorToPeak = findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);
  }
}
function renderClosedContour(enabledElement, svgDrawingHelper, annotation) {
  if (annotation.parentAnnotationUID) {
    return;
  }
  const { viewport } = enabledElement;
  const options = this._getRenderingOptions(enabledElement, annotation);
  const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));
  const childContours = getContourHolesDataCanvas(annotation, viewport);
  const allContours = [canvasPolyline, ...childContours];
  const polylineUID = "1";
  drawPath(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);
}
function renderOpenContour(enabledElement, svgDrawingHelper, annotation) {
  var _a2;
  const { viewport } = enabledElement;
  const options = this._getRenderingOptions(enabledElement, annotation);
  const canvasPoints = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));
  const polylineUID = "1";
  drawPolyline(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);
  const activeHandleIndex = annotation.data.handles.activeHandleIndex;
  if (((_a2 = this.configuration.alwaysRenderOpenContourHandles) == null ? void 0 : _a2.enabled) === true) {
    const radius = this.configuration.alwaysRenderOpenContourHandles.radius;
    const handleGroupUID = "0";
    const handlePoints = [
      canvasPoints[0],
      canvasPoints[canvasPoints.length - 1]
    ];
    if (activeHandleIndex === 0) {
      handlePoints.shift();
    } else if (activeHandleIndex === 1) {
      handlePoints.pop();
    }
    drawHandles_default(svgDrawingHelper, annotation.annotationUID, handleGroupUID, handlePoints, {
      color: options.color,
      handleRadius: radius
    });
  }
  if (activeHandleIndex !== null) {
    const handleGroupUID = "1";
    const indexOfCanvasPoints = activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;
    const handlePoint = canvasPoints[indexOfCanvasPoints];
    drawHandles_default(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [handlePoint], { color: options.color });
  }
}
function renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation) {
  const { viewport } = enabledElement;
  const { openUShapeContourVectorToPeak } = annotation.data;
  const { polyline } = annotation.data.contour;
  this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);
  if (!openUShapeContourVectorToPeak) {
    return;
  }
  const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);
  const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);
  const openUShapeContourVectorToPeakCanvas = [
    viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),
    viewport.worldToCanvas(openUShapeContourVectorToPeak[1])
  ];
  const options = this._getRenderingOptions(enabledElement, annotation);
  drawPolyline(svgDrawingHelper, annotation.annotationUID, "first-to-last", [firstCanvasPoint, lastCanvasPoint], {
    color: options.color,
    width: options.width,
    closePath: false,
    lineDash: "2,2"
  });
  drawPolyline(svgDrawingHelper, annotation.annotationUID, "midpoint-to-open-contour", [
    openUShapeContourVectorToPeakCanvas[0],
    openUShapeContourVectorToPeakCanvas[1]
  ], {
    color: options.color,
    width: options.width,
    closePath: false,
    lineDash: "2,2"
  });
}
function renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation) {
  const options = this._getRenderingOptions(enabledElement, annotation);
  const { allowOpenContours } = this.configuration;
  const { canvasPoints } = this.drawData;
  options.closePath = false;
  drawPolyline(svgDrawingHelper, annotation.annotationUID, "1", canvasPoints, options);
  if (allowOpenContours) {
    const firstPoint = canvasPoints[0];
    const lastPoint = canvasPoints[canvasPoints.length - 1];
    if (pointsAreWithinCloseContourProximity3(firstPoint, lastPoint, this.configuration.closeContourProximity)) {
      drawPolyline(svgDrawingHelper, annotation.annotationUID, "2", [lastPoint, firstPoint], options);
    } else {
      const handleGroupUID = "0";
      drawHandles_default(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [firstPoint], { color: options.color, handleRadius: 2 });
    }
  }
}
function renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {
  const { viewport } = enabledElement;
  const { fusedCanvasPoints } = this.editData;
  if (fusedCanvasPoints === void 0) {
    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);
    return;
  }
  const childContours = getContourHolesDataCanvas(annotation, viewport);
  const allContours = [fusedCanvasPoints, ...childContours];
  const options = this._getRenderingOptions(enabledElement, annotation);
  const polylineUIDToRender = "preview-1";
  if (annotation.parentAnnotationUID && options.fillOpacity) {
    options.fillOpacity = 0;
  }
  drawPath(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, allContours, options);
}
function renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {
  const { fusedCanvasPoints } = this.editData;
  if (fusedCanvasPoints === void 0) {
    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);
    return;
  }
  const options = this._getRenderingOptions(enabledElement, annotation);
  const polylineUIDToRender = "preview-1";
  drawPolyline(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);
}
function renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation) {
  if (annotation.parentAnnotationUID) {
    return;
  }
  const { viewport } = enabledElement;
  const options = this._getRenderingOptions(enabledElement, annotation);
  const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));
  const childContours = getContourHolesDataCanvas(annotation, viewport);
  const polylineUID = "1";
  const center = canvasPolyline[0];
  const radius = 6;
  const numberOfPoints = 100;
  const circlePoints = [];
  for (let i = 0; i < numberOfPoints; i++) {
    const angle = i / numberOfPoints * 2 * Math.PI;
    const x = center[0] + radius * Math.cos(angle);
    const y = center[1] + radius * Math.sin(angle);
    circlePoints.push([x, y]);
  }
  const crosshair = [
    [center[0] - radius * 2, center[1]],
    [center[0] + radius * 2, center[1]],
    [center[0], center[1] - radius * 2],
    [center[0], center[1] + radius * 2]
  ];
  drawPath(svgDrawingHelper, annotation.annotationUID, polylineUID + "-crosshair_v", [crosshair[0], crosshair[1]], options);
  drawPath(svgDrawingHelper, annotation.annotationUID, polylineUID + "-crosshair_h", [crosshair[2], crosshair[3]], options);
  const allContours = [circlePoints, ...childContours];
  drawPath(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);
}
function registerRenderMethods(toolInstance) {
  toolInstance.renderContour = renderContour.bind(toolInstance);
  toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);
  toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);
  toolInstance.renderPointContourWithMarker = renderPointContourWithMarker.bind(toolInstance);
  toolInstance.renderOpenUShapedContour = renderOpenUShapedContour.bind(toolInstance);
  toolInstance.renderContourBeingDrawn = renderContourBeingDrawn.bind(toolInstance);
  toolInstance.renderClosedContourBeingEdited = renderClosedContourBeingEdited.bind(toolInstance);
  toolInstance.renderOpenContourBeingEdited = renderOpenContourBeingEdited.bind(toolInstance);
  toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);
}
var renderMethods_default = registerRenderMethods;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js
var drawing_exports = {};
__export(drawing_exports, {
  getTextBoxCoordsCanvas: () => getTextBoxCoordsCanvas
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/getTextBoxCoordsCanvas.js
function getTextBoxCoordsCanvas(annotationCanvasPoints) {
  const corners = _determineCorners(annotationCanvasPoints);
  const centerY = (corners.top[1] + corners.bottom[1]) / 2;
  const textBoxCanvas = [corners.right[0], centerY];
  return textBoxCanvas;
}
function _determineCorners(canvasPoints) {
  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);
  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);
  const right = handlesLeftToRight[handlesLeftToRight.length - 1];
  const top = handlesTopToBottom[0];
  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];
  return {
    top,
    bottom,
    right
  };
  function _compareX(a, b) {
    return a[0] < b[0] ? -1 : 1;
  }
  function _compareY(a, b) {
    return a[1] < b[1] ? -1 : 1;
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js
function isViewportPreScaled(viewport, targetId) {
  if (viewport instanceof BaseVolumeViewport_default) {
    const volumeId = utilities_exports.getVolumeId(targetId);
    const volume = cache_default.getVolume(volumeId);
    return !!(volume == null ? void 0 : volume.scaling) && Object.keys(volume.scaling).length > 0;
  } else if (viewport instanceof StackViewport_default) {
    const { preScale } = viewport.getImageData() || {};
    return !!(preScale == null ? void 0 : preScale.scaled);
  } else {
    return false;
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/calculatePerimeter.js
function calculatePerimeter(polyline, closed2) {
  let perimeter = 0;
  for (let i = 0; i < polyline.length - 1; i++) {
    const point1 = polyline[i];
    const point2 = polyline[i + 1];
    perimeter += Math.sqrt(Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2));
  }
  if (closed2) {
    const firstPoint = polyline[0];
    const lastPoint = polyline[polyline.length - 1];
    perimeter += Math.sqrt(Math.pow(lastPoint[0] - firstPoint[0], 2) + Math.pow(lastPoint[1] - firstPoint[1], 2));
  }
  return perimeter;
}
var calculatePerimeter_default = calculatePerimeter;

// node_modules/@cornerstonejs/tools/dist/esm/tools/base/BaseTool.js
var { DefaultHistoryMemo } = utilities_exports.HistoryMemo;
var _BaseTool = class _BaseTool {
  constructor(toolProps, defaultToolProps) {
    const mergedDefaults = _BaseTool.mergeDefaultProps(_BaseTool.defaults, defaultToolProps);
    const initialProps = utilities_exports.deepMerge(mergedDefaults, toolProps);
    const { configuration: configuration3 = {}, supportedInteractionTypes, toolGroupId } = initialProps;
    this.toolGroupId = toolGroupId;
    this.supportedInteractionTypes = supportedInteractionTypes || [];
    this.configuration = Object.assign({}, configuration3);
    this.mode = ToolModes_default.Disabled;
  }
  static mergeDefaultProps(defaultProps = {}, additionalProps) {
    if (!additionalProps) {
      return defaultProps;
    }
    return utilities_exports.deepMerge(defaultProps, additionalProps);
  }
  get toolName() {
    return this.getToolName();
  }
  getToolName() {
    return this.constructor.toolName;
  }
  applyActiveStrategy(enabledElement, operationData) {
    var _a2;
    const { strategies, activeStrategy } = this.configuration;
    return (_a2 = strategies[activeStrategy]) == null ? void 0 : _a2.call(this, enabledElement, operationData);
  }
  applyActiveStrategyCallback(enabledElement, operationData, callbackType, ...extraArgs) {
    var _a2;
    const { strategies, activeStrategy } = this.configuration;
    if (!strategies[activeStrategy]) {
      throw new Error(`applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`);
    }
    return (_a2 = strategies[activeStrategy][callbackType]) == null ? void 0 : _a2.call(this, enabledElement, operationData, ...extraArgs);
  }
  setConfiguration(newConfiguration) {
    this.configuration = utilities_exports.deepMerge(this.configuration, newConfiguration);
  }
  setActiveStrategy(strategyName) {
    this.setConfiguration({ activeStrategy: strategyName });
  }
  getTargetImageData(targetId) {
    if (targetId.startsWith("imageId:")) {
      const imageId = targetId.split("imageId:")[1];
      const imageURI = utilities_exports.imageIdToURI(imageId);
      let viewports = utilities_exports.getViewportsWithImageURI(imageURI);
      if (!viewports || !viewports.length) {
        return;
      }
      viewports = viewports.filter((viewport) => {
        return viewport.getCurrentImageId() === imageId;
      });
      if (!viewports || !viewports.length) {
        return;
      }
      return viewports[0].getImageData();
    } else if (targetId.startsWith("volumeId:")) {
      const volumeId = utilities_exports.getVolumeId(targetId);
      const viewports = utilities_exports.getViewportsWithVolumeId(volumeId);
      if (!viewports || !viewports.length) {
        return;
      }
      return viewports[0].getImageData();
    } else if (targetId.startsWith("videoId:")) {
      const imageURI = utilities_exports.imageIdToURI(targetId);
      const viewports = utilities_exports.getViewportsWithImageURI(imageURI);
      if (!viewports || !viewports.length) {
        return;
      }
      return viewports[0].getImageData();
    } else {
      throw new Error('getTargetIdImage: targetId must start with "imageId:" or "volumeId:"');
    }
  }
  getTargetId(viewport) {
    var _a2;
    const targetId = (_a2 = viewport.getViewReferenceId) == null ? void 0 : _a2.call(viewport);
    if (targetId) {
      return targetId;
    }
    throw new Error("getTargetId: viewport must have a getViewReferenceId method");
  }
  undo() {
    this.doneEditMemo();
    DefaultHistoryMemo.undo();
  }
  redo() {
    DefaultHistoryMemo.redo();
  }
  static createZoomPanMemo(viewport) {
    const state8 = {
      pan: viewport.getPan(),
      zoom: viewport.getZoom()
    };
    const zoomPanMemo = {
      restoreMemo: () => {
        const currentPan = viewport.getPan();
        const currentZoom = viewport.getZoom();
        viewport.setZoom(state8.zoom);
        viewport.setPan(state8.pan);
        viewport.render();
        state8.pan = currentPan;
        state8.zoom = currentZoom;
      }
    };
    DefaultHistoryMemo.push(zoomPanMemo);
    return zoomPanMemo;
  }
  doneEditMemo() {
    var _a2, _b2;
    if ((_b2 = (_a2 = this.memo) == null ? void 0 : _a2.commitMemo) == null ? void 0 : _b2.call(_a2)) {
      DefaultHistoryMemo.push(this.memo);
    }
    this.memo = null;
  }
};
_BaseTool.defaults = {
  configuration: {
    strategies: {},
    defaultStrategy: void 0,
    activeStrategy: void 0,
    strategyOptions: {}
  }
};
var BaseTool = _BaseTool;
BaseTool.toolName = "BaseTool";
var BaseTool_default = BaseTool;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js
var config_exports = {};
__export(config_exports, {
  getFont: () => getFont_default,
  getState: () => getState_default,
  style: () => ToolStyle_default
});

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js
var annotationLocking_exports = {};
__export(annotationLocking_exports, {
  checkAndSetAnnotationLocked: () => checkAndSetAnnotationLocked,
  getAnnotationsLocked: () => getAnnotationsLocked,
  getAnnotationsLockedCount: () => getAnnotationsLockedCount,
  isAnnotationLocked: () => isAnnotationLocked,
  setAnnotationLocked: () => setAnnotationLocked,
  unlockAllAnnotations: () => unlockAllAnnotations
});
var globalLockedAnnotationUIDsSet = /* @__PURE__ */ new Set();
function setAnnotationLocked(annotationUID, locked = true) {
  const detail = makeEventDetail();
  if (annotationUID) {
    if (locked) {
      lock(annotationUID, globalLockedAnnotationUIDsSet, detail);
    } else {
      unlock(annotationUID, globalLockedAnnotationUIDsSet, detail);
    }
  }
  publish(detail, globalLockedAnnotationUIDsSet);
}
function unlockAllAnnotations() {
  const detail = makeEventDetail();
  clearLockedAnnotationsSet(globalLockedAnnotationUIDsSet, detail);
  publish(detail, globalLockedAnnotationUIDsSet);
}
function getAnnotationsLocked() {
  return Array.from(globalLockedAnnotationUIDsSet);
}
function isAnnotationLocked(annotationUID) {
  return globalLockedAnnotationUIDsSet.has(annotationUID);
}
function getAnnotationsLockedCount() {
  return globalLockedAnnotationUIDsSet.size;
}
function checkAndSetAnnotationLocked(annotationUID) {
  const isLocked = isAnnotationLocked(annotationUID);
  setAnnotationLocked(annotationUID, isLocked);
  return isLocked;
}
function makeEventDetail() {
  return Object.freeze({
    added: [],
    removed: [],
    locked: []
  });
}
function lock(annotationUID, lockedAnnotationUIDsSet, detail) {
  if (!lockedAnnotationUIDsSet.has(annotationUID)) {
    lockedAnnotationUIDsSet.add(annotationUID);
    detail.added.push(annotationUID);
    const annotation = getAnnotation(annotationUID);
    if (annotation) {
      annotation.isLocked = true;
    }
  }
}
function unlock(annotationUID, lockedAnnotationUIDsSet, detail) {
  if (lockedAnnotationUIDsSet.delete(annotationUID)) {
    detail.removed.push(annotationUID);
    const annotation = getAnnotation(annotationUID);
    if (annotation) {
      annotation.isLocked = false;
    }
  }
}
function clearLockedAnnotationsSet(lockedAnnotationUIDsSet, detail) {
  lockedAnnotationUIDsSet.forEach((annotationUID) => {
    unlock(annotationUID, lockedAnnotationUIDsSet, detail);
  });
}
function publish(detail, lockedAnnotationUIDsSet) {
  if (detail.added.length > 0 || detail.removed.length > 0) {
    lockedAnnotationUIDsSet.forEach((item) => void detail.locked.push(item));
    triggerEvent(eventTarget_default, Events_default.ANNOTATION_LOCK_CHANGE, detail);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js
var annotationSelection_exports = {};
__export(annotationSelection_exports, {
  deselectAnnotation: () => deselectAnnotation,
  getAnnotationsSelected: () => getAnnotationsSelected,
  getAnnotationsSelectedByToolName: () => getAnnotationsSelectedByToolName,
  getAnnotationsSelectedCount: () => getAnnotationsSelectedCount,
  isAnnotationSelected: () => isAnnotationSelected,
  setAnnotationSelected: () => setAnnotationSelected
});
var selectedAnnotationUIDs = /* @__PURE__ */ new Set();
function setAnnotationSelected(annotationUID, selected = true, preserveSelected = false) {
  if (selected) {
    selectAnnotation(annotationUID, preserveSelected);
  } else {
    deselectAnnotation(annotationUID);
  }
}
function selectAnnotation(annotationUID, preserveSelected = false) {
  const detail = makeEventDetail2();
  if (!preserveSelected) {
    clearSelectionSet(selectedAnnotationUIDs, detail);
    const annotation = getAnnotation(annotationUID);
    if (annotation) {
      annotation.isSelected = true;
    }
  }
  if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {
    selectedAnnotationUIDs.add(annotationUID);
    detail.added.push(annotationUID);
    const annotation = getAnnotation(annotationUID);
    if (annotation) {
      annotation.isSelected = true;
    }
  }
  publish2(detail, selectedAnnotationUIDs);
}
function deselectAnnotation(annotationUID) {
  const detail = makeEventDetail2();
  if (annotationUID) {
    if (selectedAnnotationUIDs.delete(annotationUID)) {
      detail.removed.push(annotationUID);
      const annotation = getAnnotation(annotationUID);
      annotation.isSelected = false;
    }
  } else {
    clearSelectionSet(selectedAnnotationUIDs, detail);
  }
  publish2(detail, selectedAnnotationUIDs);
}
function getAnnotationsSelected() {
  return Array.from(selectedAnnotationUIDs);
}
function getAnnotationsSelectedByToolName(toolName) {
  return getAnnotationsSelected().filter((annotationUID) => {
    var _a2;
    const annotation = getAnnotation(annotationUID);
    return ((_a2 = annotation == null ? void 0 : annotation.metadata) == null ? void 0 : _a2.toolName) === toolName;
  });
}
function isAnnotationSelected(annotationUID) {
  return selectedAnnotationUIDs.has(annotationUID);
}
function getAnnotationsSelectedCount() {
  return selectedAnnotationUIDs.size;
}
function makeEventDetail2() {
  return Object.freeze({
    added: [],
    removed: [],
    selection: []
  });
}
function clearSelectionSet(selectionSet, detail) {
  selectionSet.forEach((value) => {
    if (selectionSet.delete(value)) {
      detail.removed.push(value);
      const annotation = getAnnotation(value);
      if (annotation) {
        annotation.isSelected = false;
      }
    }
  });
}
function publish2(detail, selectionSet) {
  if (detail.added.length > 0 || detail.removed.length > 0) {
    selectionSet.forEach((item) => void detail.selection.push(item));
    triggerEvent(eventTarget_default, Events_default.ANNOTATION_SELECTION_CHANGE, detail);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js
function getState(annotation) {
  if (annotation) {
    if (annotation.data && annotation.highlighted) {
      return AnnotationStyleStates_default.Highlighted;
    }
    if (isAnnotationSelected(annotation.annotationUID)) {
      return AnnotationStyleStates_default.Selected;
    }
    if (isAnnotationLocked(annotation.annotationUID)) {
      return AnnotationStyleStates_default.Locked;
    }
    if (annotation.data && annotation.autoGenerated) {
      return AnnotationStyleStates_default.AutoGenerated;
    }
  }
  return AnnotationStyleStates_default.Default;
}
var getState_default = getState;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getFont.js
function getFont(styleSpecifier, state8, mode) {
  const fontSize = getStyleProperty("textBoxFontSize", styleSpecifier, state8, mode);
  const fontFamily = getStyleProperty("textBoxFontFamily", styleSpecifier, state8, mode);
  return `${fontSize}px ${fontFamily}`;
}
var getFont_default = getFont;

// node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js
var AnnotationDisplayTool = class extends BaseTool_default {
  constructor() {
    super(...arguments);
    this.onImageSpacingCalibrated = (evt) => {
      const { element, imageId } = evt.detail;
      const imageURI = utilities_exports.imageIdToURI(imageId);
      const annotationManager = getAnnotationManager();
      const framesOfReference = annotationManager.getFramesOfReference();
      framesOfReference.forEach((frameOfReference) => {
        const frameOfReferenceSpecificAnnotations = annotationManager.getAnnotations(frameOfReference);
        const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];
        if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {
          return;
        }
        toolSpecificAnnotations.forEach((annotation) => {
          var _a2;
          if (!((_a2 = annotation.metadata) == null ? void 0 : _a2.referencedImageId)) {
            return;
          }
          const referencedImageURI = utilities_exports.imageIdToURI(annotation.metadata.referencedImageId);
          if (referencedImageURI === imageURI) {
            annotation.invalidated = true;
            annotation.data.cachedStats = {};
          }
        });
        triggerAnnotationRender_default(element);
      });
    };
  }
  filterInteractableAnnotationsForElement(element, annotations) {
    if (!(annotations == null ? void 0 : annotations.length)) {
      return [];
    }
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    return filterAnnotationsForDisplay(viewport, annotations);
  }
  createAnnotation(evt) {
    const eventDetail = evt.detail;
    const { currentPoints, element } = eventDetail;
    const { world: worldPos } = currentPoints;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const camera = viewport.getCamera();
    const { viewPlaneNormal, viewUp, position: cameraPosition } = camera;
    const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
    const viewReference = viewport.getViewReference({ points: [worldPos] });
    return {
      highlighted: true,
      invalidated: true,
      metadata: {
        toolName: this.getToolName(),
        ...viewReference,
        referencedImageId,
        viewUp,
        cameraPosition
      },
      data: {
        cachedStats: {},
        handles: {
          points: [],
          activeHandleIndex: null,
          textBox: {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          }
        }
      }
    };
  }
  getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {
    const targetId = this.getTargetId(viewport);
    let referencedImageId = targetId.split(/^[a-zA-Z]+:/)[1];
    if (viewport instanceof BaseVolumeViewport_default) {
      const volumeId = utilities_exports.getVolumeId(targetId);
      const imageVolume = cache_default.getVolume(volumeId);
      referencedImageId = utilities_exports.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
    }
    return referencedImageId;
  }
  getStyle(property, specifications, annotation) {
    return getStyleProperty(property, specifications, getState_default(annotation), this.mode);
  }
};
AnnotationDisplayTool.toolName = "AnnotationDisplayTool";
var AnnotationDisplayTool_default = AnnotationDisplayTool;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js
var annotationVisibility_exports = {};
__export(annotationVisibility_exports, {
  checkAndSetAnnotationVisibility: () => checkAndSetAnnotationVisibility,
  isAnnotationVisible: () => isAnnotationVisible,
  setAnnotationVisibility: () => setAnnotationVisibility,
  showAllAnnotations: () => showAllAnnotations
});
var globalHiddenAnnotationUIDsSet = /* @__PURE__ */ new Set();
function setAnnotationVisibility(annotationUID, visible = true) {
  const detail = makeEventDetail3();
  if (annotationUID) {
    if (visible) {
      show(annotationUID, globalHiddenAnnotationUIDsSet, detail);
    } else {
      hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);
    }
  }
  publish3(detail);
}
function showAllAnnotations() {
  const detail = makeEventDetail3();
  globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {
    show(annotationUID, globalHiddenAnnotationUIDsSet, detail);
  });
  publish3(detail);
}
function isAnnotationVisible(annotationUID) {
  const annotation = getAnnotation(annotationUID);
  if (annotation) {
    return !globalHiddenAnnotationUIDsSet.has(annotationUID);
  }
}
function makeEventDetail3() {
  return Object.freeze({
    lastVisible: [],
    lastHidden: [],
    hidden: []
  });
}
function show(annotationUID, annotationUIDsSet, detail) {
  if (annotationUIDsSet.delete(annotationUID)) {
    detail.lastVisible.push(annotationUID);
    const annotation = getAnnotation(annotationUID);
    annotation.isVisible = true;
  }
}
function hide(annotationUID, annotationUIDsSet, detail) {
  if (!annotationUIDsSet.has(annotationUID)) {
    annotationUIDsSet.add(annotationUID);
    if (isAnnotationSelected(annotationUID)) {
      deselectAnnotation(annotationUID);
    }
    detail.lastHidden.push(annotationUID);
  }
}
function publish3(detail) {
  if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {
    globalHiddenAnnotationUIDsSet.forEach((item) => void detail.hidden.push(item));
    triggerEvent(eventTarget_default, Events_default.ANNOTATION_VISIBILITY_CHANGE, detail);
  }
}
function checkAndSetAnnotationVisibility(annotationUID) {
  const isVisible = !globalHiddenAnnotationUIDsSet.has(annotationUID);
  setAnnotationVisibility(annotationUID, isVisible);
  return isVisible;
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js
var { DefaultHistoryMemo: DefaultHistoryMemo2 } = utilities_exports.HistoryMemo;
var { PointsManager: PointsManager2 } = utilities_exports;
var AnnotationTool = class _AnnotationTool extends AnnotationDisplayTool_default {
  static createAnnotation(...annotationBaseData) {
    let annotation = {
      annotationUID: null,
      highlighted: true,
      invalidated: true,
      metadata: {
        toolName: this.toolName
      },
      data: {
        text: "",
        handles: {
          points: new Array(),
          textBox: {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          }
        },
        label: ""
      }
    };
    for (const baseData of annotationBaseData) {
      annotation = utilities_exports.deepMerge(annotation, baseData);
    }
    return annotation;
  }
  static createAnnotationForViewport(viewport, ...annotationBaseData) {
    return this.createAnnotation({ metadata: viewport.getViewReference() }, ...annotationBaseData);
  }
  static createAndAddAnnotation(viewport, ...annotationBaseData) {
    const annotation = this.createAnnotationForViewport(viewport, ...annotationBaseData);
    addAnnotation(annotation, viewport.element);
    triggerAnnotationModified(annotation, viewport.element);
  }
  constructor(toolProps, defaultToolProps) {
    var _a2, _b2;
    super(toolProps, defaultToolProps);
    this.mouseMoveCallback = (evt, filteredAnnotations) => {
      if (!filteredAnnotations) {
        return false;
      }
      const { element, currentPoints } = evt.detail;
      const canvasCoords = currentPoints.canvas;
      let annotationsNeedToBeRedrawn = false;
      for (const annotation of filteredAnnotations) {
        if (isAnnotationLocked(annotation.annotationUID) || !isAnnotationVisible(annotation.annotationUID)) {
          continue;
        }
        const { data } = annotation;
        const activateHandleIndex = data.handles ? data.handles.activeHandleIndex : void 0;
        const near = this._imagePointNearToolOrHandle(element, annotation, canvasCoords, 6);
        const nearToolAndNotMarkedActive = near && !annotation.highlighted;
        const notNearToolAndMarkedActive = !near && annotation.highlighted;
        if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {
          annotation.highlighted = !annotation.highlighted;
          annotationsNeedToBeRedrawn = true;
        } else if (data.handles && data.handles.activeHandleIndex !== activateHandleIndex) {
          annotationsNeedToBeRedrawn = true;
        }
      }
      return annotationsNeedToBeRedrawn;
    };
    this.isSuvScaled = _AnnotationTool.isSuvScaled;
    if ((_a2 = toolProps.configuration) == null ? void 0 : _a2.getTextLines) {
      this.configuration.getTextLines = toolProps.configuration.getTextLines;
    }
    if ((_b2 = toolProps.configuration) == null ? void 0 : _b2.statsCalculator) {
      this.configuration.statsCalculator = toolProps.configuration.statsCalculator;
    }
  }
  getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const { data } = annotation;
    const { isCanvasAnnotation } = data;
    const { points, textBox } = data.handles;
    if (textBox) {
      const { worldBoundingBox } = textBox;
      if (worldBoundingBox) {
        const canvasBoundingBox = {
          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),
          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),
          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),
          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight)
        };
        if (canvasCoords[0] >= canvasBoundingBox.topLeft[0] && canvasCoords[0] <= canvasBoundingBox.bottomRight[0] && canvasCoords[1] >= canvasBoundingBox.topLeft[1] && canvasCoords[1] <= canvasBoundingBox.bottomRight[1]) {
          data.handles.activeHandleIndex = null;
          return textBox;
        }
      }
    }
    for (let i = 0; i < (points == null ? void 0 : points.length); i++) {
      const point = points[i];
      const annotationCanvasCoordinate = isCanvasAnnotation ? point.slice(0, 2) : viewport.worldToCanvas(point);
      const near = vec2_exports.distance(canvasCoords, annotationCanvasCoordinate) < proximity;
      if (near === true) {
        data.handles.activeHandleIndex = i;
        return point;
      }
    }
    data.handles.activeHandleIndex = null;
  }
  getLinkedTextBoxStyle(specifications, annotation) {
    return {
      visibility: this.getStyle("textBoxVisibility", specifications, annotation),
      fontFamily: this.getStyle("textBoxFontFamily", specifications, annotation),
      fontSize: this.getStyle("textBoxFontSize", specifications, annotation),
      color: this.getStyle("textBoxColor", specifications, annotation),
      shadow: this.getStyle("textBoxShadow", specifications, annotation),
      background: this.getStyle("textBoxBackground", specifications, annotation),
      lineWidth: this.getStyle("textBoxLinkLineWidth", specifications, annotation),
      lineDash: this.getStyle("textBoxLinkLineDash", specifications, annotation)
    };
  }
  static isSuvScaled(viewport, targetId, imageId) {
    var _a2;
    if (viewport instanceof BaseVolumeViewport_default) {
      const volumeId = utilities_exports.getVolumeId(targetId);
      const volume = cache_default.getVolume(volumeId);
      return ((_a2 = volume == null ? void 0 : volume.scaling) == null ? void 0 : _a2.PT) !== void 0;
    }
    const scalingModule = imageId && metaData_exports.get("scalingModule", imageId);
    return typeof (scalingModule == null ? void 0 : scalingModule.suvbw) === "number";
  }
  getAnnotationStyle(context) {
    const { annotation, styleSpecifier } = context;
    const getStyle2 = (property) => this.getStyle(property, styleSpecifier, annotation);
    const { annotationUID } = annotation;
    const visibility = isAnnotationVisible(annotationUID);
    const locked = isAnnotationLocked(annotationUID);
    const lineWidth = getStyle2("lineWidth");
    const lineDash = getStyle2("lineDash");
    const color = getStyle2("color");
    const shadow = getStyle2("shadow");
    const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
    return {
      visibility,
      locked,
      color,
      lineWidth,
      lineDash,
      lineOpacity: 1,
      fillColor: color,
      fillOpacity: 0,
      shadow,
      textbox: textboxStyle
    };
  }
  _imagePointNearToolOrHandle(element, annotation, canvasCoords, proximity) {
    const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);
    if (handleNearImagePoint) {
      return true;
    }
    const toolNewImagePoint = this.isPointNearTool(element, annotation, canvasCoords, proximity, "mouse");
    if (toolNewImagePoint) {
      return true;
    }
  }
  static createAnnotationState(annotation, deleting) {
    const { data, annotationUID } = annotation;
    const cloneData = {
      ...data,
      cachedStats: {}
    };
    delete cloneData.contour;
    delete cloneData.spline;
    const state8 = {
      annotationUID,
      data: structuredClone(cloneData),
      deleting
    };
    const contour = data.contour;
    if (contour) {
      state8.data.contour = {
        ...contour,
        polyline: null,
        pointsManager: PointsManager2.create3(contour.polyline.length, contour.polyline)
      };
    }
    return state8;
  }
  static createAnnotationMemo(element, annotation, options) {
    if (!annotation) {
      return;
    }
    const { newAnnotation, deleting = newAnnotation ? false : void 0 } = options || {};
    const { annotationUID } = annotation;
    const state8 = _AnnotationTool.createAnnotationState(annotation, deleting);
    const annotationMemo = {
      restoreMemo: () => {
        const newState = _AnnotationTool.createAnnotationState(annotation, deleting);
        const { viewport } = getEnabledElement(element) || {};
        viewport == null ? void 0 : viewport.setViewReference(annotation.metadata);
        if (state8.deleting === true) {
          state8.deleting = false;
          Object.assign(annotation.data, state8.data);
          if (annotation.data.contour) {
            const annotationData = annotation.data;
            annotationData.contour.polyline = state8.data.contour.pointsManager.points;
            delete state8.data.contour.pointsManager;
            if (annotationData.segmentation) {
              addContourSegmentationAnnotation(annotation);
            }
          }
          state8.data = newState.data;
          addAnnotation(annotation, element);
          setAnnotationSelected(annotation.annotationUID, true);
          viewport == null ? void 0 : viewport.render();
          return;
        }
        if (state8.deleting === false) {
          state8.deleting = true;
          state8.data = newState.data;
          setAnnotationSelected(annotation.annotationUID);
          removeAnnotation(annotation.annotationUID);
          viewport == null ? void 0 : viewport.render();
          return;
        }
        const currentAnnotation = getAnnotation(annotationUID);
        if (!currentAnnotation) {
          console.warn("No current annotation");
          return;
        }
        Object.assign(currentAnnotation.data, state8.data);
        if (currentAnnotation.data.contour) {
          currentAnnotation.data.contour.polyline = state8.data.contour.pointsManager.points;
        }
        state8.data = newState.data;
        currentAnnotation.invalidated = true;
        triggerAnnotationModified(currentAnnotation, element, ChangeTypes_default.History);
      }
    };
    DefaultHistoryMemo2.push(annotationMemo);
    return annotationMemo;
  }
  createMemo(element, annotation, options) {
    this.memo || (this.memo = _AnnotationTool.createAnnotationMemo(element, annotation, options));
  }
};
AnnotationTool.toolName = "AnnotationTool";
var AnnotationTool_default = AnnotationTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourBaseTool.js
var ContourBaseTool = class extends AnnotationTool_default {
  constructor(toolProps, defaultToolProps) {
    super(toolProps, defaultToolProps);
  }
  renderAnnotation(enabledElement, svgDrawingHelper) {
    let renderStatus = false;
    const { viewport } = enabledElement;
    const { element } = viewport;
    if (!viewport.getRenderingEngine()) {
      console.warn("Rendering Engine has been destroyed");
      return renderStatus;
    }
    let annotations = getAnnotations(this.getToolName(), element);
    if (!(annotations == null ? void 0 : annotations.length)) {
      return renderStatus;
    }
    annotations = this.filterInteractableAnnotationsForElement(element, annotations);
    if (!(annotations == null ? void 0 : annotations.length)) {
      return renderStatus;
    }
    const targetId = this.getTargetId(viewport);
    const styleSpecifier = {
      toolGroupId: this.toolGroupId,
      toolName: this.getToolName(),
      viewportId: enabledElement.viewport.id
    };
    for (let i = 0; i < annotations.length; i++) {
      const annotation = annotations[i];
      styleSpecifier.annotationUID = annotation.annotationUID;
      const annotationStyle = this.getAnnotationStyle({
        annotation,
        styleSpecifier
      });
      if (!annotationStyle.visibility) {
        continue;
      }
      const annotationRendered = this.renderAnnotationInstance({
        enabledElement,
        targetId,
        annotation,
        annotationStyle,
        svgDrawingHelper
      });
      renderStatus || (renderStatus = annotationRendered);
      annotation.invalidated = false;
    }
    return renderStatus;
  }
  createAnnotation(evt) {
    const annotation = super.createAnnotation(evt);
    Object.assign(annotation.data, {
      contour: {
        polyline: [],
        closed: false
      }
    });
    Object.assign(annotation, {
      interpolationUID: "",
      autoGenerated: false
    });
    return annotation;
  }
  addAnnotation(annotation, element) {
    return addAnnotation(annotation, element);
  }
  cancelAnnotation(annotation) {
  }
  moveAnnotation(annotation, worldPosDelta) {
    const { points } = annotation.data.handles;
    for (let i = 0, numPoints = points.length; i < numPoints; i++) {
      const point = points[i];
      point[0] += worldPosDelta[0];
      point[1] += worldPosDelta[1];
      point[2] += worldPosDelta[2];
    }
    annotation.invalidated = true;
    getChildAnnotations(annotation).forEach((childAnnotation) => this.moveAnnotation(childAnnotation, worldPosDelta));
  }
  updateContourPolyline(annotation, polylineData, transforms, options) {
    var _a2;
    const decimateConfig = ((_a2 = this.configuration) == null ? void 0 : _a2.decimate) || {};
    updateContourPolyline(annotation, polylineData, transforms, {
      decimate: {
        enabled: !!decimateConfig.enabled,
        epsilon: decimateConfig.epsilon
      },
      updateWindingDirection: options == null ? void 0 : options.updateWindingDirection
    });
  }
  getPolylinePoints(annotation) {
    var _a2;
    return ((_a2 = annotation.data.contour) == null ? void 0 : _a2.polyline) ?? annotation.data.polyline;
  }
  renderAnnotationInstance(renderContext) {
    const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;
    const annotation = renderContext.annotation;
    if (annotation.parentAnnotationUID) {
      return;
    }
    const { annotationUID } = annotation;
    const { viewport } = enabledElement;
    const { worldToCanvas } = viewport;
    const polylineCanvasPoints = this.getPolylinePoints(annotation).map((point) => worldToCanvas(point));
    const { lineWidth, lineDash, color, fillColor, fillOpacity } = annotationStyle;
    const childContours = getContourHolesDataCanvas(annotation, viewport);
    const allContours = [polylineCanvasPoints, ...childContours];
    drawPath(svgDrawingHelper, annotationUID, "contourPolyline", allContours, {
      color,
      lineDash,
      lineWidth: Math.max(0.1, lineWidth),
      fillColor,
      fillOpacity
    });
    return true;
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js
var annotation_exports = {};
__export(annotation_exports, {
  AnnotationGroup: () => AnnotationGroup,
  FrameOfReferenceSpecificAnnotationManager: () => FrameOfReferenceSpecificAnnotationManager_default,
  config: () => config_exports,
  locking: () => annotationLocking_exports,
  selection: () => annotationSelection_exports,
  state: () => state5,
  visibility: () => annotationVisibility_exports
});

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js
var FrameOfReferenceSpecificAnnotationManager = class {
  constructor(uid) {
    this.getGroupKey = (annotationGroupSelector) => {
      if (typeof annotationGroupSelector === "string") {
        return annotationGroupSelector;
      }
      const element = annotationGroupSelector;
      const enabledElement = getEnabledElement(element);
      if (!enabledElement) {
        throw new Error("Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID");
      }
      return enabledElement.FrameOfReferenceUID;
    };
    this._imageVolumeModifiedHandler = (evt) => {
      const eventDetail = evt.detail;
      const { FrameOfReferenceUID } = eventDetail;
      const annotations = this.annotations;
      const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
      if (!frameOfReferenceSpecificAnnotations) {
        return;
      }
      Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {
        const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
        toolSpecificAnnotations.forEach((annotation) => {
          const invalidated = annotation.invalidated;
          if (invalidated !== void 0) {
            annotation.invalidated = true;
          }
        });
      });
    };
    this.getFramesOfReference = () => {
      return Object.keys(this.annotations);
    };
    this.getAnnotations = (groupKey, toolName) => {
      const annotations = this.annotations;
      if (!annotations[groupKey]) {
        return [];
      }
      if (toolName) {
        return annotations[groupKey][toolName] ? annotations[groupKey][toolName] : [];
      }
      return annotations[groupKey];
    };
    this.getAnnotation = (annotationUID) => {
      const annotations = this.annotations;
      for (const frameOfReferenceUID in annotations) {
        const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];
        for (const toolName in frameOfReferenceAnnotations) {
          const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];
          for (const annotation of toolSpecificAnnotations) {
            if (annotationUID === annotation.annotationUID) {
              return annotation;
            }
          }
        }
      }
    };
    this.getNumberOfAnnotations = (groupKey, toolName) => {
      const annotations = this.getAnnotations(groupKey, toolName);
      if (!annotations.length) {
        return 0;
      }
      if (toolName) {
        return annotations.length;
      }
      let total = 0;
      for (const toolName2 in annotations) {
        total += annotations[toolName2].length;
      }
      return total;
    };
    this.addAnnotation = (annotation, groupKey) => {
      const { metadata } = annotation;
      const { FrameOfReferenceUID, toolName } = metadata;
      groupKey = groupKey || FrameOfReferenceUID;
      const annotations = this.annotations;
      let frameOfReferenceSpecificAnnotations = annotations[groupKey];
      if (!frameOfReferenceSpecificAnnotations) {
        annotations[groupKey] = {};
        frameOfReferenceSpecificAnnotations = annotations[groupKey];
      }
      let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
      if (!toolSpecificAnnotations) {
        frameOfReferenceSpecificAnnotations[toolName] = [];
        toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
      }
      if (this.preprocessingFn) {
        annotation = this.preprocessingFn(annotation);
      }
      toolSpecificAnnotations.push(annotation);
    };
    this.removeAnnotation = (annotationUID) => {
      const { annotations } = this;
      for (const groupKey in annotations) {
        const groupAnnotations = annotations[groupKey];
        for (const toolName in groupAnnotations) {
          const toolAnnotations = groupAnnotations[toolName];
          const index = toolAnnotations.findIndex((annotation) => annotation.annotationUID === annotationUID);
          if (index !== -1) {
            toolAnnotations.splice(index, 1);
            if (toolAnnotations.length === 0) {
              delete groupAnnotations[toolName];
            }
          }
        }
        if (Object.keys(groupAnnotations).length === 0) {
          delete annotations[groupKey];
        }
      }
    };
    this.removeAnnotations = (groupKey, toolName) => {
      const annotations = this.annotations;
      const removedAnnotations = [];
      if (!annotations[groupKey]) {
        return removedAnnotations;
      }
      if (toolName) {
        const annotationsForTool = annotations[groupKey][toolName];
        for (const annotation of annotationsForTool) {
          this.removeAnnotation(annotation.annotationUID);
          removedAnnotations.push(annotation);
        }
      } else {
        for (const toolName2 in annotations[groupKey]) {
          const annotationsForTool = annotations[groupKey][toolName2];
          for (const annotation of annotationsForTool) {
            this.removeAnnotation(annotation.annotationUID);
            removedAnnotations.push(annotation);
          }
        }
      }
      return removedAnnotations;
    };
    this.saveAnnotations = (groupKey, toolName) => {
      const annotations = this.annotations;
      if (groupKey && toolName) {
        const frameOfReferenceSpecificAnnotations = annotations[groupKey];
        if (!frameOfReferenceSpecificAnnotations) {
          return;
        }
        const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
        return structuredClone(toolSpecificAnnotations);
      } else if (groupKey) {
        const frameOfReferenceSpecificAnnotations = annotations[groupKey];
        return structuredClone(frameOfReferenceSpecificAnnotations);
      }
      return structuredClone(annotations);
    };
    this.restoreAnnotations = (state8, groupKey, toolName) => {
      const annotations = this.annotations;
      if (groupKey && toolName) {
        let frameOfReferenceSpecificAnnotations = annotations[groupKey];
        if (!frameOfReferenceSpecificAnnotations) {
          annotations[groupKey] = {};
          frameOfReferenceSpecificAnnotations = annotations[groupKey];
        }
        frameOfReferenceSpecificAnnotations[toolName] = state8;
      } else if (groupKey) {
        annotations[groupKey] = state8;
      } else {
        this.annotations = structuredClone(state8);
      }
    };
    this.getAllAnnotations = () => {
      return Object.values(this.annotations).map((frameOfReferenceSpecificAnnotations) => Object.values(frameOfReferenceSpecificAnnotations)).flat(2);
    };
    this.getNumberOfAllAnnotations = () => {
      let count = 0;
      const annotations = this.annotations;
      for (const groupKey in annotations) {
        const frameOfReferenceSpecificAnnotations = annotations[groupKey];
        for (const toolName in frameOfReferenceSpecificAnnotations) {
          const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
          count += toolSpecificAnnotations.length;
        }
      }
      return count;
    };
    this.removeAllAnnotations = () => {
      const removedAnnotations = [];
      for (const annotation of this.getAllAnnotations()) {
        this.removeAnnotation(annotation.annotationUID);
        removedAnnotations.push(annotation);
      }
      return removedAnnotations;
    };
    if (!uid) {
      uid = utilities_exports.uuidv4();
    }
    this.annotations = {};
    this.uid = uid;
    eventTarget_default.addEventListener(enums_exports.Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);
  }
  setPreprocessingFn(preprocessingFn2) {
    this.preprocessingFn = preprocessingFn2;
  }
};
var defaultFrameOfReferenceSpecificAnnotationManager = new FrameOfReferenceSpecificAnnotationManager("DEFAULT");
var FrameOfReferenceSpecificAnnotationManager_default = FrameOfReferenceSpecificAnnotationManager;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationGroup.js
var AnnotationGroup = class {
  constructor() {
    this.annotationUIDs = /* @__PURE__ */ new Set();
    this._isVisible = true;
    this.visibleFilter = this.unboundVisibleFilter.bind(this);
  }
  unboundVisibleFilter(uid) {
    return !this._isVisible || !this.annotationUIDs.has(uid);
  }
  has(uid) {
    return this.annotationUIDs.has(uid);
  }
  setVisible(isVisible = true, baseEvent, filter) {
    if (this._isVisible === isVisible) {
      return;
    }
    this._isVisible = isVisible;
    this.annotationUIDs.forEach((uid) => {
      const annotation = getAnnotation(uid);
      if (!annotation) {
        this.annotationUIDs.delete(uid);
        return;
      }
      if (annotation.isVisible === isVisible) {
        return;
      }
      if (!isVisible && (filter == null ? void 0 : filter(uid)) === false) {
        return;
      }
      annotation.isVisible = isVisible;
      const eventDetail = {
        ...baseEvent,
        annotation
      };
      triggerEvent(eventTarget_default, Events_default.ANNOTATION_MODIFIED, eventDetail);
    });
  }
  get isVisible() {
    return this._isVisible;
  }
  findNearby(uid, direction) {
    const uids = [...this.annotationUIDs];
    if (uids.length === 0) {
      return null;
    }
    if (!uid) {
      return uids[direction === 1 ? 0 : uids.length - 1];
    }
    const index = uids.indexOf(uid);
    if (index === -1 || index + direction < 0 || index + direction >= uids.length) {
      return null;
    }
    return uids[index + direction];
  }
  add(...annotationUIDs) {
    annotationUIDs.forEach((annotationUID) => this.annotationUIDs.add(annotationUID));
  }
  remove(...annotationUIDs) {
    annotationUIDs.forEach((annotationUID) => this.annotationUIDs.delete(annotationUID));
  }
  clear() {
    this.annotationUIDs.clear();
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/utilities/defineProperties.js
var checkAndDefineTextBoxProperty = (annotation) => {
  if (!annotation.data) {
    annotation.data = {};
  }
  if (!annotation.data.handles) {
    annotation.data.handles = {};
  }
  if (!annotation.data.handles.textBox) {
    annotation.data.handles.textBox = {};
  }
  return annotation;
};
var checkAndDefineCachedStatsProperty = (annotation) => {
  if (!annotation.data) {
    annotation.data = {};
  }
  if (!annotation.data.cachedStats) {
    annotation.data.cachedStats = {};
  }
  return annotation;
};

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js
var defaultManager2 = defaultFrameOfReferenceSpecificAnnotationManager;
var preprocessingFn = (annotation) => {
  annotation = checkAndDefineTextBoxProperty(annotation);
  annotation = checkAndDefineCachedStatsProperty(annotation);
  const uid = annotation.annotationUID;
  const isLocked = checkAndSetAnnotationLocked(uid);
  annotation.isLocked = isLocked;
  const isVisible = checkAndSetAnnotationVisibility(uid);
  annotation.isVisible = isVisible;
  return annotation;
};
defaultManager2.setPreprocessingFn(preprocessingFn);
setAnnotationManager(defaultManager2);
function resetAnnotationManager() {
  setAnnotationManager(defaultManager2);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js
var state5 = {
  ...annotationState_exports,
  resetAnnotationManager
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js
var DEFAULT_CONTOUR_SEG_TOOLNAME = "PlanarFreehandContourSegmentationTool";
function getInterpolationData(viewportData, filterParams = []) {
  const { viewport, sliceData, annotation } = viewportData;
  const interpolationDatas = /* @__PURE__ */ new Map();
  const { toolName, originalToolName } = annotation.metadata;
  const testToolName = originalToolName || toolName;
  const annotations = (getAnnotations(testToolName, viewport.element) || []).filter((annotation2) => !annotation2.metadata.originalToolName || annotation2.metadata.originalToolName === testToolName);
  if (testToolName !== DEFAULT_CONTOUR_SEG_TOOLNAME) {
    const modifiedAnnotations = getAnnotations(DEFAULT_CONTOUR_SEG_TOOLNAME, viewport.element);
    if (modifiedAnnotations == null ? void 0 : modifiedAnnotations.length) {
      modifiedAnnotations.forEach((annotation2) => {
        const { metadata } = annotation2;
        if (metadata.originalToolName === testToolName && metadata.originalToolName !== metadata.toolName) {
          annotations.push(annotation2);
        }
      });
    }
  }
  if (!(annotations == null ? void 0 : annotations.length)) {
    return interpolationDatas;
  }
  for (let i = 0; i < sliceData.numberOfSlices; i++) {
    const imageAnnotations = annotations.filter((x) => x.metadata.sliceIndex === i);
    if (!(imageAnnotations == null ? void 0 : imageAnnotations.length)) {
      continue;
    }
    const filteredInterpolatedAnnotations = imageAnnotations.filter((imageAnnotation) => {
      return filterParams.every((x) => {
        const parent = x.parentKey ? x.parentKey(imageAnnotation) : imageAnnotation;
        const value = parent == null ? void 0 : parent[x.key];
        if (Array.isArray(value)) {
          return value.every((item, index) => item === x.value[index]);
        }
        return value === x.value;
      });
    });
    if (filteredInterpolatedAnnotations.length) {
      interpolationDatas.set(i, filteredInterpolatedAnnotations);
    }
  }
  return interpolationDatas;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationDataCollection.js
function getInterpolationDataCollection(viewportData, filterParams) {
  const imageAnnotations = getInterpolationData(viewportData, filterParams);
  const interpolatedDataCollection = [];
  if (!(imageAnnotations == null ? void 0 : imageAnnotations.size)) {
    return interpolatedDataCollection;
  }
  for (const annotations of imageAnnotations.values()) {
    annotations.forEach((annotation) => {
      interpolatedDataCollection.push(annotation);
    });
  }
  return interpolatedDataCollection;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/createPolylineToolData.js
function createPolylineToolData(polyline, handlePoints, referencedToolData) {
  const annotation = utilities_exports.deepMerge({
    data: {},
    metadata: {}
  }, referencedToolData);
  Object.assign(annotation, {
    highlighted: false,
    invalidated: true,
    autoGenerated: true,
    annotationUID: void 0,
    cachedStats: {},
    childAnnotationUIDs: [],
    parentAnnotationUID: void 0
  });
  Object.assign(annotation.data, {
    handles: {
      points: handlePoints.points || handlePoints || [],
      interpolationSources: handlePoints.sources,
      activeHandleIndex: null,
      textBox: {
        hasMoved: false,
        worldPosition: [0, 0, 0],
        worldBoundingBox: {
          topLeft: [0, 0, 0],
          topRight: [0, 0, 0],
          bottomLeft: [0, 0, 0],
          bottomRight: [0, 0, 0]
        }
      }
    },
    contour: {
      ...referencedToolData.data.contour,
      polyline
    }
  });
  return annotation;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/findAnnotationForInterpolation.js
function findAnnotationsForInterpolation(toolData, viewportData) {
  const interpolationData = getInterpolationData(viewportData, [
    {
      key: "interpolationUID",
      value: viewportData.interpolationUID
    }
  ]);
  const rangeToInterpolate = getRangeToInterpolate(interpolationData);
  if (!rangeToInterpolate) {
    console.warn("No annotations found to interpolate", interpolationData);
    return;
  }
  const sliceEdited = _getSlicePositionOfToolData(interpolationData, toolData.annotationUID);
  const interpolationList = [];
  for (let i = rangeToInterpolate[0] + 1; i < rangeToInterpolate[1]; i++) {
    if (_sliceNeedsInterpolating(interpolationData, i)) {
      const contourPair = _getBoundingPair(i, rangeToInterpolate, interpolationData);
      if ((contourPair == null ? void 0 : contourPair[0]) === sliceEdited || (contourPair == null ? void 0 : contourPair[1]) === sliceEdited) {
        _appendInterpolationList(contourPair, interpolationList, i);
      }
    }
  }
  return {
    interpolationData,
    interpolationList
  };
}
function getRangeToInterpolate(interpolationData) {
  let first = Infinity;
  let last = -Infinity;
  let found = false;
  for (const [sliceIndex, annotations] of interpolationData.entries()) {
    if (annotations.length) {
      first = Math.min(sliceIndex, first);
      last = Math.max(sliceIndex, last);
      found = true;
    }
  }
  if (!found) {
    return;
  }
  return [first, last];
}
function _getSlicePositionOfToolData(interpolationData, annotationUID) {
  for (const [sliceIndex, annotations] of interpolationData) {
    for (let j = 0; j < annotations.length; j++) {
      if (annotations[j].annotationUID === annotationUID) {
        return sliceIndex;
      }
    }
  }
  return;
}
function _sliceNeedsInterpolating(interpolationData, sliceIndex) {
  const annotations = interpolationData.get(sliceIndex);
  return !(annotations == null ? void 0 : annotations.length) || annotations.length === 1 && annotations[0].autoGenerated;
}
function _appendInterpolationList(contourPair, interpolationList, itemIndex) {
  const [startIndex] = contourPair;
  interpolationList[startIndex] || (interpolationList[startIndex] = {
    pair: contourPair,
    list: []
  });
  interpolationList[startIndex].list.push(itemIndex);
}
function _getBoundingPair(sliceIndex, sliceRange, interpolationData) {
  const annotationPair = [];
  let canInterpolate = true;
  for (let i = sliceIndex - 1; i >= sliceRange[0]; i--) {
    const annotations = interpolationData.get(i);
    if (annotations == null ? void 0 : annotations.length) {
      if (annotations[0].autoGenerated) {
        continue;
      }
      if (annotations.length > 1) {
        canInterpolate = false;
      }
      annotationPair.push(i);
      break;
    }
  }
  if (!canInterpolate || !annotationPair.length) {
    return;
  }
  for (let i = sliceIndex + 1; i <= sliceRange[1]; i++) {
    const annotations = interpolationData.get(i);
    if (annotations == null ? void 0 : annotations.length) {
      if (annotations[0].autoGenerated) {
        continue;
      }
      if (annotations.length > 1) {
        canInterpolate = false;
      }
      annotationPair.push(i);
      break;
    }
  }
  if (!canInterpolate || annotationPair.length < 2) {
    return;
  }
  return annotationPair;
}
var findAnnotationForInterpolation_default = findAnnotationsForInterpolation;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/selectHandles.js
var { PointsManager: PointsManager3 } = utilities_exports;
function selectHandles(polyline, handleCount = 12) {
  const handles = PointsManager3.create3(handleCount);
  handles.sources = [];
  const { sources: destPoints } = handles;
  const { length, sources: sourcePoints = [] } = polyline;
  const distance = 5;
  if (length < distance * 3) {
    return polyline.subselect(handleCount);
  }
  const interval = Math.floor(Math.max(2 * length / handleCount, distance * 2));
  sourcePoints.forEach(() => destPoints.push(PointsManager3.create3(handleCount)));
  const dotValues = createDotValues(polyline, distance);
  const minimumRegions = findMinimumRegions(dotValues, handleCount);
  const indices = [];
  if ((minimumRegions == null ? void 0 : minimumRegions.length) > 2) {
    let lastHandle = -1;
    const thirdInterval = interval / 3;
    minimumRegions.forEach((region) => {
      const [start, , end] = region;
      const midIndex = Math.ceil((start + end) / 2);
      if (end - lastHandle < thirdInterval) {
        return;
      }
      if (midIndex - start > 2 * thirdInterval) {
        addInterval(indices, lastHandle, start, interval, length);
        lastHandle = addInterval(indices, start, midIndex, interval, length);
      } else {
        lastHandle = addInterval(indices, lastHandle, midIndex, interval, length);
      }
      if (end - lastHandle > thirdInterval) {
        lastHandle = addInterval(indices, lastHandle, end, interval, length);
      }
    });
    const firstHandle = indices[0];
    const lastDistance = indexValue(firstHandle + length - lastHandle, length);
    if (lastDistance > 2 * thirdInterval) {
      addInterval(indices, lastHandle, firstHandle - thirdInterval, interval, length);
    }
  } else {
    const interval2 = Math.floor(length / handleCount);
    addInterval(indices, -1, length - interval2, interval2, length);
  }
  indices.forEach((index) => {
    const point = polyline.getPointArray(index);
    handles.push(point);
    sourcePoints.forEach((source, destSourceIndex) => destPoints[destSourceIndex].push(source.getPoint(index)));
  });
  return handles;
}
function createDotValues(polyline, distance = 6) {
  const { length } = polyline;
  const prevVec3 = vec3_exports.create();
  const nextVec3 = vec3_exports.create();
  const dotValues = new Float32Array(length);
  for (let i = 0; i < length; i++) {
    const point = polyline.getPoint(i);
    const prevPoint = polyline.getPoint(i - distance);
    const nextPoint = polyline.getPoint((i + distance) % length);
    vec3_exports.sub(prevVec3, point, prevPoint);
    vec3_exports.sub(nextVec3, nextPoint, point);
    const dot = vec3_exports.dot(prevVec3, nextVec3) / (vec3_exports.len(prevVec3) * vec3_exports.len(nextVec3));
    dotValues[i] = dot;
  }
  return dotValues;
}
function findMinimumRegions(dotValues, handleCount) {
  const { max: max2, deviation } = getStats(dotValues);
  const { length } = dotValues;
  if (deviation < 0.01 || length < handleCount * 3) {
    return [];
  }
  const inflection = [];
  let pair = null;
  let minValue;
  let minIndex = 0;
  for (let i = 0; i < length; i++) {
    const dot = dotValues[i];
    if (dot < max2 - deviation) {
      if (pair) {
        pair[2] = i;
        if (dot < minValue) {
          minValue = dot;
          minIndex = i;
        }
        pair[1] = minIndex;
      } else {
        minValue = dot;
        minIndex = i;
        pair = [i, i, i];
      }
    } else {
      if (pair) {
        inflection.push(pair);
        pair = null;
      }
    }
  }
  if (pair) {
    if (inflection[0][0] === 0) {
      inflection[0][0] = pair[0];
    } else {
      pair[1] = minIndex;
      pair[2] = length - 1;
      inflection.push(pair);
    }
  }
  return inflection;
}
function addInterval(indices, start, finish, interval, length) {
  if (finish < start) {
    finish += length;
  }
  const distance = finish - start;
  const count = Math.ceil(distance / interval);
  if (count <= 0) {
    if (indices[indices.length - 1] !== finish) {
      indices.push(indexValue(finish, length));
    }
    return finish;
  }
  for (let i = 1; i <= count; i++) {
    const index = indexValue(start + i * distance / count, length);
    indices.push(index);
  }
  return indices[indices.length - 1];
}
function indexValue(v, length) {
  return (Math.round(v) + length) % length;
}
function getStats(dotValues) {
  const { length } = dotValues;
  let sum = 0;
  let min = Infinity;
  let max2 = -Infinity;
  let sumSq = 0;
  for (let i = 0; i < length; i++) {
    const dot = dotValues[i];
    sum += dot;
    min = Math.min(min, dot);
    max2 = Math.max(max2, dot);
  }
  const mean = sum / length;
  for (let i = 0; i < length; i++) {
    const valueDiff = dotValues[i] - mean;
    sumSq += valueDiff * valueDiff;
  }
  return {
    mean,
    max: max2,
    min,
    sumSq,
    deviation: Math.sqrt(sumSq / length)
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/updateChildInterpolationUID.js
function updateChildInterpolationUID(annotation) {
  const { parentAnnotationUID, annotationUID } = annotation;
  if (!parentAnnotationUID) {
    return annotation.interpolationUID;
  }
  const parentAnnotation = state5.getAnnotation(parentAnnotationUID);
  const { interpolationUID } = parentAnnotation;
  const index = parentAnnotation.childAnnotationUIDs.indexOf(annotationUID);
  annotation.interpolationUID = `${interpolationUID}-${index}`;
  return annotation.interpolationUID;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportsForAnnotation.js
var { isEqual: isEqual2 } = utilities_exports;
function getViewportsForAnnotation(annotation) {
  const { metadata } = annotation;
  return getEnabledElements().filter((enabledElement) => {
    if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {
      const viewport = enabledElement.viewport;
      const { viewPlaneNormal, viewUp } = viewport.getCamera();
      return isEqual2(viewPlaneNormal, metadata.viewPlaneNormal) && (!metadata.viewUp || isEqual2(viewUp, metadata.viewUp));
    }
    return;
  }).map((enabledElement) => enabledElement.viewport);
}

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js
var DEFAULT_CONTOUR_SEG_TOOL_NAME = "PlanarFreehandContourSegmentationTool";
async function contourSegmentationCompletedListener(evt) {
  const sourceAnnotation = evt.detail.annotation;
  if (!isContourSegmentationAnnotation(sourceAnnotation)) {
    return;
  }
  const viewport = getViewport(sourceAnnotation);
  const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(viewport, sourceAnnotation);
  if (!contourSegmentationAnnotations.length) {
    return;
  }
  const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);
  const targetAnnotationInfo = findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations);
  if (!targetAnnotationInfo) {
    return;
  }
  const { targetAnnotation, targetPolyline, isContourHole } = targetAnnotationInfo;
  if (isContourHole) {
    const { contourHoleProcessingEnabled = false } = evt.detail;
    if (!contourHoleProcessingEnabled) {
      return;
    }
    createPolylineHole(viewport, targetAnnotation, sourceAnnotation);
  } else {
    combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);
  }
}
function isFreehandContourSegToolRegisteredForViewport(viewport, silent = false) {
  const toolName = "PlanarFreehandContourSegmentationTool";
  const toolGroup = getToolGroupForViewport_default(viewport.id, viewport.renderingEngineId);
  let errorMessage;
  if (!toolGroup.hasTool(toolName)) {
    errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;
  } else if (!toolGroup.getToolOptions(toolName)) {
    errorMessage = `Tool ${toolName} must be in active/passive state`;
  }
  if (errorMessage && !silent) {
    console.warn(errorMessage);
  }
  return !errorMessage;
}
function getViewport(annotation) {
  const viewports = getViewportsForAnnotation(annotation);
  const viewportWithToolRegistered = viewports.find((viewport) => isFreehandContourSegToolRegisteredForViewport(viewport, true));
  return viewportWithToolRegistered ?? viewports[0];
}
function convertContourPolylineToCanvasSpace(polyline, viewport) {
  const numPoints = polyline.length;
  const projectedPolyline = new Array(numPoints);
  for (let i = 0; i < numPoints; i++) {
    projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);
  }
  return projectedPolyline;
}
function getValidContourSegmentationAnnotations(viewport, sourceAnnotation) {
  const { annotationUID: sourceAnnotationUID } = sourceAnnotation;
  const allAnnotations = getAllAnnotations();
  return allAnnotations.filter((targetAnnotation) => targetAnnotation.annotationUID && targetAnnotation.annotationUID !== sourceAnnotationUID && isContourSegmentationAnnotation(targetAnnotation) && areSameSegment(targetAnnotation, sourceAnnotation) && viewport.isReferenceViewable(targetAnnotation.metadata));
}
function findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations) {
  const sourceAABB = polyline_exports.getAABB(sourcePolyline);
  for (let i = 0; i < contourSegmentationAnnotations.length; i++) {
    const targetAnnotation = contourSegmentationAnnotations[i];
    const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);
    const targetAABB = polyline_exports.getAABB(targetPolyline);
    const aabbIntersect = aabb_exports.intersectAABB(sourceAABB, targetAABB);
    const lineSegmentsIntersect = aabbIntersect && polyline_exports.intersectPolyline(sourcePolyline, targetPolyline);
    const isContourHole = aabbIntersect && !lineSegmentsIntersect && polyline_exports.containsPoints(targetPolyline, sourcePolyline);
    if (lineSegmentsIntersect || isContourHole) {
      return { targetAnnotation, targetPolyline, isContourHole };
    }
  }
}
function createPolylineHole(viewport, targetAnnotation, holeAnnotation) {
  const { windingDirection: targetWindingDirection } = targetAnnotation.data.contour;
  const { windingDirection: holeWindingDirection } = holeAnnotation.data.contour;
  addChildAnnotation(targetAnnotation, holeAnnotation);
  removeContourSegmentationAnnotation(holeAnnotation);
  const { contour: holeContour } = holeAnnotation.data;
  const holePolyline = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);
  updateContourPolyline(holeAnnotation, {
    points: holePolyline,
    closed: holeContour.closed
  }, viewport);
  const { element } = viewport;
  const updatedToolNames = /* @__PURE__ */ new Set([
    DEFAULT_CONTOUR_SEG_TOOL_NAME,
    targetAnnotation.metadata.toolName,
    holeAnnotation.metadata.toolName
  ]);
  for (const toolName of updatedToolNames.values()) {
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
  }
}
function getContourHolesData(viewport, annotation) {
  return getChildAnnotations(annotation).map((holeAnnotation) => {
    const polyline = convertContourPolylineToCanvasSpace(holeAnnotation.data.contour.polyline, viewport);
    return { annotation: holeAnnotation, polyline };
  });
}
function combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline) {
  var _a2;
  if (!hasToolByName(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {
    console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone`);
    return;
  }
  if (!isFreehandContourSegToolRegisteredForViewport(viewport)) {
    return;
  }
  const sourceStartPoint = sourcePolyline[0];
  const mergePolylines2 = polyline_exports.containsPoint(targetPolyline, sourceStartPoint);
  const contourHolesData = getContourHolesData(viewport, targetAnnotation);
  const unassignedContourHolesSet = new Set(contourHolesData);
  const reassignedContourHolesMap = /* @__PURE__ */ new Map();
  const assignHoleToPolyline = (parentPolyline, holeData) => {
    let holes = reassignedContourHolesMap.get(parentPolyline);
    if (!holes) {
      holes = [];
      reassignedContourHolesMap.set(parentPolyline, holes);
    }
    holes.push(holeData);
    unassignedContourHolesSet.delete(holeData);
  };
  const newPolylines = [];
  if (mergePolylines2) {
    const mergedPolyline = polyline_exports.mergePolylines(targetPolyline, sourcePolyline);
    newPolylines.push(mergedPolyline);
    Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => assignHoleToPolyline(mergedPolyline, holeData));
  } else {
    const subtractedPolylines = polyline_exports.subtractPolylines(targetPolyline, sourcePolyline);
    subtractedPolylines.forEach((newPolyline) => {
      newPolylines.push(newPolyline);
      Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {
        const containsHole = polyline_exports.containsPoints(newPolyline, holeData.polyline);
        if (containsHole) {
          assignHoleToPolyline(newPolyline, holeData);
          unassignedContourHolesSet.delete(holeData);
        }
      });
    });
  }
  Array.from(reassignedContourHolesMap.values()).forEach((contourHolesDataArray) => contourHolesDataArray.forEach((contourHoleData) => clearParentAnnotation(contourHoleData.annotation)));
  const { element } = viewport;
  const enabledElement = getEnabledElement(element);
  const { metadata, data } = targetAnnotation;
  const { handles, segmentation } = data;
  const { textBox } = handles;
  removeAnnotation(sourceAnnotation.annotationUID);
  removeAnnotation(targetAnnotation.annotationUID);
  for (let i = 0; i < newPolylines.length; i++) {
    const polyline = newPolylines[i];
    const startPoint = viewport.canvasToWorld(polyline[0]);
    const endPoint = viewport.canvasToWorld(polyline[polyline.length - 1]);
    const newAnnotation = {
      metadata: {
        ...metadata,
        toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,
        originalToolName: metadata.originalToolName || metadata.toolName
      },
      data: {
        cachedStats: {},
        handles: {
          points: [startPoint, endPoint],
          textBox: textBox ? { ...textBox } : void 0
        },
        contour: {
          polyline: [],
          closed: true
        },
        spline: targetAnnotation.data.spline,
        segmentation: {
          ...segmentation
        }
      },
      annotationUID: utilities_exports.uuidv4(),
      highlighted: true,
      invalidated: true,
      isLocked: false,
      isVisible: void 0,
      interpolationUID: targetAnnotation.interpolationUID,
      interpolationCompleted: targetAnnotation.interpolationCompleted
    };
    updateContourPolyline(newAnnotation, {
      points: polyline,
      closed: true,
      targetWindingDirection: ContourWindingDirection.Clockwise
    }, viewport);
    addAnnotation(newAnnotation, element);
    addContourSegmentationAnnotation(newAnnotation);
    triggerAnnotationModified(newAnnotation, viewport.element);
    (_a2 = reassignedContourHolesMap.get(polyline)) == null ? void 0 : _a2.forEach((holeData) => addChildAnnotation(newAnnotation, holeData.annotation));
  }
  updateViewports(enabledElement, targetAnnotation, sourceAnnotation);
}
function updateViewports(enabledElement, targetAnnotation, sourceAnnotation) {
  const { viewport } = enabledElement;
  const { element } = viewport;
  const updatedTtoolNames = /* @__PURE__ */ new Set([
    DEFAULT_CONTOUR_SEG_TOOL_NAME,
    targetAnnotation.metadata.toolName,
    sourceAnnotation.metadata.toolName
  ]);
  for (const toolName of updatedTtoolNames.values()) {
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
  }
  return new Promise((resolve) => window.requestAnimationFrame(resolve));
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/interpolate.js
var { PointsManager: PointsManager4 } = utilities_exports;
var dP = 0.2;
function interpolate(viewportData) {
  if (!viewportData.annotation) {
    return;
  }
  const { isInterpolationUpdate, annotation } = viewportData;
  queueMicrotask(() => {
    try {
      if (isInterpolationUpdate) {
        annotation.isInterpolationUpdate = true;
        annotation.autoGenerated = false;
      }
      startInterpolation(viewportData);
    } finally {
      if (isInterpolationUpdate) {
        annotation.autoGenerated = true;
      }
    }
  });
}
function startInterpolation(viewportData) {
  const { annotation: toolData } = viewportData;
  updateChildInterpolationUID(toolData);
  const { interpolationData, interpolationList } = findAnnotationForInterpolation_default(toolData, viewportData) || {};
  if (!interpolationData || !interpolationList) {
    return;
  }
  const eventData = {
    toolName: toolData.metadata.toolName,
    toolType: toolData.metadata.toolName,
    viewport: viewportData.viewport
  };
  for (let i = 0; i < interpolationList.length; i++) {
    if (interpolationList[i]) {
      _linearlyInterpolateBetween(interpolationList[i].list, interpolationList[i].pair, interpolationData, eventData);
    }
  }
  const { id, renderingEngineId, element } = viewportData.viewport;
  const eventDetails = {
    annotation: toolData,
    element,
    viewportId: id,
    renderingEngineId
  };
  if (interpolationList.length) {
    triggerEvent(viewportData.viewport.element, Events_default.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED, eventDetails);
  }
}
function _linearlyInterpolateBetween(indices, annotationPair, interpolationData, eventData) {
  const annotation0 = interpolationData.get(annotationPair[0])[0];
  const annotation1 = interpolationData.get(annotationPair[1])[0];
  const c1 = _generateClosedContour(annotation0.data.contour.polyline);
  const c2 = _generateClosedContour(annotation1.data.contour.polyline);
  const { c1Interp, c2Interp } = _generateInterpolationContourPair(c1, c2);
  c1Interp.kIndex = annotationPair[0];
  c2Interp.kIndex = annotationPair[1];
  indices.forEach(function(index) {
    _linearlyInterpolateContour(c1Interp, c2Interp, index, annotationPair, interpolationData, c1.x.length > c2.x.length, eventData);
  });
}
function _linearlyInterpolateContour(c1Interp, c2Interp, sliceIndex, annotationPair, interpolationData, c1HasMoreNodes, eventData) {
  const [startIndex, endIndex] = annotationPair;
  const zInterp = (sliceIndex - startIndex) / (endIndex - startIndex);
  const annotation0 = interpolationData.get(startIndex)[0];
  const annotation1 = interpolationData.get(endIndex)[0];
  const interpolated3DPoints = _generateInterpolatedOpenContour(c1Interp, c2Interp, zInterp, c1HasMoreNodes);
  const nearestAnnotation = zInterp > 0.5 ? annotation1 : annotation0;
  const handlePoints = selectHandles(interpolated3DPoints);
  if (interpolationData.has(sliceIndex)) {
    _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);
  } else {
    _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);
  }
}
function _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {
  var _a2;
  const points = interpolated3DPoints.points;
  const { viewport } = eventData;
  const interpolatedAnnotation = createPolylineToolData(points, handlePoints, referencedToolData);
  const viewRef = viewport.getViewReference({ sliceIndex });
  if (!viewRef) {
    throw new Error(`Can't find slice ${sliceIndex}`);
  }
  Object.assign(interpolatedAnnotation.metadata, viewRef);
  state5.addAnnotation(interpolatedAnnotation, viewport.element);
  (_a2 = referencedToolData.onInterpolationComplete) == null ? void 0 : _a2.call(referencedToolData, interpolatedAnnotation, referencedToolData);
  const { parentAnnotationUID } = referencedToolData;
  if (parentAnnotationUID) {
    const parentReferenced = state5.getAnnotation(parentAnnotationUID);
    const parentAnnotation = _findExistingAnnotation(parentReferenced, sliceIndex, eventData);
    createPolylineHole(viewport, parentAnnotation, interpolatedAnnotation);
  }
}
function _findExistingAnnotation(referencedToolData, sliceIndex, eventData) {
  const { viewport } = eventData;
  const annotations = state5.getAnnotations(referencedToolData.metadata.toolName, viewport.element);
  for (let i = 0; i < annotations.length; i++) {
    const annotation = annotations[i];
    if (annotation.interpolationUID === referencedToolData.interpolationUID && annotation.metadata.sliceIndex === sliceIndex) {
      return annotation;
    }
  }
}
function _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {
  const oldAnnotationData = _findExistingAnnotation(referencedToolData, sliceIndex, eventData);
  const points = interpolated3DPoints.points;
  const interpolatedAnnotation = createPolylineToolData(points, handlePoints, oldAnnotationData);
  Object.assign(oldAnnotationData, {
    metadata: interpolatedAnnotation.metadata,
    data: interpolatedAnnotation.data
  });
}
function _generateInterpolatedOpenContour(c1ir, c2ir, zInterp, c1HasMoreNodes) {
  const indices = c1HasMoreNodes ? c1ir.I : c2ir.I;
  const c1 = PointsManager4.fromXYZ(c1ir);
  const c2 = PointsManager4.fromXYZ(c2ir);
  const { length } = c1;
  const cInterp = PointsManager4.create3(length);
  const vecSubtract = vec3_exports.create();
  const vecResult = vec3_exports.create();
  const c1Source = PointsManager4.create3(length);
  c1Source.kIndex = c1ir.kIndex;
  const c2Source = PointsManager4.create3(length);
  c2Source.kIndex = c2ir.kIndex;
  for (let i = 0; i < c1ir.x.length; i++) {
    if (indices[i]) {
      const c1point = c1.getPoint(i);
      const c2point = c2.getPoint(i);
      c1Source.push(c1point);
      c2Source.push(c2point);
      vec3_exports.sub(vecSubtract, c2point, c1point);
      cInterp.push(vec3_exports.scaleAndAdd(vecResult, c1point, vecSubtract, zInterp));
    }
  }
  cInterp.sources = [c1Source, c2Source];
  return cInterp;
}
function _generateInterpolationContourPair(c1, c2) {
  const cumPerim1 = _getCumulativePerimeter(c1);
  const cumPerim2 = _getCumulativePerimeter(c2);
  const interpNodes = Math.max(Math.ceil(cumPerim1[cumPerim1.length - 1] / dP), Math.ceil(cumPerim2[cumPerim2.length - 1] / dP));
  const cumPerim1Norm = _normalisedCumulativePerimeter(cumPerim1);
  const cumPerim2Norm = _normalisedCumulativePerimeter(cumPerim2);
  const numNodes1 = interpNodes + c2.x.length;
  const numNodes2 = interpNodes + c1.x.length;
  const perim1Interp = _getInterpolatedPerim(numNodes1, cumPerim1Norm);
  const perim2Interp = _getInterpolatedPerim(numNodes2, cumPerim2Norm);
  const perim1Ind = _getIndicatorArray(numNodes1 - 2, c1.x.length);
  const perim2Ind = _getIndicatorArray(numNodes2 - 2, c2.x.length);
  const nodesPerSegment1 = _getNodesPerSegment(perim1Interp, perim1Ind);
  const nodesPerSegment2 = _getNodesPerSegment(perim2Interp, perim2Ind);
  const c1i = _getSuperSampledContour(c1, nodesPerSegment1);
  const c2i = _getSuperSampledContour(c2, nodesPerSegment2);
  _shiftSuperSampledContourInPlace(c1i, c2i);
  return _reduceContoursToOriginNodes(c1i, c2i);
}
function _reduceContoursToOriginNodes(c1i, c2i) {
  const c1Interp = {
    x: [],
    y: [],
    z: [],
    I: []
  };
  const c2Interp = {
    x: [],
    y: [],
    z: [],
    I: []
  };
  for (let i = 0; i < c1i.x.length; i++) {
    if (c1i.I[i] || c2i.I[i]) {
      c1Interp.x.push(c1i.x[i]);
      c1Interp.y.push(c1i.y[i]);
      c1Interp.z.push(c1i.z[i]);
      c1Interp.I.push(c1i.I[i]);
      c2Interp.x.push(c2i.x[i]);
      c2Interp.y.push(c2i.y[i]);
      c2Interp.z.push(c2i.z[i]);
      c2Interp.I.push(c2i.I[i]);
    }
  }
  return {
    c1Interp,
    c2Interp
  };
}
function _shiftSuperSampledContourInPlace(c1i, c2i) {
  const c1iLength = c1i.x.length;
  const optimal = {
    startingNode: 0,
    totalSquaredXYLengths: Infinity
  };
  for (let startingNode = 0; startingNode < c1iLength; startingNode++) {
    let node2 = startingNode;
    let totalSquaredXYLengths = 0;
    for (let iteration = 0; iteration < c1iLength; iteration++) {
      totalSquaredXYLengths += (c1i.x[node2] - c2i.x[iteration]) ** 2 + (c1i.y[node2] - c2i.y[iteration]) ** 2 + (c1i.z[node2] - c2i.z[iteration]) ** 2;
      node2++;
      if (node2 === c1iLength) {
        node2 = 0;
      }
    }
    if (totalSquaredXYLengths < optimal.totalSquaredXYLengths) {
      optimal.totalSquaredXYLengths = totalSquaredXYLengths;
      optimal.startingNode = startingNode;
    }
  }
  const node = optimal.startingNode;
  _shiftCircularArray(c1i.x, node);
  _shiftCircularArray(c1i.y, node);
  _shiftCircularArray(c1i.z, node);
  _shiftCircularArray(c1i.I, node);
}
function _shiftCircularArray(arr, count) {
  count -= arr.length * Math.floor(count / arr.length);
  const slicedArray = arr.splice(0, count);
  arr.push(...slicedArray);
  return arr;
}
function _getSuperSampledContour(c, nodesPerSegment) {
  const ci = {
    x: [],
    y: [],
    z: [],
    I: []
  };
  for (let n = 0; n < c.x.length - 1; n++) {
    ci.x.push(c.x[n]);
    ci.y.push(c.y[n]);
    ci.z.push(c.z[n]);
    ci.I.push(true);
    const xSpacing = (c.x[n + 1] - c.x[n]) / (nodesPerSegment[n] + 1);
    const ySpacing = (c.y[n + 1] - c.y[n]) / (nodesPerSegment[n] + 1);
    const zSpacing = (c.z[n + 1] - c.z[n]) / (nodesPerSegment[n] + 1);
    for (let i = 0; i < nodesPerSegment[n] - 1; i++) {
      ci.x.push(ci.x[ci.x.length - 1] + xSpacing);
      ci.y.push(ci.y[ci.y.length - 1] + ySpacing);
      ci.z.push(ci.z[ci.z.length - 1] + zSpacing);
      ci.I.push(false);
    }
  }
  return ci;
}
function _getNodesPerSegment(perimInterp, perimInd) {
  const idx = [];
  for (let i = 0; i < perimInterp.length; ++i) {
    idx[i] = i;
  }
  idx.sort(function(a, b) {
    return perimInterp[a] < perimInterp[b] ? -1 : 1;
  });
  const perimIndSorted = [];
  for (let i = 0; i < perimInd.length; i++) {
    perimIndSorted.push(perimInd[idx[i]]);
  }
  const indicesOfOriginNodes = perimIndSorted.reduce(function(arr, elementValue, i) {
    if (elementValue) {
      arr.push(i);
    }
    return arr;
  }, []);
  const nodesPerSegment = [];
  for (let i = 0; i < indicesOfOriginNodes.length - 1; i++) {
    nodesPerSegment.push(indicesOfOriginNodes[i + 1] - indicesOfOriginNodes[i]);
  }
  return nodesPerSegment;
}
function _getIndicatorArray(numFalse, numTrue) {
  const perimInd = new Array(numFalse + numTrue);
  perimInd.fill(false, 0, numFalse);
  perimInd.fill(true, numFalse, numFalse + numTrue);
  return perimInd;
}
function _getInterpolatedPerim(numNodes, cumPerimNorm) {
  const diff = 1 / (numNodes - 1);
  const linspace = [diff];
  for (let i = 1; i < numNodes - 2; i++) {
    linspace.push(linspace[linspace.length - 1] + diff);
  }
  return linspace.concat(cumPerimNorm);
}
function _normalisedCumulativePerimeter(cumPerim) {
  const cumPerimNorm = [];
  for (let i = 0; i < cumPerim.length; i++) {
    cumPerimNorm.push(cumPerim[i] / cumPerim[cumPerim.length - 1]);
  }
  return cumPerimNorm;
}
function _getCumulativePerimeter(contour) {
  const cumulativePerimeter = [0];
  for (let i = 1; i < contour.x.length; i++) {
    const lengthOfSegment = Math.sqrt((contour.x[i] - contour.x[i - 1]) ** 2 + (contour.y[i] - contour.y[i - 1]) ** 2 + (contour.z[i] - contour.z[i - 1]) ** 2);
    cumulativePerimeter.push(cumulativePerimeter[i - 1] + lengthOfSegment);
  }
  return cumulativePerimeter;
}
function _generateClosedContour(points) {
  const c = {
    x: [],
    y: [],
    z: []
  };
  for (let i = 0; i < points.length; i++) {
    c.x[i] = points[i][0];
    c.y[i] = points[i][1];
    c.z[i] = points[i][2];
  }
  c.x.push(c.x[0]);
  c.y.push(c.y[0]);
  c.z.push(c.z[0]);
  return c;
}
var interpolate_default = interpolate;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/deleteRelatedAnnotations.js
function deleteRelatedAnnotations(viewportData) {
  const { annotation } = viewportData;
  const interpolationAnnotations = getInterpolationData(viewportData, [
    { key: "interpolationUID", value: viewportData.interpolationUID }
  ]);
  const referencedSliceIndex = annotation.metadata.sliceIndex;
  let minInterpolation = -1;
  let maxInterpolation = viewportData.sliceData.numberOfSlices;
  for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {
    if (sliceIndex === referencedSliceIndex) {
      continue;
    }
    const nonInterpolated = annotations.find((annotation2) => !annotation2.autoGenerated);
    if (!nonInterpolated) {
      continue;
    }
    if (sliceIndex < referencedSliceIndex) {
      minInterpolation = Math.max(sliceIndex, minInterpolation);
    } else {
      maxInterpolation = Math.min(sliceIndex, maxInterpolation);
    }
  }
  const removedAnnotations = [];
  for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {
    if (sliceIndex <= minInterpolation || sliceIndex >= maxInterpolation || sliceIndex === referencedSliceIndex) {
      continue;
    }
    annotations.forEach((annotationToDelete) => {
      if (annotationToDelete.autoGenerated) {
        state5.removeAnnotation(annotationToDelete.annotationUID);
        removedAnnotations.push(annotationToDelete);
      }
    });
  }
  if (removedAnnotations.length) {
    const eventDetails = {
      annotations: removedAnnotations,
      element: viewportData.viewport.element,
      viewportId: viewportData.viewport.id,
      renderingEngineId: viewportData.viewport.getRenderingEngine().id
    };
    triggerEvent(viewportData.viewport.element, Events_default.INTERPOLATED_ANNOTATIONS_REMOVED, eventDetails);
  }
  if (minInterpolation >= 0 && maxInterpolation < viewportData.sliceData.numberOfSlices) {
    const nextAnnotation = interpolationAnnotations.get(maxInterpolation)[0];
    const viewportNewData = {
      viewport: viewportData.viewport,
      sliceData: {
        numberOfSlices: viewportData.sliceData.numberOfSlices,
        imageIndex: nextAnnotation.metadata.sliceIndex
      },
      annotation: nextAnnotation,
      interpolationUID: nextAnnotation.interpolationUID
    };
    interpolate_default(viewportNewData);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js
function getViewportForAnnotation(annotation) {
  const viewports = getViewportsForAnnotation(annotation);
  return viewports.length ? viewports[0] : void 0;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js
var { uuidv4 } = utilities_exports;
var ChangeTypesForInterpolation = [
  ChangeTypes_default.HandlesUpdated,
  ChangeTypes_default.InterpolationUpdated
];
var _InterpolationManager = class _InterpolationManager {
  static addTool(toolName) {
    if (!this.toolNames.includes(toolName)) {
      this.toolNames.push(toolName);
    }
  }
  static acceptAutoGenerated(annotationGroupSelector, selector = {}) {
    const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;
    for (const toolName of toolNames || _InterpolationManager.toolNames) {
      const annotations = state5.getAnnotations(toolName, annotationGroupSelector);
      if (!(annotations == null ? void 0 : annotations.length)) {
        continue;
      }
      for (const annotation of annotations) {
        const { interpolationUID, data, autoGenerated, metadata } = annotation;
        if (interpolationUID) {
          annotation.interpolationCompleted = true;
        }
        if (!autoGenerated) {
          continue;
        }
        if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {
          continue;
        }
        if (sliceIndex !== void 0 && metadata && sliceIndex !== metadata.sliceIndex) {
          continue;
        }
        if (segmentationId && segmentationId !== data.segmentation.segmentationId) {
          continue;
        }
        addContourSegmentationAnnotation(annotation);
        annotation.autoGenerated = false;
      }
    }
  }
};
_InterpolationManager.toolNames = [];
_InterpolationManager.handleAnnotationCompleted = (evt) => {
  var _a2;
  const annotation = evt.detail.annotation;
  if (!(annotation == null ? void 0 : annotation.metadata)) {
    return;
  }
  const { toolName, originalToolName } = annotation.metadata;
  if (!_InterpolationManager.toolNames.includes(toolName) && !_InterpolationManager.toolNames.includes(originalToolName)) {
    return;
  }
  const viewport = getViewportForAnnotation(annotation);
  if (!viewport) {
    console.warn("Unable to find viewport for", annotation);
    return;
  }
  const sliceData = getSliceData(viewport);
  const viewportData = {
    viewport,
    sliceData,
    annotation,
    interpolationUID: annotation.interpolationUID
  };
  const hasInterpolationUID = !!annotation.interpolationUID;
  annotation.autoGenerated = false;
  if (hasInterpolationUID) {
    deleteRelatedAnnotations(viewportData);
    interpolate_default(viewportData);
    return;
  }
  const filterData = [
    {
      key: "segmentIndex",
      value: annotation.data.segmentation.segmentIndex,
      parentKey: (annotation2) => annotation2.data.segmentation
    },
    {
      key: "viewPlaneNormal",
      value: annotation.metadata.viewPlaneNormal,
      parentKey: (annotation2) => annotation2.metadata
    },
    {
      key: "viewUp",
      value: annotation.metadata.viewUp,
      parentKey: (annotation2) => annotation2.metadata
    }
  ];
  let interpolationAnnotations = getInterpolationDataCollection(viewportData, filterData);
  const { sliceIndex } = annotation.metadata;
  const skipUIDs = /* @__PURE__ */ new Set();
  interpolationAnnotations.forEach((interpolationAnnotation) => {
    if (interpolationAnnotation.interpolationCompleted || interpolationAnnotation.metadata.sliceIndex === sliceIndex) {
      const { interpolationUID } = interpolationAnnotation;
      skipUIDs.add(interpolationUID);
    }
  });
  interpolationAnnotations = interpolationAnnotations.filter((interpolationAnnotation) => !skipUIDs.has(interpolationAnnotation.interpolationUID));
  annotation.interpolationUID = ((_a2 = interpolationAnnotations[0]) == null ? void 0 : _a2.interpolationUID) || uuidv4();
  viewportData.interpolationUID = annotation.interpolationUID;
  interpolate_default(viewportData);
};
_InterpolationManager.handleAnnotationUpdate = (evt) => {
  const annotation = evt.detail.annotation;
  const { changeType = ChangeTypes_default.HandlesUpdated } = evt.detail;
  if (!(annotation == null ? void 0 : annotation.metadata)) {
    return;
  }
  const { toolName, originalToolName } = annotation.metadata;
  if (!_InterpolationManager.toolNames.includes(toolName) && !_InterpolationManager.toolNames.includes(originalToolName) || !ChangeTypesForInterpolation.includes(changeType)) {
    return;
  }
  const viewport = getViewportForAnnotation(annotation);
  if (!viewport) {
    console.warn("Unable to find matching viewport for annotation interpolation", annotation);
    return;
  }
  if (annotation.autoGenerated) {
    addContourSegmentationAnnotation(annotation);
    annotation.autoGenerated = false;
  }
  const sliceData = getSliceData(viewport);
  const viewportData = {
    viewport,
    sliceData,
    annotation,
    interpolationUID: annotation.interpolationUID,
    isInterpolationUpdate: changeType === ChangeTypes_default.InterpolationUpdated
  };
  interpolate_default(viewportData);
};
_InterpolationManager.handleAnnotationDelete = (evt) => {
  const annotation = evt.detail.annotation;
  if (!(annotation == null ? void 0 : annotation.metadata)) {
    return;
  }
  const { toolName } = annotation.metadata;
  if (!_InterpolationManager.toolNames.includes(toolName) || annotation.autoGenerated) {
    return;
  }
  const viewport = getViewportForAnnotation(annotation);
  if (!viewport) {
    console.warn("No viewport, can't delete interpolated results", annotation);
    return;
  }
  const sliceData = getSliceData(viewport);
  const viewportData = {
    viewport,
    sliceData,
    annotation,
    interpolationUID: annotation.interpolationUID
  };
  annotation.autoGenerated = false;
  deleteRelatedAnnotations(viewportData);
};
var InterpolationManager = _InterpolationManager;
function getSliceData(viewport) {
  const sliceData = {
    numberOfSlices: viewport.getNumberOfSlices(),
    imageIndex: viewport.getCurrentImageIdIndex()
  };
  return sliceData;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js
function triggerAnnotationRenderForToolGroupIds(toolGroupIds) {
  toolGroupIds.forEach((toolGroupId) => {
    const toolGroup = getToolGroup_default(toolGroupId);
    if (!toolGroup) {
      console.warn(`ToolGroup not available for ${toolGroupId}`);
      return;
    }
    const viewportsInfo = toolGroup.getViewportsInfo();
    viewportsInfo.forEach((viewportInfo) => {
      const { renderingEngineId, viewportId } = viewportInfo;
      const renderingEngine = getRenderingEngine(renderingEngineId);
      if (!renderingEngine) {
        console.warn(`RenderingEngine not available for ${renderingEngineId}`);
        return;
      }
      const viewport = renderingEngine.getViewport(viewportId);
      triggerAnnotationRender_default(viewport.element);
    });
  });
}
var triggerAnnotationRenderForToolGroupIds_default = triggerAnnotationRenderForToolGroupIds;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js
function getActiveSegmentation(viewportId) {
  const segmentationStateManager = defaultSegmentationStateManager;
  return segmentationStateManager.getActiveSegmentation(viewportId);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js
function getActiveSegmentIndex(segmentationId) {
  const segmentation = getSegmentation(segmentationId);
  if (segmentation) {
    const activeSegmentIndex = Object.keys(segmentation.segments).find((segmentIndex) => segmentation.segments[segmentIndex].active);
    return activeSegmentIndex ? Number(activeSegmentIndex) : void 0;
  }
  return void 0;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js
var segmentLocking_exports = {};
__export(segmentLocking_exports, {
  getLockedSegmentIndices: () => getLockedSegmentIndices,
  isSegmentIndexLocked: () => isSegmentIndexLocked,
  setSegmentIndexLocked: () => setSegmentIndexLocked
});
function isSegmentIndexLocked(segmentationId, segmentIndex) {
  const segmentation = getSegmentation(segmentationId);
  if (!segmentation) {
    throw new Error(`No segmentation state found for ${segmentationId}`);
  }
  const { segments } = segmentation;
  return segments[segmentIndex].locked;
}
function setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {
  const segmentation = getSegmentation(segmentationId);
  if (!segmentation) {
    throw new Error(`No segmentation state found for ${segmentationId}`);
  }
  const { segments } = segmentation;
  segments[segmentIndex].locked = locked;
  triggerSegmentationModified(segmentationId);
}
function getLockedSegmentIndices(segmentationId) {
  const segmentation = getSegmentation(segmentationId);
  if (!segmentation) {
    throw new Error(`No segmentation state found for ${segmentationId}`);
  }
  const { segments } = segmentation;
  const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);
  return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js
function getSegmentationRepresentationVisibility(viewportId, specifier) {
  const segmentationStateManager = defaultSegmentationStateManager;
  return segmentationStateManager.getSegmentationRepresentationVisibility(viewportId, specifier);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js
function internalGetHiddenSegmentIndices(viewportId, specifier) {
  const representation = getSegmentationRepresentation(viewportId, specifier);
  if (!representation) {
    return /* @__PURE__ */ new Set();
  }
  const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {
    if (!segment.visible) {
      acc.add(Number(segmentIndex));
    }
    return acc;
  }, /* @__PURE__ */ new Set());
  return segmentsHidden;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSVGStyleForSegment.js
function getSVGStyleForSegment({ segmentationId, segmentIndex, viewportId, autoGenerated = false }) {
  const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);
  const segmentationVisible = getSegmentationRepresentationVisibility(viewportId, {
    segmentationId,
    type: SegmentationRepresentations_default.Contour
  });
  const activeSegmentation = getActiveSegmentation(viewportId);
  const isActive = (activeSegmentation == null ? void 0 : activeSegmentation.segmentationId) === segmentationId;
  const style = segmentationStyle.getStyle({
    viewportId,
    segmentationId,
    type: SegmentationRepresentations_default.Contour,
    segmentIndex
  });
  const mergedConfig = style;
  let lineWidth = 1;
  let lineDash = void 0;
  let lineOpacity = 1;
  let fillOpacity = 0;
  if (autoGenerated) {
    lineWidth = mergedConfig.outlineWidthAutoGenerated ?? lineWidth;
    lineDash = mergedConfig.outlineDashAutoGenerated ?? lineDash;
    lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;
    fillOpacity = mergedConfig.fillAlphaAutoGenerated ?? fillOpacity;
  } else if (isActive) {
    lineWidth = mergedConfig.outlineWidth ?? lineWidth;
    lineDash = mergedConfig.outlineDash ?? lineDash;
    lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;
    fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;
  } else {
    lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;
    lineDash = mergedConfig.outlineDashInactive ?? lineDash;
    lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;
    fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;
  }
  if (getActiveSegmentIndex(segmentationId) === segmentIndex) {
    lineWidth += mergedConfig.activeSegmentOutlineWidthDelta;
  }
  lineWidth = mergedConfig.renderOutline ? lineWidth : 0;
  fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;
  const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;
  const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;
  const hiddenSegments = internalGetHiddenSegmentIndices(viewportId, {
    segmentationId,
    type: SegmentationRepresentations_default.Contour
  });
  const isVisible = !hiddenSegments.has(segmentIndex);
  return {
    color,
    fillColor,
    lineWidth,
    fillOpacity,
    lineDash,
    textbox: {
      color
    },
    visibility: segmentationVisible && isVisible
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js
var _ContourSegmentationBaseTool = class _ContourSegmentationBaseTool extends ContourBaseTool {
  constructor(toolProps, defaultToolProps) {
    var _a2;
    super(toolProps, defaultToolProps);
    if ((_a2 = this.configuration.interpolation) == null ? void 0 : _a2.enabled) {
      InterpolationManager.addTool(this.getToolName());
    }
  }
  isContourSegmentationTool() {
    return true;
  }
  createAnnotation(evt) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const enabledElement = getEnabledElement(element);
    if (!enabledElement) {
      return;
    }
    const { viewport } = enabledElement;
    const contourAnnotation = super.createAnnotation(evt);
    if (!this.isContourSegmentationTool()) {
      return contourAnnotation;
    }
    const activeSeg = getActiveSegmentation(viewport.id);
    if (!activeSeg) {
      throw new Error("No active segmentation detected, create one before using scissors tool");
    }
    if (!activeSeg.representationData.Contour) {
      throw new Error(`A contour segmentation must be active`);
    }
    const { segmentationId } = activeSeg;
    const segmentIndex = getActiveSegmentIndex(segmentationId);
    return utilities_exports.deepMerge(contourAnnotation, {
      data: {
        segmentation: {
          segmentationId,
          segmentIndex
        }
      }
    });
  }
  addAnnotation(annotation, element) {
    const annotationUID = super.addAnnotation(annotation, element);
    if (this.isContourSegmentationTool()) {
      const contourSegAnnotation = annotation;
      addContourSegmentationAnnotation(contourSegAnnotation);
    }
    return annotationUID;
  }
  cancelAnnotation(annotation) {
    if (this.isContourSegmentationTool()) {
      removeContourSegmentationAnnotation(annotation);
    }
    super.cancelAnnotation(annotation);
  }
  getAnnotationStyle(context) {
    const annotationStyle = super.getAnnotationStyle(context);
    if (!this.isContourSegmentationTool()) {
      return annotationStyle;
    }
    const contourSegmentationStyle = this._getContourSegmentationStyle(context);
    return utilities_exports.deepMerge(annotationStyle, contourSegmentationStyle);
  }
  renderAnnotationInstance(renderContext) {
    const { annotation } = renderContext;
    const { invalidated } = annotation;
    const renderResult = super.renderAnnotationInstance(renderContext);
    if (invalidated && this.isContourSegmentationTool()) {
      const { segmentationId } = annotation.data.segmentation;
      triggerSegmentationDataModified(segmentationId);
      const viewportIds = getViewportIdsWithSegmentation(segmentationId);
      const toolGroupIds = viewportIds.map((viewportId) => {
        const toolGroup = getToolGroupForViewport_default(viewportId);
        return toolGroup.id;
      });
      triggerAnnotationRenderForToolGroupIds(toolGroupIds);
    }
    return renderResult;
  }
  _getContourSegmentationStyle(context) {
    const annotation = context.annotation;
    const { segmentationId, segmentIndex } = annotation.data.segmentation;
    const { viewportId } = context.styleSpecifier;
    const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });
    if (!(segmentationRepresentations == null ? void 0 : segmentationRepresentations.length)) {
      return {};
    }
    let segmentationRepresentation;
    if (segmentationRepresentations.length > 1) {
      segmentationRepresentation = segmentationRepresentations.find((rep) => rep.segmentationId === segmentationId && rep.type === SegmentationRepresentations_default.Contour);
    } else {
      segmentationRepresentation = segmentationRepresentations[0];
    }
    const { autoGenerated } = annotation;
    const segmentsLocked = getLockedSegmentIndices(segmentationId);
    const annotationLocked = segmentsLocked.includes(segmentIndex);
    const { color, fillColor, lineWidth, fillOpacity, lineDash, visibility } = getSVGStyleForSegment({
      segmentationId,
      segmentIndex,
      viewportId,
      autoGenerated
    });
    return {
      color,
      fillColor,
      lineWidth,
      fillOpacity,
      lineDash,
      textbox: {
        color
      },
      visibility,
      locked: annotationLocked
    };
  }
};
_ContourSegmentationBaseTool.PreviewSegmentIndex = 255;
var ContourSegmentationBaseTool = _ContourSegmentationBaseTool;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js
function getPixelValueUnits(modality, imageId, options) {
  if (modality === "CT") {
    return "HU";
  } else if (modality === "PT") {
    return _handlePTModality(imageId, options);
  } else {
    return "";
  }
}
function _handlePTModality(imageId, options) {
  if (!options.isPreScaled) {
    return "raw";
  }
  if (options.isSuvScaled) {
    return "SUV";
  }
  const generalSeriesModule = metaData_exports.get("generalSeriesModule", imageId);
  if ((generalSeriesModule == null ? void 0 : generalSeriesModule.modality) === "PT") {
    const petSeriesModule = metaData_exports.get("petSeriesModule", imageId);
    return (petSeriesModule == null ? void 0 : petSeriesModule.units) || "unitless";
  }
  return "unknown";
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js
var { pointCanProjectOnLine: pointCanProjectOnLine2 } = polyline_exports;
var { EPSILON: EPSILON6 } = constants_exports;
var PARALLEL_THRESHOLD3 = 1 - EPSILON6;
var PlanarFreehandROITool = class extends ContourSegmentationBaseTool {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      storePointData: false,
      shadow: true,
      preventHandleOutsideImage: false,
      contourHoleAdditionModifierKey: KeyboardBindings.Shift,
      alwaysRenderOpenContourHandles: {
        enabled: false,
        radius: 2
      },
      allowOpenContours: true,
      closeContourProximity: 10,
      checkCanvasEditFallbackProximity: 6,
      makeClockWise: true,
      subPixelResolution: 4,
      smoothing: {
        smoothOnAdd: false,
        smoothOnEdit: false,
        knotsRatioPercentageOnAdd: 40,
        knotsRatioPercentageOnEdit: 40
      },
      interpolation: {
        enabled: false,
        onInterpolationComplete: null
      },
      decimate: {
        enabled: false,
        epsilon: 0.1
      },
      displayOnePointAsCrosshairs: false,
      calculateStats: true,
      getTextLines: defaultGetTextLines,
      statsCalculator: BasicStatsCalculator
    }
  }) {
    super(toolProps, defaultToolProps);
    this.isDrawing = false;
    this.isEditingClosed = false;
    this.isEditingOpen = false;
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const annotation = this.createAnnotation(evt);
      this.addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.activateDraw(evt, annotation, viewportIdsToRender);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.handleSelectedCallback = (evt, annotation, handle) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      if (annotation.data.contour.closed) {
        this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);
      } else {
        this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);
      }
      evt.preventDefault();
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { polyline: points } = annotation.data.contour;
      let previousPoint = viewport.worldToCanvas(points[0]);
      for (let i = 1; i < points.length; i++) {
        const p1 = previousPoint;
        const p2 = viewport.worldToCanvas(points[i]);
        const canProject = pointCanProjectOnLine2(canvasCoords, p1, p2, proximity);
        if (canProject) {
          return true;
        }
        previousPoint = p2;
      }
      if (!annotation.data.contour.closed) {
        return false;
      }
      const pStart = viewport.worldToCanvas(points[0]);
      const pEnd = viewport.worldToCanvas(points[points.length - 1]);
      return pointCanProjectOnLine2(canvasCoords, pStart, pEnd, proximity);
    };
    this.cancel = (element) => {
      const isDrawing = this.isDrawing;
      const isEditingOpen = this.isEditingOpen;
      const isEditingClosed = this.isEditingClosed;
      if (isDrawing) {
        this.cancelDrawing(element);
      } else if (isEditingOpen) {
        this.cancelOpenContourEdit(element);
      } else if (isEditingClosed) {
        this.cancelClosedContourEdit(element);
      }
    };
    this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {
      const { data } = annotation;
      const { cachedStats } = data;
      const { polyline: points, closed: closed2 } = data.contour;
      const targetIds = Object.keys(cachedStats);
      for (let i = 0; i < targetIds.length; i++) {
        const targetId = targetIds[i];
        const image = this.getTargetImageData(targetId);
        if (!image) {
          continue;
        }
        const { imageData, metadata } = image;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const modalityUnitOptions = {
          isPreScaled: isViewportPreScaled(viewport, targetId),
          isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId)
        };
        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
        const calibratedScale = getCalibratedLengthUnitsAndScale(image, () => {
          const polyline = data.contour.polyline;
          const numPoints = polyline.length;
          const projectedPolyline = new Array(numPoints);
          for (let i2 = 0; i2 < numPoints; i2++) {
            projectedPolyline[i2] = viewport.worldToCanvas(polyline[i2]);
          }
          const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY } = polyline_exports.getAABB(projectedPolyline);
          const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);
          const topLeftBBIndex = utilities_exports.transformWorldToIndex(imageData, topLeftBBWorld);
          const bottomRightBBWorld = viewport.canvasToWorld([
            canvasMaxX,
            canvasMaxY
          ]);
          const bottomRightBBIndex = utilities_exports.transformWorldToIndex(imageData, bottomRightBBWorld);
          return [topLeftBBIndex, bottomRightBBIndex];
        });
        if (closed2) {
          this.updateClosedCachedStats({
            targetId,
            viewport,
            canvasCoordinates,
            points,
            imageData,
            metadata,
            cachedStats,
            modalityUnit,
            calibratedScale
          });
        } else {
          this.updateOpenCachedStats({
            metadata,
            canvasCoordinates,
            targetId,
            cachedStats,
            modalityUnit,
            calibratedScale
          });
        }
      }
      triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes_default.StatsUpdated);
      annotation.invalidated = false;
      return cachedStats;
    };
    this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {
      const { data } = annotation;
      const targetId = this.getTargetId(viewport);
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
      if (!options.visibility) {
        return;
      }
      const textLines = this.configuration.getTextLines(data, targetId);
      if (!textLines || textLines.length === 0) {
        return;
      }
      const canvasCoordinates = data.contour.polyline.map((p) => viewport.worldToCanvas(p));
      if (!data.handles.textBox.hasMoved) {
        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);
        data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
      }
      const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
      const textBoxUID = "1";
      const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotation.annotationUID ?? "", textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
      const { x: left, y: top, width, height } = boundingBox;
      data.handles.textBox.worldBoundingBox = {
        topLeft: viewport.canvasToWorld([left, top]),
        topRight: viewport.canvasToWorld([left + width, top]),
        bottomLeft: viewport.canvasToWorld([left, top + height]),
        bottomRight: viewport.canvasToWorld([left + width, top + height])
      };
    };
    drawLoop_default(this);
    editLoopCommon_default(this);
    closedContourEditLoop_default(this);
    openContourEditLoop_default(this);
    openContourEndEditLoop_default(this);
    renderMethods_default(this);
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
  filterInteractableAnnotationsForElement(element, annotations) {
    if (!annotations || !annotations.length) {
      return;
    }
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    let annotationsToDisplay;
    if (viewport instanceof VolumeViewport_default) {
      const camera = viewport.getCamera();
      const { spacingInNormalDirection } = utilities_exports.getTargetVolumeAndSpacingInNormalDir(viewport, camera);
      annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);
    } else {
      annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);
    }
    return annotationsToDisplay;
  }
  filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {
    const { viewPlaneNormal } = camera;
    const annotationsWithParallelNormals = annotations.filter((td2) => {
      const annotationViewPlaneNormal = td2.metadata.viewPlaneNormal;
      const isParallel = Math.abs(vec3_exports.dot(viewPlaneNormal, annotationViewPlaneNormal)) > PARALLEL_THRESHOLD3;
      return annotationViewPlaneNormal && isParallel;
    });
    if (!annotationsWithParallelNormals.length) {
      return [];
    }
    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;
    const { focalPoint } = camera;
    const annotationsWithinSlice = [];
    for (const annotation of annotationsWithParallelNormals) {
      const data = annotation.data;
      const point = data.contour.polyline[0];
      if (!annotation.isVisible) {
        continue;
      }
      const dir = vec3_exports.create();
      vec3_exports.sub(dir, focalPoint, point);
      const dot = vec3_exports.dot(dir, viewPlaneNormal);
      if (Math.abs(dot) < halfSpacingInNormalDirection) {
        annotationsWithinSlice.push(annotation);
      }
    }
    return annotationsWithinSlice;
  }
  isContourSegmentationTool() {
    return false;
  }
  createAnnotation(evt) {
    const worldPos = evt.detail.currentPoints.world;
    const contourAnnotation = super.createAnnotation(evt);
    const onInterpolationComplete = (annotation2) => {
      annotation2.data.handles.points.length = 0;
    };
    const annotation = utilities_exports.deepMerge(contourAnnotation, {
      data: {
        contour: {
          polyline: [[...worldPos]]
        },
        label: "",
        cachedStats: {}
      },
      onInterpolationComplete
    });
    return annotation;
  }
  getAnnotationStyle(context) {
    return super.getAnnotationStyle(context);
  }
  renderAnnotationInstance(renderContext) {
    const { enabledElement, targetId, svgDrawingHelper } = renderContext;
    const annotation = renderContext.annotation;
    let renderStatus = false;
    const { viewport, renderingEngine } = enabledElement;
    const isDrawing = this.isDrawing;
    const isEditingOpen = this.isEditingOpen;
    const isEditingClosed = this.isEditingClosed;
    if (!(isDrawing || isEditingOpen || isEditingClosed)) {
      if (this.configuration.displayOnePointAsCrosshairs && annotation.data.contour.polyline.length === 1) {
        this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);
      } else {
        this.renderContour(enabledElement, svgDrawingHelper, annotation);
      }
    } else {
      const activeAnnotationUID = this.commonData.annotation.annotationUID;
      if (annotation.annotationUID === activeAnnotationUID) {
        if (isDrawing) {
          this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);
        } else if (isEditingClosed) {
          this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
        } else if (isEditingOpen) {
          this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
        } else {
          throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);
        }
      } else {
        if (this.configuration.displayOnePointAsCrosshairs && annotation.data.contour.polyline.length === 1) {
          this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);
        } else {
          this.renderContour(enabledElement, svgDrawingHelper, annotation);
        }
      }
      renderStatus = true;
    }
    if (!this.configuration.calculateStats) {
      return;
    }
    this._calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement);
    this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);
    return renderStatus;
  }
  _calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement) {
    var _a2, _b2, _c;
    const activeAnnotationUID = (_a2 = this.commonData) == null ? void 0 : _a2.annotation.annotationUID;
    if (annotation.annotationUID === activeAnnotationUID && !((_b2 = this.commonData) == null ? void 0 : _b2.movingTextBox)) {
      return;
    }
    if (!((_c = this.commonData) == null ? void 0 : _c.movingTextBox)) {
      const { data } = annotation;
      if (!data.cachedStats[targetId] || data.cachedStats[targetId].areaUnit == null) {
        data.cachedStats[targetId] = {
          Modality: null,
          area: null,
          max: null,
          mean: null,
          stdDev: null,
          areaUnit: null
        };
        this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
      } else if (annotation.invalidated) {
        this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
      }
    }
  }
  updateClosedCachedStats({ viewport, points, imageData, metadata, cachedStats, targetId, modalityUnit, canvasCoordinates, calibratedScale }) {
    var _a2, _b2, _c;
    const { scale, areaUnit, units } = calibratedScale;
    const { voxelManager } = viewport.getImageData();
    const canvasPoint = canvasCoordinates[0];
    const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
    const deltaXPoint = viewport.canvasToWorld([
      canvasPoint[0] + 1,
      canvasPoint[1]
    ]);
    const deltaYPoint = viewport.canvasToWorld([
      canvasPoint[0],
      canvasPoint[1] + 1
    ]);
    const deltaInX = vec3_exports.distance(originalWorldPoint, deltaXPoint);
    const deltaInY = vec3_exports.distance(originalWorldPoint, deltaYPoint);
    const worldPosIndex = utilities_exports.transformWorldToIndex(imageData, points[0]);
    worldPosIndex[0] = Math.floor(worldPosIndex[0]);
    worldPosIndex[1] = Math.floor(worldPosIndex[1]);
    worldPosIndex[2] = Math.floor(worldPosIndex[2]);
    let iMin = worldPosIndex[0];
    let iMax = worldPosIndex[0];
    let jMin = worldPosIndex[1];
    let jMax = worldPosIndex[1];
    let kMin = worldPosIndex[2];
    let kMax = worldPosIndex[2];
    for (let j = 1; j < points.length; j++) {
      const worldPosIndex3 = utilities_exports.transformWorldToIndex(imageData, points[j]);
      worldPosIndex3[0] = Math.floor(worldPosIndex3[0]);
      worldPosIndex3[1] = Math.floor(worldPosIndex3[1]);
      worldPosIndex3[2] = Math.floor(worldPosIndex3[2]);
      iMin = Math.min(iMin, worldPosIndex3[0]);
      iMax = Math.max(iMax, worldPosIndex3[0]);
      jMin = Math.min(jMin, worldPosIndex3[1]);
      jMax = Math.max(jMax, worldPosIndex3[1]);
      kMin = Math.min(kMin, worldPosIndex3[2]);
      kMax = Math.max(kMax, worldPosIndex3[2]);
    }
    const worldPosIndex2 = utilities_exports.transformWorldToIndex(imageData, points[1]);
    worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);
    worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);
    worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);
    let area = polyline_exports.getArea(canvasCoordinates) / scale / scale;
    area *= deltaInX * deltaInY;
    const iDelta = 0.01 * (iMax - iMin);
    const jDelta = 0.01 * (jMax - jMin);
    const kDelta = 0.01 * (kMax - kMin);
    iMin = Math.floor(iMin - iDelta);
    iMax = Math.ceil(iMax + iDelta);
    jMin = Math.floor(jMin - jDelta);
    jMax = Math.ceil(jMax + jDelta);
    kMin = Math.floor(kMin - kDelta);
    kMax = Math.ceil(kMax + kDelta);
    const boundsIJK = [
      [iMin, iMax],
      [jMin, jMax],
      [kMin, kMax]
    ];
    const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);
    const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);
    let curRow = 0;
    let intersections = [];
    let intersectionCounter = 0;
    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
      imageData,
      isInObject: (pointLPS, _pointIJK) => {
        let result = true;
        const point = viewport.worldToCanvas(pointLPS);
        if (point[1] != curRow) {
          intersectionCounter = 0;
          curRow = point[1];
          intersections = getLineSegmentIntersectionsCoordinates(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);
          intersections.sort(/* @__PURE__ */ function(index) {
            return function(a, b) {
              return a[index] === b[index] ? 0 : a[index] < b[index] ? -1 : 1;
            };
          }(0));
        }
        if (intersections.length && point[0] > intersections[0][0]) {
          intersections.shift();
          intersectionCounter++;
        }
        if (intersectionCounter % 2 === 0) {
          result = false;
        }
        return result;
      },
      boundsIJK,
      returnPoints: this.configuration.storePointData
    });
    const stats = this.configuration.statsCalculator.getStatistics();
    cachedStats[targetId] = {
      Modality: metadata.Modality,
      area,
      perimeter: calculatePerimeter_default(canvasCoordinates, closed) / scale,
      mean: (_a2 = stats.mean) == null ? void 0 : _a2.value,
      max: (_b2 = stats.max) == null ? void 0 : _b2.value,
      stdDev: (_c = stats.stdDev) == null ? void 0 : _c.value,
      statsArray: stats.array,
      pointsInShape,
      areaUnit,
      modalityUnit,
      unit: units
    };
  }
  updateOpenCachedStats({ targetId, metadata, canvasCoordinates, cachedStats, modalityUnit, calibratedScale }) {
    const { scale, units } = calibratedScale;
    cachedStats[targetId] = {
      Modality: metadata.Modality,
      length: calculatePerimeter_default(canvasCoordinates, false) / scale,
      modalityUnit,
      getPixelValueUnitunit: units
    };
  }
};
function defaultGetTextLines(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { area, mean, stdDev, length, perimeter, max: max2, isEmptyArea, unit, areaUnit, modalityUnit } = cachedVolumeStats || {};
  const textLines = [];
  if (area) {
    const areaLine = isEmptyArea ? `Area: Oblique not supported` : `Area: ${utilities_exports.roundNumber(area)} ${areaUnit}`;
    textLines.push(areaLine);
  }
  if (mean) {
    textLines.push(`Mean: ${utilities_exports.roundNumber(mean)} ${modalityUnit}`);
  }
  if (Number.isFinite(max2)) {
    textLines.push(`Max: ${utilities_exports.roundNumber(max2)} ${modalityUnit}`);
  }
  if (stdDev) {
    textLines.push(`Std Dev: ${utilities_exports.roundNumber(stdDev)} ${modalityUnit}`);
  }
  if (perimeter) {
    textLines.push(`Perimeter: ${utilities_exports.roundNumber(perimeter)} ${unit}`);
  }
  if (length) {
    textLines.push(`${utilities_exports.roundNumber(length)} ${unit}`);
  }
  return textLines;
}
PlanarFreehandROITool.toolName = "PlanarFreehandROI";
var PlanarFreehandROITool_default = PlanarFreehandROITool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js
var PlanarFreehandContourSegmentationTool = class extends PlanarFreehandROITool_default {
  constructor(toolProps) {
    const initialProps = utilities_exports.deepMerge({
      configuration: {
        calculateStats: false,
        allowOpenContours: false
      }
    }, toolProps);
    super(initialProps);
  }
  isContourSegmentationTool() {
    return true;
  }
  renderAnnotationInstance(renderContext) {
    const annotation = renderContext.annotation;
    const { invalidated } = annotation;
    const renderResult = super.renderAnnotationInstance(renderContext);
    if (invalidated) {
      const { segmentationId } = annotation.data.segmentation;
      triggerSegmentationDataModified(segmentationId);
    }
    return renderResult;
  }
};
PlanarFreehandContourSegmentationTool.toolName = "PlanarFreehandContourSegmentationTool";
var PlanarFreehandContourSegmentationTool_default = PlanarFreehandContourSegmentationTool;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Contour/utils/createAndAddContourSegmentationsFromClippedSurfaces.js
function createAndAddContourSegmentationsFromClippedSurfaces(rawContourData, viewport, segmentationId) {
  const annotationUIDsMap = /* @__PURE__ */ new Map();
  for (const [segmentIndex, contoursData] of rawContourData) {
    for (const contourData of contoursData) {
      const { points } = contourData;
      const { lineSegments, linesNumberOfPoints } = _extractLineSegments(contourData);
      for (let i = 0; i < lineSegments.length; i++) {
        const line = lineSegments[i];
        const polyline = [];
        for (let j = 0; j < linesNumberOfPoints[i]; j++) {
          const pointIndex = line[j];
          polyline.push([
            points[3 * pointIndex],
            points[3 * pointIndex + 1],
            points[3 * pointIndex + 2]
          ]);
        }
        if (polyline.length < 3) {
          continue;
        }
        const contourSegmentationAnnotation = {
          annotationUID: utilities_exports.uuidv4(),
          data: {
            contour: {
              closed: true,
              polyline
            },
            segmentation: {
              segmentationId,
              segmentIndex
            },
            handles: {}
          },
          handles: {},
          highlighted: false,
          autoGenerated: false,
          invalidated: false,
          isLocked: false,
          isVisible: true,
          metadata: {
            toolName: PlanarFreehandContourSegmentationTool_default.toolName,
            ...viewport.getViewReference()
          }
        };
        addAnnotation(contourSegmentationAnnotation, viewport.element);
        const currentSet = (annotationUIDsMap == null ? void 0 : annotationUIDsMap.get(segmentIndex)) || /* @__PURE__ */ new Set();
        currentSet.add(contourSegmentationAnnotation.annotationUID);
        annotationUIDsMap.set(segmentIndex, currentSet);
      }
    }
  }
  return annotationUIDsMap;
}
var _extractLineSegments = (contourData) => {
  const { numberOfCells, lines } = contourData;
  const lineSegments = [];
  const linesNumberOfPoints = [];
  for (let i = 0; i < lines.length; ) {
    const pointsInLine = lines[i];
    linesNumberOfPoints.push(pointsInLine);
    lineSegments.push(lines.slice(i + 1, i + pointsInLine + 1));
    i += pointsInLine + 1;
    if (lineSegments.length === numberOfCells) {
      break;
    }
  }
  return { lineSegments, linesNumberOfPoints };
};

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Contour/contourComputationStrategies.js
async function computeContourData(segmentationId, options = {}) {
  var _a2;
  const segmentIndices = ((_a2 = options.segmentIndices) == null ? void 0 : _a2.length) ? options.segmentIndices : getUniqueSegmentIndices(segmentationId);
  let rawContourData;
  const segmentation = getSegmentation(segmentationId);
  const representationData = segmentation.representationData;
  try {
    if (representationData.Surface) {
      rawContourData = await computeContourFromSurfaceSegmentation(segmentationId, {
        segmentIndices,
        ...options
      });
    } else if (representationData.Labelmap) {
      rawContourData = await computeContourFromLabelmapSegmentation(segmentationId, {
        segmentIndices,
        ...options
      });
    }
  } catch (error) {
    console.error(error);
    throw error;
  }
  if (!rawContourData) {
    throw new Error("Not enough data to convert to contour, currently only support converting volume labelmap to contour if available");
  }
  const { viewport } = options;
  const annotationUIDsMap = createAndAddContourSegmentationsFromClippedSurfaces(rawContourData, viewport, segmentationId);
  segmentationStyle.setStyle({ segmentationId, type: SegmentationRepresentations_default.Contour }, {
    fillAlpha: 0
  });
  return {
    annotationUIDsMap
  };
}
async function computeContourFromLabelmapSegmentation(segmentationId, options = {}) {
  if (!options.viewport) {
    throw new Error("Viewport is required to compute contour from labelmap");
  }
  const results = await computeSurfaceFromLabelmapSegmentation(segmentationId, options);
  if (!(results == null ? void 0 : results.length)) {
    console.error("Failed to convert labelmap to surface or labelmap is empty");
    return;
  }
  const { viewport } = options;
  const pointsAndPolys = results.map((surface) => {
    return {
      id: surface.segmentIndex.toString(),
      points: surface.data.points,
      polys: surface.data.polys,
      segmentIndex: surface.segmentIndex
    };
  });
  const polyDataCache2 = await clipAndCacheSurfacesForViewport(pointsAndPolys, viewport);
  const rawResults = extractContourData(polyDataCache2);
  return rawResults;
}
async function computeContourFromSurfaceSegmentation(segmentationId, options = {}) {
  var _a2;
  if (!options.viewport) {
    throw new Error("Viewport is required to compute contour from surface");
  }
  const { viewport } = options;
  const segmentIndices = ((_a2 = options.segmentIndices) == null ? void 0 : _a2.length) ? options.segmentIndices : getUniqueSegmentIndices(segmentationId);
  const segmentIndexToSurfaceId = /* @__PURE__ */ new Map();
  const surfaceIdToSegmentIndex = /* @__PURE__ */ new Map();
  const segmentation = getSegmentation(segmentationId);
  const representationData = segmentation.representationData.Surface;
  const surfacesInfo = [];
  representationData.geometryIds.forEach((geometryId, segmentIndex) => {
    var _a3;
    if (segmentIndices.includes(segmentIndex)) {
      segmentIndexToSurfaceId.set(segmentIndex, geometryId);
      const surface = (_a3 = cache_default.getGeometry(geometryId)) == null ? void 0 : _a3.data;
      if (surface) {
        surfacesInfo.push({
          id: geometryId,
          points: surface.points,
          polys: surface.polys,
          segmentIndex
        });
      }
    }
  });
  segmentIndexToSurfaceId.forEach((surfaceId, segmentIndex) => {
    surfaceIdToSegmentIndex.set(surfaceId, segmentIndex);
  });
  const polyDataCache2 = await clipAndCacheSurfacesForViewport(surfacesInfo, viewport);
  const rawResults = extractContourData(polyDataCache2);
  return rawResults;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Contour/computeAndAddContourRepresentation.js
function computeAndAddContourRepresentation(segmentationId, options = {}) {
  return computeAndAddRepresentation(segmentationId, SegmentationRepresentations_default.Contour, () => computeContourData(segmentationId, options), () => void 0);
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/removeContourFromElement.js
function removeContourFromElement(viewportId, segmentationId, removeFromCache = false) {
  const segmentation = getSegmentation(segmentationId);
  const { annotationUIDsMap } = segmentation.representationData.Contour;
  annotationUIDsMap.forEach((annotationSet) => {
    annotationSet.forEach((annotationUID) => {
      removeAnnotation(annotationUID);
    });
  });
}
var removeContourFromElement_default = removeContourFromElement;

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js
var polySegConversionInProgress = false;
function removeRepresentation2(viewportId, segmentationId, renderImmediate = false) {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  if (!renderImmediate) {
    return;
  }
  removeContourFromElement_default(viewportId, segmentationId);
  viewport.render();
}
async function render2(viewport, contourRepresentation) {
  var _a2;
  const { segmentationId } = contourRepresentation;
  const segmentation = getSegmentation(segmentationId);
  if (!segmentation) {
    return;
  }
  let contourData = segmentation.representationData[SegmentationRepresentations_default.Contour];
  if (!contourData && canComputeRequestedRepresentation(segmentationId, SegmentationRepresentations_default.Contour) && !polySegConversionInProgress) {
    polySegConversionInProgress = true;
    contourData = await computeAndAddContourRepresentation(segmentationId, {
      viewport
    });
    polySegConversionInProgress = false;
  }
  if (!contourData) {
    return;
  }
  if (!((_a2 = contourData.geometryIds) == null ? void 0 : _a2.length)) {
    return;
  }
  handleContourSegmentation2(viewport, contourData.geometryIds, contourData.annotationUIDsMap, contourRepresentation);
}
var contourDisplay_default = {
  render: render2,
  removeRepresentation: removeRepresentation2
};

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js
function getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {
  const segmentationStateManager = defaultSegmentationStateManager;
  return segmentationStateManager.getCurrentLabelmapImageIdForViewport(viewportId, segmentationId);
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addVolumesAsIndependentComponents.js
var internalCache = /* @__PURE__ */ new Map();
var load = ({ cfun, ofun, actor }) => {
  actor.getProperty().setRGBTransferFunction(1, cfun);
  actor.getProperty().setScalarOpacity(1, ofun);
};
async function addVolumesAsIndependentComponents({ viewport, volumeInputs, segmentationId }) {
  var _a2;
  const defaultActor = viewport.getDefaultActor();
  const { actor } = defaultActor;
  const { uid, callback } = defaultActor;
  const referenceVolumeId = viewport.getVolumeId();
  if ((_a2 = internalCache.get(uid)) == null ? void 0 : _a2.added) {
    return {
      uid,
      actor
    };
  }
  const volumeInputArray = volumeInputs;
  const firstImageVolume = cache_default.getVolume(volumeInputArray[0].volumeId);
  if (!firstImageVolume) {
    throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
  }
  const { volumeId } = volumeInputArray[0];
  const segImageVolume = await volumeLoader_exports.loadVolume(volumeId);
  if (!segImageVolume) {
    throw new Error(`segImageVolume with id: ${segImageVolume.volumeId} does not exist`);
  }
  const segVoxelManager = segImageVolume.voxelManager;
  const { imageData: segImageData } = segImageVolume;
  const baseVolume = cache_default.getVolume(referenceVolumeId);
  const baseVoxelManager = baseVolume.voxelManager;
  const newComp = 2;
  const cubeData = new Float32Array(newComp * baseVolume.voxelManager.getScalarDataLength());
  const dims = segImageData.getDimensions();
  for (let z = 0; z < dims[2]; ++z) {
    for (let y = 0; y < dims[1]; ++y) {
      for (let x = 0; x < dims[0]; ++x) {
        const iTuple = x + dims[0] * (y + dims[1] * z);
        cubeData[iTuple * newComp + 0] = baseVoxelManager.getAtIndex(iTuple);
        cubeData[iTuple * newComp + 1] = segVoxelManager.getAtIndex(iTuple);
      }
    }
  }
  viewport.removeActors([uid]);
  const oldMapper = actor.getMapper();
  const mapper = convertMapperToNotSharedMapper(oldMapper);
  actor.setMapper(mapper);
  mapper.setBlendMode(enums_exports.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND);
  const arrayAgain = mapper.getInputData().getPointData().getArray(0);
  arrayAgain.setData(cubeData);
  arrayAgain.setNumberOfComponents(2);
  actor.getProperty().setColorMixPreset(1);
  actor.getProperty().setForceNearestInterpolation(1, true);
  actor.getProperty().setIndependentComponents(true);
  viewport.addActor({
    actor,
    uid,
    callback,
    referencedId: referenceVolumeId,
    representationUID: `${segmentationId}-${SegmentationRepresentations_default.Labelmap}`
  });
  internalCache.set(uid, {
    added: true,
    segmentationRepresentationUID: `${segmentationId}`,
    originalBlendMode: viewport.getBlendMode()
  });
  actor.set({
    preLoad: load
  });
  function onSegmentationDataModified2(evt) {
    const { segmentationId: segmentationId2, modifiedSlicesToUse } = evt.detail;
    const { representationData } = getSegmentation(segmentationId2);
    const { volumeId: segVolumeId } = representationData.Labelmap;
    if (segVolumeId !== segImageVolume.volumeId) {
      return;
    }
    const segmentationVolume = cache_default.getVolume(segVolumeId);
    const segVoxelManager2 = segmentationVolume.voxelManager;
    const array = mapper.getInputData().getPointData().getArray(0);
    const baseData = array.getData();
    const newComp2 = 2;
    const dims2 = segImageData.getDimensions();
    const slices = (modifiedSlicesToUse == null ? void 0 : modifiedSlicesToUse.length) ? modifiedSlicesToUse : Array.from({ length: dims2[2] }, (_, i) => i);
    for (const z of slices) {
      for (let y = 0; y < dims2[1]; ++y) {
        for (let x = 0; x < dims2[0]; ++x) {
          const iTuple = x + dims2[0] * (y + dims2[1] * z);
          baseData[iTuple * newComp2 + 1] = segVoxelManager2.getAtIndex(iTuple);
        }
      }
    }
    array.setData(baseData);
  }
  eventTarget_default.addEventListener(Events_default.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified2);
  eventTarget_default.addEventListener(Events_default.SEGMENTATION_REPRESENTATION_REMOVED, async (evt) => {
    eventTarget_default.removeEventListener(Events_default.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified2);
    const actorEntry = viewport.getActor(uid);
    const { element, id } = viewport;
    viewport.removeActors([uid]);
    const actor2 = await createVolumeActor_default({
      volumeId: uid,
      blendMode: enums_exports.BlendModes.MAXIMUM_INTENSITY_BLEND,
      callback: ({ volumeActor }) => {
        if (actorEntry.callback) {
          actorEntry.callback({
            volumeActor,
            volumeId
          });
        }
      }
    }, element, id);
    viewport.addActor({ actor: actor2, uid });
    viewport.render();
  });
  return {
    uid,
    actor
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addLabelmapToElement.js
var { uuidv4: uuidv42 } = utilities_exports;
async function addLabelmapToElement(element, labelMapData, segmentationId, config) {
  const enabledElement = getEnabledElement(element);
  const { renderingEngine, viewport } = enabledElement;
  const { id: viewportId } = viewport;
  const visibility = true;
  const immediateRender = false;
  const suppressEvents = true;
  if (viewport instanceof BaseVolumeViewport_default) {
    const volumeLabelMapData = labelMapData;
    const volumeId = _ensureVolumeHasVolumeId(volumeLabelMapData, segmentationId);
    if (!cache_default.getVolume(volumeId)) {
      await _handleMissingVolume(labelMapData);
    }
    const blendMode = (config == null ? void 0 : config.blendMode) ?? enums_exports.BlendModes.MAXIMUM_INTENSITY_BLEND;
    const useIndependentComponents = blendMode === enums_exports.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND;
    const volumeInputs = [
      {
        volumeId,
        visibility,
        representationUID: `${segmentationId}-${SegmentationRepresentations_default.Labelmap}`,
        useIndependentComponents,
        blendMode
      }
    ];
    if (!volumeInputs[0].useIndependentComponents) {
      await addVolumesToViewports_default(renderingEngine, volumeInputs, [viewportId], immediateRender, suppressEvents);
    } else {
      const result = await addVolumesAsIndependentComponents({
        viewport,
        volumeInputs,
        segmentationId
      });
      return result;
    }
  } else {
    const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);
    const stackInputs = [
      {
        imageId: segmentationImageId,
        representationUID: `${segmentationId}-${SegmentationRepresentations_default.Labelmap}`
      }
    ];
    addImageSlicesToViewports_default(renderingEngine, stackInputs, [viewportId]);
  }
  triggerSegmentationDataModified(segmentationId);
}
function _ensureVolumeHasVolumeId(labelMapData, segmentationId) {
  let { volumeId } = labelMapData;
  if (!volumeId) {
    volumeId = uuidv42();
    const segmentation = getSegmentation(segmentationId);
    segmentation.representationData.Labelmap = {
      ...segmentation.representationData.Labelmap,
      volumeId
    };
    labelMapData.volumeId = volumeId;
    triggerSegmentationModified(segmentationId);
  }
  return volumeId;
}
async function _handleMissingVolume(labelMapData) {
  const stackData = labelMapData;
  const hasImageIds = stackData.imageIds.length > 0;
  if (!hasImageIds) {
    throw new Error("cannot create labelmap, no imageIds found for the volume labelmap");
  }
  const volume = await volumeLoader_exports.createAndCacheVolumeFromImages(labelMapData.volumeId || uuidv42(), stackData.imageIds);
  return volume;
}
var addLabelmapToElement_default = addLabelmapToElement;

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/removeLabelmapFromElement.js
function removeLabelmapFromElement(element, segmentationId) {
  const enabledElement = getEnabledElement(element);
  const { viewport } = enabledElement;
  viewport.removeActors([getLabelmapActorUID(viewport.id, segmentationId)]);
}
var removeLabelmapFromElement_default = removeLabelmapFromElement;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js
var activeSegmentation_exports = {};
__export(activeSegmentation_exports, {
  getActiveSegmentation: () => getActiveSegmentation2,
  setActiveSegmentation: () => setActiveSegmentation2
});

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js
function setActiveSegmentation(viewportId, segmentationId) {
  const segmentationStateManager = defaultSegmentationStateManager;
  segmentationStateManager.setActiveSegmentation(viewportId, segmentationId);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js
function getActiveSegmentation2(viewportId) {
  return getActiveSegmentation(viewportId);
}
function setActiveSegmentation2(viewportId, segmentationId) {
  setActiveSegmentation(viewportId, segmentationId);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Labelmap/convertContourToLabelmap.js
var workerManager4 = getWebWorkerManager();
var triggerWorkerProgress4 = (eventTarget, progress) => {
  triggerEvent(eventTarget, enums_exports.Events.WEB_WORKER_PROGRESS, {
    progress,
    type: WorkerTypes_default.POLYSEG_CONTOUR_TO_LABELMAP
  });
};
async function convertContourToVolumeLabelmap(contourRepresentationData, options = {}) {
  var _a2;
  const viewport = options.viewport;
  const volumeId = viewport.getVolumeId();
  const imageIds = utilities_exports.getViewportImageIds(viewport);
  if (!imageIds) {
    throw new Error("No imageIds found, labelmap computation from contour requires viewports with imageIds");
  }
  const segmentationVolumeId = utilities_exports.uuidv4();
  const segmentationVolume = volumeLoader_exports.createAndCacheDerivedLabelmapVolume(volumeId, {
    volumeId: segmentationVolumeId
  });
  const { dimensions, origin, direction, spacing, voxelManager } = segmentationVolume;
  const { segmentIndices, annotationUIDsInSegmentMap } = _getAnnotationMapFromSegmentation(contourRepresentationData, options);
  triggerWorkerProgress4(eventTarget_default, 0);
  const newScalarData = await workerManager4.executeTask("polySeg", "convertContourToVolumeLabelmap", {
    segmentIndices,
    dimensions,
    scalarData: (_a2 = voxelManager.getCompleteScalarDataArray) == null ? void 0 : _a2.call(voxelManager),
    origin,
    direction,
    spacing,
    annotationUIDsInSegmentMap
  }, {
    callbacks: [
      (progress) => {
        triggerWorkerProgress4(eventTarget_default, progress);
      }
    ]
  });
  triggerWorkerProgress4(eventTarget_default, 100);
  voxelManager.setCompleteScalarDataArray(newScalarData);
  segmentationVolume.modified();
  return {
    volumeId: segmentationVolume.volumeId
  };
}
async function convertContourToStackLabelmap(contourRepresentationData, options = {}) {
  if (!options.viewport) {
    throw new Error("No viewport provided, labelmap computation from contour requires viewports");
  }
  const viewport = options.viewport;
  const imageIds = viewport.getImageIds();
  if (!imageIds) {
    throw new Error("No imageIds found, labelmap computation from contour requires viewports with imageIds");
  }
  imageIds.forEach((imageId) => {
    if (!cache_default.getImageLoadObject(imageId)) {
      throw new Error("ImageIds must be cached before converting contour to labelmap");
    }
  });
  const segImages = await imageLoader_exports.createAndCacheDerivedLabelmapImages(imageIds);
  const segmentationImageIds = segImages.map((it) => it.imageId);
  const { segmentIndices, annotationUIDsInSegmentMap } = _getAnnotationMapFromSegmentation(contourRepresentationData, options);
  const segmentationsInfo = /* @__PURE__ */ new Map();
  segmentationImageIds.forEach((segImageId, index) => {
    const segImage = cache_default.getImage(segImageId);
    const imagePlaneModule = metaData_exports.get(enums_exports.MetadataModules.IMAGE_PLANE, segImageId);
    let { columnCosines, rowCosines, rowPixelSpacing, columnPixelSpacing, imagePositionPatient } = imagePlaneModule;
    columnCosines = columnCosines ?? [0, 1, 0];
    rowCosines = rowCosines ?? [1, 0, 0];
    rowPixelSpacing = rowPixelSpacing ?? 1;
    columnPixelSpacing = columnPixelSpacing ?? 1;
    imagePositionPatient = imagePositionPatient ?? [0, 0, 0];
    const rowCosineVec = vec3_exports.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);
    const colCosineVec = vec3_exports.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);
    const scanAxisNormal = vec3_exports.create();
    vec3_exports.cross(scanAxisNormal, rowCosineVec, colCosineVec);
    const direction = [...rowCosineVec, ...colCosineVec, ...scanAxisNormal];
    const spacing = [rowPixelSpacing, columnPixelSpacing, 1];
    const origin = imagePositionPatient;
    segmentationsInfo.set(imageIds[index], {
      direction,
      spacing,
      origin,
      scalarData: segImage.voxelManager.getScalarData(),
      imageId: segImageId,
      dimensions: [segImage.width, segImage.height, 1]
    });
  });
  triggerWorkerProgress4(eventTarget_default, 0);
  const newSegmentationsScalarData = await workerManager4.executeTask("polySeg", "convertContourToStackLabelmap", {
    segmentationsInfo,
    annotationUIDsInSegmentMap,
    segmentIndices
  }, {
    callbacks: [
      (progress) => {
        triggerWorkerProgress4(eventTarget_default, progress);
      }
    ]
  });
  triggerWorkerProgress4(eventTarget_default, 100);
  const segImageIds = [];
  newSegmentationsScalarData.forEach(({ scalarData }, referencedImageId) => {
    var _a2, _b2;
    const segmentationInfo = segmentationsInfo.get(referencedImageId);
    const { imageId: segImageId } = segmentationInfo;
    const segImage = cache_default.getImage(segImageId);
    segImage.voxelManager.getScalarData().set(scalarData);
    (_b2 = (_a2 = segImage.imageFrame) == null ? void 0 : _a2.pixelData) == null ? void 0 : _b2.set(scalarData);
    segImageIds.push(segImageId);
  });
  return {
    imageIds: segImageIds
  };
}
function _getAnnotationMapFromSegmentation(contourRepresentationData, options = {}) {
  var _a2;
  const annotationMap = contourRepresentationData.annotationUIDsMap;
  const segmentIndices = ((_a2 = options.segmentIndices) == null ? void 0 : _a2.length) ? options.segmentIndices : Array.from(annotationMap.keys());
  const annotationUIDsInSegmentMap = /* @__PURE__ */ new Map();
  segmentIndices.forEach((index) => {
    const annotationUIDsInSegment = annotationMap.get(index);
    let uids = Array.from(annotationUIDsInSegment);
    uids = uids.filter((uid) => !getAnnotation(uid).parentAnnotationUID);
    const annotations = uids.map((uid) => {
      var _a3;
      const annotation = getAnnotation(uid);
      const hasChildAnnotations = (_a3 = annotation.childAnnotationUIDs) == null ? void 0 : _a3.length;
      return {
        polyline: annotation.data.contour.polyline,
        referencedImageId: annotation.metadata.referencedImageId,
        holesPolyline: hasChildAnnotations && annotation.childAnnotationUIDs.map((childUID) => {
          const childAnnotation = getAnnotation(childUID);
          return childAnnotation.data.contour.polyline;
        })
      };
    });
    annotationUIDsInSegmentMap.set(index, annotations);
  });
  return { segmentIndices, annotationUIDsInSegmentMap };
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Labelmap/convertSurfaceToLabelmap.js
var workerManager5 = getWebWorkerManager();
var triggerWorkerProgress5 = (eventTarget, progress) => {
  triggerEvent(eventTarget, enums_exports.Events.WEB_WORKER_PROGRESS, {
    progress,
    type: WorkerTypes_default.POLYSEG_SURFACE_TO_LABELMAP
  });
};
async function convertSurfaceToVolumeLabelmap(surfaceRepresentationData, segmentationVolume) {
  const { geometryIds } = surfaceRepresentationData;
  if (!(geometryIds == null ? void 0 : geometryIds.size)) {
    throw new Error("No geometry IDs found for surface representation");
  }
  const segmentsInfo = /* @__PURE__ */ new Map();
  geometryIds.forEach((geometryId, segmentIndex) => {
    const geometry = cache_default.getGeometry(geometryId);
    const geometryData = geometry.data;
    const points = geometryData.points;
    const polys = geometryData.polys;
    segmentsInfo.set(segmentIndex, {
      points,
      polys
    });
  });
  const { dimensions, direction, origin, spacing, voxelManager } = segmentationVolume;
  triggerWorkerProgress5(eventTarget_default, 0);
  const newScalarData = await workerManager5.executeTask("polySeg", "convertSurfacesToVolumeLabelmap", {
    segmentsInfo,
    dimensions,
    spacing,
    direction,
    origin
  }, {
    callbacks: [
      (progress) => {
        triggerWorkerProgress5(eventTarget_default, progress);
      }
    ]
  });
  triggerWorkerProgress5(eventTarget_default, 100);
  voxelManager.setCompleteScalarDataArray(newScalarData);
  segmentationVolume.modified();
  return {
    volumeId: segmentationVolume.volumeId
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddSegmentationRepresentation.js
function internalAddSegmentationRepresentation(viewportId, representationInput) {
  const { segmentationId, config } = representationInput;
  const renderingConfig = {
    colorLUTIndex: getColorLUTIndex(config),
    ...config
  };
  defaultSegmentationStateManager.addSegmentationRepresentation(viewportId, segmentationId, representationInput.type, renderingConfig);
  if (representationInput.type === SegmentationRepresentations_default.Contour) {
    triggerAnnotationRenderForViewportIds([viewportId]);
  }
  triggerSegmentationModified(segmentationId);
}
function getColorLUTIndex(config) {
  const { colorLUTOrIndex } = config || {};
  if (colorLUTOrIndex === void 0) {
    const index2 = addColorLUT(JSON.parse(JSON.stringify(COLOR_LUT_default)));
    return index2;
  }
  if (typeof colorLUTOrIndex === "number") {
    return colorLUTOrIndex;
  }
  if (Array.isArray(colorLUTOrIndex) && colorLUTOrIndex.every((item) => Array.isArray(item) && item.length === 4)) {
    const index2 = addColorLUT(colorLUTOrIndex);
    return index2;
  }
  const index = addColorLUT(JSON.parse(JSON.stringify(COLOR_LUT_default)));
  return index;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js
function addSegmentationRepresentations(viewportId, segmentationInputArray) {
  segmentationInputArray.map((segmentationInput) => {
    return internalAddSegmentationRepresentation(viewportId, segmentationInput);
  });
}
function addContourRepresentationToViewport(viewportId, contourInputArray) {
  return addSegmentationRepresentations(viewportId, contourInputArray.map((input) => ({
    ...input,
    type: SegmentationRepresentations_default.Contour
  })));
}
function addContourRepresentationToViewportMap(viewportInputMap) {
  const results = {};
  for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
    results[viewportId] = addContourRepresentationToViewport(viewportId, inputArray);
  }
  return results;
}
function addLabelmapRepresentationToViewport(viewportId, labelmapInputArray) {
  return addSegmentationRepresentations(viewportId, labelmapInputArray.map((input) => ({
    ...input,
    type: SegmentationRepresentations_default.Labelmap
  })));
}
function addLabelmapRepresentationToViewportMap(viewportInputMap) {
  const results = {};
  for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
    results[viewportId] = addLabelmapRepresentationToViewport(viewportId, inputArray.map((input) => ({
      ...input,
      type: SegmentationRepresentations_default.Labelmap
    })));
  }
}
function addSurfaceRepresentationToViewport(viewportId, surfaceInputArray) {
  return addSegmentationRepresentations(viewportId, surfaceInputArray.map((input) => ({
    ...input,
    type: SegmentationRepresentations_default.Surface
  })));
}
function addSurfaceRepresentationToViewportMap(viewportInputMap) {
  const results = {};
  for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
    results[viewportId] = addSurfaceRepresentationToViewport(viewportId, inputArray);
  }
  return results;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/updateStackSegmentationState.js
async function updateStackSegmentationState({ segmentationId, viewportId, imageIds, options }) {
  const segmentation = getSegmentation(segmentationId);
  if (options == null ? void 0 : options.removeOriginal) {
    const data = segmentation.representationData.Labelmap;
    if (cache_default.getVolume(data.volumeId)) {
      cache_default.removeVolumeLoadObject(data.volumeId);
    }
    segmentation.representationData.Labelmap = {
      imageIds
    };
  } else {
    segmentation.representationData.Labelmap = {
      ...segmentation.representationData.Labelmap,
      imageIds
    };
  }
  await addSegmentationRepresentations(viewportId, [
    {
      segmentationId,
      type: SegmentationRepresentations_default.Labelmap
    }
  ]);
  eventTarget_default.addEventListenerOnce(Events_default.SEGMENTATION_RENDERED, () => triggerSegmentationDataModified(segmentationId));
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js
async function computeStackLabelmapFromVolume({ volumeId }) {
  const segmentationVolume = cache_default.getVolume(volumeId);
  return { imageIds: segmentationVolume.imageIds };
}
function convertVolumeToStackLabelmap({ segmentationId, options }) {
  const segmentation = getSegmentation(segmentationId);
  if (!segmentation) {
    return;
  }
  const { volumeId } = segmentation.representationData.Labelmap;
  const segmentationVolume = cache_default.getVolume(volumeId);
  return updateStackSegmentationState({
    segmentationId,
    viewportId: options.viewportId,
    imageIds: segmentationVolume.imageIds,
    options
  });
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Labelmap/labelmapComputationStrategies.js
async function computeLabelmapData(segmentationId, options = {}) {
  var _a2;
  const segmentIndices = ((_a2 = options.segmentIndices) == null ? void 0 : _a2.length) ? options.segmentIndices : getUniqueSegmentIndices(segmentationId);
  let rawLabelmapData;
  const segmentation = getSegmentation(segmentationId);
  const representationData = segmentation.representationData;
  try {
    if (representationData.Contour) {
      rawLabelmapData = await computeLabelmapFromContourSegmentation(segmentationId, {
        segmentIndices,
        ...options
      });
    } else if (representationData.Surface) {
      rawLabelmapData = await computeLabelmapFromSurfaceSegmentation(segmentation.segmentationId, {
        segmentIndices,
        ...options
      });
    }
  } catch (error) {
    console.error(error);
    throw error;
  }
  if (!rawLabelmapData) {
    throw new Error("Not enough data to convert to surface, currently only support converting volume labelmap to surface if available");
  }
  return rawLabelmapData;
}
async function computeLabelmapFromContourSegmentation(segmentationId, options = {}) {
  var _a2;
  const isVolume = options.viewport ? options.viewport instanceof VolumeViewport_default : true;
  if (isVolume && !options.viewport) {
    throw new Error("Cannot compute labelmap from contour segmentation without providing the viewport");
  }
  const segmentIndices = ((_a2 = options.segmentIndices) == null ? void 0 : _a2.length) ? options.segmentIndices : getUniqueSegmentIndices(segmentationId);
  const segmentation = getSegmentation(segmentationId);
  const representationData = segmentation.representationData.Contour;
  const convertFunction = isVolume ? convertContourToVolumeLabelmap : convertContourToStackLabelmap;
  const result = await convertFunction(representationData, {
    segmentIndices,
    viewport: options.viewport
  });
  return result;
}
async function computeLabelmapFromSurfaceSegmentation(segmentationId, options = {}) {
  var _a2;
  const { viewport } = options;
  const isVolume = viewport ? viewport instanceof VolumeViewport_default : true;
  const segmentIndices = ((_a2 = options.segmentIndices) == null ? void 0 : _a2.length) ? options.segmentIndices : getUniqueSegmentIndices(segmentationId);
  const segmentation = getSegmentation(segmentationId);
  const segmentsGeometryIds = /* @__PURE__ */ new Map();
  const representationData = segmentation.representationData.Surface;
  representationData.geometryIds.forEach((geometryId, segmentIndex) => {
    if (segmentIndices.includes(segmentIndex)) {
      segmentsGeometryIds.set(segmentIndex, geometryId);
    }
  });
  if (isVolume && !viewport) {
    throw new Error("Cannot compute labelmap from surface segmentation without providing the viewport");
  }
  let segmentationVolume;
  if (isVolume) {
    const volumeId = viewport.getVolumeId();
    segmentationVolume = volumeLoader_exports.createAndCacheDerivedLabelmapVolume(volumeId);
  } else {
    const imageIds = options.viewport.getImageIds();
    const segImages = imageLoader_exports.createAndCacheDerivedLabelmapImages(imageIds);
    const segImageIds = segImages.map((image) => image.imageId);
    segmentationVolume = await volumeLoader_exports.createAndCacheVolumeFromImages("generatedSegmentationVolumeId", segImageIds);
  }
  const result = await convertSurfaceToVolumeLabelmap({ geometryIds: segmentsGeometryIds }, segmentationVolume);
  if (isVolume) {
    return result;
  }
  const stackData = await computeStackLabelmapFromVolume({
    volumeId: segmentationVolume.volumeId
  });
  return stackData;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Labelmap/computeAndAddLabelmapRepresentation.js
async function computeAndAddLabelmapRepresentation(segmentationId, options = {}) {
  return computeAndAddRepresentation(segmentationId, SegmentationRepresentations_default.Labelmap, () => computeLabelmapData(segmentationId, options), () => null, () => {
    defaultSegmentationStateManager.processLabelmapRepresentationAddition(options.viewport.id, segmentationId);
    setTimeout(() => {
      triggerSegmentationDataModified(segmentationId);
    }, 0);
  });
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js
var MAX_NUMBER_COLORS = 255;
var labelMapConfigCache = /* @__PURE__ */ new Map();
var polySegConversionInProgress2 = false;
function removeRepresentation3(viewportId, segmentationId, renderImmediate = false) {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  labelMapConfigCache.forEach((value, key) => {
    if (key.includes(segmentationId)) {
      labelMapConfigCache.delete(key);
    }
  });
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  removeLabelmapFromElement_default(viewport.element, segmentationId);
  if (!renderImmediate) {
    return;
  }
  viewport.render();
}
async function render3(viewport, representation) {
  const { segmentationId, config } = representation;
  const segmentation = getSegmentation(segmentationId);
  if (!segmentation) {
    console.warn("No segmentation found for segmentationId: ", segmentationId);
    return;
  }
  let labelmapData = segmentation.representationData[SegmentationRepresentations_default.Labelmap];
  let labelmapActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);
  if (!labelmapData && canComputeRequestedRepresentation(segmentationId, SegmentationRepresentations_default.Labelmap) && !polySegConversionInProgress2) {
    polySegConversionInProgress2 = true;
    labelmapData = await computeAndAddLabelmapRepresentation(segmentationId, {
      viewport
    });
    if (!labelmapData) {
      throw new Error(`No labelmap data found for segmentationId ${segmentationId}.`);
    }
    polySegConversionInProgress2 = false;
  }
  if (!labelmapData) {
    return;
  }
  if (viewport instanceof VolumeViewport_default) {
    if (!labelmapActorEntry) {
      await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);
    }
    labelmapActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);
  } else {
    const labelmapImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);
    if (!labelmapImageId) {
      return;
    }
    if (!labelmapActorEntry) {
      await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);
    }
    labelmapActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);
  }
  if (!labelmapActorEntry) {
    return;
  }
  _setLabelmapColorAndOpacity(viewport.id, labelmapActorEntry, representation);
}
function _setLabelmapColorAndOpacity(viewportId, labelmapActorEntry, segmentationRepresentation) {
  var _a2;
  const { segmentationId } = segmentationRepresentation;
  const { cfun, ofun } = segmentationRepresentation.config;
  const { colorLUTIndex } = segmentationRepresentation;
  const activeSegmentation = getActiveSegmentation2(viewportId);
  const isActiveLabelmap = (activeSegmentation == null ? void 0 : activeSegmentation.segmentationId) === segmentationId;
  const labelmapStyle = segmentationStyle.getStyle({
    viewportId,
    type: SegmentationRepresentations_default.Labelmap,
    segmentationId
  });
  const renderInactiveSegmentations = segmentationStyle.getRenderInactiveSegmentations(viewportId);
  const colorLUT = getColorLUT(colorLUTIndex);
  const numColors = Math.min(256, colorLUT.length);
  const { outlineWidth, renderOutline, outlineOpacity, activeSegmentOutlineWidthDelta } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap);
  const segmentsHidden = internalGetHiddenSegmentIndices(viewportId, {
    segmentationId,
    type: SegmentationRepresentations_default.Labelmap
  });
  for (let i = 0; i < numColors; i++) {
    const segmentIndex = i;
    const segmentColor = colorLUT[segmentIndex];
    const perSegmentStyle = segmentationStyle.getStyle({
      viewportId,
      type: SegmentationRepresentations_default.Labelmap,
      segmentationId,
      segmentIndex
    });
    const segmentSpecificLabelmapConfig = perSegmentStyle;
    const { fillAlpha, outlineWidth: outlineWidth2, renderFill, renderOutline: renderOutline2 } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap, segmentSpecificLabelmapConfig);
    const { forceOpacityUpdate, forceColorUpdate } = _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, {
      fillAlpha,
      renderFill,
      renderOutline: renderOutline2,
      segmentColor,
      outlineWidth: outlineWidth2,
      segmentsHidden,
      cfun,
      ofun
    });
    if (forceColorUpdate) {
      cfun.addRGBPoint(segmentIndex, segmentColor[0] / MAX_NUMBER_COLORS, segmentColor[1] / MAX_NUMBER_COLORS, segmentColor[2] / MAX_NUMBER_COLORS);
    }
    if (forceOpacityUpdate) {
      if (renderFill) {
        const segmentOpacity = segmentsHidden.has(segmentIndex) ? 0 : segmentColor[3] / 255 * fillAlpha;
        ofun.removePoint(segmentIndex);
        ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1);
      } else {
        ofun.addPointLong(segmentIndex, 0.01, 0.5, 1);
      }
    }
  }
  ofun.setClamping(false);
  const labelmapActor = labelmapActorEntry.actor;
  const { preLoad } = ((_a2 = labelmapActor.get) == null ? void 0 : _a2.call(labelmapActor, "preLoad")) || { preLoad: null };
  if (preLoad) {
    preLoad({ cfun, ofun, actor: labelmapActor });
  } else {
    labelmapActor.getProperty().setRGBTransferFunction(0, cfun);
    labelmapActor.getProperty().setScalarOpacity(0, ofun);
    labelmapActor.getProperty().setInterpolationTypeToNearest();
  }
  if (renderOutline) {
    labelmapActor.getProperty().setUseLabelOutline(renderOutline);
    labelmapActor.getProperty().setLabelOutlineOpacity(outlineOpacity);
    const activeSegmentIndex = getActiveSegmentIndex(segmentationRepresentation.segmentationId);
    const outlineWidths = new Array(numColors - 1);
    for (let i = 1; i < numColors; i++) {
      const isHidden = segmentsHidden.has(i);
      if (isHidden) {
        outlineWidths[i - 1] = 0;
        continue;
      }
      outlineWidths[i - 1] = i === activeSegmentIndex ? outlineWidth + activeSegmentOutlineWidthDelta : outlineWidth;
    }
    labelmapActor.getProperty().setLabelOutlineThickness(outlineWidths);
  } else {
    labelmapActor.getProperty().setLabelOutlineThickness(new Array(numColors - 1).fill(0));
  }
  const visible = isActiveLabelmap || renderInactiveSegmentations;
  labelmapActor.setVisibility(visible);
}
function _getLabelmapConfig(labelmapConfig, isActiveLabelmap, segmentsLabelmapConfig) {
  const segmentLabelmapConfig = segmentsLabelmapConfig || {};
  const configToUse = {
    ...labelmapConfig,
    ...segmentLabelmapConfig
  };
  const fillAlpha = isActiveLabelmap ? configToUse.fillAlpha : configToUse.fillAlphaInactive;
  const outlineWidth = isActiveLabelmap ? configToUse.outlineWidth : configToUse.outlineWidthInactive;
  const renderFill = isActiveLabelmap ? configToUse.renderFill : configToUse.renderFillInactive;
  const renderOutline = isActiveLabelmap ? configToUse.renderOutline : configToUse.renderOutlineInactive;
  const outlineOpacity = isActiveLabelmap ? configToUse.outlineOpacity : configToUse.outlineOpacityInactive;
  const activeSegmentOutlineWidthDelta = configToUse.activeSegmentOutlineWidthDelta;
  return {
    fillAlpha,
    outlineWidth,
    renderFill,
    renderOutline,
    outlineOpacity,
    activeSegmentOutlineWidthDelta
  };
}
function _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, { fillAlpha, renderFill, renderOutline, segmentColor, outlineWidth, segmentsHidden, cfun, ofun }) {
  const cacheUID = `${viewportId}-${segmentationId}-${segmentIndex}`;
  const oldConfig = labelMapConfigCache.get(cacheUID);
  if (!oldConfig) {
    labelMapConfigCache.set(cacheUID, {
      fillAlpha,
      renderFill,
      renderOutline,
      outlineWidth,
      segmentColor: segmentColor.slice(),
      segmentsHidden: new Set(segmentsHidden),
      cfunMTime: cfun.getMTime(),
      ofunMTime: ofun.getMTime()
    });
    return {
      forceOpacityUpdate: true,
      forceColorUpdate: true
    };
  }
  const { fillAlpha: oldFillAlpha, renderFill: oldRenderFill, renderOutline: oldRenderOutline, outlineWidth: oldOutlineWidth, segmentColor: oldSegmentColor, segmentsHidden: oldSegmentsHidden, cfunMTime: oldCfunMTime, ofunMTime: oldOfunMTime } = oldConfig;
  const forceColorUpdate = oldSegmentColor[0] !== segmentColor[0] || oldSegmentColor[1] !== segmentColor[1] || oldSegmentColor[2] !== segmentColor[2];
  const forceOpacityUpdate = oldSegmentColor[3] !== segmentColor[3] || oldFillAlpha !== fillAlpha || oldRenderFill !== renderFill || oldRenderOutline !== renderOutline || oldOutlineWidth !== outlineWidth || oldSegmentsHidden !== segmentsHidden;
  if (forceOpacityUpdate || forceColorUpdate) {
    labelMapConfigCache.set(cacheUID, {
      fillAlpha,
      renderFill,
      renderOutline,
      outlineWidth,
      segmentColor: segmentColor.slice(),
      segmentsHidden: new Set(segmentsHidden),
      cfunMTime: cfun.getMTime(),
      ofunMTime: ofun.getMTime()
    });
  }
  return {
    forceOpacityUpdate,
    forceColorUpdate
  };
}
async function _addLabelmapToViewport(viewport, labelmapData, segmentationId, config) {
  const result = await addLabelmapToElement_default(viewport.element, labelmapData, segmentationId, config);
  return result || void 0;
}
var labelmapDisplay_default = {
  render: render3,
  removeRepresentation: removeRepresentation3
};

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js
var renderers = {
  [SegmentationRepresentations_default.Labelmap]: labelmapDisplay_default,
  [SegmentationRepresentations_default.Contour]: contourDisplay_default,
  [SegmentationRepresentations_default.Surface]: surfaceDisplay_default
};
var planarContourToolName = PlanarFreehandContourSegmentationTool_default.toolName;
var SegmentationRenderingEngine = class {
  constructor() {
    this._needsRender = /* @__PURE__ */ new Set();
    this._animationFrameSet = false;
    this._animationFrameHandle = null;
    this._getAllViewports = () => {
      const renderingEngine = getRenderingEngines();
      return renderingEngine.flatMap((renderingEngine2) => renderingEngine2.getViewports());
    };
    this._renderFlaggedSegmentations = () => {
      this._throwIfDestroyed();
      const viewportIds = Array.from(this._needsRender);
      viewportIds.forEach((viewportId) => {
        this._triggerRender(viewportId);
      });
      this._needsRender.clear();
      this._animationFrameSet = false;
      this._animationFrameHandle = null;
    };
  }
  renderSegmentationsForViewport(viewportId) {
    const viewportIds = viewportId ? [viewportId] : this._getViewportIdsForSegmentation();
    this._setViewportsToBeRenderedNextFrame(viewportIds);
  }
  renderSegmentation(segmentationId) {
    const viewportIds = this._getViewportIdsForSegmentation(segmentationId);
    this._setViewportsToBeRenderedNextFrame(viewportIds);
  }
  _getViewportIdsForSegmentation(segmentationId) {
    const viewports = this._getAllViewports();
    const viewportIds = [];
    for (const viewport of viewports) {
      const viewportId = viewport.id;
      if (segmentationId) {
        const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });
        if ((segmentationRepresentations == null ? void 0 : segmentationRepresentations.length) > 0) {
          viewportIds.push(viewportId);
        }
      } else {
        const segmentationRepresentations = getSegmentationRepresentations(viewportId);
        if ((segmentationRepresentations == null ? void 0 : segmentationRepresentations.length) > 0) {
          viewportIds.push(viewportId);
        }
      }
    }
    return viewportIds;
  }
  _throwIfDestroyed() {
    if (this.hasBeenDestroyed) {
      throw new Error("this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.");
    }
  }
  _setViewportsToBeRenderedNextFrame(viewportIds) {
    viewportIds.forEach((viewportId) => {
      this._needsRender.add(viewportId);
    });
    this._render();
  }
  _render() {
    if (this._needsRender.size > 0 && this._animationFrameSet === false) {
      this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);
      this._animationFrameSet = true;
    }
  }
  _triggerRender(viewportId) {
    const segmentationRepresentations = getSegmentationRepresentations(viewportId);
    if (!(segmentationRepresentations == null ? void 0 : segmentationRepresentations.length)) {
      return;
    }
    const { viewport } = getEnabledElementByViewportId(viewportId) || {};
    if (!viewport) {
      return;
    }
    const viewportRenderList = [];
    const segmentationRenderList = segmentationRepresentations.map((representation) => {
      if (representation.type === SegmentationRepresentations_default.Contour) {
        this._addPlanarFreeHandToolIfAbsent(viewport);
      }
      const display = renderers[representation.type];
      try {
        const viewportId2 = display.render(viewport, representation);
        viewportRenderList.push(viewportId2);
      } catch (error) {
        console.error(error);
      }
      return Promise.resolve({
        segmentationId: representation.segmentationId,
        type: representation.type
      });
    });
    Promise.allSettled(segmentationRenderList).then((results) => {
      const segmentationDetails = results.filter((r) => r.status === "fulfilled").map((r) => r.value);
      function onSegmentationRender(evt) {
        const { element: element2, viewportId: viewportId2 } = evt.detail;
        element2.removeEventListener(enums_exports.Events.IMAGE_RENDERED, onSegmentationRender);
        segmentationDetails.forEach((detail) => {
          const eventDetail = {
            viewportId: viewportId2,
            segmentationId: detail.segmentationId,
            type: detail.type
          };
          triggerEvent(eventTarget_default, Events_default.SEGMENTATION_RENDERED, {
            ...eventDetail
          });
        });
      }
      const element = viewport.element;
      element.addEventListener(enums_exports.Events.IMAGE_RENDERED, onSegmentationRender);
      viewport.render();
    });
  }
  _addPlanarFreeHandToolIfAbsent(viewport) {
    if (!(planarContourToolName in state.tools)) {
      addTool(PlanarFreehandContourSegmentationTool_default);
    }
    const toolGroup = getToolGroupForViewport_default(viewport.id);
    if (!toolGroup.hasTool(planarContourToolName)) {
      toolGroup.addTool(planarContourToolName);
      toolGroup.setToolPassive(planarContourToolName);
    }
  }
};
function triggerSegmentationRender(viewportId) {
  segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);
}
function triggerSegmentationRenderBySegmentationId(segmentationId) {
  segmentationRenderingEngine.renderSegmentation(segmentationId);
}
var segmentationRenderingEngine = new SegmentationRenderingEngine();

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js
var segmentationState_exports = {};
__export(segmentationState_exports, {
  addColorLUT: () => addColorLUT,
  addSegmentations: () => addSegmentations,
  destroy: () => destroy2,
  getColorLUT: () => getColorLUT,
  getCurrentLabelmapImageIdForViewport: () => getCurrentLabelmapImageIdForViewport,
  getNextColorLUTIndex: () => getNextColorLUTIndex,
  getSegmentation: () => getSegmentation,
  getSegmentationRepresentation: () => getSegmentationRepresentation,
  getSegmentationRepresentations: () => getSegmentationRepresentations,
  getSegmentationRepresentationsBySegmentationId: () => getSegmentationRepresentationsBySegmentationId,
  getSegmentations: () => getSegmentations,
  getStackSegmentationImageIdsForViewport: () => getStackSegmentationImageIdsForViewport,
  getViewportIdsWithSegmentation: () => getViewportIdsWithSegmentation,
  getViewportSegmentations: () => getViewportSegmentations,
  removeAllSegmentationRepresentations: () => removeAllSegmentationRepresentations,
  removeAllSegmentations: () => removeAllSegmentations,
  removeColorLUT: () => removeColorLUT,
  removeContourRepresentation: () => removeContourRepresentation,
  removeLabelmapRepresentation: () => removeLabelmapRepresentation,
  removeSegmentation: () => removeSegmentation,
  removeSegmentationRepresentation: () => removeSegmentationRepresentation,
  removeSurfaceRepresentation: () => removeSurfaceRepresentation,
  updateLabelmapSegmentationImageReferences: () => updateLabelmapSegmentationImageReferences
});

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js
function getSegmentations() {
  const segmentationStateManager = defaultSegmentationStateManager;
  const state8 = segmentationStateManager.getState();
  return state8.segmentations;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js
function normalizeSegmentationInput(segmentationInput) {
  const { segmentationId, representation, config } = segmentationInput;
  const { type, data: inputData } = representation;
  const data = inputData ? { ...inputData } : {};
  if (!data) {
    throw new Error("Segmentation representation data may not be undefined");
  }
  if (type === SegmentationRepresentations_default.Contour) {
    normalizeContourData(data);
  }
  const normalizedSegments = normalizeSegments(config == null ? void 0 : config.segments, type, data);
  config == null ? true : delete config.segments;
  return {
    segmentationId,
    label: (config == null ? void 0 : config.label) ?? null,
    cachedStats: (config == null ? void 0 : config.cachedStats) ?? {},
    segments: normalizedSegments,
    representationData: {
      [type]: {
        ...data
      }
    }
  };
}
function normalizeContourData(contourData) {
  contourData.geometryIds = contourData.geometryIds ?? [];
  contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? /* @__PURE__ */ new Map();
}
function normalizeSegments(segmentsConfig, type, data) {
  const normalizedSegments = {};
  if (segmentsConfig) {
    Object.entries(segmentsConfig).forEach(([segmentIndex, segment]) => {
      normalizedSegments[segmentIndex] = {
        segmentIndex: Number(segmentIndex),
        label: segment.label ?? `Segment ${segmentIndex}`,
        locked: segment.locked ?? false,
        cachedStats: segment.cachedStats ?? {},
        active: segment.active ?? false
      };
    });
  } else if (type === SegmentationRepresentations_default.Surface) {
    normalizeSurfaceSegments(normalizedSegments, data);
  } else {
    normalizedSegments[1] = createDefaultSegment();
  }
  return normalizedSegments;
}
function normalizeSurfaceSegments(normalizedSegments, surfaceData) {
  const { geometryIds } = surfaceData;
  geometryIds.forEach((geometryId) => {
    const geometry = cache_default.getGeometry(geometryId);
    if (geometry == null ? void 0 : geometry.data) {
      const { segmentIndex } = geometry.data;
      normalizedSegments[segmentIndex] = { segmentIndex };
    }
  });
}
function createDefaultSegment() {
  return {
    segmentIndex: 1,
    label: "Segment 1",
    locked: false,
    cachedStats: {},
    active: true
  };
}
var normalizeSegmentationInput_default = normalizeSegmentationInput;

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js
function addSegmentations(segmentationInputArray, suppressEvents) {
  const segmentationStateManager = defaultSegmentationStateManager;
  segmentationInputArray.forEach((segmentationInput) => {
    const segmentation = normalizeSegmentationInput_default(segmentationInput);
    segmentationStateManager.addSegmentation(segmentation);
    if (!suppressEvents) {
      triggerSegmentationModified(segmentation.segmentationId);
    }
  });
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js
function removeSegmentationRepresentation(viewportId, specifier, immediate) {
  return _removeSegmentationRepresentations(viewportId, specifier, immediate);
}
function removeSegmentationRepresentations(viewportId, specifier, immediate) {
  return _removeSegmentationRepresentations(viewportId, specifier, immediate);
}
function _removeSegmentationRepresentations(viewportId, specifier, immediate) {
  const { segmentationId, type } = specifier;
  _removeRepresentationObject(viewportId, segmentationId, type, immediate);
  return defaultSegmentationStateManager.removeSegmentationRepresentations(viewportId, {
    segmentationId,
    type
  });
}
function removeAllSegmentationRepresentations() {
  const state8 = defaultSegmentationStateManager.getAllViewportSegmentationRepresentations();
  state8.forEach(({ viewportId, representations }) => {
    representations.forEach(({ segmentationId, type }) => {
      removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type
      });
    });
  });
  defaultSegmentationStateManager.resetState();
}
function removeLabelmapRepresentation(viewportId, segmentationId, immediate) {
  removeSegmentationRepresentation(viewportId, {
    segmentationId,
    type: SegmentationRepresentations_default.Labelmap
  }, immediate);
}
function removeContourRepresentation(viewportId, segmentationId, immediate) {
  removeSegmentationRepresentation(viewportId, {
    segmentationId,
    type: SegmentationRepresentations_default.Contour
  }, immediate);
}
function removeSurfaceRepresentation(viewportId, segmentationId, immediate) {
  removeSegmentationRepresentation(viewportId, {
    segmentationId,
    type: SegmentationRepresentations_default.Surface
  }, immediate);
}
function _removeRepresentationObject(viewportId, segmentationId, type, immediate) {
  const representations = getSegmentationRepresentations(viewportId, {
    segmentationId,
    type
  });
  representations.forEach((representation) => {
    if (representation.type === SegmentationRepresentations_default.Labelmap) {
      labelmapDisplay_default.removeRepresentation(viewportId, representation.segmentationId, immediate);
    } else if (representation.type === SegmentationRepresentations_default.Contour) {
      contourDisplay_default.removeRepresentation(viewportId, representation.segmentationId, immediate);
    } else if (representation.type === SegmentationRepresentations_default.Surface) {
      surfaceDisplay_default.removeRepresentation(viewportId, representation.segmentationId, immediate);
    }
  });
  const { viewport } = getEnabledElementByViewportId(viewportId) || {};
  if (viewport) {
    viewport.render();
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js
function removeSegmentation(segmentationId) {
  const segmentationStateManager = defaultSegmentationStateManager;
  const viewportsWithSegmentation = segmentationStateManager.getAllViewportSegmentationRepresentations().filter(({ representations }) => representations.some((rep) => rep.segmentationId === segmentationId)).map(({ viewportId }) => viewportId);
  viewportsWithSegmentation.forEach((viewportId) => {
    removeSegmentationRepresentations(viewportId, { segmentationId });
  });
  segmentationStateManager.removeSegmentation(segmentationId);
  triggerSegmentationRemoved(segmentationId);
}
function removeAllSegmentations() {
  const segmentationStateManager = defaultSegmentationStateManager;
  const segmentations = segmentationStateManager.getState().segmentations;
  segmentations.forEach((segmentation) => {
    removeSegmentation(segmentation.segmentationId);
  });
  segmentationStateManager.resetState();
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js
function removeColorLUT(colorLUTIndex) {
  const segmentationStateManager = defaultSegmentationStateManager;
  segmentationStateManager.removeColorLUT(colorLUTIndex);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js
function getViewportSegmentations(viewportId, type) {
  const segmentationStateManager = defaultSegmentationStateManager;
  const state8 = segmentationStateManager.getState();
  const viewportRepresentations = state8.viewportSegRepresentations[viewportId];
  const segmentations = viewportRepresentations.map((representation) => {
    if (type && representation.type === type) {
      return getSegmentation(representation.segmentationId);
    }
    return getSegmentation(representation.segmentationId);
  });
  const filteredSegmentations = segmentations.filter((segmentation) => segmentation !== void 0);
  return filteredSegmentations;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js
function updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {
  const segmentationStateManager = defaultSegmentationStateManager;
  return segmentationStateManager.updateLabelmapSegmentationImageReferences(viewportId, segmentationId);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js
function getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {
  const segmentationStateManager = defaultSegmentationStateManager;
  return segmentationStateManager.getStackSegmentationImageIdsForViewport(viewportId, segmentationId);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js
function destroy2() {
  defaultSegmentationStateManager.resetState();
}

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.js
var onLabelmapSegmentationDataModified = function(evt) {
  const { segmentationId, modifiedSlicesToUse } = evt.detail;
  const { representationData } = getSegmentation(segmentationId);
  const viewportIds = getViewportIdsWithSegmentation(segmentationId);
  const hasVolumeViewport = viewportIds.some((viewportId) => {
    const { viewport } = getEnabledElementByViewportId(viewportId);
    return viewport instanceof VolumeViewport_default;
  });
  const hasStackViewport = viewportIds.some((viewportId) => {
    const { viewport } = getEnabledElementByViewportId(viewportId);
    return viewport instanceof StackViewport_default;
  });
  const hasBothStackAndVolume = hasVolumeViewport && hasStackViewport;
  viewportIds.forEach((viewportId) => {
    const { viewport } = getEnabledElementByViewportId(viewportId);
    if (viewport instanceof VolumeViewport_default) {
      performVolumeLabelmapUpdate({
        modifiedSlicesToUse: hasBothStackAndVolume ? [] : modifiedSlicesToUse,
        representationData,
        type: SegmentationRepresentations_default.Labelmap
      });
    }
    if (viewport instanceof StackViewport_default) {
      performStackLabelmapUpdate({
        viewportIds,
        segmentationId
      });
    }
  });
};
function performVolumeLabelmapUpdate({ modifiedSlicesToUse, representationData, type }) {
  const segmentationVolume = cache_default.getVolume(representationData[type].volumeId);
  if (!segmentationVolume) {
    console.warn("segmentation not found in cache");
    return;
  }
  const { imageData, vtkOpenGLTexture } = segmentationVolume;
  let slicesToUpdate;
  if ((modifiedSlicesToUse == null ? void 0 : modifiedSlicesToUse.length) > 0) {
    slicesToUpdate = modifiedSlicesToUse;
  } else {
    const numSlices = imageData.getDimensions()[2];
    slicesToUpdate = [...Array(numSlices).keys()];
  }
  slicesToUpdate.forEach((i) => {
    vtkOpenGLTexture.setUpdatedFrame(i);
  });
  imageData.modified();
}
function performStackLabelmapUpdate({ viewportIds, segmentationId }) {
  viewportIds.forEach((viewportId) => {
    let representations = getSegmentationRepresentations(viewportId, { segmentationId });
    representations = representations.filter((representation) => representation.type === SegmentationRepresentations_default.Labelmap);
    representations.forEach((representation) => {
      if (representation.segmentationId !== segmentationId) {
        return;
      }
      const enabledElement = getEnabledElementByViewportId(viewportId);
      if (!enabledElement) {
        return;
      }
      const { viewport } = enabledElement;
      if (viewport instanceof VolumeViewport_default) {
        return;
      }
      const actorEntry = getLabelmapActorEntry(viewportId, segmentationId);
      if (!actorEntry) {
        return;
      }
      const segImageData = actorEntry.actor.getMapper().getInputData();
      const currentSegmentationImageId = getCurrentLabelmapImageIdForViewport(viewportId, segmentationId);
      const segmentationImage = cache_default.getImage(currentSegmentationImageId);
      segImageData.modified();
      utilities_exports.updateVTKImageDataWithCornerstoneImage(segImageData, segmentationImage);
    });
  });
}
var onLabelmapSegmentationDataModified_default = onLabelmapSegmentationDataModified;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationDataModifiedEventListener.js
var onSegmentationDataModified = function(evt) {
  const { segmentationId } = evt.detail;
  const { representationData } = getSegmentation(segmentationId);
  if (representationData.Labelmap) {
    onLabelmapSegmentationDataModified_default(evt);
  }
  triggerSegmentationRenderBySegmentationId(segmentationId);
};
var segmentationDataModifiedEventListener_default = onSegmentationDataModified;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationModifiedEventListener.js
var segmentationModifiedListener = function(evt) {
  const { segmentationId } = evt.detail;
  triggerSegmentationRenderBySegmentationId(segmentationId);
};
var segmentationModifiedEventListener_default = segmentationModifiedListener;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js
var enable6 = function(element) {
  if (!element) {
    return;
  }
  const enabledElement = getEnabledElement(element);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  if (viewport instanceof BaseVolumeViewport_default) {
    return;
  }
  element.addEventListener(enums_exports.Events.STACK_NEW_IMAGE, _imageChangeEventListener);
  element.addEventListener(enums_exports.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
var disable6 = function(element) {
  element.removeEventListener(enums_exports.Events.STACK_NEW_IMAGE, _imageChangeEventListener);
  element.removeEventListener(enums_exports.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
function _imageChangeEventListener(evt) {
  const eventData = evt.detail;
  const { viewportId, renderingEngineId } = eventData;
  const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);
  const representations = getSegmentationRepresentations(viewportId);
  if (!(representations == null ? void 0 : representations.length)) {
    return;
  }
  const labelmapRepresentations = representations.filter((representation) => representation.type === SegmentationRepresentations_default.Labelmap);
  const actors = viewport.getActors();
  labelmapRepresentations.forEach((representation) => {
    const { segmentationId } = representation;
    updateLabelmapSegmentationImageReferences(viewportId, segmentationId);
  });
  const labelmapActors = labelmapRepresentations.map((representation) => {
    return getLabelmapActorEntry(viewportId, representation.segmentationId);
  }).filter((actor) => actor !== void 0);
  if (!labelmapActors.length) {
    return;
  }
  labelmapActors.forEach((actor) => {
    const validActor = labelmapRepresentations.find((representation) => {
      const derivedImageId = getCurrentLabelmapImageIdForViewport(viewportId, representation.segmentationId);
      return derivedImageId === actor.referencedId;
    });
    if (!validActor) {
      viewport.removeActors([actor.uid]);
    }
  });
  labelmapRepresentations.forEach((representation) => {
    const { segmentationId } = representation;
    const currentImageId = viewport.getCurrentImageId();
    const derivedImageId = getCurrentLabelmapImageIdForViewport(viewportId, segmentationId);
    if (!derivedImageId) {
      return;
    }
    const derivedImage = cache_default.getImage(derivedImageId);
    if (!derivedImage) {
      console.warn("No derived image found in the cache for segmentation representation", representation);
      return;
    }
    const segmentationActorInput = actors.find((actor) => actor.referencedId === derivedImageId);
    if (!segmentationActorInput) {
      const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);
      const currentImage = cache_default.getImage(currentImageId) || {
        imageId: currentImageId
      };
      const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);
      const originToUse = currentOrigin;
      const constructor = derivedImage.voxelManager.getConstructor();
      const newPixelData = derivedImage.voxelManager.getScalarData();
      const scalarArray = vtkDataArray$1.newInstance({
        name: "Pixels",
        numberOfComponents: 1,
        values: new constructor(newPixelData)
      });
      const imageData = vtkImageData$1.newInstance();
      imageData.setDimensions(dimensions[0], dimensions[1], 1);
      imageData.setSpacing(spacing);
      imageData.setDirection(direction);
      imageData.setOrigin(originToUse);
      imageData.getPointData().setScalars(scalarArray);
      imageData.modified();
      viewport.addImages([
        {
          imageId: derivedImageId,
          representationUID: `${segmentationId}-${SegmentationRepresentations_default.Labelmap}`,
          callback: ({ imageActor }) => {
            imageActor.getMapper().setInputData(imageData);
          }
        }
      ]);
      triggerSegmentationRender(viewportId);
      return;
    } else {
      const segmentationImageData = segmentationActorInput.actor.getMapper().getInputData();
      if (segmentationImageData.setDerivedImage) {
        segmentationImageData.setDerivedImage(derivedImage);
      } else {
        utilities_exports.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);
      }
    }
    viewport.render();
    if (evt.type === enums_exports.Events.IMAGE_RENDERED) {
      viewport.element.removeEventListener(enums_exports.Events.IMAGE_RENDERED, _imageChangeEventListener);
    }
  });
}
var imageChangeEventListener_default = {
  enable: enable6,
  disable: disable6
};

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.js
function contourSegmentationRemovedListener(evt) {
  const annotation = evt.detail.annotation;
  removeContourSegmentationAnnotation(annotation);
}

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationCompletedListener.js
function annotationCompletedListener(evt) {
  const annotation = evt.detail.annotation;
  if (isContourSegmentationAnnotation(annotation)) {
    contourSegmentationCompletedListener(evt);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationSelectionListener.js
function annotationSelectionListener(evt) {
  const deselectedAnnotation = evt.detail.removed;
  if (!deselectedAnnotation.length) {
    return;
  }
  const renderingEngines = getRenderingEngines();
  renderingEngines.forEach((renderingEngine) => {
    const viewports = renderingEngine.getViewports();
    const viewportIds = viewports.map((vp) => vp.id);
    triggerAnnotationRenderForViewportIds(viewportIds);
  });
}
var annotationSelectionListener_default = annotationSelectionListener;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationModifiedListener.js
function annotationModifiedListener(evt) {
  const { viewportId } = evt.detail;
  triggerAnnotationRenderForViewportIds_default([viewportId]);
}
var annotationModifiedListener_default = annotationModifiedListener;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationRemovedListener.js
function annotationRemovedListener(evt) {
  const annotation = evt.detail.annotation;
  if (isContourSegmentationAnnotation(annotation)) {
    contourSegmentationRemovedListener(evt);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageRenderedEventDispatcher.js
var onImageRendered = function(evt) {
  triggerAnnotationRender_default(evt.detail.element);
};
var enable7 = function(element) {
  element.addEventListener(enums_exports.Events.IMAGE_RENDERED, onImageRendered);
};
var disable7 = function(element) {
  element.removeEventListener(enums_exports.Events.IMAGE_RENDERED, onImageRendered);
};
var imageRenderedEventDispatcher_default = {
  enable: enable7,
  disable: disable7
};

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/customCallbackHandler.js
var { Active: Active4 } = ToolModes_default;
function customCallbackHandler(handlerType, customFunction, evt) {
  if (state.isInteractingWithTool) {
    return false;
  }
  const { renderingEngineId, viewportId } = evt.detail;
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  if (!toolGroup) {
    return false;
  }
  let activeTool;
  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
  for (let j = 0; j < toolGroupToolNames.length; j++) {
    const toolName = toolGroupToolNames[j];
    const tool = toolGroup.toolOptions[toolName];
    const toolInstance = toolGroup.getToolInstance(toolName);
    if (tool.mode === Active4 && typeof toolInstance[customFunction] === "function") {
      activeTool = toolGroup.getToolInstance(toolName);
      break;
    }
  }
  if (!activeTool) {
    return;
  }
  activeTool[customFunction](evt);
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseClick.js
var mouseClick = customCallbackHandler.bind(null, "Mouse", "mouseClickCallback");
var mouseClick_default = mouseClick;

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDoubleClick.js
var mouseDoubleClick = customCallbackHandler.bind(null, "Mouse", "doubleClickCallback");
var mouseDoubleClick_default = mouseDoubleClick;

// node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithMoveableHandles.js
function filterToolsWithMoveableHandles(element, ToolAndAnnotations, canvasCoords, interactionType = "mouse") {
  const proximity = interactionType === "touch" ? 36 : 6;
  const toolsWithMoveableHandles = [];
  ToolAndAnnotations.forEach(({ tool, annotations }) => {
    for (const annotation of annotations) {
      if (annotation.isLocked || !annotation.isVisible) {
        continue;
      }
      const handle = tool.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);
      if (handle) {
        toolsWithMoveableHandles.push({
          tool,
          annotation,
          handle
        });
        break;
      }
    }
  });
  return toolsWithMoveableHandles;
}

// node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js
function filterToolsWithAnnotationsForElement(element, tools) {
  const result = [];
  for (let i = 0; i < tools.length; i++) {
    const tool = tools[i];
    if (!tool) {
      console.warn("undefined tool in filterToolsWithAnnotationsForElement");
      continue;
    }
    let annotations = getAnnotations(tool.constructor.toolName, element);
    if (!(annotations == null ? void 0 : annotations.length)) {
      continue;
    }
    if (typeof tool.filterInteractableAnnotationsForElement === "function") {
      annotations = tool.filterInteractableAnnotationsForElement(element, annotations);
    }
    if ((annotations == null ? void 0 : annotations.length) > 0) {
      result.push({ tool, annotations });
    }
  }
  return result;
}

// node_modules/@cornerstonejs/tools/dist/esm/store/filterMoveableAnnotationTools.js
function filterMoveableAnnotationTools(element, ToolAndAnnotations, canvasCoords, interactionType = "mouse") {
  const proximity = interactionType === "touch" ? 36 : 6;
  const moveableAnnotationTools = [];
  ToolAndAnnotations.forEach(({ tool, annotations }) => {
    for (const annotation of annotations) {
      if (annotation.isLocked || !annotation.isVisible) {
        continue;
      }
      const near = tool.isPointNearTool(element, annotation, canvasCoords, proximity, interactionType);
      if (near) {
        moveableAnnotationTools.push({
          tool,
          annotation
        });
        break;
      }
    }
  });
  return moveableAnnotationTools;
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForMouseEvent.js
var { Active: Active5 } = ToolModes_default;
function getActiveToolForMouseEvent(evt) {
  const { renderingEngineId, viewportId, event: mouseEvent } = evt.detail;
  const modifierKey = getMouseModifier_default(mouseEvent) || keyboard_default.getModifierKey();
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  if (!toolGroup) {
    return null;
  }
  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();
  const mouseButton = evt.detail.buttons ?? (mouseEvent == null ? void 0 : mouseEvent.buttons) ?? defaultMousePrimary;
  for (let j = 0; j < toolGroupToolNames.length; j++) {
    const toolName = toolGroupToolNames[j];
    const toolOptions = toolGroup.toolOptions[toolName];
    const correctBinding = toolOptions.bindings.length && toolOptions.bindings.some((binding) => {
      return binding.mouseButton === mouseButton && binding.modifierKey === modifierKey;
    });
    if (toolOptions.mode === Active5 && correctBinding) {
      return toolGroup.getToolInstance(toolName);
    }
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js
function getToolsWithModesForMouseEvent(evt, modesFilter, evtButton) {
  const { renderingEngineId, viewportId } = evt.detail;
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  if (!toolGroup) {
    return [];
  }
  const enabledTools = [];
  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
  for (let j = 0; j < toolGroupToolNames.length; j++) {
    const toolName = toolGroupToolNames[j];
    const tool = toolGroup.toolOptions[toolName];
    const correctBinding = evtButton != null && tool.bindings.length && tool.bindings.some((binding) => binding.mouseButton === evtButton);
    if (modesFilter.includes(tool.mode) && (!evtButton || correctBinding)) {
      const toolInstance = toolGroup.getToolInstance(toolName);
      enabledTools.push(toolInstance);
    }
  }
  return enabledTools;
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithActionsForMouseEvent.js
function getToolsWithActionsForMouseEvent(evt, toolModes) {
  var _a2;
  const toolsWithActions = /* @__PURE__ */ new Map();
  const { renderingEngineId, viewportId } = evt.detail;
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  if (!toolGroup) {
    return toolsWithActions;
  }
  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();
  const mouseEvent = evt.detail.event;
  const mouseButton = (mouseEvent == null ? void 0 : mouseEvent.buttons) ?? defaultMousePrimary;
  const modifierKey = getMouseModifier_default(mouseEvent) || keyboard_default.getModifierKey();
  for (let j = 0; j < toolGroupToolNames.length; j++) {
    const toolName = toolGroupToolNames[j];
    const tool = toolGroup.getToolInstance(toolName);
    const actionsConfig = ((_a2 = tool.configuration) == null ? void 0 : _a2.actions) ?? {};
    const actions = Object.values(actionsConfig);
    if (!(actions == null ? void 0 : actions.length) || !toolModes.includes(tool.mode)) {
      continue;
    }
    const action = actions.find((action2) => {
      var _a3;
      return ((_a3 = action2.bindings) == null ? void 0 : _a3.length) && action2.bindings.some((binding) => binding.mouseButton === mouseButton && binding.modifierKey === modifierKey);
    });
    if (action) {
      toolsWithActions.set(tool, action);
    }
  }
  return toolsWithActions;
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDownAnnotationAction.js
var { Active: Active6, Passive: Passive4 } = ToolModes_default;
function mouseDownAnnotationAction(evt) {
  if (state.isInteractingWithTool) {
    return false;
  }
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  const enabledElement = getEnabledElement(element);
  const { canvas: canvasCoords } = eventDetail.currentPoints;
  if (!enabledElement) {
    return false;
  }
  const toolsWithActions = getToolsWithActionsForMouseEvent(evt, [
    Active6,
    Passive4
  ]);
  const tools = Array.from(toolsWithActions.keys());
  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(element, tools);
  const moveableAnnotationTools = filterMoveableAnnotationTools(element, annotationToolsWithAnnotations, canvasCoords);
  if (moveableAnnotationTools.length > 0) {
    const { tool, annotation } = moveableAnnotationTools[0];
    const action = toolsWithActions.get(tool);
    const method = typeof action.method === "string" ? tool[action.method] : action.method;
    method.call(tool, evt, annotation);
    return true;
  }
  return false;
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDown.js
var { Active: Active7, Passive: Passive5 } = ToolModes_default;
function mouseDown(evt) {
  if (state.isInteractingWithTool) {
    return;
  }
  const activeTool = getActiveToolForMouseEvent(evt);
  if (activeTool && typeof activeTool.preMouseDownCallback === "function") {
    const consumedEvent = activeTool.preMouseDownCallback(evt);
    if (consumedEvent) {
      return;
    }
  }
  const isPrimaryClick = evt.detail.event.buttons === 1;
  const activeToolsWithEventBinding = getToolsWithModesForMouseEvent(evt, [Active7], evt.detail.event.buttons);
  const passiveToolsIfEventWasPrimaryMouseButton = isPrimaryClick ? getToolsWithModesForMouseEvent(evt, [Passive5]) : void 0;
  const applicableTools = [
    ...activeToolsWithEventBinding || [],
    ...passiveToolsIfEventWasPrimaryMouseButton || []
  ];
  const actionExecuted = mouseDownAnnotationAction(evt);
  if (actionExecuted) {
    return;
  }
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(element, applicableTools);
  const canvasCoords = eventDetail.currentPoints.canvas;
  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(element, annotationToolsWithAnnotations, canvasCoords, "mouse");
  const isMultiSelect = !!evt.detail.event.shiftKey;
  if (annotationToolsWithMoveableHandles.length > 0) {
    const { tool, annotation, handle } = getAnnotationForSelection(annotationToolsWithMoveableHandles);
    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);
    tool.handleSelectedCallback(evt, annotation, handle, "Mouse");
    return;
  }
  const moveableAnnotationTools = filterMoveableAnnotationTools(element, annotationToolsWithAnnotations, canvasCoords, "mouse");
  if (moveableAnnotationTools.length > 0) {
    const { tool, annotation } = getAnnotationForSelection(moveableAnnotationTools);
    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);
    tool.toolSelectedCallback(evt, annotation, "Mouse", canvasCoords);
    return;
  }
  if (activeTool && typeof activeTool.postMouseDownCallback === "function") {
    const consumedEvent = activeTool.postMouseDownCallback(evt);
    if (consumedEvent) {
      return;
    }
  }
}
function getAnnotationForSelection(toolsWithMovableHandles) {
  if (toolsWithMovableHandles.length > 1) {
    const unlockAndVisibleAnnotation = toolsWithMovableHandles.find((item) => {
      const isUnlocked = !isAnnotationLocked(item.annotation.annotationUID);
      const isVisible = isAnnotationVisible(item.annotation.annotationUID);
      return isUnlocked && isVisible;
    });
    if (unlockAndVisibleAnnotation) {
      return unlockAndVisibleAnnotation;
    }
  }
  return toolsWithMovableHandles[0];
}
function toggleAnnotationSelection(annotationUID, isMultiSelect = false) {
  if (isMultiSelect) {
    if (isAnnotationSelected(annotationUID)) {
      setAnnotationSelected(annotationUID, false);
    } else {
      const preserveSelected = true;
      setAnnotationSelected(annotationUID, true, preserveSelected);
    }
  } else {
    const preserveSelected = false;
    setAnnotationSelected(annotationUID, true, preserveSelected);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDownActivate.js
function mouseDownActivate(evt) {
  if (state.isInteractingWithTool) {
    return;
  }
  const activeTool = getActiveToolForMouseEvent(evt);
  if (!activeTool) {
    return;
  }
  if (state.isMultiPartToolActive) {
    return;
  }
  if (activeTool.addNewAnnotation) {
    const annotation = activeTool.addNewAnnotation(evt, "mouse");
    setAnnotationSelected(annotation.annotationUID);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDrag.js
function mouseDrag(evt) {
  if (state.isInteractingWithTool) {
    return;
  }
  const activeTool = getActiveToolForMouseEvent(evt);
  const noFoundToolOrDoesNotHaveMouseDragCallback = !activeTool || typeof activeTool.mouseDragCallback !== "function";
  if (noFoundToolOrDoesNotHaveMouseDragCallback) {
    return;
  }
  activeTool.mouseDragCallback(evt);
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseMove.js
var { Active: Active8, Passive: Passive6 } = ToolModes_default;
function mouseMove(evt) {
  if (state.isInteractingWithTool || state.isMultiPartToolActive) {
    return;
  }
  const activeAndPassiveTools = getToolsWithModesForMouseEvent(evt, [
    Active8,
    Passive6
  ]);
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  const toolsWithAnnotations = filterToolsWithAnnotationsForElement(element, activeAndPassiveTools);
  const toolsWithoutAnnotations = activeAndPassiveTools.filter((tool) => {
    const doesNotHaveAnnotations = !toolsWithAnnotations.some((toolAndAnnotation) => toolAndAnnotation.tool.getToolName() === tool.getToolName());
    return doesNotHaveAnnotations;
  });
  let annotationsNeedToBeRedrawn = false;
  for (const { tool, annotations } of toolsWithAnnotations) {
    if (typeof tool.mouseMoveCallback === "function") {
      annotationsNeedToBeRedrawn = tool.mouseMoveCallback(evt, annotations) || annotationsNeedToBeRedrawn;
    }
  }
  toolsWithoutAnnotations.forEach((tool) => {
    if (typeof tool.mouseMoveCallback === "function") {
      tool.mouseMoveCallback(evt);
    }
  });
  if (annotationsNeedToBeRedrawn === true) {
    triggerAnnotationRender_default(element);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseUp.js
var mouseUp = customCallbackHandler.bind(null, "Mouse", "mouseUpCallback");
var mouseUp_default = mouseUp;

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseWheel.js
function mouseWheel(evt) {
  if (state.isInteractingWithTool) {
    return;
  }
  evt.detail.buttons = MouseBindings.Wheel | (evt.detail.event.buttons || 0);
  const activeTool = getActiveToolForMouseEvent(evt);
  if (!activeTool) {
    return;
  }
  return activeTool.mouseWheelCallback(evt);
}
var mouseWheel_default = mouseWheel;

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseToolEventDispatcher.js
var enable8 = function(element) {
  element.addEventListener(Events_default.MOUSE_CLICK, mouseClick_default);
  element.addEventListener(Events_default.MOUSE_DOWN, mouseDown);
  element.addEventListener(Events_default.MOUSE_DOWN_ACTIVATE, mouseDownActivate);
  element.addEventListener(Events_default.MOUSE_DOUBLE_CLICK, mouseDoubleClick_default);
  element.addEventListener(Events_default.MOUSE_DRAG, mouseDrag);
  element.addEventListener(Events_default.MOUSE_MOVE, mouseMove);
  element.addEventListener(Events_default.MOUSE_UP, mouseUp_default);
  element.addEventListener(Events_default.MOUSE_WHEEL, mouseWheel_default);
};
var disable8 = function(element) {
  element.removeEventListener(Events_default.MOUSE_CLICK, mouseClick_default);
  element.removeEventListener(Events_default.MOUSE_DOWN, mouseDown);
  element.removeEventListener(Events_default.MOUSE_DOWN_ACTIVATE, mouseDownActivate);
  element.removeEventListener(Events_default.MOUSE_DOUBLE_CLICK, mouseDoubleClick_default);
  element.removeEventListener(Events_default.MOUSE_DRAG, mouseDrag);
  element.removeEventListener(Events_default.MOUSE_MOVE, mouseMove);
  element.removeEventListener(Events_default.MOUSE_UP, mouseUp_default);
  element.removeEventListener(Events_default.MOUSE_WHEEL, mouseWheel_default);
};
var mouseToolEventDispatcher = {
  enable: enable8,
  disable: disable8
};
var mouseToolEventDispatcher_default = mouseToolEventDispatcher;

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForKeyboardEvent.js
var { Active: Active9 } = ToolModes_default;
function getActiveToolForKeyboardEvent(evt) {
  const { renderingEngineId, viewportId } = evt.detail;
  const mouseButton = getMouseButton();
  const modifierKey = keyboard_default.getModifierKey();
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  if (!toolGroup) {
    return null;
  }
  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();
  for (let j = 0; j < toolGroupToolNames.length; j++) {
    const toolName = toolGroupToolNames[j];
    const toolOptions = toolGroup.toolOptions[toolName];
    if (toolOptions.mode !== Active9) {
      continue;
    }
    const correctBinding = toolOptions.bindings.length && toolOptions.bindings.some((binding) => binding.mouseButton === (mouseButton ?? defaultMousePrimary) && binding.modifierKey === modifierKey);
    if (correctBinding) {
      return toolGroup.getToolInstance(toolName);
    }
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithActionsForKeyboardEvents.js
function getToolsWithModesForKeyboardEvent(evt, toolModes) {
  var _a2;
  const toolsWithActions = /* @__PURE__ */ new Map();
  const { renderingEngineId, viewportId } = evt.detail;
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  if (!toolGroup) {
    return toolsWithActions;
  }
  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
  const key = evt.detail.key;
  for (let j = 0; j < toolGroupToolNames.length; j++) {
    const toolName = toolGroupToolNames[j];
    const tool = toolGroup.getToolInstance(toolName);
    const actionsConfig = (_a2 = tool.configuration) == null ? void 0 : _a2.actions;
    if (!actionsConfig) {
      continue;
    }
    const actions = Object.values(actionsConfig);
    if (!(actions == null ? void 0 : actions.length) || !toolModes.includes(tool.mode)) {
      continue;
    }
    const action = actions.find((action2) => {
      var _a3;
      return (_a3 = action2.bindings) == null ? void 0 : _a3.some((binding) => binding.key === key);
    });
    if (action) {
      toolsWithActions.set(tool, action);
    }
  }
  return toolsWithActions;
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyDown.js
function keyDown(evt) {
  const activeTool = getActiveToolForKeyboardEvent(evt);
  if (activeTool) {
    const { renderingEngineId, viewportId } = evt.detail;
    const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
    const toolName = activeTool.getToolName();
    if (Object.keys(toolGroup.toolOptions).includes(toolName)) {
      toolGroup.setViewportsCursorByToolName(toolName);
    }
  }
  const activeToolsWithEventBinding = getToolsWithModesForKeyboardEvent(evt, [
    ToolModes_default.Active
  ]);
  if (activeToolsWithEventBinding == null ? void 0 : activeToolsWithEventBinding.size) {
    const { element } = evt.detail;
    for (const [key, value] of [...activeToolsWithEventBinding.entries()]) {
      const method = typeof value.method === "function" ? value.method : key[value.method];
      method.call(key, element, value, evt);
    }
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyUp.js
function keyUp(evt) {
  const activeTool = getActiveToolForKeyboardEvent(evt);
  if (!activeTool) {
    return;
  }
  const { renderingEngineId, viewportId } = evt.detail;
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  resetModifierKey();
  const toolName = activeTool.getToolName();
  if (Object.keys(toolGroup.toolOptions).includes(toolName)) {
    toolGroup.setViewportsCursorByToolName(toolName);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardToolEventDispatcher.js
var enable9 = function(element) {
  element.addEventListener(Events_default.KEY_DOWN, keyDown);
  element.addEventListener(Events_default.KEY_UP, keyUp);
};
var disable9 = function(element) {
  element.removeEventListener(Events_default.KEY_DOWN, keyDown);
  element.removeEventListener(Events_default.KEY_UP, keyUp);
};
var keyboardToolEventDispatcher = {
  enable: enable9,
  disable: disable9
};
var keyboardToolEventDispatcher_default = keyboardToolEventDispatcher;

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js
var { Active: Active10, Passive: Passive7, Enabled: Enabled4 } = ToolModes_default;
var onCameraModified = function(evt) {
  const enabledTools = getToolsWithModesForMouseEvent(evt, [
    Active10,
    Passive7,
    Enabled4
  ]);
  enabledTools.forEach((tool) => {
    if (tool.onCameraModified) {
      tool.onCameraModified(evt);
    }
  });
};
var enable10 = function(element) {
  element.addEventListener(enums_exports.Events.CAMERA_MODIFIED, onCameraModified);
};
var disable10 = function(element) {
  element.removeEventListener(enums_exports.Events.CAMERA_MODIFIED, onCameraModified);
};
var cameraModifiedEventDispatcher_default = {
  enable: enable10,
  disable: disable10
};

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js
var { Active: Active11, Passive: Passive8, Enabled: Enabled5 } = ToolModes_default;
var onImageSpacingCalibrated = function(evt) {
  const enabledTools = getToolsWithModesForMouseEvent(evt, [
    Active11,
    Passive8,
    Enabled5
  ]);
  enabledTools.forEach((tool) => {
    if (tool.onImageSpacingCalibrated) {
      tool.onImageSpacingCalibrated(evt);
    }
  });
};
var enable11 = function(element) {
  element.addEventListener(enums_exports.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);
};
var disable11 = function(element) {
  element.removeEventListener(enums_exports.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);
};
var imageSpacingCalibratedEventDispatcher_default = {
  enable: enable11,
  disable: disable11
};

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForTouchEvent.js
var { Active: Active12 } = ToolModes_default;
function getActiveToolForTouchEvent(evt) {
  const { renderingEngineId, viewportId } = evt.detail;
  const touchEvent = evt.detail.event;
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  if (!toolGroup) {
    return null;
  }
  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
  const numTouchPoints = Object.keys(touchEvent.touches).length;
  const modifierKey = getMouseModifier_default(touchEvent) || keyboard_default.getModifierKey();
  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();
  for (let j = 0; j < toolGroupToolNames.length; j++) {
    const toolName = toolGroupToolNames[j];
    const toolOptions = toolGroup.toolOptions[toolName];
    const correctBinding = toolOptions.bindings.length && toolOptions.bindings.some((binding) => (binding.numTouchPoints === numTouchPoints || numTouchPoints === 1 && binding.mouseButton === defaultMousePrimary) && binding.modifierKey === modifierKey);
    if (toolOptions.mode === Active12 && correctBinding) {
      return toolGroup.getToolInstance(toolName);
    }
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForTouchEvent.js
function getToolsWithModesForTouchEvent(evt, modesFilter, numTouchPoints) {
  const { renderingEngineId, viewportId } = evt.detail;
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  if (!toolGroup) {
    return [];
  }
  const enabledTools = [];
  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);
  for (let j = 0; j < toolGroupToolNames.length; j++) {
    const toolName = toolGroupToolNames[j];
    const tool = toolGroup.toolOptions[toolName];
    const correctBinding = numTouchPoints != null && tool.bindings.length && tool.bindings.some((binding) => binding.numTouchPoints === numTouchPoints);
    if (modesFilter.includes(tool.mode) && (!numTouchPoints || correctBinding)) {
      const toolInstance = toolGroup.getToolInstance(toolName);
      enabledTools.push(toolInstance);
    }
  }
  return enabledTools;
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStart.js
var { Active: Active13, Passive: Passive9 } = ToolModes_default;
function touchStart(evt) {
  if (state.isInteractingWithTool) {
    return;
  }
  const activeTool = getActiveToolForTouchEvent(evt);
  if (activeTool && typeof activeTool.preTouchStartCallback === "function") {
    const consumedEvent = activeTool.preTouchStartCallback(evt);
    if (consumedEvent) {
      return;
    }
  }
  const isPrimaryClick = Object.keys(evt.detail.event.touches).length === 1;
  const activeToolsWithEventBinding = getToolsWithModesForTouchEvent(evt, [Active13], Object.keys(evt.detail.event.touches).length);
  const passiveToolsIfEventWasPrimaryTouchButton = isPrimaryClick ? getToolsWithModesForTouchEvent(evt, [Passive9]) : void 0;
  const applicableTools = [
    ...activeToolsWithEventBinding || [],
    ...passiveToolsIfEventWasPrimaryTouchButton || [],
    activeTool
  ];
  const eventDetail = evt.detail;
  const { element } = eventDetail;
  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(element, applicableTools);
  const canvasCoords = eventDetail.currentPoints.canvas;
  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(element, annotationToolsWithAnnotations, canvasCoords, "touch");
  const isMultiSelect = false;
  if (annotationToolsWithMoveableHandles.length > 0) {
    const { tool, annotation, handle } = getAnnotationForSelection2(annotationToolsWithMoveableHandles);
    toggleAnnotationSelection2(annotation.annotationUID, isMultiSelect);
    tool.handleSelectedCallback(evt, annotation, handle, "Touch");
    return;
  }
  const moveableAnnotationTools = filterMoveableAnnotationTools(element, annotationToolsWithAnnotations, canvasCoords, "touch");
  if (moveableAnnotationTools.length > 0) {
    const { tool, annotation } = getAnnotationForSelection2(moveableAnnotationTools);
    toggleAnnotationSelection2(annotation.annotationUID, isMultiSelect);
    tool.toolSelectedCallback(evt, annotation, "Touch");
    return;
  }
  if (activeTool && typeof activeTool.postTouchStartCallback === "function") {
    const consumedEvent = activeTool.postTouchStartCallback(evt);
    if (consumedEvent) {
      return;
    }
  }
}
function getAnnotationForSelection2(toolsWithMovableHandles) {
  return toolsWithMovableHandles.length > 1 && toolsWithMovableHandles.find((item) => !isAnnotationLocked(item.annotation.annotationUID) && isAnnotationVisible(item.annotation.annotationUID)) || toolsWithMovableHandles[0];
}
function toggleAnnotationSelection2(annotationUID, isMultiSelect = false) {
  if (isMultiSelect) {
    if (isAnnotationSelected(annotationUID)) {
      setAnnotationSelected(annotationUID, false);
    } else {
      const preserveSelected = true;
      setAnnotationSelected(annotationUID, true, preserveSelected);
    }
  } else {
    const preserveSelected = false;
    setAnnotationSelected(annotationUID, true, preserveSelected);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStartActivate.js
function touchStartActivate(evt) {
  if (state.isInteractingWithTool) {
    return;
  }
  const activeTool = getActiveToolForTouchEvent(evt);
  if (!activeTool) {
    return;
  }
  if (state.isMultiPartToolActive) {
    return;
  }
  if (activeTool.addNewAnnotation) {
    const annotation = activeTool.addNewAnnotation(evt, "touch");
    setAnnotationSelected(annotation.annotationUID);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchDrag.js
function touchDrag(evt) {
  if (state.isInteractingWithTool) {
    return;
  }
  const activeTool = getActiveToolForTouchEvent(evt);
  const noFoundToolOrDoesNotHaveTouchDragCallback = !activeTool || typeof activeTool.touchDragCallback !== "function";
  if (noFoundToolOrDoesNotHaveTouchDragCallback) {
    return;
  }
  activeTool.touchDragCallback(evt);
}

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchEnd.js
var touchEnd = customCallbackHandler.bind(null, "Touch", "touchEndCallback");
var touchEnd_default = touchEnd;

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchTap.js
var touchTap = customCallbackHandler.bind(null, "Touch", "touchTapCallback");
var touchTap_default = touchTap;

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchPress.js
var touchPress = customCallbackHandler.bind(null, "Touch", "touchPressCallback");
var touchPress_default = touchPress;

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchToolEventDispatcher.js
var enable12 = function(element) {
  element.addEventListener(Events_default.TOUCH_START, touchStart);
  element.addEventListener(Events_default.TOUCH_START_ACTIVATE, touchStartActivate);
  element.addEventListener(Events_default.TOUCH_DRAG, touchDrag);
  element.addEventListener(Events_default.TOUCH_END, touchEnd_default);
  element.addEventListener(Events_default.TOUCH_TAP, touchTap_default);
  element.addEventListener(Events_default.TOUCH_PRESS, touchPress_default);
};
var disable12 = function(element) {
  element.removeEventListener(Events_default.TOUCH_START, touchStart);
  element.removeEventListener(Events_default.TOUCH_START_ACTIVATE, touchStartActivate);
  element.removeEventListener(Events_default.TOUCH_DRAG, touchDrag);
  element.removeEventListener(Events_default.TOUCH_END, touchEnd_default);
  element.removeEventListener(Events_default.TOUCH_PRESS, touchPress_default);
};
var touchToolEventDispatcher = {
  enable: enable12,
  disable: disable12
};
var touchToolEventDispatcher_default = touchToolEventDispatcher;

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js
var enable13 = function() {
  eventTarget_default.addEventListener(Events_default.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);
  eventTarget_default.addEventListener(Events_default.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);
  eventTarget_default.addEventListener(Events_default.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);
};
var disable13 = function() {
  eventTarget_default.removeEventListener(Events_default.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);
  eventTarget_default.removeEventListener(Events_default.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);
  eventTarget_default.removeEventListener(Events_default.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);
};
var annotationInterpolationEventDispatcher_default = {
  enable: enable13,
  disable: disable13
};

// node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js
var { Active: Active14, Passive: Passive10, Enabled: Enabled6 } = ToolModes_default;
var onCameraReset = function(evt) {
  const enabledTools = getToolsWithModesForMouseEvent(evt, [
    Active14,
    Passive10,
    Enabled6
  ]);
  enabledTools.forEach((tool) => {
    if (tool.onResetCamera) {
      tool.onResetCamera(evt);
    }
  });
};
var enable14 = function(element) {
  element.addEventListener(enums_exports.Events.CAMERA_RESET, onCameraReset);
};
var disable14 = function(element) {
  element.removeEventListener(enums_exports.Events.CAMERA_RESET, onCameraReset);
};
var cameraResetEventDispatcher_default = {
  enable: enable14,
  disable: disable14
};

// node_modules/@cornerstonejs/tools/dist/esm/store/addEnabledElement.js
function addEnabledElement(evt) {
  const { element, viewportId } = evt.detail;
  const svgLayer = _createSvgAnnotationLayer(viewportId);
  _setSvgNodeCache(element);
  _appendChild(svgLayer, element);
  annotationRenderingEngine.addViewportElement(viewportId, element);
  mouse_default.enable(element);
  wheel_default.enable(element);
  touch_default.enable(element);
  keyboard_default.enable(element);
  imageChangeEventListener_default.enable(element);
  imageRenderedEventDispatcher_default.enable(element);
  cameraModifiedEventDispatcher_default.enable(element);
  imageSpacingCalibratedEventDispatcher_default.enable(element);
  cameraResetEventDispatcher_default.enable(element);
  mouseToolEventDispatcher_default.enable(element);
  keyboardToolEventDispatcher_default.enable(element);
  touchToolEventDispatcher_default.enable(element);
  state.enabledElements.push(element);
}
function _createSvgAnnotationLayer(viewportId) {
  const svgns = "http://www.w3.org/2000/svg";
  const svgLayer = document.createElementNS(svgns, "svg");
  const svgLayerId = `svg-layer-${viewportId}`;
  svgLayer.classList.add("svg-layer");
  svgLayer.setAttribute("id", svgLayerId);
  svgLayer.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  svgLayer.style.width = "100%";
  svgLayer.style.height = "100%";
  svgLayer.style.pointerEvents = "none";
  svgLayer.style.position = "absolute";
  const defs = document.createElementNS(svgns, "defs");
  const filter = document.createElementNS(svgns, "filter");
  const feOffset = document.createElementNS(svgns, "feOffset");
  const feColorMatrix = document.createElementNS(svgns, "feColorMatrix");
  const feBlend = document.createElementNS(svgns, "feBlend");
  filter.setAttribute("id", `shadow-${svgLayerId}`);
  filter.setAttribute("filterUnits", "userSpaceOnUse");
  feOffset.setAttribute("result", "offOut");
  feOffset.setAttribute("in", "SourceGraphic");
  feOffset.setAttribute("dx", "0.5");
  feOffset.setAttribute("dy", "0.5");
  feColorMatrix.setAttribute("result", "matrixOut");
  feColorMatrix.setAttribute("in", "offOut");
  feColorMatrix.setAttribute("in2", "matrix");
  feColorMatrix.setAttribute("values", "0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0");
  feBlend.setAttribute("in", "SourceGraphic");
  feBlend.setAttribute("in2", "matrixOut");
  feBlend.setAttribute("mode", "normal");
  filter.appendChild(feOffset);
  filter.appendChild(feColorMatrix);
  filter.appendChild(feBlend);
  defs.appendChild(filter);
  svgLayer.appendChild(defs);
  return svgLayer;
}
function _setSvgNodeCache(element) {
  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;
  const elementHash = `${viewportId}:${renderingEngineId}`;
  state.svgNodeCache[elementHash] = {};
}
function _appendChild(newNode, referenceNode) {
  referenceNode.querySelector("div.viewport-element").appendChild(newNode);
}

// node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizersForViewport.js
function getSynchronizersForViewport(viewportId, renderingEngineId) {
  const synchronizersFilteredByIds = [];
  if (!renderingEngineId && !viewportId) {
    throw new Error("At least one of renderingEngineId or viewportId should be given");
  }
  for (let i = 0; i < state.synchronizers.length; i++) {
    const synchronizer = state.synchronizers[i];
    const notDisabled = !synchronizer.isDisabled();
    const hasSourceViewport = synchronizer.hasSourceViewport(renderingEngineId, viewportId);
    const hasTargetViewport = synchronizer.hasTargetViewport(renderingEngineId, viewportId);
    if (notDisabled && (hasSourceViewport || hasTargetViewport)) {
      synchronizersFilteredByIds.push(synchronizer);
    }
  }
  return synchronizersFilteredByIds;
}
var getSynchronizersForViewport_default = getSynchronizersForViewport;

// node_modules/@cornerstonejs/tools/dist/esm/store/removeEnabledElement.js
var VIEWPORT_ELEMENT2 = "viewport-element";
function removeEnabledElement(elementDisabledEvt) {
  const { element, viewportId } = elementDisabledEvt.detail;
  _resetSvgNodeCache(element);
  _removeSvgNode(element);
  annotationRenderingEngine.removeViewportElement(viewportId, element);
  mouse_default.disable(element);
  wheel_default.disable(element);
  touch_default.disable(element);
  keyboard_default.disable(element);
  imageChangeEventListener_default.disable(element);
  imageRenderedEventDispatcher_default.disable(element);
  cameraModifiedEventDispatcher_default.disable(element);
  imageSpacingCalibratedEventDispatcher_default.disable(element);
  cameraResetEventDispatcher_default.disable(element);
  mouseToolEventDispatcher_default.disable(element);
  keyboardToolEventDispatcher_default.disable(element);
  touchToolEventDispatcher_default.disable(element);
  _removeViewportFromSynchronizers(element);
  _removeViewportFromToolGroup(element);
  _removeEnabledElement(element);
}
var _removeViewportFromSynchronizers = (element) => {
  const enabledElement = getEnabledElement(element);
  const synchronizers = getSynchronizersForViewport_default(enabledElement.viewportId, enabledElement.renderingEngineId);
  synchronizers.forEach((sync) => {
    sync.remove(enabledElement);
  });
};
var _removeViewportFromToolGroup = (element) => {
  const { renderingEngineId, viewportId } = getEnabledElement(element);
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  if (toolGroup) {
    toolGroup.removeViewports(renderingEngineId, viewportId);
  }
};
function _resetSvgNodeCache(element) {
  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;
  const elementHash = `${viewportId}:${renderingEngineId}`;
  delete state.svgNodeCache[elementHash];
}
function _removeSvgNode(element) {
  const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT2}`);
  const svgLayer = internalViewportNode.querySelector("svg");
  if (svgLayer) {
    internalViewportNode.removeChild(svgLayer);
  }
}
var _removeEnabledElement = function(element) {
  const foundElementIndex = state.enabledElements.findIndex((el) => el === element);
  if (foundElementIndex > -1) {
    state.enabledElements.splice(foundElementIndex, 1);
  }
};
var removeEnabledElement_default = removeEnabledElement;

// node_modules/@cornerstonejs/tools/dist/esm/store/cancelActiveManipulations.js
function cancelActiveManipulations(element) {
  const tools = getToolsWithModesForElement(element, [
    ToolModes_default.Active,
    ToolModes_default.Passive
  ]);
  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);
  for (const { tool } of toolsWithData) {
    const annotationUID = tool.cancel(element);
    if (annotationUID) {
      return annotationUID;
    }
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/Synchronizer.js
var Synchronizer = class {
  constructor(synchronizerId, eventName2, eventHandler, options) {
    this._viewportOptions = {};
    this._onEvent = (evt) => {
      var _a2;
      if (this._ignoreFiredEvents === true) {
        return;
      }
      if (!this._targetViewports.length) {
        return;
      }
      const enabledElement = this._eventSource === "element" ? getEnabledElement(evt.currentTarget) : getEnabledElementByViewportId((_a2 = evt.detail) == null ? void 0 : _a2.viewportId);
      if (!enabledElement) {
        return;
      }
      const { renderingEngineId, viewportId } = enabledElement;
      if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {
        return;
      }
      this.fireEvent({
        renderingEngineId,
        viewportId
      }, evt);
    };
    this._enabled = true;
    this._eventName = eventName2;
    this._eventHandler = eventHandler;
    this._ignoreFiredEvents = false;
    this._sourceViewports = [];
    this._targetViewports = [];
    this._options = options || {};
    this._eventSource = this._options.eventSource || "element";
    this._auxiliaryEvents = this._options.auxiliaryEvents || [];
    this.id = synchronizerId;
  }
  isDisabled() {
    return !this._enabled || !this._hasSourceElements();
  }
  setOptions(viewportId, options = {}) {
    this._viewportOptions[viewportId] = options;
  }
  setEnabled(enabled) {
    this._enabled = enabled;
  }
  getOptions(viewportId) {
    return this._viewportOptions[viewportId];
  }
  add(viewportInfo) {
    this.addTarget(viewportInfo);
    this.addSource(viewportInfo);
  }
  addSource(viewportInfo) {
    if (_containsViewport(this._sourceViewports, viewportInfo)) {
      return;
    }
    const { renderingEngineId, viewportId } = viewportInfo;
    const viewport = getRenderingEngine(renderingEngineId).getViewport(viewportId);
    if (!viewport) {
      console.warn(`Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`);
      return;
    }
    const eventSource = this._eventSource === "element" ? viewport.element : eventTarget_default;
    eventSource.addEventListener(this._eventName, this._onEvent.bind(this));
    this._auxiliaryEvents.forEach(({ name, source }) => {
      const target = source === "element" ? viewport.element : eventTarget_default;
      target.addEventListener(name, this._onEvent.bind(this));
    });
    this._updateDisableHandlers();
    this._sourceViewports.push(viewportInfo);
  }
  addTarget(viewportInfo) {
    if (_containsViewport(this._targetViewports, viewportInfo)) {
      return;
    }
    this._targetViewports.push(viewportInfo);
    this._updateDisableHandlers();
  }
  getSourceViewports() {
    return this._sourceViewports;
  }
  getTargetViewports() {
    return this._targetViewports;
  }
  destroy() {
    this._sourceViewports.forEach((s) => this.removeSource(s));
    this._targetViewports.forEach((t) => this.removeTarget(t));
  }
  remove(viewportInfo) {
    this.removeTarget(viewportInfo);
    this.removeSource(viewportInfo);
  }
  removeSource(viewportInfo) {
    const index = _getViewportIndex(this._sourceViewports, viewportInfo);
    if (index === -1) {
      return;
    }
    const eventSource = this._eventSource === "element" ? this.getViewportElement(viewportInfo) : eventTarget_default;
    this._sourceViewports.splice(index, 1);
    eventSource.removeEventListener(this._eventName, this._eventHandler);
    this._auxiliaryEvents.forEach(({ name, source }) => {
      const target = source === "element" ? this.getViewportElement(viewportInfo) : eventTarget_default;
      target.removeEventListener(name, this._eventHandler);
    });
    this._updateDisableHandlers();
  }
  removeTarget(viewportInfo) {
    const index = _getViewportIndex(this._targetViewports, viewportInfo);
    if (index === -1) {
      return;
    }
    this._targetViewports.splice(index, 1);
    this._updateDisableHandlers();
  }
  hasSourceViewport(renderingEngineId, viewportId) {
    return _containsViewport(this._sourceViewports, {
      renderingEngineId,
      viewportId
    });
  }
  hasTargetViewport(renderingEngineId, viewportId) {
    return _containsViewport(this._targetViewports, {
      renderingEngineId,
      viewportId
    });
  }
  fireEvent(sourceViewport, sourceEvent) {
    if (this.isDisabled() || this._ignoreFiredEvents) {
      return;
    }
    this._ignoreFiredEvents = true;
    const promises = [];
    try {
      for (let i = 0; i < this._targetViewports.length; i++) {
        const targetViewport = this._targetViewports[i];
        const targetIsSource = sourceViewport.viewportId === targetViewport.viewportId;
        if (targetIsSource) {
          continue;
        }
        const result = this._eventHandler(this, sourceViewport, targetViewport, sourceEvent, this._options);
        if (result instanceof Promise) {
          promises.push(result);
        }
      }
    } catch (ex) {
      console.warn(`Synchronizer, for: ${this._eventName}`, ex);
    } finally {
      if (promises.length) {
        Promise.allSettled(promises).then(() => {
          this._ignoreFiredEvents = false;
        });
      } else {
        this._ignoreFiredEvents = false;
      }
    }
  }
  _hasSourceElements() {
    return this._sourceViewports.length !== 0;
  }
  _updateDisableHandlers() {
    const viewports = _getUniqueViewports(this._sourceViewports, this._targetViewports);
    const _remove = this.remove.bind(this);
    const disableHandler = (elementDisabledEvent) => {
      _remove(elementDisabledEvent.detail.element);
    };
    viewports.forEach((vp) => {
      const eventSource = this.getEventSource(vp);
      if (!eventSource) {
        return;
      }
      eventSource.removeEventListener(enums_exports.Events.ELEMENT_DISABLED, disableHandler);
      eventSource.addEventListener(enums_exports.Events.ELEMENT_DISABLED, disableHandler);
    });
  }
  getEventSource(viewportInfo) {
    return this._eventSource === "element" ? this.getViewportElement(viewportInfo) : eventTarget_default;
  }
  getViewportElement(viewportInfo) {
    const { renderingEngineId, viewportId } = viewportInfo;
    const renderingEngine = getRenderingEngine(renderingEngineId);
    if (!renderingEngine) {
      return null;
    }
    const viewport = renderingEngine.getViewport(viewportId);
    if (!viewport) {
      return null;
    }
    return viewport.element;
  }
};
function _getUniqueViewports(vp1, vp2) {
  const unique = [];
  const vps = vp1.concat(vp2);
  for (let i = 0; i < vps.length; i++) {
    const vp = vps[i];
    if (!unique.some((u) => vp.renderingEngineId === u.renderingEngineId && vp.viewportId === u.viewportId)) {
      unique.push(vp);
    }
  }
  return unique;
}
function _getViewportIndex(arr, vp) {
  return arr.findIndex((ar) => vp.renderingEngineId === ar.renderingEngineId && vp.viewportId === ar.viewportId);
}
function _containsViewport(arr, vp) {
  return arr.some((ar) => ar.renderingEngineId === vp.renderingEngineId && ar.viewportId === vp.viewportId);
}
var Synchronizer_default = Synchronizer;

// node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js
var SynchronizerManager_exports = {};
__export(SynchronizerManager_exports, {
  createSynchronizer: () => createSynchronizer_default,
  destroy: () => destroy_default2,
  destroySynchronizer: () => destroySynchronizer_default,
  getAllSynchronizers: () => getAllSynchronizers_default,
  getSynchronizer: () => getSynchronizer_default,
  getSynchronizersForViewport: () => getSynchronizersForViewport_default
});

// node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/createSynchronizer.js
function createSynchronizer(synchronizerId, eventName2, eventHandler, options) {
  const synchronizerWithSameIdExists = state.synchronizers.some((sync) => sync.id === synchronizerId);
  if (synchronizerWithSameIdExists) {
    throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);
  }
  const synchronizer = new Synchronizer_default(synchronizerId, eventName2, eventHandler, options);
  state.synchronizers.push(synchronizer);
  return synchronizer;
}
var createSynchronizer_default = createSynchronizer;

// node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroy.js
function destroy3() {
  while (state.synchronizers.length > 0) {
    const synchronizer = state.synchronizers.pop();
    synchronizer.destroy();
  }
}
var destroy_default2 = destroy3;

// node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizer.js
function getSynchronizer(synchronizerId) {
  return state.synchronizers.find((s) => s.id === synchronizerId);
}
var getSynchronizer_default = getSynchronizer;

// node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getAllSynchronizers.js
function getAllSynchronizers() {
  return state.synchronizers;
}
var getAllSynchronizers_default = getAllSynchronizers;

// node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroySynchronizer.js
function destroySynchronizer(synchronizerId) {
  const synchronizerIndex = state.synchronizers.findIndex((sync) => sync.id === synchronizerId);
  if (synchronizerIndex > -1) {
    const synchronizer = state.synchronizers[synchronizerIndex];
    synchronizer.destroy();
    state.synchronizers.splice(synchronizerIndex, 1);
  }
}
var destroySynchronizer_default = destroySynchronizer;

// node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRepresentationModifiedListener.js
var segmentationRepresentationModifiedListener = function(evt) {
  const { viewportId } = evt.detail;
  triggerSegmentationRender(viewportId);
};
var segmentationRepresentationModifiedListener_default = segmentationRepresentationModifiedListener;

// node_modules/@cornerstonejs/tools/dist/esm/init.js
var csToolsInitialized = false;
function init(defaultConfiguration = {}) {
  if (csToolsInitialized) {
    return;
  }
  _addCornerstoneEventListeners();
  _addCornerstoneToolsEventListeners();
  csToolsInitialized = true;
}
function destroy4() {
  _removeCornerstoneEventListeners();
  _removeCornerstoneToolsEventListeners();
  destroy_default();
  resetCornerstoneToolsState();
  const annotationManager = getAnnotationManager();
  const segmentationStateManager = defaultSegmentationStateManager;
  annotationManager.restoreAnnotations({});
  segmentationStateManager.resetState();
  csToolsInitialized = false;
}
function _addCornerstoneEventListeners() {
  _removeCornerstoneEventListeners();
  const elementEnabledEvent = enums_exports.Events.ELEMENT_ENABLED;
  const elementDisabledEvent = enums_exports.Events.ELEMENT_DISABLED;
  eventTarget_default.addEventListener(elementEnabledEvent, addEnabledElement);
  eventTarget_default.addEventListener(elementDisabledEvent, removeEnabledElement_default);
  annotationInterpolationEventDispatcher_default.enable();
}
function _removeCornerstoneEventListeners() {
  const elementEnabledEvent = enums_exports.Events.ELEMENT_ENABLED;
  const elementDisabledEvent = enums_exports.Events.ELEMENT_DISABLED;
  eventTarget_default.removeEventListener(elementEnabledEvent, addEnabledElement);
  eventTarget_default.removeEventListener(elementDisabledEvent, removeEnabledElement_default);
  annotationInterpolationEventDispatcher_default.disable();
}
function _addCornerstoneToolsEventListeners() {
  _removeCornerstoneToolsEventListeners();
  eventTarget_default.addEventListener(Events_default.ANNOTATION_COMPLETED, annotationCompletedListener);
  eventTarget_default.addEventListener(Events_default.ANNOTATION_MODIFIED, annotationModifiedListener_default);
  eventTarget_default.addEventListener(Events_default.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener_default);
  eventTarget_default.addEventListener(Events_default.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener_default);
  eventTarget_default.addEventListener(Events_default.ANNOTATION_REMOVED, annotationRemovedListener);
  eventTarget_default.addEventListener(Events_default.SEGMENTATION_MODIFIED, segmentationModifiedEventListener_default);
  eventTarget_default.addEventListener(Events_default.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener_default);
  eventTarget_default.addEventListener(Events_default.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedListener_default);
  eventTarget_default.addEventListener(Events_default.SEGMENTATION_REPRESENTATION_ADDED, segmentationRepresentationModifiedListener_default);
}
function _removeCornerstoneToolsEventListeners() {
  eventTarget_default.removeEventListener(Events_default.ANNOTATION_COMPLETED, annotationCompletedListener);
  eventTarget_default.removeEventListener(Events_default.ANNOTATION_MODIFIED, annotationModifiedListener_default);
  eventTarget_default.removeEventListener(Events_default.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener_default);
  eventTarget_default.removeEventListener(Events_default.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener_default);
  eventTarget_default.removeEventListener(Events_default.SEGMENTATION_MODIFIED, segmentationModifiedEventListener_default);
  eventTarget_default.removeEventListener(Events_default.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener_default);
  eventTarget_default.removeEventListener(Events_default.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedListener_default);
  eventTarget_default.removeEventListener(Events_default.SEGMENTATION_REPRESENTATION_ADDED, segmentationRepresentationModifiedListener_default);
}

// node_modules/@cornerstonejs/tools/dist/esm/constants/index.js
var constants_exports2 = {};
__export(constants_exports2, {
  COLOR_LUT: () => COLOR_LUT_default
});

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/index.js
var synchronizers_exports = {};
__export(synchronizers_exports, {
  createCameraPositionSynchronizer: () => createCameraPositionSynchronizer,
  createImageSliceSynchronizer: () => createImageSliceSynchronizer,
  createPresentationViewSynchronizer: () => createPresentationViewSynchronizer,
  createSlabThicknessSynchronizer: () => createPresentationViewSynchronizer2,
  createStackImageSynchronizer: () => createStackImageSynchronizer,
  createVOISynchronizer: () => createVOISynchronizer,
  createZoomPanSynchronizer: () => createZoomPanSynchronizer
});

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/cameraSyncCallback.js
function cameraSyncCallback(synchronizerInstance, sourceViewport, targetViewport, cameraModifiedEvent) {
  const { camera } = cameraModifiedEvent.detail;
  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
  if (!renderingEngine) {
    throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
  }
  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
  tViewport.setCamera(camera);
  tViewport.render();
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js
var { CAMERA_MODIFIED } = enums_exports.Events;
function createCameraPositionSynchronizer(synchronizerName) {
  const cameraPositionSynchronizer = createSynchronizer_default(synchronizerName, CAMERA_MODIFIED, cameraSyncCallback);
  return cameraPositionSynchronizer;
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/presentationViewSyncCallback.js
function presentationViewSyncCallback(_synchronizerInstance, sourceViewport, targetViewport, _sourceEvent, options) {
  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
  if (!renderingEngine) {
    throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
  }
  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
  const presentationView = sViewport.getViewPresentation(options);
  tViewport.setViewPresentation(presentationView);
  tViewport.render();
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js
var { CAMERA_MODIFIED: CAMERA_MODIFIED2 } = enums_exports.Events;
function createPresentationViewSynchronizer(synchronizerName, options) {
  const presentationView = createSynchronizer_default(synchronizerName, CAMERA_MODIFIED2, presentationViewSyncCallback, { viewPresentation: options });
  return presentationView;
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/voiSyncCallback.js
function voiSyncCallback(synchronizerInstance, sourceViewport, targetViewport, modifiedEvent, options) {
  const eventDetail = modifiedEvent.detail;
  const { volumeId, range: range2, invertStateChanged, invert, colormap } = eventDetail;
  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
  if (!renderingEngine) {
    throw new Error(`Rendering Engine does not exist: ${targetViewport.renderingEngineId}`);
  }
  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
  const tProperties = {
    voiRange: range2
  };
  if ((options == null ? void 0 : options.syncInvertState) && invertStateChanged) {
    tProperties.invert = invert;
  }
  if ((options == null ? void 0 : options.syncColormap) && colormap) {
    tProperties.colormap = colormap;
  }
  if (tViewport instanceof BaseVolumeViewport_default) {
    const isFusion = tViewport._actors && tViewport._actors.size > 1;
    if (isFusion) {
      tViewport.setProperties(tProperties, volumeId);
    } else {
      tViewport.setProperties(tProperties);
    }
  } else if (tViewport instanceof StackViewport_default) {
    tViewport.setProperties(tProperties);
  } else {
    throw new Error("Viewport type not supported.");
  }
  tViewport.render();
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createVOISynchronizer.js
function createVOISynchronizer(synchronizerName, options) {
  options = Object.assign({ syncInvertState: true, syncColormap: true }, options);
  const VOISynchronizer = createSynchronizer_default(synchronizerName, enums_exports.Events.VOI_MODIFIED, voiSyncCallback, {
    auxiliaryEvents: [
      {
        name: enums_exports.Events.COLORMAP_MODIFIED
      }
    ],
    ...options
  });
  return VOISynchronizer;
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/zoomPanSyncCallback.js
function zoomPanSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {
  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
  if (!renderingEngine) {
    throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
  }
  const options = synchronizerInstance.getOptions(targetViewport.viewportId);
  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
  if ((options == null ? void 0 : options.syncZoom) !== false) {
    const srcZoom = sViewport.getZoom();
    tViewport.setZoom(srcZoom);
  }
  if ((options == null ? void 0 : options.syncPan) !== false) {
    const srcPan = sViewport.getPan();
    tViewport.setPan(srcPan);
  }
  tViewport.render();
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js
var { CAMERA_MODIFIED: CAMERA_MODIFIED3 } = enums_exports.Events;
function createZoomPanSynchronizer(synchronizerName) {
  const zoomPanSynchronizer = createSynchronizer_default(synchronizerName, CAMERA_MODIFIED3, zoomPanSyncCallback);
  return zoomPanSynchronizer;
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/areViewportsCoplanar.js
function areViewportsCoplanar(viewport1, viewport2) {
  const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();
  const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();
  const dotProducts = vec3_exports.dot(viewPlaneNormal1, viewPlaneNormal2);
  return Math.abs(dotProducts) > 0.9;
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/imageSliceSyncCallback.js
var getSpatialRegistration = (targetId, sourceId) => utilities_exports.spatialRegistrationMetadataProvider.get("spatialRegistrationModule", targetId, sourceId);
async function imageSliceSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {
  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
  if (!renderingEngine) {
    throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
  }
  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
  const options = synchronizerInstance.getOptions(targetViewport.viewportId);
  if (options == null ? void 0 : options.disabled) {
    return;
  }
  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
  const imageId1 = sViewport.getCurrentImageId();
  const imagePlaneModule1 = metaData_exports.get("imagePlaneModule", imageId1);
  const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;
  const targetImageIds = tViewport.getImageIds();
  if (!areViewportsCoplanar(sViewport, tViewport)) {
    return;
  }
  let registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);
  if (!registrationMatrixMat4) {
    const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();
    const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();
    if (frameOfReferenceUID1 === frameOfReferenceUID2 && (options == null ? void 0 : options.useInitialPosition) !== false) {
      registrationMatrixMat4 = mat4_exports.identity(mat4_exports.create());
    } else {
      utilities_exports.calculateViewportsSpatialRegistration(sViewport, tViewport);
      registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);
    }
    if (!registrationMatrixMat4) {
      return;
    }
  }
  const targetImagePositionPatientWithRegistrationMatrix = vec3_exports.transformMat4(vec3_exports.create(), sourceImagePositionPatient, registrationMatrixMat4);
  const closestImageIdIndex2 = _getClosestImageIdIndex(targetImagePositionPatientWithRegistrationMatrix, targetImageIds);
  let imageIndexToSet = closestImageIdIndex2.index;
  if (tViewport instanceof VolumeViewport_default) {
    imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;
  }
  if (closestImageIdIndex2.index !== -1 && tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index) {
    await utilities_exports.jumpToSlice(tViewport.element, {
      imageIndex: imageIndexToSet
    });
  }
}
function _getClosestImageIdIndex(targetPoint, imageIds) {
  return imageIds.reduce((closestImageIdIndex, imageId, index) => {
    const { imagePositionPatient } = metaData_exports.get("imagePlaneModule", imageId);
    const distance = vec3_exports.distance(imagePositionPatient, targetPoint);
    if (distance < closestImageIdIndex.distance) {
      return {
        distance,
        index
      };
    }
    return closestImageIdIndex;
  }, {
    distance: Infinity,
    index: -1
  });
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js
var { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = enums_exports.Events;
function createImageSliceSynchronizer(synchronizerName) {
  const stackImageSynchronizer = createSynchronizer_default(synchronizerName, STACK_NEW_IMAGE, imageSliceSyncCallback, {
    auxiliaryEvents: [
      {
        name: "VOLUME_NEW_IMAGE"
      }
    ]
  });
  return stackImageSynchronizer;
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/slabThicknessSyncCallback.js
function slabThicknessSyncCallback(_synchronizerInstance, sourceViewport, targetViewport) {
  var _a2, _b2;
  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
  if (!renderingEngine) {
    throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
  }
  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
  const slabThickness = (_a2 = sViewport.getSlabThickness) == null ? void 0 : _a2.call(sViewport);
  if (!slabThickness) {
    return;
  }
  (_b2 = tViewport.setSlabThickness) == null ? void 0 : _b2.call(tViewport, slabThickness);
  tViewport.render();
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js
var { CAMERA_MODIFIED: CAMERA_MODIFIED4 } = enums_exports.Events;
function createPresentationViewSynchronizer2(synchronizerName) {
  const presentationView = createSynchronizer_default(synchronizerName, CAMERA_MODIFIED4, slabThicknessSyncCallback);
  return presentationView;
}

// node_modules/@cornerstonejs/tools/dist/esm/synchronizers/index.js
var createStackImageSynchronizer = createImageSliceSynchronizer;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js
var utilities_exports2 = {};
__export(utilities_exports2, {
  IslandRemoval: () => IslandRemoval,
  annotationFrameRange: () => AnnotationFrameRange,
  annotationHydration: () => annotationHydration,
  boundingBox: () => boundingBox_exports,
  calibrateImageSpacing: () => calibrateImageSpacing,
  cine: () => cine_exports,
  contourSegmentation: () => contourSegmentation_exports,
  contours: () => contours_exports,
  debounce: () => debounce_default,
  drawing: () => drawing_exports,
  dynamicVolume: () => dynamicVolume_exports,
  getAnnotationNearPoint: () => getAnnotationNearPoint,
  getAnnotationNearPointOnEnabledElement: () => getAnnotationNearPointOnEnabledElement,
  getCalibratedAspect: () => getCalibratedAspect,
  getCalibratedLengthUnitsAndScale: () => getCalibratedLengthUnitsAndScale,
  getCalibratedProbeUnitsAndValue: () => getCalibratedProbeUnitsAndValue,
  getClosestImageIdForStackViewport: () => getClosestImageIdForStackViewport,
  getSphereBoundsInfo: () => getSphereBoundsInfo,
  getViewportForAnnotation: () => getViewportForAnnotation,
  isObject: () => isObject_default,
  math: () => math_exports,
  normalizeViewportPlane: () => normalizeViewportPlane,
  orientation: () => orientation_exports,
  planar: () => planar_exports,
  planarFreehandROITool: () => planarFreehandROITool_exports,
  pointInSurroundingSphereCallback: () => pointInSurroundingSphereCallback,
  pointToString: () => pointToString,
  polyDataUtils: () => utils_exports,
  rectangleROITool: () => rectangleROITool_exports,
  roundNumber: () => roundNumber,
  segmentation: () => segmentation_exports,
  stackContextPrefetch: () => stackContextPrefetch_default,
  stackPrefetch: () => stackPrefetch_default,
  throttle: () => throttle_default,
  touch: () => touch_exports,
  triggerAnnotationRender: () => triggerAnnotationRender_default,
  triggerAnnotationRenderForToolGroupIds: () => triggerAnnotationRenderForToolGroupIds_default,
  triggerAnnotationRenderForViewportIds: () => triggerAnnotationRenderForViewportIds_default,
  triggerEvent: () => triggerEvent,
  viewport: () => viewport_exports,
  viewportFilters: () => viewportFilters_exports,
  voi: () => voi_exports
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/getAnnotationNearPoint.js
function getAnnotationNearPoint(element, canvasPoint, proximity = 5) {
  const enabledElement = getEnabledElement(element);
  if (!enabledElement) {
    throw new Error("getAnnotationNearPoint: enabledElement not found");
  }
  return getAnnotationNearPointOnEnabledElement(enabledElement, canvasPoint, proximity);
}
function getAnnotationNearPointOnEnabledElement(enabledElement, point, proximity) {
  const { renderingEngineId, viewportId } = enabledElement;
  const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
  if (!toolGroup) {
    return null;
  }
  const { _toolInstances: tools } = toolGroup;
  for (const name in tools) {
    const found = findAnnotationNearPointByTool(tools[name], enabledElement, point, proximity);
    if (found) {
      return found;
    }
  }
  return null;
}
function findAnnotationNearPointByTool(tool, enabledElement, point, proximity) {
  var _a2, _b2;
  const { viewport } = enabledElement;
  const annotations = getAnnotations(tool.constructor.toolName, viewport == null ? void 0 : viewport.element);
  const currentId = (_a2 = viewport == null ? void 0 : viewport.getCurrentImageId) == null ? void 0 : _a2.call(viewport);
  if (annotations == null ? void 0 : annotations.length) {
    const { element } = enabledElement.viewport;
    for (const annotation of annotations) {
      const referencedImageId = (_b2 = annotation.metadata) == null ? void 0 : _b2.referencedImageId;
      if (currentId && referencedImageId && currentId !== referencedImageId || !tool.isPointNearTool) {
        continue;
      }
      if (tool.isPointNearTool(element, annotation, point, proximity, "") || tool.getHandleNearImagePoint(element, annotation, point, proximity)) {
        return annotation;
      }
    }
  }
  return null;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js
var { calibratedPixelSpacingMetadataProvider } = utilities_exports;
function calibrateImageSpacing(imageId, renderingEngine, calibrationOrScale) {
  if (typeof calibrationOrScale === "number") {
    calibrationOrScale = {
      type: enums_exports.CalibrationTypes.USER,
      scale: calibrationOrScale
    };
  }
  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);
  const viewports = renderingEngine.getStackViewports();
  viewports.forEach((viewport) => {
    const imageIds = viewport.getImageIds();
    if (imageIds.includes(imageId)) {
      viewport.calibrateSpacing(imageId);
    }
  });
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js
var boundingBox_exports = {};
__export(boundingBox_exports, {
  extend2DBoundingBoxInViewAxis: () => extend2DBoundingBoxInViewAxis_default,
  getBoundingBoxAroundShape: () => getBoundingBoxAroundShapeIJK,
  getBoundingBoxAroundShapeIJK: () => getBoundingBoxAroundShapeIJK,
  getBoundingBoxAroundShapeWorld: () => getBoundingBoxAroundShapeWorld
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/extend2DBoundingBoxInViewAxis.js
function extend2DBoundingBoxInViewAxis(boundsIJK, numSlicesToProject) {
  const sliceNormalIndex = boundsIJK.findIndex(([min, max2]) => min === max2);
  if (sliceNormalIndex === -1) {
    throw new Error("3D bounding boxes not supported in an oblique plane");
  }
  boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;
  boundsIJK[sliceNormalIndex][1] += numSlicesToProject;
  return boundsIJK;
}
var extend2DBoundingBoxInViewAxis_default = extend2DBoundingBoxInViewAxis;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js
var { transformWorldToIndex } = utilities_exports;
function _getSphereBoundsInfo(circlePoints, imageData, directionVectors) {
  const [bottom, top] = circlePoints;
  const centerWorld = vec3_exports.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);
  const radiusWorld = vec3_exports.distance(bottom, top) / 2;
  const { boundsIJK, topLeftWorld, bottomRightWorld } = _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld);
  return {
    boundsIJK,
    centerWorld,
    radiusWorld,
    topLeftWorld,
    bottomRightWorld
  };
}
function getSphereBoundsInfo(circlePoints, imageData) {
  const direction = imageData.getDirection();
  const rowCosine = vec3_exports.fromValues(direction[0], direction[1], direction[2]);
  const columnCosine = vec3_exports.fromValues(direction[3], direction[4], direction[5]);
  const scanAxis = vec3_exports.fromValues(direction[6], direction[7], direction[8]);
  const viewPlaneNormal = vec3_exports.negate(vec3_exports.create(), scanAxis);
  const directionVectors = {
    row: rowCosine,
    column: columnCosine,
    normal: viewPlaneNormal
  };
  return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);
}
function getSphereBoundsInfoFromViewport(circlePoints, imageData, viewport) {
  if (!viewport) {
    throw new Error("viewport is required in order to calculate the sphere bounds");
  }
  const camera = viewport.getCamera();
  const viewUp = vec3_exports.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
  const viewPlaneNormal = vec3_exports.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
  const viewRight = vec3_exports.create();
  vec3_exports.cross(viewRight, viewUp, viewPlaneNormal);
  const directionVectors = {
    row: viewRight,
    normal: viewPlaneNormal,
    column: vec3_exports.negate(vec3_exports.create(), viewUp)
  };
  return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);
}
function _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld) {
  const dimensions = imageData.getDimensions();
  const { row: rowCosine, column: columnCosine, normal: vecNormal } = directionVectors;
  const topLeftWorld = vec3_exports.create();
  const bottomRightWorld = vec3_exports.create();
  vec3_exports.scaleAndAdd(topLeftWorld, centerWorld, vecNormal, radiusWorld);
  vec3_exports.scaleAndAdd(bottomRightWorld, centerWorld, vecNormal, -radiusWorld);
  vec3_exports.scaleAndAdd(topLeftWorld, topLeftWorld, columnCosine, -radiusWorld);
  vec3_exports.scaleAndAdd(bottomRightWorld, bottomRightWorld, columnCosine, radiusWorld);
  vec3_exports.scaleAndAdd(topLeftWorld, topLeftWorld, rowCosine, -radiusWorld);
  vec3_exports.scaleAndAdd(bottomRightWorld, bottomRightWorld, rowCosine, radiusWorld);
  const topLeftIJK = transformWorldToIndex(imageData, topLeftWorld);
  const bottomRightIJK = transformWorldToIndex(imageData, bottomRightWorld);
  const pointsIJK = circlePoints.map((p) => transformWorldToIndex(imageData, p));
  const boundsIJK = getBoundingBoxAroundShapeIJK([topLeftIJK, bottomRightIJK, ...pointsIJK], dimensions);
  return { boundsIJK, topLeftWorld, bottomRightWorld };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationFrameRange.js
var _AnnotationFrameRange = class _AnnotationFrameRange {
  static imageIdToFrames(imageId) {
    const match = imageId.match(this.frameRangeExtractor);
    if (!match || !match[2]) {
      return null;
    }
    const range2 = match[2].split("-").map((it) => Number(it));
    if (range2.length === 1) {
      return range2[0];
    }
    return range2;
  }
  static framesToString(range2) {
    if (Array.isArray(range2)) {
      return `${range2[0]}-${range2[1]}`;
    }
    return String(range2);
  }
  static framesToImageId(imageId, range2) {
    const match = imageId.match(this.frameRangeExtractor);
    if (!match || !match[2]) {
      return null;
    }
    const newRangeString = this.framesToString(range2);
    return imageId.replace(this.frameRangeExtractor, `${match[1]}${newRangeString}`);
  }
  static setFrameRange(annotation, range2, eventBase) {
    const { referencedImageId } = annotation.metadata;
    annotation.metadata.referencedImageId = this.framesToImageId(referencedImageId, range2);
    const eventDetail = {
      ...eventBase,
      annotation
    };
    triggerEvent(eventTarget_default, Events_default.ANNOTATION_MODIFIED, eventDetail);
  }
  static getFrameRange(annotation) {
    return this.imageIdToFrames(annotation.metadata.referencedImageId);
  }
};
_AnnotationFrameRange.frameRangeExtractor = /(\/frames\/|[&?]frameNumber=)([^/&?]*)/i;
var AnnotationFrameRange = _AnnotationFrameRange;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/index.js
var contours_exports = {};
__export(contours_exports, {
  AnnotationToPointData: () => AnnotationToPointData_default,
  acceptAutogeneratedInterpolations: () => acceptAutogeneratedInterpolations,
  areCoplanarContours: () => areCoplanarContours,
  calculatePerimeter: () => calculatePerimeter_default,
  contourFinder: () => contourFinder_default,
  detectContourHoles: () => detectContourHoles_default,
  findHandlePolylineIndex: () => findHandlePolylineIndex,
  generateContourSetsFromLabelmap: () => generateContourSetsFromLabelmap,
  getContourHolesDataCanvas: () => getContourHolesDataCanvas,
  getContourHolesDataWorld: () => getContourHolesDataWorld,
  getDeduplicatedVTKPolyDataPoints: () => getDeduplicatedVTKPolyDataPoints,
  updateContourPolyline: () => updateContourPolyline
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/areCoplanarContours.js
function areCoplanarContours(firstAnnotation, secondAnnotation) {
  const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;
  const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;
  const dot = vec3_exports.dot(firstViewPlaneNormal, secondViewPlaneNormal);
  const parallelPlanes = common_exports.equals(1, Math.abs(dot));
  if (!parallelPlanes) {
    return false;
  }
  const { polyline: firstPolyline } = firstAnnotation.data.contour;
  const { polyline: secondPolyline } = secondAnnotation.data.contour;
  const firstDistance = vec3_exports.dot(firstViewPlaneNormal, firstPolyline[0]);
  const secondDistance = vec3_exports.dot(firstViewPlaneNormal, secondPolyline[0]);
  return common_exports.equals(firstDistance, secondDistance);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js
function findNextLink(line, lines, contourPoints) {
  let index = -1;
  lines.forEach((cell, i) => {
    if (index >= 0) {
      return;
    }
    if (cell.a == line.b) {
      index = i;
    }
  });
  if (index >= 0) {
    const nextLine = lines[index];
    lines.splice(index, 1);
    contourPoints.push(nextLine.b);
    if (contourPoints[0] == nextLine.b) {
      return {
        remainingLines: lines,
        contourPoints,
        type: "CLOSED_PLANAR"
      };
    }
    return findNextLink(nextLine, lines, contourPoints);
  }
  return {
    remainingLines: lines,
    contourPoints,
    type: "OPEN_PLANAR"
  };
}
function findContours(lines) {
  if (lines.length == 0) {
    return [];
  }
  const contourPoints = [];
  const firstCell = lines.shift();
  contourPoints.push(firstCell.a);
  contourPoints.push(firstCell.b);
  const result = findNextLink(firstCell, lines, contourPoints);
  if (result.remainingLines.length == 0) {
    return [
      {
        type: result.type,
        contourPoints: result.contourPoints
      }
    ];
  } else {
    const extraContours = findContours(result.remainingLines);
    extraContours.push({
      type: result.type,
      contourPoints: result.contourPoints
    });
    return extraContours;
  }
}
function findContoursFromReducedSet(lines) {
  return findContours(lines);
}
var contourFinder_default = {
  findContours,
  findContoursFromReducedSet
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getDeduplicatedVTKPolyDataPoints.js
function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {
  const points = polyData.getPoints();
  const lines = polyData.getLines();
  const pointsArray = new Array(points.getNumberOfPoints()).fill(0).map((_, i) => points.getPoint(i).slice());
  const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {
    const cell = lines.getCell(i * 3).slice();
    return { a: cell[0], b: cell[1] };
  });
  if (bypass) {
    return { points: pointsArray, lines: linesArray };
  }
  const newPoints = [];
  for (const [i, pt] of pointsArray.entries()) {
    const index = newPoints.findIndex((point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]);
    if (index >= 0) {
      linesArray.map((line) => {
        if (line.a === i) {
          line.a = index;
        }
        if (line.b === i) {
          line.b = index;
        }
        return line;
      });
    } else {
      const newIndex = newPoints.length;
      newPoints.push(pt);
      linesArray.map((line) => {
        if (line.a === i) {
          line.a = newIndex;
        }
        if (line.b === i) {
          line.b = newIndex;
        }
        return line;
      });
    }
  }
  const newLines = linesArray.filter((line) => line.a !== line.b);
  return { points: newPoints, lines: newLines };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/detectContourHoles.js
var getIsPointInsidePolygon = (point, vertices) => {
  const x = point[0];
  const y = point[1];
  let inside = false;
  for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
    const xi = vertices[i][0], yi = vertices[i][1];
    const xj = vertices[j][0], yj = vertices[j][1];
    const intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) {
      inside = !inside;
    }
  }
  return inside;
};
function checkEnclosed(outerContour, innerContour, points) {
  const vertices = [];
  outerContour.contourPoints.forEach((point) => {
    vertices.push([points[point][0], points[point][1]]);
  });
  let pointsNotEnclosed = 0;
  innerContour.contourPoints.forEach((point) => {
    const result = getIsPointInsidePolygon([points[point][0], points[point][1]], vertices);
    if (!result) {
      pointsNotEnclosed++;
    }
  });
  return pointsNotEnclosed === 0;
}
function processContourHoles(contours, points, useXOR = true) {
  const retContours = contours.filter((contour) => contour.type !== "CLOSED_PLANAR");
  const closedContours = contours.filter((contour) => contour.type === "CLOSED_PLANAR");
  const contourWithHoles = [];
  let contourWithoutHoles = [];
  closedContours.forEach((contour, index) => {
    const holes = [];
    closedContours.forEach((hContour, hIndex) => {
      if (index != hIndex) {
        if (checkEnclosed(contour, hContour, points)) {
          holes.push(hIndex);
        }
      }
    });
    if (holes.length > 0) {
      contourWithHoles.push({
        contour,
        holes
      });
    } else {
      contourWithoutHoles.push(index);
    }
  });
  if (useXOR) {
    contourWithHoles.forEach((contourHoleSet) => {
      contourHoleSet.contour.type = "CLOSEDPLANAR_XOR";
      retContours.push(contourHoleSet.contour);
      contourHoleSet.holes.forEach((holeIndex) => {
        closedContours[holeIndex].type = "CLOSEDPLANAR_XOR";
        retContours.push(closedContours[holeIndex]);
        contourWithoutHoles = contourWithoutHoles.filter((contourIndex2) => {
          return contourIndex2 !== holeIndex;
        });
      });
    });
    contourWithoutHoles.forEach((contourIndex2) => {
      retContours.push(closedContours[contourIndex2]);
    });
  } else {
  }
  return retContours;
}
var detectContourHoles_default = { processContourHoles };

// node_modules/@kitware/vtk.js/Common/DataModel/EdgeLocator.js
var EdgeLocator = class {
  constructor() {
    let oriented = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    this.oriented = oriented;
    this.edgeMap = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.edgeMap.clear();
  }
  computeEdgeKey(pointId0, pointId1) {
    return this.oriented || pointId0 < pointId1 ? (
      // Cantor pairing function:
      0.5 * (pointId0 * pointId1) * (pointId0 * pointId1 + 1) + pointId1
    ) : 0.5 * (pointId1 * pointId0) * (pointId1 * pointId0 + 1) + pointId0;
  }
  insertUniqueEdge(pointId0, pointId1, newEdgeValue) {
    const key = this.computeEdgeKey(pointId0, pointId1);
    let node = this.edgeMap.get(key);
    if (!node) {
      node = {
        key,
        edgeId: this.edgeMap.size,
        value: newEdgeValue
      };
      this.edgeMap.set(key, node);
    }
    return node;
  }
  insertEdge(pointId0, pointId1, newEdgeValue) {
    const key = this.computeEdgeKey(pointId0, pointId1);
    const node = {
      key,
      edgeId: this.edgeMap.size,
      value: newEdgeValue
    };
    this.edgeMap.set(key, node);
    return node;
  }
  isInsertedEdge(pointId0, pointId1) {
    const key = this.computeEdgeKey(pointId0, pointId1);
    return this.edgeMap.get(key);
  }
  static getEdgePointIds(node) {
    const n = 0.5 * (-1 + Math.sqrt(8 * node.key + 1));
    const pointId0 = node.key - 0.5 * (n + 1) * n;
    const pointId1 = n - pointId0;
    return [pointId0, pointId1];
  }
};
function newInstance() {
  let initialValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return new EdgeLocator(initialValues.oriented);
}
var vtkEdgeLocator = {
  newInstance
};

// node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares/caseTable.js
var MARCHING_SQUARES_CASES = [
  [-1, -1, -1, -1, -1],
  [0, 3, -1, -1, -1],
  [1, 0, -1, -1, -1],
  [1, 3, -1, -1, -1],
  [2, 1, -1, -1, -1],
  [0, 3, 2, 1, -1],
  [2, 0, -1, -1, -1],
  [2, 3, -1, -1, -1],
  [3, 2, -1, -1, -1],
  [0, 2, -1, -1, -1],
  [1, 0, 3, 2, -1],
  [1, 2, -1, -1, -1],
  [3, 1, -1, -1, -1],
  [0, 1, -1, -1, -1],
  [3, 0, -1, -1, -1],
  [-1, -1, -1, -1, -1]
  /* 15 */
];
var EDGES = [[0, 1], [1, 3], [2, 3], [0, 2]];
function getCase(index) {
  return MARCHING_SQUARES_CASES[index];
}
function getEdge(eid) {
  return EDGES[eid];
}
var vtkCaseTable = {
  getCase,
  getEdge
};

// node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js
var {
  vtkErrorMacro,
  vtkDebugMacro
} = macro;
function vtkImageMarchingSquares(publicAPI, model) {
  function getKernels() {
    let kernelX = 0;
    let kernelY = 1;
    if (model.slicingMode === 1) {
      kernelX = 0;
      kernelY = 2;
    } else if (model.slicingMode === 0) {
      kernelX = 1;
      kernelY = 2;
    }
    return [kernelX, kernelY];
  }
  model.classHierarchy.push("vtkImageMarchingSquares");
  publicAPI.getContourValues = () => model.contourValues;
  publicAPI.setContourValues = (cValues) => {
    model.contourValues = cValues;
    publicAPI.modified();
  };
  const ids = [];
  const pixelScalars = [];
  const pixelPts = [];
  const edgeLocator = vtkEdgeLocator.newInstance();
  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {
    const [i, j, k] = ijk;
    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i;
    ids[1] = ids[0] + increments[kernelX];
    ids[2] = ids[0] + increments[kernelY];
    ids[3] = ids[2] + increments[kernelX];
    for (let ii = 0; ii < 4; ++ii) {
      pixelScalars[ii] = scalars[ids[ii]];
    }
  };
  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {
    const i = ijk[kernelX];
    const j = ijk[kernelY];
    pixelPts[0] = origin[kernelX] + i * spacing[kernelX];
    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];
    pixelPts[2] = pixelPts[0] + spacing[kernelX];
    pixelPts[3] = pixelPts[1];
    pixelPts[4] = pixelPts[0];
    pixelPts[5] = pixelPts[1] + spacing[kernelY];
    pixelPts[6] = pixelPts[2];
    pixelPts[7] = pixelPts[5];
  };
  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {
    var _a2;
    const k = ijk[model.slicingMode];
    const CASE_MASK = [1, 2, 8, 4];
    const xyz = [];
    let pId;
    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);
    let index = 0;
    for (let idx = 0; idx < 4; idx++) {
      if (pixelScalars[idx] >= cVal) {
        index |= CASE_MASK[idx];
      }
    }
    const pixelLines = vtkCaseTable.getCase(index);
    if (pixelLines[0] < 0) {
      return;
    }
    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);
    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];
    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {
      lines.push(2);
      for (let eid = 0; eid < 2; eid++) {
        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);
        pId = void 0;
        if (model.mergePoints) {
          pId = (_a2 = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])) == null ? void 0 : _a2.value;
        }
        if (pId === void 0) {
          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);
          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);
          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);
          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);
          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);
          xyz[model.slicingMode] = z;
          pId = points.length / 3;
          points.push(xyz[0], xyz[1], xyz[2]);
          if (model.mergePoints) {
            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);
          }
        }
        lines.push(pId);
      }
    }
  };
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input) {
      vtkErrorMacro("Invalid or missing input");
      return;
    }
    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {
      vtkErrorMacro("Invalid or missing slicing mode");
      return;
    }
    console.time("msquares");
    const origin = input.getOrigin();
    const spacing = input.getSpacing();
    const dims = input.getDimensions();
    const extent = input.getExtent();
    const increments = input.computeIncrements(extent);
    const scalars = input.getPointData().getScalars().getData();
    const [kernelX, kernelY] = getKernels();
    const points = [];
    const lines = [];
    let k = Math.round(model.slice);
    if (k >= dims[model.slicingMode]) {
      k = 0;
    }
    const ijk = [0, 0, 0];
    ijk[model.slicingMode] = k;
    for (let cv = 0; cv < model.contourValues.length; ++cv) {
      for (let j = 0; j < dims[kernelY] - 1; ++j) {
        ijk[kernelY] = j;
        for (let i = 0; i < dims[kernelX] - 1; ++i) {
          ijk[kernelX] = i;
          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);
        }
      }
      edgeLocator.initialize();
    }
    const polydata = vtkPolyData$1.newInstance();
    polydata.getPoints().setData(new Float32Array(points), 3);
    polydata.getLines().setData(new Uint32Array(lines));
    outData[0] = polydata;
    vtkDebugMacro("Produced output");
    console.timeEnd("msquares");
  };
}
var DEFAULT_VALUES = {
  contourValues: [],
  slicingMode: 2,
  slice: 0,
  mergePoints: false
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["slicingMode", "slice", "mergePoints"]);
  macro.algo(publicAPI, model, 1, 1);
  vtkImageMarchingSquares(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkImageMarchingSquares");
var vtkImageMarchingSquares$1 = {
  newInstance: newInstance2,
  extend: extend2
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/generateContourSetsFromLabelmap.js
var { Labelmap } = SegmentationRepresentations_default;
function generateContourSetsFromLabelmap({ segmentations }) {
  var _a2;
  const { representationData, segments = [0, 1] } = segmentations;
  const { volumeId: segVolumeId } = representationData[Labelmap];
  const vol = cache_default.getVolume(segVolumeId);
  if (!vol) {
    console.warn(`No volume found for ${segVolumeId}`);
    return;
  }
  const voxelManager = vol.voxelManager;
  const segData = voxelManager.getCompleteScalarDataArray();
  const numSlices = vol.dimensions[2];
  const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];
  for (let z = 0; z < numSlices; z++) {
    for (let y = 0; y < vol.dimensions[1]; y++) {
      const index = y * vol.dimensions[0] + z * pixelsPerSlice;
      segData[index] = 0;
      segData[index + vol.dimensions[0] - 1] = 0;
    }
  }
  const ContourSets = [];
  const { FrameOfReferenceUID } = vol.metadata;
  const numSegments = segments.length;
  for (let segIndex = 0; segIndex < numSegments; segIndex++) {
    const segment = segments[segIndex];
    if (!segment) {
      continue;
    }
    const sliceContours = [];
    const scalars = vtkDataArray$1.newInstance({
      name: "Scalars",
      numberOfComponents: 1,
      size: pixelsPerSlice * numSlices,
      dataType: "Uint8Array"
    });
    const { containedSegmentIndices } = segment;
    for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {
      if (isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)) {
        continue;
      }
      const frameStart = sliceIndex * pixelsPerSlice;
      try {
        for (let i = 0; i < pixelsPerSlice; i++) {
          const value = segData[i + frameStart];
          if (value === segIndex || (containedSegmentIndices == null ? void 0 : containedSegmentIndices.has(value))) {
            scalars.setValue(i + frameStart, 1);
          } else {
            scalars.setValue(i, 0);
          }
        }
        const mSquares = vtkImageMarchingSquares$1.newInstance({
          slice: sliceIndex
        });
        const imageDataCopy = vtkImageData$1.newInstance();
        imageDataCopy.shallowCopy(vol.imageData);
        imageDataCopy.getPointData().setScalars(scalars);
        mSquares.setInputData(imageDataCopy);
        const cValues = [1];
        mSquares.setContourValues(cValues);
        mSquares.setMergePoints(false);
        const msOutput = mSquares.getOutputData();
        const reducedSet = getDeduplicatedVTKPolyDataPoints(msOutput);
        if ((_a2 = reducedSet.points) == null ? void 0 : _a2.length) {
          const contours = findContoursFromReducedSet(reducedSet.lines);
          sliceContours.push({
            contours,
            polyData: reducedSet,
            FrameNumber: sliceIndex + 1,
            sliceIndex,
            FrameOfReferenceUID
          });
        }
      } catch (e) {
        console.warn(sliceIndex);
        console.warn(e);
      }
    }
    const metadata = {
      FrameOfReferenceUID
    };
    const ContourSet = {
      label: segment.label,
      color: segment.color,
      metadata,
      sliceContours
    };
    ContourSets.push(ContourSet);
  }
  return ContourSets;
}
function isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {
  const startIdx = sliceIndex * pixelsPerSlice;
  const endIdx = startIdx + pixelsPerSlice;
  for (let i = startIdx; i < endIdx; i++) {
    if (segData[i] === segIndex) {
      return false;
    }
  }
  return true;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js
var RectangleROIStartEndThreshold = class {
  constructor() {
  }
  static getContourSequence(toolData, metadataProvider) {
    const { data } = toolData;
    const { projectionPoints, projectionPointsImageIds } = data.cachedStats;
    return projectionPoints.map((point, index) => {
      const ContourData = getPointData(point);
      const ContourImageSequence = getContourImageSequence(projectionPointsImageIds[index], metadataProvider);
      return {
        NumberOfContourPoints: ContourData.length / 3,
        ContourImageSequence,
        ContourGeometricType: "CLOSED_PLANAR",
        ContourData
      };
    });
  }
};
RectangleROIStartEndThreshold.toolName = "RectangleROIStartEndThreshold";
function getPointData(points) {
  const orderedPoints = [
    ...points[0],
    ...points[1],
    ...points[3],
    ...points[2]
  ];
  const pointsArray = orderedPoints.flat();
  const pointsArrayWithPrecision = pointsArray.map((point) => {
    return point.toFixed(2);
  });
  return pointsArrayWithPrecision;
}
function getContourImageSequence(imageId, metadataProvider) {
  const sopCommon = metadataProvider.get("sopCommonModule", imageId);
  return {
    ReferencedSOPClassUID: sopCommon.sopClassUID,
    ReferencedSOPInstanceUID: sopCommon.sopInstanceUID
  };
}
var RectangleROIStartEndThreshold_default = RectangleROIStartEndThreshold;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/AnnotationToPointData.js
function validateAnnotation(annotation) {
  if (!(annotation == null ? void 0 : annotation.data)) {
    throw new Error("Tool data is empty");
  }
  if (!annotation.metadata || annotation.metadata.referencedImageId) {
    throw new Error("Tool data is not associated with any imageId");
  }
}
var _AnnotationToPointData = class _AnnotationToPointData {
  constructor() {
  }
  static convert(annotation, index, metadataProvider) {
    validateAnnotation(annotation);
    const { toolName } = annotation.metadata;
    const toolClass = _AnnotationToPointData.TOOL_NAMES[toolName];
    if (!toolClass) {
      throw new Error(`Unknown tool type: ${toolName}, cannot convert to RTSSReport`);
    }
    const ContourSequence = toolClass.getContourSequence(annotation, metadataProvider);
    const color = [
      Math.floor(Math.random() * 255),
      Math.floor(Math.random() * 255),
      Math.floor(Math.random() * 255)
    ];
    return {
      ReferencedROINumber: index + 1,
      ROIDisplayColor: color,
      ContourSequence
    };
  }
  static register(toolClass) {
    _AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;
  }
};
_AnnotationToPointData.TOOL_NAMES = {};
var AnnotationToPointData = _AnnotationToPointData;
AnnotationToPointData.register(RectangleROIStartEndThreshold_default);
var AnnotationToPointData_default = AnnotationToPointData;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/acceptAutogeneratedInterpolations.js
function acceptAutogeneratedInterpolations(annotationGroupSelector, selector) {
  InterpolationManager.acceptAutoGenerated(annotationGroupSelector, selector);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js
var { isEqual: isEqual3 } = utilities_exports;
function findHandlePolylineIndex(annotation, handleIndex) {
  const { polyline } = annotation.data.contour;
  const { points } = annotation.data.handles;
  const { length } = points;
  if (handleIndex === length) {
    return polyline.length;
  }
  if (handleIndex < 0) {
    handleIndex = (handleIndex + length) % length;
  }
  if (handleIndex === 0) {
    return 0;
  }
  const handle = points[handleIndex];
  const index = polyline.findIndex((point) => isEqual3(handle, point));
  if (index !== -1) {
    return index;
  }
  let closestDistance = Infinity;
  return polyline.reduce((closestIndex, point, testIndex) => {
    const distance = vec3_exports.squaredDistance(point, handle);
    if (distance < closestDistance) {
      closestDistance = distance;
      return testIndex;
    }
    return closestIndex;
  }, -1);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js
var segmentation_exports = {};
__export(segmentation_exports, {
  IslandRemoval: () => IslandRemoval,
  LabelmapMemo: () => createLabelmapMemo_exports,
  VolumetricCalculator: () => VolumetricCalculator,
  contourAndFindLargestBidirectional: () => contourAndFindLargestBidirectional,
  createBidirectionalToolData: () => createBidirectionalToolData,
  createLabelmapVolumeForViewport: () => createLabelmapVolumeForViewport,
  createMergedLabelmapForIndex: () => createMergedLabelmapForIndex_default,
  floodFill: () => floodFill_default,
  getBrushSizeForToolGroup: () => getBrushSizeForToolGroup,
  getBrushThresholdForToolGroup: () => getBrushThresholdForToolGroup,
  getBrushToolInstances: () => getBrushToolInstances,
  getHoveredContourSegmentationAnnotation: () => getHoveredContourSegmentationAnnotation,
  getSegmentIndexAtLabelmapBorder: () => getSegmentIndexAtLabelmapBorder,
  getSegmentIndexAtWorldPoint: () => getSegmentIndexAtWorldPoint,
  getUniqueSegmentIndices: () => getUniqueSegmentIndices,
  growCut: () => growCut_exports,
  invalidateBrushCursor: () => invalidateBrushCursor,
  rectangleROIThresholdVolumeByRange: () => rectangleROIThresholdVolumeByRange_default,
  segmentContourAction: () => segmentContourAction,
  setBrushSizeForToolGroup: () => setBrushSizeForToolGroup,
  setBrushThresholdForToolGroup: () => setBrushThresholdForToolGroup,
  thresholdSegmentationByRange: () => thresholdSegmentationByRange_default,
  thresholdVolumeByRange: () => thresholdVolumeByRange_default,
  triggerSegmentationRender: () => triggerSegmentationRender,
  triggerSegmentationRenderBySegmentationId: () => triggerSegmentationRenderBySegmentationId
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdVolumeByRange.js
function thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, options) {
  const { imageData: segmentationImageData } = segmentationVolume;
  const { overwrite, boundsIJK } = options;
  const overlapType = (options == null ? void 0 : options.overlapType) || 0;
  const segVoxelManager = segmentationVolume.voxelManager;
  const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
  if (overwrite) {
    for (let i = 0; i < scalarDataLength; i++) {
      segVoxelManager.setAtIndex(i, 0);
    }
  }
  const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);
  let overlaps, total, range2;
  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {
    const callbackOverlap = ({ value }) => {
      total = total + 1;
      if (value >= range2.lower && value <= range2.upper) {
        overlaps = overlaps + 1;
      }
    };
    const { imageData, dimensions, lower, upper } = volumeInfo;
    const overlapBounds = getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter);
    total = 0;
    overlaps = 0;
    range2 = { lower, upper };
    let overlapTest = false;
    const { voxelManager: voxelManager2 } = imageData.get("voxelManager");
    voxelManager2.forEach(callbackOverlap, {
      imageData,
      boundsIJK: overlapBounds
    });
    if (overlapType === 0) {
      overlapTest = overlaps > 0;
    } else if (overlapType == 1) {
      overlapTest = overlaps === total;
    }
    return overlapTest;
  };
  const testRange = (volumeInfo, pointIJK) => {
    const { imageData, lower, upper } = volumeInfo;
    const voxelManager2 = imageData.get("voxelManager").voxelManager;
    const offset = voxelManager2.toIndex(pointIJK);
    const value = voxelManager2.getAtIndex(offset);
    if (value <= lower || value >= upper) {
      return false;
    } else {
      return true;
    }
  };
  const callback = ({ index, pointIJK, pointLPS }) => {
    let insert = volumeInfoList.length > 0;
    for (let i = 0; i < volumeInfoList.length; i++) {
      if (volumeInfoList[i].volumeSize === scalarDataLength) {
        insert = testRange(volumeInfoList[i], pointIJK);
      } else {
        insert = testOverlapRange(volumeInfoList[i], volumeInfoList[baseVolumeIdx].spacing, pointLPS);
      }
      if (!insert) {
        break;
      }
    }
    if (insert) {
      segVoxelManager.setAtIndex(index, options.segmentIndex || 1);
    }
  };
  const voxelManager = segmentationVolume.voxelManager;
  voxelManager.forEach(callback, {
    imageData: segmentationImageData,
    boundsIJK
  });
  triggerSegmentationDataModified(segmentationVolume.volumeId);
  return segmentationVolume;
}
var thresholdVolumeByRange_default = thresholdVolumeByRange;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js
var { transformWorldToIndex: transformWorldToIndex2 } = utilities_exports;
var _RectangleROITool = class _RectangleROITool extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      storePointData: false,
      shadow: true,
      preventHandleOutsideImage: false,
      getTextLines: defaultGetTextLines2,
      statsCalculator: BasicStatsCalculator
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        invalidated: true,
        highlighted: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId,
          ...viewport.getViewReference({ points: [worldPos] })
        },
        data: {
          label: "",
          handles: {
            points: [
              [...worldPos],
              [...worldPos],
              [...worldPos],
              [...worldPos]
            ],
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            },
            activeHandleIndex: null
          },
          cachedStats: {}
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex: 3,
        movingTextBox: false,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const { points } = data.handles;
      const canvasPoint1 = viewport.worldToCanvas(points[0]);
      const canvasPoint2 = viewport.worldToCanvas(points[3]);
      const rect = this._getRectangleImageCoordinates([
        canvasPoint1,
        canvasPoint2
      ]);
      const point = [canvasCoords[0], canvasCoords[1]];
      const { left, top, width, height } = rect;
      const distanceToPoint5 = distanceToPoint4([left, top, width, height], point);
      if (distanceToPoint5 <= proximity) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        movingTextBox: false
      };
      this._activateModify(element);
      hideElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this.handleSelectedCallback = (evt, annotation, handle) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { data } = annotation;
      annotation.highlighted = true;
      let movingTextBox = false;
      let handleIndex;
      if (handle.worldPosition) {
        movingTextBox = true;
      } else {
        handleIndex = data.handles.points.findIndex((p) => p === handle);
      }
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex,
        movingTextBox
      };
      this._activateModify(element);
      hideElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      this.doneEditMemo();
      this.editData = null;
      this.isDrawing = false;
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation } = this.editData;
      this.createMemo(element, annotation, { newAnnotation });
      const { data } = annotation;
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { points } = data.handles;
        points.forEach((point) => {
          point[0] += worldPosDelta[0];
          point[1] += worldPosDelta[1];
          point[2] += worldPosDelta[2];
        });
        annotation.invalidated = true;
      } else {
        const { currentPoints } = eventDetail;
        const enabledElement2 = getEnabledElement(element);
        const { worldToCanvas, canvasToWorld } = enabledElement2.viewport;
        const worldPos = currentPoints.world;
        const { points } = data.handles;
        points[handleIndex] = [...worldPos];
        let bottomLeftCanvas;
        let bottomRightCanvas;
        let topLeftCanvas;
        let topRightCanvas;
        let bottomLeftWorld;
        let bottomRightWorld;
        let topLeftWorld;
        let topRightWorld;
        switch (handleIndex) {
          case 0:
          case 3:
            bottomLeftCanvas = worldToCanvas(points[0]);
            topRightCanvas = worldToCanvas(points[3]);
            bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
            topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
            bottomRightWorld = canvasToWorld(bottomRightCanvas);
            topLeftWorld = canvasToWorld(topLeftCanvas);
            points[1] = bottomRightWorld;
            points[2] = topLeftWorld;
            break;
          case 1:
          case 2:
            bottomRightCanvas = worldToCanvas(points[1]);
            topLeftCanvas = worldToCanvas(points[2]);
            bottomLeftCanvas = [
              topLeftCanvas[0],
              bottomRightCanvas[1]
            ];
            topRightCanvas = [
              bottomRightCanvas[0],
              topLeftCanvas[1]
            ];
            bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
            topRightWorld = canvasToWorld(topRightCanvas);
            points[0] = bottomLeftWorld;
            points[3] = topRightWorld;
            break;
        }
        annotation.invalidated = true;
      }
      this.editData.hasMoved = true;
      const enabledElement = getEnabledElement(element);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.cancel = (element) => {
      if (this.isDrawing) {
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        resetElementCursor(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        const { data } = annotation;
        annotation.highlighted = false;
        data.handles.activeHandleIndex = null;
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        if (newAnnotation) {
          triggerAnnotationCompleted(annotation);
        }
        this.editData = null;
        return annotation.annotationUID;
      }
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const targetId = this.getTargetId(viewport);
      const renderingEngine = viewport.getRenderingEngine();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { points, activeHandleIndex } = data.handles;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth, lineDash } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        const { viewPlaneNormal, viewUp } = viewport.getCamera();
        if (!data.cachedStats[targetId] || data.cachedStats[targetId].areaUnit == null) {
          data.cachedStats[targetId] = {
            Modality: null,
            area: null,
            max: null,
            mean: null,
            stdDev: null,
            areaUnit: null
          };
          this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);
        } else if (annotation.invalidated) {
          this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);
          if (viewport instanceof VolumeViewport_default) {
            const { referencedImageId } = annotation.metadata;
            for (const targetId2 in data.cachedStats) {
              if (targetId2.startsWith("imageId")) {
                const viewports = renderingEngine.getStackViewports();
                const invalidatedStack = viewports.find((vp) => {
                  const referencedImageURI = utilities_exports.imageIdToURI(referencedImageId);
                  const hasImageURI = vp.hasImageURI(referencedImageURI);
                  const currentImageURI = utilities_exports.imageIdToURI(vp.getCurrentImageId());
                  return hasImageURI && currentImageURI !== referencedImageURI;
                });
                if (invalidatedStack) {
                  delete data.cachedStats[targetId2];
                }
              }
            }
          }
        }
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        let activeHandleCanvasCoords;
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
            color
          });
        }
        const dataId = `${annotationUID}-rect`;
        const rectangleUID = "0";
        drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, {
          color,
          lineDash,
          lineWidth
        }, dataId);
        renderStatus = true;
        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        if (!options.visibility) {
          data.handles.textBox = {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          };
          continue;
        }
        const textLines = this.configuration.getTextLines(data, targetId);
        if (!textLines || textLines.length === 0) {
          continue;
        }
        if (!data.handles.textBox.hasMoved) {
          const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);
          data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
        }
        const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
        const textBoxUID = "1";
        const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
        const { x: left, y: top, width, height } = boundingBox;
        data.handles.textBox.worldBoundingBox = {
          topLeft: viewport.canvasToWorld([left, top]),
          topRight: viewport.canvasToWorld([left + width, top]),
          bottomLeft: viewport.canvasToWorld([left, top + height]),
          bottomRight: viewport.canvasToWorld([left + width, top + height])
        };
      }
      return renderStatus;
    };
    this._getRectangleImageCoordinates = (points) => {
      const [point0, point1] = points;
      return {
        left: Math.min(point0[0], point1[0]),
        top: Math.min(point0[1], point1[1]),
        width: Math.abs(point0[0] - point1[0]),
        height: Math.abs(point0[1] - point1[1])
      };
    };
    this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {
      var _a2, _b2, _c;
      const { data } = annotation;
      const { viewport } = enabledElement;
      const { element } = viewport;
      const worldPos1 = data.handles.points[0];
      const worldPos2 = data.handles.points[3];
      const { cachedStats } = data;
      const targetIds = Object.keys(cachedStats);
      for (let i = 0; i < targetIds.length; i++) {
        const targetId = targetIds[i];
        const image = this.getTargetImageData(targetId);
        if (!image) {
          continue;
        }
        const { dimensions, imageData, metadata, voxelManager } = image;
        const pos1Index = transformWorldToIndex2(imageData, worldPos1);
        pos1Index[0] = Math.floor(pos1Index[0]);
        pos1Index[1] = Math.floor(pos1Index[1]);
        pos1Index[2] = Math.floor(pos1Index[2]);
        const pos2Index = transformWorldToIndex2(imageData, worldPos2);
        pos2Index[0] = Math.floor(pos2Index[0]);
        pos2Index[1] = Math.floor(pos2Index[1]);
        pos2Index[2] = Math.floor(pos2Index[2]);
        if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {
          this.isHandleOutsideImage = false;
          const iMin = Math.min(pos1Index[0], pos2Index[0]);
          const iMax = Math.max(pos1Index[0], pos2Index[0]);
          const jMin = Math.min(pos1Index[1], pos2Index[1]);
          const jMax = Math.max(pos1Index[1], pos2Index[1]);
          const kMin = Math.min(pos1Index[2], pos2Index[2]);
          const kMax = Math.max(pos1Index[2], pos2Index[2]);
          const boundsIJK = [
            [iMin, iMax],
            [jMin, jMax],
            [kMin, kMax]
          ];
          const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);
          const handles = [pos1Index, pos2Index];
          const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);
          const area = Math.abs(worldWidth * worldHeight) / (scale * scale);
          const pixelUnitsOptions = {
            isPreScaled: isViewportPreScaled(viewport, targetId),
            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId)
          };
          const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
          const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
            boundsIJK,
            imageData,
            returnPoints: this.configuration.storePointData
          });
          const stats = this.configuration.statsCalculator.getStatistics();
          cachedStats[targetId] = {
            Modality: metadata.Modality,
            area,
            mean: (_a2 = stats.mean) == null ? void 0 : _a2.value,
            stdDev: (_b2 = stats.stdDev) == null ? void 0 : _b2.value,
            max: (_c = stats.max) == null ? void 0 : _c.value,
            statsArray: stats.array,
            pointsInShape,
            areaUnit,
            modalityUnit
          };
        } else {
          this.isHandleOutsideImage = true;
          cachedStats[targetId] = {
            Modality: metadata.Modality
          };
        }
      }
      annotation.invalidated = false;
      triggerAnnotationModified(annotation, element);
      return cachedStats;
    };
    this._isInsideVolume = (index1, index2, dimensions) => {
      return utilities_exports.indexWithinDimensions(index1, dimensions) && utilities_exports.indexWithinDimensions(index2, dimensions);
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
};
_RectangleROITool.hydrate = (viewportId, points, options) => {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
  const { viewPlaneNormal, viewUp } = viewport.getCamera();
  const instance = new _RectangleROITool();
  const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);
  const annotation = {
    annotationUID: (options == null ? void 0 : options.annotationUID) || utilities_exports.uuidv4(),
    data: {
      handles: {
        points,
        activeHandleIndex: null
      },
      label: "",
      cachedStats: {}
    },
    highlighted: false,
    autoGenerated: false,
    invalidated: false,
    isLocked: false,
    isVisible: true,
    metadata: {
      toolName: instance.getToolName(),
      viewPlaneNormal,
      FrameOfReferenceUID,
      referencedImageId,
      ...options
    }
  };
  addAnnotation(annotation, viewport.element);
  triggerAnnotationRenderForViewportIds_default([viewport.id]);
};
var RectangleROITool = _RectangleROITool;
function defaultGetTextLines2(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { area, mean, max: max2, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
  if (mean === void 0) {
    return;
  }
  const textLines = [];
  textLines.push(`Area: ${utilities_exports.roundNumber(area)} ${areaUnit}`);
  textLines.push(`Mean: ${utilities_exports.roundNumber(mean)} ${modalityUnit}`);
  textLines.push(`Max: ${utilities_exports.roundNumber(max2)} ${modalityUnit}`);
  textLines.push(`Std Dev: ${utilities_exports.roundNumber(stdDev)} ${modalityUnit}`);
  return textLines;
}
RectangleROITool.toolName = "RectangleROI";
var RectangleROITool_default = RectangleROITool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js
var { transformWorldToIndex: transformWorldToIndex3 } = utilities_exports;
var RectangleROIStartEndThresholdTool = class extends RectangleROITool_default {
  constructor(toolProps = {}, defaultToolProps = {
    configuration: {
      storePointData: false,
      numSlicesToPropagate: 10,
      computePointsInsideVolume: false,
      getTextLines: defaultGetTextLines3,
      statsCalculator: BasicStatsCalculator,
      showTextBox: false
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      let referencedImageId, imageVolume, volumeId;
      if (viewport instanceof StackViewport_default) {
        throw new Error("Stack Viewport Not implemented");
      } else {
        const targetId = this.getTargetId(viewport);
        volumeId = utilities_exports.getVolumeId(targetId);
        imageVolume = cache_default.getVolume(volumeId);
        referencedImageId = utilities_exports.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
      }
      const spacingInNormal = utilities_exports.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
      const startCoord = this._getStartCoordinate(worldPos, viewPlaneNormal);
      const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          viewPlaneNormal: [...viewPlaneNormal],
          enabledElement,
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId,
          toolName: this.getToolName(),
          volumeId,
          spacingInNormal
        },
        data: {
          label: "",
          startCoordinate: startCoord,
          endCoordinate: endCoord,
          cachedStats: {
            pointsInVolume: [],
            projectionPoints: [],
            projectionPointsImageIds: [referencedImageId],
            statistics: []
          },
          handles: {
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            },
            points: [
              [...worldPos],
              [...worldPos],
              [...worldPos],
              [...worldPos]
            ],
            activeHandleIndex: null
          },
          labelmapUID: null
        }
      };
      this._computeProjectionPoints(annotation, imageVolume);
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex: 3,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      const enabledElement = getEnabledElement(element);
      this.editData = null;
      this.isDrawing = false;
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      const targetId = this.getTargetId(enabledElement.viewport);
      const imageVolume = cache_default.getVolume(targetId.split(/volumeId:|\?/)[1]);
      if (this.configuration.calculatePointsInsideVolume) {
        this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      let annotations = getAnnotations(this.getToolName(), viewport.element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data, metadata } = annotation;
        const { startCoordinate, endCoordinate } = data;
        const { points, activeHandleIndex } = data.handles;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        styleSpecifier.annotationUID = annotationUID;
        const lineWidth = this.getStyle("lineWidth", styleSpecifier, annotation);
        const lineDash = this.getStyle("lineDash", styleSpecifier, annotation);
        const color = this.getStyle("color", styleSpecifier, annotation);
        const focalPoint = viewport.getCamera().focalPoint;
        const viewplaneNormal = viewport.getCamera().viewPlaneNormal;
        let startCoord = startCoordinate;
        let endCoord = endCoordinate;
        if (Array.isArray(startCoordinate)) {
          startCoord = this._getCoordinateForViewplaneNormal(startCoord, viewplaneNormal);
          data.startCoordinate = startCoord;
          data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = startCoord;
          data.startCoordinate = startCoord;
          data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = startCoord;
        }
        if (Array.isArray(endCoordinate)) {
          endCoord = this._getCoordinateForViewplaneNormal(endCoord, viewplaneNormal);
          data.endCoordinate = endCoord;
          data.endCoordinate = endCoord;
        }
        const roundedStartCoord = utilities_exports.roundToPrecision(startCoord);
        const roundedEndCoord = utilities_exports.roundToPrecision(endCoord);
        const coord = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);
        const roundedCoord = utilities_exports.roundToPrecision(coord);
        if (roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) || roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)) {
          continue;
        }
        if (annotation.invalidated) {
          this._throttledCalculateCachedStats(annotation, enabledElement);
        }
        let firstOrLastSlice = false;
        if (roundedCoord === roundedStartCoord || roundedCoord === roundedEndCoord) {
          firstOrLastSlice = true;
        }
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        let activeHandleCanvasCoords;
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null && firstOrLastSlice) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
            color
          });
        }
        let lineDashToUse = lineDash;
        if (!firstOrLastSlice) {
          lineDashToUse = 2;
        }
        const rectangleUID = "0";
        drawRect(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
          color,
          lineDash: lineDashToUse,
          lineWidth
        });
        renderStatus = true;
        if (this.configuration.showTextBox && this.configuration.calculatePointsInsideVolume) {
          const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
          if (!options.visibility) {
            data.handles.textBox = {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            };
            continue;
          }
          const textLines = this.configuration.getTextLines(data, { metadata });
          if (!textLines || textLines.length === 0) {
            continue;
          }
          if (!data.handles.textBox.hasMoved) {
            const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);
            data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
          }
          const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
          const textBoxUID = "1";
          const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
          const { x: left, y: top, width, height } = boundingBox;
          data.handles.textBox.worldBoundingBox = {
            topLeft: viewport.canvasToWorld([left, top]),
            topRight: viewport.canvasToWorld([left + width, top]),
            bottomLeft: viewport.canvasToWorld([left, top + height]),
            bottomRight: viewport.canvasToWorld([left + width, top + height])
          };
        }
      }
      return renderStatus;
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStatsTool, 100, { trailing: true });
  }
  _computeProjectionPoints(annotation, imageVolume) {
    const { data, metadata } = annotation;
    const { viewPlaneNormal, spacingInNormal } = metadata;
    const { imageData } = imageVolume;
    const { startCoordinate, endCoordinate } = data;
    const { points } = data.handles;
    const startIJK = transformWorldToIndex3(imageData, points[0]);
    const endIJK = transformWorldToIndex3(imageData, points[0]);
    const startWorld = vec3_exports.create();
    imageData.indexToWorldVec3(startIJK, startWorld);
    const endWorld = vec3_exports.create();
    imageData.indexToWorldVec3(endIJK, endWorld);
    if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {
      startWorld[2] = startCoordinate;
      endWorld[2] = endCoordinate;
    } else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {
      startWorld[0] = startCoordinate;
      endWorld[0] = endCoordinate;
    } else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {
      startWorld[1] = startCoordinate;
      endWorld[1] = endCoordinate;
    }
    const distance = vec3_exports.distance(startWorld, endWorld);
    const newProjectionPoints = [];
    for (let dist = 0; dist < distance; dist += spacingInNormal) {
      newProjectionPoints.push(points.map((point) => {
        const newPoint = vec3_exports.create();
        vec3_exports.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);
        return Array.from(newPoint);
      }));
    }
    data.cachedStats.projectionPoints = newProjectionPoints;
  }
  _computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement) {
    var _a2, _b2, _c;
    const { data, metadata } = annotation;
    const { viewPlaneNormal, viewUp } = metadata;
    const { viewport } = enabledElement;
    const projectionPoints = data.cachedStats.projectionPoints;
    const pointsInsideVolume = [[]];
    const image = this.getTargetImageData(targetId);
    const worldPos1 = data.handles.points[0];
    const worldPos2 = data.handles.points[3];
    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);
    const measureInfo = getCalibratedLengthUnitsAndScale(image, data.habdles);
    const area = Math.abs(worldWidth * worldHeight) / (measureInfo.scale * measureInfo.scale);
    const modalityUnitOptions = {
      isPreScaled: isViewportPreScaled(viewport, targetId),
      isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId)
    };
    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
    for (let i = 0; i < projectionPoints.length; i++) {
      if (!imageVolume) {
        continue;
      }
      const projectionPoint = projectionPoints[i][0];
      const { dimensions, imageData, voxelManager } = imageVolume;
      const worldPos1Index = transformWorldToIndex3(imageData, worldPos1);
      const worldProjectionPointIndex = transformWorldToIndex3(imageData, projectionPoint);
      const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
      worldPos1Index[0] = Math.floor(worldPos1Index[0]);
      worldPos1Index[1] = Math.floor(worldPos1Index[1]);
      worldPos1Index[2] = Math.floor(worldPos1Index[2]);
      worldPos1Index[indexOfProjection] = worldProjectionPointIndex[indexOfProjection];
      const worldPos2Index = transformWorldToIndex3(imageData, worldPos2);
      worldPos2Index[0] = Math.floor(worldPos2Index[0]);
      worldPos2Index[1] = Math.floor(worldPos2Index[1]);
      worldPos2Index[2] = Math.floor(worldPos2Index[2]);
      worldPos2Index[indexOfProjection] = worldProjectionPointIndex[indexOfProjection];
      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
        this.isHandleOutsideImage = false;
        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
        const boundsIJK = [
          [iMin, iMax],
          [jMin, jMax],
          [kMin, kMax]
        ];
        const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
          boundsIJK,
          imageData,
          returnPoints: this.configuration.storePointData
        });
        pointsInsideVolume.push(pointsInShape);
      }
    }
    const stats = this.configuration.statsCalculator.getStatistics();
    data.cachedStats.pointsInVolume = pointsInsideVolume;
    data.cachedStats.statistics = {
      Modality: metadata.Modality,
      area,
      mean: (_a2 = stats.mean) == null ? void 0 : _a2.value,
      stdDev: (_b2 = stats.stdDev) == null ? void 0 : _b2.value,
      max: (_c = stats.max) == null ? void 0 : _c.value,
      statsArray: stats.array,
      areaUnit: measureInfo.areaUnit,
      modalityUnit
    };
  }
  _calculateCachedStatsTool(annotation, enabledElement) {
    const data = annotation.data;
    const { viewport } = enabledElement;
    const { cachedStats } = data;
    const targetId = this.getTargetId(viewport);
    const imageVolume = cache_default.getVolume(targetId.split(/volumeId:|\?/)[1]);
    this._computeProjectionPoints(annotation, imageVolume);
    if (this.configuration.calculatePointsInsideVolume) {
      this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
    }
    if (this.configuration.calculatePointsInsideVolume) {
      this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
    }
    annotation.invalidated = false;
    triggerAnnotationModified(annotation, viewport.element);
    return cachedStats;
  }
  _getStartCoordinate(worldPos, viewPlaneNormal) {
    const startPos = worldPos;
    const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);
    return startCoord;
  }
  _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
    const endPos = vec3_exports.create();
    vec3_exports.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagate * spacingInNormal);
    const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);
    return endCoord;
  }
  _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {
    const viewplaneNormalAbs = [
      Math.abs(viewPlaneNormal[0]),
      Math.abs(viewPlaneNormal[1]),
      Math.abs(viewPlaneNormal[2])
    ];
    const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));
    return indexOfDirection;
  }
  _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {
    const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
    return pos[indexOfDirection];
  }
};
function defaultGetTextLines3(data, _context = {}) {
  const cachedVolumeStats = data.cachedStats.statistics;
  const { area, mean, max: max2, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
  if (mean === void 0) {
    return;
  }
  const textLines = [];
  textLines.push(`Area: ${utilities_exports.roundNumber(area)} ${areaUnit}`);
  textLines.push(`Mean: ${utilities_exports.roundNumber(mean)} ${modalityUnit}`);
  textLines.push(`Max: ${utilities_exports.roundNumber(max2)} ${modalityUnit}`);
  textLines.push(`Std Dev: ${utilities_exports.roundNumber(stdDev)} ${modalityUnit}`);
  return textLines;
}
RectangleROIStartEndThresholdTool.toolName = "RectangleROIStartEndThreshold";
var RectangleROIStartEndThresholdTool_default = RectangleROIStartEndThresholdTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js
var RectangleROIThresholdTool = class extends RectangleROITool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      shadow: true,
      preventHandleOutsideImage: false
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const targetId = this.getTargetId(viewport);
      let referencedImageId, volumeId;
      if (viewport instanceof StackViewport_default) {
        referencedImageId = targetId.split("imageId:")[1];
      } else {
        volumeId = utilities_exports.getVolumeId(targetId);
        const imageVolume = cache_default.getVolume(volumeId);
        referencedImageId = utilities_exports.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
      }
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          viewPlaneNormal: [...viewPlaneNormal],
          enabledElement,
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId,
          toolName: this.getToolName(),
          volumeId
        },
        data: {
          label: "",
          handles: {
            textBox: {
              hasMoved: false,
              worldPosition: null,
              worldBoundingBox: null
            },
            points: [
              [...worldPos],
              [...worldPos],
              [...worldPos],
              [...worldPos]
            ],
            activeHandleIndex: null
          },
          segmentationId: null
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex: 3,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { points, activeHandleIndex } = data.handles;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        styleSpecifier.annotationUID = annotationUID;
        const lineWidth = this.getStyle("lineWidth", styleSpecifier, annotation);
        const lineDash = this.getStyle("lineDash", styleSpecifier, annotation);
        const color = this.getStyle("color", styleSpecifier, annotation);
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        triggerAnnotationModified(annotation, element);
        let activeHandleCanvasCoords;
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
            color
          });
        }
        const rectangleUID = "0";
        drawRect(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
          color,
          lineDash,
          lineWidth
        });
        renderStatus = true;
      }
      return renderStatus;
    };
  }
};
RectangleROIThresholdTool.toolName = "RectangleROIThreshold";
var RectangleROIThresholdTool_default = RectangleROIThresholdTool;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.js
function getBoundsIJKFromRectangleAnnotations(annotations, referenceVolume, options = {}) {
  const AllBoundsIJK = [];
  annotations.forEach((annotation) => {
    var _a2, _b2;
    const { data } = annotation;
    const { points } = data.handles;
    const { imageData, dimensions } = referenceVolume;
    let pointsToUse = points;
    if ((_a2 = data.cachedStats) == null ? void 0 : _a2.projectionPoints) {
      const { projectionPoints } = data.cachedStats;
      pointsToUse = [].concat(...projectionPoints);
    }
    const rectangleCornersIJK = pointsToUse.map((world) => utilities_exports.transformWorldToIndex(imageData, world));
    let boundsIJK2 = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, dimensions);
    if (options.numSlicesToProject && !((_b2 = data.cachedStats) == null ? void 0 : _b2.projectionPoints)) {
      boundsIJK2 = extend2DBoundingBoxInViewAxis_default(boundsIJK2, options.numSlicesToProject);
    }
    AllBoundsIJK.push(boundsIJK2);
  });
  if (AllBoundsIJK.length === 1) {
    return AllBoundsIJK[0];
  }
  const boundsIJK = AllBoundsIJK.reduce((accumulator, currentValue) => {
    return {
      iMin: Math.min(accumulator.iMin, currentValue.iMin),
      jMin: Math.min(accumulator.jMin, currentValue.jMin),
      kMin: Math.min(accumulator.kMin, currentValue.kMin),
      iMax: Math.max(accumulator.iMax, currentValue.iMax),
      jMax: Math.max(accumulator.jMax, currentValue.jMax),
      kMax: Math.max(accumulator.kMax, currentValue.kMax)
    };
  }, {
    iMin: Infinity,
    jMin: Infinity,
    kMin: Infinity,
    iMax: -Infinity,
    jMax: -Infinity,
    kMax: -Infinity
  });
  return boundsIJK;
}
var getBoundsIJKFromRectangleAnnotations_default = getBoundsIJKFromRectangleAnnotations;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/rectangleROIThresholdVolumeByRange.js
function rectangleROIThresholdVolumeByRange(annotationUIDs, segmentationVolume, thresholdVolumeInformation, options) {
  const annotations = annotationUIDs.map((annotationUID) => {
    return state5.getAnnotation(annotationUID);
  });
  _validateAnnotations(annotations);
  let boundsIJK;
  for (let i = 0; i < thresholdVolumeInformation.length; i++) {
    const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();
    if (volumeSize === segmentationVolume.voxelManager.getScalarDataLength() || i === 0) {
      boundsIJK = getBoundsIJKFromRectangleAnnotations_default(annotations, thresholdVolumeInformation[i].volume, options);
    }
  }
  const outputSegmentationVolume = thresholdVolumeByRange_default(segmentationVolume, thresholdVolumeInformation, { ...options, boundsIJK });
  outputSegmentationVolume.modified();
  return outputSegmentationVolume;
}
function _validateAnnotations(annotations) {
  const validToolNames = [
    RectangleROIThresholdTool_default.toolName,
    RectangleROIStartEndThresholdTool_default.toolName
  ];
  for (const annotation of annotations) {
    const name = annotation.metadata.toolName;
    if (!validToolNames.includes(name)) {
      throw new Error("rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations");
    }
  }
}
var rectangleROIThresholdVolumeByRange_default = rectangleROIThresholdVolumeByRange;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createMergedLabelmapForIndex.js
function createMergedLabelmapForIndex(labelmaps, segmentIndex = 1, volumeId = "mergedLabelmap") {
  labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {
    if (!utilities_exports.isEqual(dimensions, labelmaps[0].dimensions) || !utilities_exports.isEqual(direction, labelmaps[0].direction) || !utilities_exports.isEqual(spacing, labelmaps[0].spacing) || !utilities_exports.isEqual(origin, labelmaps[0].origin)) {
      throw new Error("labelmaps must have the same size and shape");
    }
  });
  const labelmap = labelmaps[0];
  const arrayType = labelmap.voxelManager.getConstructor();
  const outputData = new arrayType(labelmap.voxelManager.getScalarDataLength());
  labelmaps.forEach((labelmap2) => {
    const voxelManager = labelmap2.voxelManager;
    const scalarDataLength = voxelManager.getScalarDataLength();
    for (let i = 0; i < scalarDataLength; i++) {
      if (voxelManager.getAtIndex(i) === segmentIndex) {
        outputData[i] = segmentIndex;
      }
    }
  });
  const options = {
    scalarData: outputData,
    metadata: labelmap.metadata,
    spacing: labelmap.spacing,
    origin: labelmap.origin,
    direction: labelmap.direction,
    dimensions: labelmap.dimensions
  };
  const mergedVolume = volumeLoader_exports.createLocalVolume(volumeId, options);
  return mergedVolume;
}
var createMergedLabelmapForIndex_default = createMergedLabelmapForIndex;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapVolumeForViewport.js
async function createLabelmapVolumeForViewport(input) {
  const { viewportId, renderingEngineId, options } = input;
  let { segmentationId } = input;
  const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);
  if (!enabledElement) {
    throw new Error("element disabled");
  }
  const { viewport } = enabledElement;
  if (!(viewport instanceof VolumeViewport_default)) {
    throw new Error("Segmentation only supports VolumeViewport");
  }
  const { uid } = viewport.getDefaultActor();
  if (segmentationId === void 0) {
    segmentationId = `${uid}-based-segmentation-${(options == null ? void 0 : options.volumeId) ?? utilities_exports.uuidv4().slice(0, 8)}`;
  }
  if (options) {
    const properties = structuredClone(options);
    await volumeLoader_exports.createLocalVolume(segmentationId, properties);
  } else {
    const volumeId = viewport.getVolumeId();
    volumeLoader_exports.createAndCacheDerivedLabelmapVolume(volumeId, {
      volumeId: segmentationId
    });
  }
  return segmentationId;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js
function floodFill(getter, seed, options = {}) {
  const onFlood = options.onFlood;
  const onBoundary = options.onBoundary;
  const equals = options.equals;
  const filter = options.filter;
  const diagonals = options.diagonals || false;
  const startNode = get3(seed);
  const permutations = prunedPermutations();
  const stack = [];
  const flooded = [];
  const visits = /* @__PURE__ */ new Set();
  const bounds = options.bounds;
  stack.push({ currentArgs: seed });
  while (stack.length > 0) {
    flood(stack.pop());
  }
  return {
    flooded
  };
  function flood(job) {
    const getArgs = job.currentArgs;
    const prevArgs = job.previousArgs;
    if (visited(getArgs)) {
      return;
    }
    markAsVisited(getArgs);
    if (member(getArgs)) {
      markAsFlooded(getArgs);
      pushAdjacent(getArgs);
    } else {
      markAsBoundary(prevArgs);
    }
  }
  function visited(key) {
    const [x, y, z = 0] = key;
    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
    return visits.has(iKey);
  }
  function markAsVisited(key) {
    const [x, y, z = 0] = key;
    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
    visits.add(iKey);
  }
  function member(getArgs) {
    const node = get3(getArgs);
    return equals ? equals(node, startNode) : node === startNode;
  }
  function markAsFlooded(getArgs) {
    flooded.push(getArgs);
    if (onFlood) {
      onFlood(...getArgs);
    }
  }
  function markAsBoundary(prevArgs) {
    const [x, y, z = 0] = prevArgs;
    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
    bounds == null ? void 0 : bounds.set(iKey, prevArgs);
    if (onBoundary) {
      onBoundary(...prevArgs);
    }
  }
  function pushAdjacent(getArgs) {
    for (let i = 0; i < permutations.length; i += 1) {
      const perm = permutations[i];
      const nextArgs = getArgs.slice(0);
      for (let j = 0; j < getArgs.length; j += 1) {
        nextArgs[j] += perm[j];
      }
      if ((filter == null ? void 0 : filter(nextArgs)) === false) {
        continue;
      }
      if (visited(nextArgs)) {
        continue;
      }
      stack.push({
        currentArgs: nextArgs,
        previousArgs: getArgs
      });
    }
  }
  function get3(getArgs) {
    return getter(...getArgs);
  }
  function prunedPermutations() {
    const permutations2 = permute(seed.length);
    return permutations2.filter(function(perm) {
      const count = countNonZeroes(perm);
      return count !== 0 && (count === 1 || diagonals);
    });
  }
  function permute(length) {
    const perms = [];
    const permutation = function(string) {
      return string.split("").map(function(c) {
        return parseInt(c, 10) - 1;
      });
    };
    for (let i = 0; i < Math.pow(3, length); i += 1) {
      const string = lpad(i.toString(3), "0", length);
      perms.push(permutation(string));
    }
    return perms;
  }
}
function countNonZeroes(array) {
  let count = 0;
  for (let i = 0; i < array.length; i += 1) {
    if (array[i] !== 0) {
      count += 1;
    }
  }
  return count;
}
function lpad(string, character, length) {
  const array = new Array(length + 1);
  const pad = array.join(character);
  return (pad + string).slice(-length);
}
var floodFill_default = floodFill;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/determineSegmentIndex.js
var determineSegmentIndex_default = {
  [StrategyCallbacks_default.Initialize]: (operationData) => {
    const { strategySpecificConfiguration } = operationData;
    if (!strategySpecificConfiguration) {
      return;
    }
    const { centerSegmentIndex } = strategySpecificConfiguration;
    if (centerSegmentIndex) {
      operationData.segmentIndex = centerSegmentIndex.segmentIndex;
    }
  },
  [StrategyCallbacks_default.OnInteractionStart]: (operationData) => {
    const { segmentIndex, previewSegmentIndex, segmentationVoxelManager, centerIJK, strategySpecificConfiguration, viewPlaneNormal, segmentationImageData, preview } = operationData;
    if (!(strategySpecificConfiguration == null ? void 0 : strategySpecificConfiguration.useCenterSegmentIndex)) {
      return;
    }
    delete strategySpecificConfiguration.centerSegmentIndex;
    let hasSegmentIndex = false;
    let hasPreviewIndex = false;
    const nestedBounds = [
      ...segmentationVoxelManager.getBoundsIJK()
    ];
    if (Math.abs(viewPlaneNormal[0]) > 0.8) {
      nestedBounds[0] = [centerIJK[0], centerIJK[0]];
    } else if (Math.abs(viewPlaneNormal[1]) > 0.8) {
      nestedBounds[1] = [centerIJK[1], centerIJK[1]];
    } else if (Math.abs(viewPlaneNormal[2]) > 0.8) {
      nestedBounds[2] = [centerIJK[2], centerIJK[2]];
    }
    const callback = ({ value }) => {
      hasSegmentIndex || (hasSegmentIndex = value === segmentIndex);
      hasPreviewIndex || (hasPreviewIndex = value === previewSegmentIndex);
    };
    segmentationVoxelManager.forEach(callback, {
      imageData: segmentationImageData,
      isInObject: operationData.isInObject,
      boundsIJK: nestedBounds
    });
    if (!hasSegmentIndex && !hasPreviewIndex) {
      return;
    }
    let existingValue = segmentationVoxelManager.getAtIJKPoint(centerIJK);
    if (existingValue === previewSegmentIndex) {
      if (preview) {
        existingValue = preview.segmentIndex;
      } else {
        return;
      }
    } else if (hasPreviewIndex) {
      existingValue = null;
    }
    operationData.segmentIndex = existingValue;
    strategySpecificConfiguration.centerSegmentIndex = {
      segmentIndex: existingValue
    };
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/dynamicThreshold.js
var dynamicThreshold_default = {
  [StrategyCallbacks_default.Initialize]: (operationData) => {
    const { operationName, centerIJK, strategySpecificConfiguration, segmentationVoxelManager, imageVoxelManager, segmentIndex, viewport } = operationData;
    const { THRESHOLD } = strategySpecificConfiguration;
    if (!(THRESHOLD == null ? void 0 : THRESHOLD.isDynamic) || !centerIJK || !segmentIndex) {
      return;
    }
    if (operationName === StrategyCallbacks_default.RejectPreview || operationName === StrategyCallbacks_default.OnInteractionEnd) {
      return;
    }
    const boundsIJK = segmentationVoxelManager.getBoundsIJK();
    const { threshold: oldThreshold, dynamicRadius = 0 } = THRESHOLD;
    const useDelta = oldThreshold ? 0 : dynamicRadius;
    const { viewPlaneNormal } = viewport.getCamera();
    const nestedBounds = boundsIJK.map((ijk, idx) => {
      const [min, max2] = ijk;
      return [
        Math.max(min, centerIJK[idx] - useDelta),
        Math.min(max2, centerIJK[idx] + useDelta)
      ];
    });
    if (Math.abs(viewPlaneNormal[0]) > 0.8) {
      nestedBounds[0] = [centerIJK[0], centerIJK[0]];
    } else if (Math.abs(viewPlaneNormal[1]) > 0.8) {
      nestedBounds[1] = [centerIJK[1], centerIJK[1]];
    } else if (Math.abs(viewPlaneNormal[2]) > 0.8) {
      nestedBounds[2] = [centerIJK[2], centerIJK[2]];
    }
    const threshold = oldThreshold || [Infinity, -Infinity];
    const useDeltaSqr = useDelta * useDelta;
    const callback = ({ value, pointIJK }) => {
      const distance = vec3_exports.sqrDist(centerIJK, pointIJK);
      if (distance > useDeltaSqr) {
        return;
      }
      const gray = Array.isArray(value) ? vec3_exports.len(value) : value;
      threshold[0] = Math.min(gray, threshold[0]);
      threshold[1] = Math.max(gray, threshold[1]);
    };
    imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });
    operationData.strategySpecificConfiguration.THRESHOLD.threshold = threshold;
  },
  [StrategyCallbacks_default.OnInteractionStart]: (operationData) => {
    var _a2;
    const { strategySpecificConfiguration, preview } = operationData;
    if (!((_a2 = strategySpecificConfiguration == null ? void 0 : strategySpecificConfiguration.THRESHOLD) == null ? void 0 : _a2.isDynamic) && !preview) {
      return;
    }
    strategySpecificConfiguration.THRESHOLD.threshold = null;
  },
  [StrategyCallbacks_default.ComputeInnerCircleRadius]: (operationData) => {
    const { configuration: configuration3, viewport } = operationData;
    const { THRESHOLD: { dynamicRadius = 0 } = {} } = configuration3.strategySpecificConfiguration || {};
    if (dynamicRadius === 0) {
      return;
    }
    const imageData = viewport.getImageData();
    if (!imageData) {
      return;
    }
    const { spacing } = imageData;
    const centerCanvas = [
      viewport.element.clientWidth / 2,
      viewport.element.clientHeight / 2
    ];
    const radiusInWorld = dynamicRadius * spacing[0];
    const centerCursorInWorld = viewport.canvasToWorld(centerCanvas);
    const offSetCenterInWorld = centerCursorInWorld.map((coord) => coord + radiusInWorld);
    const offSetCenterCanvas = viewport.worldToCanvas(offSetCenterInWorld);
    const dynamicRadiusInCanvas = Math.abs(centerCanvas[0] - offSetCenterCanvas[0]);
    const { strategySpecificConfiguration, activeStrategy } = configuration3;
    if (!strategySpecificConfiguration[activeStrategy]) {
      strategySpecificConfiguration[activeStrategy] = {};
    }
    strategySpecificConfiguration[activeStrategy].dynamicRadiusInCanvas = 3 + dynamicRadiusInCanvas;
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/erase.js
var erase_default = {
  [StrategyCallbacks_default.Initialize]: (operationData) => {
    operationData.segmentIndex = 0;
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/normalizeViewportPlane.js
var { isEqual: isEqual4 } = utilities_exports;
var acquisitionMapping = {
  toIJK: (ijkPrime) => ijkPrime,
  fromIJK: (ijk) => ijk,
  type: "acquistion"
};
var jkMapping = {
  toIJK: ([j, k, i]) => [i, j, k],
  fromIJK: ([i, j, k]) => [j, k, i],
  type: "jk"
};
var ikMapping = {
  toIJK: ([i, k, j]) => [i, j, k],
  fromIJK: ([i, j, k]) => [i, k, j],
  type: "ik"
};
function normalizeViewportPlane(viewport, boundsIJK) {
  if (!(viewport instanceof BaseVolumeViewport_default)) {
    return { ...acquisitionMapping, boundsIJKPrime: boundsIJK };
  }
  const { viewPlaneNormal } = viewport.getCamera();
  const mapping = isEqual4(Math.abs(viewPlaneNormal[0]), 1) && jkMapping || isEqual4(Math.abs(viewPlaneNormal[1]), 1) && ikMapping || isEqual4(Math.abs(viewPlaneNormal[2]), 1) && acquisitionMapping;
  if (!mapping) {
    return {
      toIJK: null,
      boundsIJKPrime: null,
      fromIJK: null,
      error: `Only mappings orthogonal to acquisition plane are permitted, but requested ${viewPlaneNormal}`
    };
  }
  return { ...mapping, boundsIJKPrime: mapping.fromIJK(boundsIJK) };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/islandRemoval.js
var { RLEVoxelMap, VoxelManager } = utilities_exports;
var MAX_IMAGE_SIZE = 65535;
var SegmentationEnum;
(function(SegmentationEnum2) {
  SegmentationEnum2[SegmentationEnum2["SEGMENT"] = -1] = "SEGMENT";
  SegmentationEnum2[SegmentationEnum2["ISLAND"] = -2] = "ISLAND";
  SegmentationEnum2[SegmentationEnum2["INTERIOR"] = -3] = "INTERIOR";
  SegmentationEnum2[SegmentationEnum2["EXTERIOR"] = -4] = "EXTERIOR";
  SegmentationEnum2[SegmentationEnum2["INTERIOR_SMALL"] = -5] = "INTERIOR_SMALL";
  SegmentationEnum2[SegmentationEnum2["INTERIOR_TEST"] = -6] = "INTERIOR_TEST";
})(SegmentationEnum || (SegmentationEnum = {}));
var IslandRemoval = class _IslandRemoval {
  constructor(options) {
    this.fillInternalEdge = false;
    this.maxInternalRemove = 128;
    this.maxInternalRemove = (options == null ? void 0 : options.maxInternalRemove) ?? this.maxInternalRemove;
    this.fillInternalEdge = (options == null ? void 0 : options.fillInternalEdge) ?? this.fillInternalEdge;
  }
  initialize(viewport, segmentationVoxels, options) {
    const hasSource = !!segmentationVoxels.sourceVoxelManager;
    const segmentationVoxelManager = hasSource ? segmentationVoxels.sourceVoxelManager : segmentationVoxels;
    const previewVoxelManager = hasSource ? segmentationVoxels : VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);
    const { segmentIndex = 1, previewSegmentIndex = 1 } = options;
    const clickedPoints = options.points || previewVoxelManager.getPoints();
    if (!(clickedPoints == null ? void 0 : clickedPoints.length)) {
      return;
    }
    const boundsIJK = previewVoxelManager.getBoundsIJK().map((bound, i) => [
      Math.min(bound[0], ...clickedPoints.map((point) => point[i])),
      Math.max(bound[1], ...clickedPoints.map((point) => point[i]))
    ]);
    if (boundsIJK.find((it) => it[0] < 0 || it[1] > MAX_IMAGE_SIZE)) {
      return;
    }
    const { toIJK, fromIJK, boundsIJKPrime, error } = normalizeViewportPlane(viewport, boundsIJK);
    if (error) {
      console.warn("Not performing island removal for planes not orthogonal to acquisition plane", error);
      return;
    }
    const [width, height, depth] = fromIJK(segmentationVoxelManager.dimensions);
    const segmentSet = new RLEVoxelMap(width, height, depth);
    const getter = (i, j, k) => {
      const index = segmentationVoxelManager.toIndex(toIJK([i, j, k]));
      const oldVal = segmentationVoxelManager.getAtIndex(index);
      if (oldVal === previewSegmentIndex || oldVal === segmentIndex) {
        return SegmentationEnum.SEGMENT;
      }
    };
    segmentSet.fillFrom(getter, boundsIJKPrime);
    segmentSet.normalizer = { toIJK, fromIJK, boundsIJKPrime };
    this.segmentSet = segmentSet;
    this.previewVoxelManager = previewVoxelManager;
    this.segmentIndex = segmentIndex;
    this.previewSegmentIndex = previewSegmentIndex ?? segmentIndex;
    this.selectedPoints = clickedPoints;
    return true;
  }
  floodFillSegmentIsland() {
    const { selectedPoints: clickedPoints, segmentSet } = this;
    let floodedCount = 0;
    const { fromIJK } = segmentSet.normalizer;
    clickedPoints.forEach((clickedPoint) => {
      const ijkPrime = fromIJK(clickedPoint);
      const index = segmentSet.toIndex(ijkPrime);
      const [iPrime, jPrime, kPrime] = ijkPrime;
      if (segmentSet.get(index) === SegmentationEnum.SEGMENT) {
        floodedCount += segmentSet.floodFill(iPrime, jPrime, kPrime, SegmentationEnum.ISLAND);
      }
    });
    return floodedCount;
  }
  removeExternalIslands() {
    const { previewVoxelManager, segmentSet } = this;
    const { toIJK } = segmentSet.normalizer;
    const callback = (index, rle) => {
      const [, jPrime, kPrime] = segmentSet.toIJK(index);
      if (rle.value !== SegmentationEnum.ISLAND) {
        for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {
          const clearPoint = toIJK([iPrime, jPrime, kPrime]);
          const v = previewVoxelManager.getAtIJKPoint(clearPoint);
          previewVoxelManager.setAtIJKPoint(clearPoint, v === void 0 ? 0 : null);
        }
      }
    };
    segmentSet.forEach(callback, { rowModified: true });
  }
  removeInternalIslands() {
    const { segmentSet, previewVoxelManager, previewSegmentIndex } = this;
    const { height, normalizer, width } = segmentSet;
    const { toIJK } = normalizer;
    segmentSet.forEachRow((baseIndex, row) => {
      let lastRle;
      for (const rle of [...row]) {
        if (rle.value !== SegmentationEnum.ISLAND) {
          continue;
        }
        if (!lastRle) {
          if (this.fillInternalEdge && rle.start > 0) {
            for (let iPrime = 0; iPrime < rle.start; iPrime++) {
              segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
            }
          }
          lastRle = rle;
          continue;
        }
        for (let iPrime = lastRle.end; iPrime < rle.start; iPrime++) {
          segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
        }
        lastRle = rle;
      }
      if (this.fillInternalEdge && (lastRle == null ? void 0 : lastRle.end) < width) {
        for (let iPrime = lastRle.end; iPrime < width; iPrime++) {
          segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
        }
      }
    });
    segmentSet.forEach((baseIndex, rle) => {
      if (rle.value !== SegmentationEnum.INTERIOR) {
        return;
      }
      const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);
      const rowPrev = jPrime > 0 ? segmentSet.getRun(jPrime - 1, kPrime) : null;
      const rowNext = jPrime + 1 < height ? segmentSet.getRun(jPrime + 1, kPrime) : null;
      const isLast = jPrime === height - 1;
      const isFirst = jPrime === 0;
      const prevCovers = _IslandRemoval.covers(rle, rowPrev) || isFirst && this.fillInternalEdge;
      const nextCovers = _IslandRemoval.covers(rle, rowNext) || isLast && this.fillInternalEdge;
      if (rle.end - rle.start > 2 && (!prevCovers || !nextCovers)) {
        segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.EXTERIOR, { singlePlane: true });
      }
    });
    segmentSet.forEach((baseIndex, rle) => {
      if (rle.value !== SegmentationEnum.INTERIOR) {
        return;
      }
      const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);
      const size = segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.INTERIOR_TEST);
      const isBig = size > this.maxInternalRemove;
      const newType = isBig ? SegmentationEnum.EXTERIOR : SegmentationEnum.INTERIOR_SMALL;
      segmentSet.floodFill(rle.start, jPrime, kPrime, newType);
    });
    segmentSet.forEach((baseIndex, rle) => {
      if (rle.value !== SegmentationEnum.INTERIOR_SMALL) {
        return;
      }
      for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {
        const clearPoint = toIJK(segmentSet.toIJK(baseIndex + iPrime));
        previewVoxelManager.setAtIJKPoint(clearPoint, previewSegmentIndex);
      }
    });
    return previewVoxelManager.getArrayOfModifiedSlices();
  }
  static covers(rle, row) {
    if (!row) {
      return false;
    }
    let { start } = rle;
    const { end } = rle;
    for (const rowRle of row) {
      if (start >= rowRle.start && start < rowRle.end) {
        start = rowRle.end;
        if (start >= end) {
          return true;
        }
      }
    }
    return false;
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/islandRemovalComposition.js
var islandRemovalComposition_default = {
  [StrategyCallbacks_default.OnInteractionEnd]: (operationData) => {
    const { strategySpecificConfiguration, previewSegmentIndex, segmentIndex, viewport, previewVoxelManager, segmentationVoxelManager } = operationData;
    if (!strategySpecificConfiguration.THRESHOLD || segmentIndex === null) {
      return;
    }
    const islandRemoval = new IslandRemoval();
    const voxelManager = previewVoxelManager ?? segmentationVoxelManager;
    if (!islandRemoval.initialize(viewport, voxelManager, {
      previewSegmentIndex,
      segmentIndex
    })) {
      return;
    }
    islandRemoval.floodFillSegmentIsland();
    islandRemoval.removeExternalIslands();
    islandRemoval.removeInternalIslands();
    const arrayOfSlices = voxelManager.getArrayOfModifiedSlices();
    if (!arrayOfSlices) {
      return;
    }
    triggerSegmentationDataModified(operationData.segmentationId, arrayOfSlices, previewSegmentIndex);
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/preview.js
function lightenColor(r, g, b, a, factor = 0.4) {
  return [
    Math.round(r + (255 - r) * factor),
    Math.round(g + (255 - g) * factor),
    Math.round(b + (255 - b) * factor),
    a
  ];
}
var preview_default = {
  [StrategyCallbacks_default.Preview]: function(operationData) {
    var _a2, _b2;
    const { previewColors, strategySpecificConfiguration, enabledElement } = operationData;
    if (!previewColors || !strategySpecificConfiguration) {
      return;
    }
    if (operationData.preview) {
      delete operationData.preview;
    }
    delete strategySpecificConfiguration.centerSegmentIndex;
    (_a2 = this.onInteractionStart) == null ? void 0 : _a2.call(this, enabledElement, operationData);
    const preview = this.fill(enabledElement, operationData);
    if (preview) {
      preview.isPreviewFromHover = true;
      operationData.preview = preview;
      (_b2 = this.onInteractionEnd) == null ? void 0 : _b2.call(this, enabledElement, operationData);
    }
    return preview;
  },
  [StrategyCallbacks_default.Initialize]: (operationData) => {
    const { segmentIndex, previewSegmentIndex, previewColors, preview, segmentationId, segmentationVoxelManager } = operationData;
    if (previewColors === void 0 || !previewSegmentIndex) {
      operationData.memo = operationData.createMemo(segmentationId, segmentationVoxelManager);
      return;
    }
    if (preview) {
      preview.previewVoxelManager.sourceVoxelManager = operationData.segmentationVoxelManager;
      operationData.previewVoxelManager = preview.previewVoxelManager;
    }
    if (segmentIndex === null) {
      return;
    }
    const configColor = previewColors == null ? void 0 : previewColors[segmentIndex];
    const segmentColor = getSegmentIndexColor(operationData.viewport.id, operationData.segmentationId, segmentIndex);
    if (!configColor && !segmentColor) {
      return;
    }
    const previewColor = configColor || lightenColor(...segmentColor);
    setSegmentIndexColor(operationData.viewport.id, operationData.segmentationId, previewSegmentIndex, previewColor);
  },
  [StrategyCallbacks_default.AcceptPreview]: (operationData) => {
    const { segmentationVoxelManager, previewVoxelManager, previewSegmentIndex, segmentationId, preview } = operationData || {};
    if (previewSegmentIndex === void 0) {
      return;
    }
    const segmentIndex = (preview == null ? void 0 : preview.segmentIndex) ?? operationData.segmentIndex;
    if (!previewVoxelManager || previewVoxelManager.modifiedSlices.size === 0) {
      return;
    }
    const memo = operationData.createMemo(segmentationId, segmentationVoxelManager);
    operationData.memo = memo;
    const { voxelManager } = memo;
    const callback = ({ index, value }) => {
      const oldValue = segmentationVoxelManager.getAtIndex(index);
      if (oldValue === previewSegmentIndex) {
        segmentationVoxelManager.setAtIndex(index, value);
        voxelManager.setAtIndex(index, segmentIndex);
      }
    };
    previewVoxelManager.forEach(callback, {});
    triggerSegmentationDataModified(operationData.segmentationId, previewVoxelManager.getArrayOfModifiedSlices(), preview.segmentIndex);
    previewVoxelManager.clear();
  },
  [StrategyCallbacks_default.RejectPreview]: (operationData) => {
    const { previewVoxelManager, segmentationVoxelManager } = operationData;
    if (previewVoxelManager.modifiedSlices.size === 0) {
      return;
    }
    const callback = ({ index, value }) => {
      segmentationVoxelManager.setAtIndex(index, value);
    };
    previewVoxelManager.forEach(callback);
    triggerSegmentationDataModified(operationData.segmentationId, previewVoxelManager.getArrayOfModifiedSlices(), 0);
    previewVoxelManager.clear();
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/regionFill.js
var regionFill_default = {
  [StrategyCallbacks_default.Fill]: (operationData) => {
    var _a2;
    const { segmentsLocked, segmentationImageData, segmentationVoxelManager, previewVoxelManager, brushStrategy, centerIJK } = operationData;
    const isWithinThreshold = (_a2 = brushStrategy.createIsInThreshold) == null ? void 0 : _a2.call(brushStrategy, operationData);
    const { setValue } = brushStrategy;
    const callback = isWithinThreshold ? (data) => {
      const { value, index } = data;
      if (segmentsLocked.includes(value) || !isWithinThreshold(index)) {
        return;
      }
      setValue(operationData, data);
    } : (data) => setValue(operationData, data);
    segmentationVoxelManager.forEach(callback, {
      imageData: segmentationImageData,
      isInObject: operationData.isInObject,
      boundsIJK: operationData.isInObjectBoundsIJK
    });
    previewVoxelManager.addPoint(centerIJK);
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/setValue.js
var setValue_default = {
  [StrategyCallbacks_default.INTERNAL_setValue]: (operationData, { value, index }) => {
    const { segmentsLocked, segmentIndex, previewSegmentIndex, segmentationVoxelManager, memo } = operationData;
    const previewVoxelManager = (memo == null ? void 0 : memo.voxelManager) || operationData.previewVoxelManager;
    const existingValue = segmentationVoxelManager.getAtIndex(index);
    let changed = false;
    if (segmentIndex === null) {
      const oldValue = previewVoxelManager.getAtIndex(index);
      if (oldValue !== void 0) {
        changed = previewVoxelManager.setAtIndex(index, oldValue);
      }
      return;
    }
    if (existingValue === segmentIndex || segmentsLocked.includes(value)) {
      return;
    }
    if (existingValue === previewSegmentIndex) {
      if (previewVoxelManager.getAtIndex(index) === void 0) {
        changed = segmentationVoxelManager.setAtIndex(index, segmentIndex);
      } else {
        return;
      }
    }
    const useSegmentIndex = previewSegmentIndex ?? segmentIndex;
    changed = previewVoxelManager.setAtIndex(index, useSegmentIndex);
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/threshold.js
var threshold_default = {
  [StrategyCallbacks_default.CreateIsInThreshold]: (operationData) => {
    const { imageVoxelManager, strategySpecificConfiguration, segmentIndex } = operationData;
    if (!strategySpecificConfiguration || !segmentIndex) {
      return;
    }
    return (index) => {
      const { THRESHOLD, THRESHOLD_INSIDE_CIRCLE } = strategySpecificConfiguration;
      const voxelValue = imageVoxelManager.getAtIndex(index);
      const gray = Array.isArray(voxelValue) ? vec3_exports.length(voxelValue) : voxelValue;
      const { threshold } = THRESHOLD || THRESHOLD_INSIDE_CIRCLE || {};
      if (!(threshold == null ? void 0 : threshold.length)) {
        return true;
      }
      return threshold[0] <= gray && gray <= threshold[1];
    };
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/VolumetricCalculator.js
var TEST_MAX_LOCATIONS = 10;
var _VolumetricCalculator = class _VolumetricCalculator extends BasicStatsCalculator {
  static getStatistics(options) {
    const { spacing } = options;
    const stats = BasicStatsCalculator.getStatistics();
    const volumeUnit = spacing ? "mm" : "voxels";
    const volumeScale = spacing ? spacing[0] * spacing[1] * spacing[2] * 1e3 : 1;
    stats.volume = {
      value: Array.isArray(stats.count.value) ? stats.count.value.map((v) => v * volumeScale) : stats.count.value * volumeScale,
      unit: volumeUnit,
      name: "volume"
    };
    stats.maxIJKs = this.maxIJKs;
    stats.array.push(stats.volume);
    this.maxIJKs = [];
    return stats;
  }
  static statsCallback(data) {
    BasicStatsCalculator.statsCallback(data);
    const { value } = data;
    const { maxIJKs } = this;
    const { length } = maxIJKs;
    if (typeof value !== "number" || length >= TEST_MAX_LOCATIONS && value < maxIJKs[0].value) {
      return;
    }
    if (!length || value >= maxIJKs[length - 1].value) {
      maxIJKs.push(data);
    } else {
      for (let i = 0; i < length; i++) {
        if (value <= maxIJKs[i].value) {
          maxIJKs.splice(i, 0, data);
          break;
        }
      }
    }
    if (length >= TEST_MAX_LOCATIONS) {
      maxIJKs.splice(0, 1);
    }
  }
};
_VolumetricCalculator.maxIJKs = [];
var VolumetricCalculator = _VolumetricCalculator;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js
function getStrategyData({ operationData, viewport }) {
  var _a2;
  let segmentationImageData, segmentationScalarData, imageScalarData;
  let imageVoxelManager;
  let segmentationVoxelManager;
  if (viewport instanceof BaseVolumeViewport_default) {
    const { volumeId, referencedVolumeId } = operationData;
    if (!volumeId) {
      const event = new CustomEvent(enums_exports.Events.ERROR_EVENT, {
        detail: {
          type: "Segmentation",
          message: "No volume id found for the segmentation"
        },
        cancelable: true
      });
      eventTarget_default.dispatchEvent(event);
      return null;
    }
    const segmentationVolume = cache_default.getVolume(volumeId);
    if (!segmentationVolume) {
      return;
    }
    segmentationVoxelManager = segmentationVolume.voxelManager;
    if (referencedVolumeId) {
      const imageVolume = cache_default.getVolume(referencedVolumeId);
      imageVoxelManager = imageVolume.voxelManager;
    }
    ({ imageData: segmentationImageData } = segmentationVolume);
  } else {
    const { segmentationId } = operationData;
    const labelmapImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);
    if (!labelmapImageId) {
      return;
    }
    const currentImageId = viewport.getCurrentImageId();
    if (!currentImageId) {
      return;
    }
    const actorEntry = getLabelmapActorEntry(viewport.id, segmentationId);
    if (!actorEntry) {
      return;
    }
    const currentSegImage = cache_default.getImage(labelmapImageId);
    segmentationImageData = actorEntry.actor.getMapper().getInputData();
    segmentationVoxelManager = currentSegImage.voxelManager;
    const currentSegmentationImageId = operationData.imageId;
    const segmentationImage = cache_default.getImage(currentSegmentationImageId);
    if (!segmentationImage) {
      return;
    }
    segmentationScalarData = (_a2 = segmentationImage.getPixelData) == null ? void 0 : _a2.call(segmentationImage);
    const image = cache_default.getImage(currentImageId);
    const imageData = image ? null : viewport.getImageData();
    imageScalarData = (image == null ? void 0 : image.getPixelData()) || imageData.getScalarData();
    imageVoxelManager = image == null ? void 0 : image.voxelManager;
  }
  return {
    segmentationImageData,
    segmentationScalarData,
    imageScalarData,
    segmentationVoxelManager,
    imageVoxelManager
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/labelmapStatistics.js
var radiusForVol1 = Math.pow(3 * 1e3 / (4 * Math.PI), 1 / 3);
var labelmapStatistics_default = {
  [StrategyCallbacks_default.GetStatistics]: function(enabledElement, operationData, options) {
    const { viewport } = enabledElement;
    let { indices } = options;
    const { segmentationId } = operationData;
    if (!indices) {
      indices = [getActiveSegmentIndex(segmentationId)];
    } else if (!Array.isArray(indices)) {
      indices = [indices, 255];
    }
    const indicesArr = indices;
    const { segmentationVoxelManager, imageVoxelManager, segmentationImageData } = getStrategyData({
      operationData,
      viewport
    });
    const spacing = segmentationImageData.getSpacing();
    const { boundsIJK: boundsOrig } = segmentationVoxelManager;
    if (!boundsOrig) {
      return VolumetricCalculator.getStatistics({ spacing });
    }
    segmentationVoxelManager.forEach((voxel) => {
      const { value, pointIJK } = voxel;
      if (indicesArr.indexOf(value) === -1) {
        return;
      }
      const imageValue = imageVoxelManager.getAtIJKPoint(pointIJK);
      VolumetricCalculator.statsCallback({ value: imageValue, pointIJK });
    });
    const targetId = viewport.getReferenceId();
    const modalityUnitOptions = {
      isPreScaled: isViewportPreScaled(viewport, targetId),
      isSuvScaled: AnnotationTool_default.isSuvScaled(viewport, targetId, viewport.getCurrentImageId())
    };
    const imageData = viewport.getImageData();
    const unit = getPixelValueUnits(imageData.metadata.Modality, viewport.getCurrentImageId(), modalityUnitOptions);
    const stats = VolumetricCalculator.getStatistics({ spacing, unit });
    const { maxIJKs } = stats;
    if (!(maxIJKs == null ? void 0 : maxIJKs.length)) {
      return stats;
    }
    stats.mean.unit = unit;
    stats.max.unit = unit;
    stats.min.unit = unit;
    if (unit !== "SUV") {
      return;
    }
    const radiusIJK = spacing.map((s) => Math.max(1, Math.round(1.1 * radiusForVol1 / s)));
    for (const testMax of maxIJKs) {
      const testStats = getSphereStats(testMax, radiusIJK, segmentationImageData, imageVoxelManager, spacing);
      if (!testStats) {
        continue;
      }
      const { mean } = testStats;
      if (!stats.peakValue || stats.peakValue.value <= mean.value) {
        stats.peakValue = {
          name: "peakValue",
          label: "Peak Value",
          value: mean.value,
          unit
        };
      }
    }
    return stats;
  }
};
function getSphereStats(testMax, radiusIJK, segData, imageVoxels, spacing) {
  const { pointIJK: centerIJK } = testMax;
  const boundsIJK = centerIJK.map((ijk, idx) => [
    ijk - radiusIJK[idx],
    ijk + radiusIJK[idx]
  ]);
  const testFunction = (_pointLPS, pointIJK) => {
    const i = (pointIJK[0] - centerIJK[0]) / radiusIJK[0];
    const j = (pointIJK[1] - centerIJK[1]) / radiusIJK[1];
    const k = (pointIJK[2] - centerIJK[2]) / radiusIJK[2];
    const radius = i * i + j * j + k * k;
    return radius <= 1;
  };
  const statsFunction = ({ pointIJK, pointLPS }) => {
    const value = imageVoxels.getAtIJKPoint(pointIJK);
    if (value === void 0) {
      return;
    }
    VolumetricCalculator.statsCallback({ value, pointLPS, pointIJK });
  };
  VolumetricCalculator.statsInit({ storePointData: false });
  utilities_exports.pointInShapeCallback(segData, {
    pointInShapeFn: testFunction,
    callback: statsFunction,
    boundsIJK
  });
  return VolumetricCalculator.getStatistics({ spacing });
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js
var compositions_default = {
  determineSegmentIndex: determineSegmentIndex_default,
  dynamicThreshold: dynamicThreshold_default,
  erase: erase_default,
  islandRemoval: islandRemovalComposition_default,
  preview: preview_default,
  regionFill: regionFill_default,
  setValue: setValue_default,
  threshold: threshold_default,
  labelmapStatistics: labelmapStatistics_default
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js
var { VoxelManager: VoxelManager2 } = utilities_exports;
var _BrushStrategy = class _BrushStrategy {
  constructor(name, ...initializers) {
    this._initialize = [];
    this._fill = [];
    this._onInteractionStart = [];
    this.fill = (enabledElement, operationData) => {
      const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks_default.Fill);
      if (!initializedData) {
        return;
      }
      const { strategySpecificConfiguration = {}, centerIJK } = initializedData;
      if (utilities_exports.isEqual(centerIJK, strategySpecificConfiguration.centerIJK)) {
        return operationData.preview;
      } else {
        strategySpecificConfiguration.centerIJK = centerIJK;
      }
      this._fill.forEach((func) => func(initializedData));
      const { segmentationVoxelManager, previewVoxelManager, previewSegmentIndex, segmentIndex } = initializedData;
      const isPreview = previewSegmentIndex && previewVoxelManager.modifiedSlices.size;
      triggerSegmentationDataModified(initializedData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), isPreview ? previewSegmentIndex : segmentIndex);
      if (!previewSegmentIndex || !previewVoxelManager.modifiedSlices.size) {
        segmentationVoxelManager.resetModifiedSlices();
        return null;
      }
      return initializedData.preview || initializedData;
    };
    this.onInteractionStart = (enabledElement, operationData) => {
      const { preview } = operationData;
      if (preview == null ? void 0 : preview.isPreviewFromHover) {
        preview.isPreviewFromHover = false;
        return;
      }
      const initializedData = this.initialize(enabledElement, operationData);
      if (!initializedData) {
        return;
      }
      this._onInteractionStart.forEach((func) => func.call(this, initializedData));
    };
    this.addPreview = (enabledElement, operationData) => {
      const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks_default.AddPreview);
      if (!initializedData) {
        return;
      }
      return initializedData.preview || initializedData;
    };
    this.configurationName = name;
    this.compositions = initializers;
    initializers.forEach((initializer) => {
      const result = typeof initializer === "function" ? initializer() : initializer;
      if (!result) {
        return;
      }
      for (const key in result) {
        if (!_BrushStrategy.childFunctions[key]) {
          throw new Error(`Didn't find ${key} as a brush strategy`);
        }
        _BrushStrategy.childFunctions[key](this, result[key]);
      }
    });
    this.strategyFunction = (enabledElement, operationData) => {
      return this.fill(enabledElement, operationData);
    };
    for (const key of Object.keys(_BrushStrategy.childFunctions)) {
      this.strategyFunction[key] = this[key];
    }
  }
  initialize(enabledElement, operationData, operationName) {
    var _a2, _b2, _c;
    const { viewport } = enabledElement;
    const data = getStrategyData({ operationData, viewport });
    if (!data) {
      console.warn("No data found for BrushStrategy");
      return operationData.preview;
    }
    const { imageVoxelManager, segmentationVoxelManager, segmentationImageData } = data;
    const segmentationVoxelManagerToUse = ((_a2 = operationData.override) == null ? void 0 : _a2.voxelManager) || segmentationVoxelManager;
    const segmentationImageDataToUse = ((_b2 = operationData.override) == null ? void 0 : _b2.imageData) || segmentationImageData;
    const previewVoxelManager = ((_c = operationData.preview) == null ? void 0 : _c.previewVoxelManager) || VoxelManager2.createRLEHistoryVoxelManager(segmentationVoxelManager);
    const previewEnabled = !!operationData.previewColors;
    const previewSegmentIndex = previewEnabled ? 255 : void 0;
    const initializedData = {
      operationName,
      previewSegmentIndex,
      ...operationData,
      enabledElement,
      imageVoxelManager,
      segmentationVoxelManager: segmentationVoxelManagerToUse,
      segmentationImageData: segmentationImageDataToUse,
      previewVoxelManager,
      viewport,
      centerWorld: null,
      isInObject: null,
      isInObjectBoundsIJK: null,
      brushStrategy: this
    };
    this._initialize.forEach((func) => func(initializedData));
    return initializedData;
  }
};
_BrushStrategy.COMPOSITIONS = compositions_default;
_BrushStrategy.childFunctions = {
  [StrategyCallbacks_default.OnInteractionStart]: addListMethod(StrategyCallbacks_default.OnInteractionStart, StrategyCallbacks_default.Initialize),
  [StrategyCallbacks_default.OnInteractionEnd]: addListMethod(StrategyCallbacks_default.OnInteractionEnd, StrategyCallbacks_default.Initialize),
  [StrategyCallbacks_default.Fill]: addListMethod(StrategyCallbacks_default.Fill),
  [StrategyCallbacks_default.Initialize]: addListMethod(StrategyCallbacks_default.Initialize),
  [StrategyCallbacks_default.CreateIsInThreshold]: addSingletonMethod(StrategyCallbacks_default.CreateIsInThreshold),
  [StrategyCallbacks_default.AcceptPreview]: addListMethod(StrategyCallbacks_default.AcceptPreview, StrategyCallbacks_default.Initialize),
  [StrategyCallbacks_default.RejectPreview]: addListMethod(StrategyCallbacks_default.RejectPreview, StrategyCallbacks_default.Initialize),
  [StrategyCallbacks_default.INTERNAL_setValue]: addSingletonMethod(StrategyCallbacks_default.INTERNAL_setValue),
  [StrategyCallbacks_default.Preview]: addSingletonMethod(StrategyCallbacks_default.Preview, false),
  [StrategyCallbacks_default.ComputeInnerCircleRadius]: addListMethod(StrategyCallbacks_default.ComputeInnerCircleRadius),
  [StrategyCallbacks_default.AddPreview]: addListMethod(StrategyCallbacks_default.AddPreview),
  [StrategyCallbacks_default.GetStatistics]: addSingletonMethod(StrategyCallbacks_default.GetStatistics),
  compositions: null
};
var BrushStrategy = _BrushStrategy;
function addListMethod(name, createInitialized) {
  const listName = `_${name}`;
  return (brushStrategy, func) => {
    brushStrategy[listName] || (brushStrategy[listName] = []);
    brushStrategy[listName].push(func);
    brushStrategy[name] || (brushStrategy[name] = createInitialized ? (enabledElement, operationData) => {
      const initializedData = brushStrategy[createInitialized](enabledElement, operationData, name);
      brushStrategy[listName].forEach((func2) => func2.call(brushStrategy, initializedData));
    } : (operationData) => {
      brushStrategy[listName].forEach((func2) => func2.call(brushStrategy, operationData));
    });
  };
}
function addSingletonMethod(name, isInitialized = true) {
  return (brushStrategy, func) => {
    if (brushStrategy[name]) {
      throw new Error(`The singleton method ${name} already exists`);
    }
    brushStrategy[name] = isInitialized ? func : (enabledElement, operationData, ...args) => {
      operationData.enabledElement = enabledElement;
      return func.call(brushStrategy, operationData, ...args);
    };
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js
function pointInSphere(sphere, pointLPS) {
  const { center, radius } = sphere;
  const radius2 = sphere.radius2 || radius * radius;
  return (pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) + (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) + (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <= radius2;
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js
var { transformWorldToIndex: transformWorldToIndex4, isEqual: isEqual5 } = utilities_exports;
var initializeCircle = {
  [StrategyCallbacks_default.Initialize]: (operationData) => {
    const { points, viewport, segmentationImageData } = operationData;
    if (!points) {
      return;
    }
    const center = vec3_exports.fromValues(0, 0, 0);
    points.forEach((point) => {
      vec3_exports.add(center, center, point);
    });
    vec3_exports.scale(center, center, 1 / points.length);
    operationData.centerWorld = center;
    operationData.centerIJK = transformWorldToIndex4(segmentationImageData, center);
    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
    const [topLeftCanvas, bottomRightCanvas] = getCanvasEllipseCorners(canvasCoordinates);
    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
    const circleCornersIJK = points.map((world) => {
      return transformWorldToIndex4(segmentationImageData, world);
    });
    const boundsIJK = getBoundingBoxAroundShapeIJK(circleCornersIJK, segmentationImageData.getDimensions());
    operationData.isInObject = createPointInEllipse({
      topLeftWorld,
      bottomRightWorld,
      center
    });
    operationData.isInObjectBoundsIJK = boundsIJK;
  }
};
function createPointInEllipse(worldInfo) {
  const { topLeftWorld, bottomRightWorld, center } = worldInfo;
  const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;
  const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;
  const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;
  const radius = Math.max(xRadius, yRadius, zRadius);
  if (isEqual5(xRadius, radius) && isEqual5(yRadius, radius) && isEqual5(zRadius, radius)) {
    const sphereObj = {
      center,
      radius,
      radius2: radius * radius
    };
    return (pointLPS) => pointInSphere(sphereObj, pointLPS);
  }
  const ellipseObj = {
    center,
    xRadius,
    yRadius,
    zRadius
  };
  const { precalculated } = precalculatePointInEllipse(ellipseObj, {});
  return precalculated;
}
var CIRCLE_STRATEGY = new BrushStrategy("Circle", compositions_default.regionFill, compositions_default.setValue, initializeCircle, compositions_default.determineSegmentIndex, compositions_default.preview, compositions_default.labelmapStatistics);
var CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy("CircleThreshold", compositions_default.regionFill, compositions_default.setValue, initializeCircle, compositions_default.determineSegmentIndex, compositions_default.dynamicThreshold, compositions_default.threshold, compositions_default.preview, compositions_default.islandRemoval, compositions_default.labelmapStatistics);
var fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;
var thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;
function fillOutsideCircle() {
  throw new Error("Not yet implemented");
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js
var { transformWorldToIndex: transformWorldToIndex5 } = utilities_exports;
var sphereComposition = {
  [StrategyCallbacks_default.Initialize]: (operationData) => {
    const { points, viewport, segmentationImageData } = operationData;
    if (!points) {
      return;
    }
    const center = vec3_exports.fromValues(0, 0, 0);
    points.forEach((point) => {
      vec3_exports.add(center, center, point);
    });
    vec3_exports.scale(center, center, 1 / points.length);
    operationData.centerWorld = center;
    operationData.centerIJK = transformWorldToIndex5(segmentationImageData, center);
    const { boundsIJK: newBoundsIJK, topLeftWorld, bottomRightWorld } = getSphereBoundsInfoFromViewport(points.slice(0, 2), segmentationImageData, viewport);
    operationData.isInObjectBoundsIJK = newBoundsIJK;
    operationData.isInObject = createPointInEllipse({
      topLeftWorld,
      bottomRightWorld,
      center
    });
  }
};
var SPHERE_STRATEGY = new BrushStrategy("Sphere", compositions_default.regionFill, compositions_default.setValue, sphereComposition, compositions_default.determineSegmentIndex, compositions_default.preview, compositions_default.labelmapStatistics);
var fillInsideSphere = SPHERE_STRATEGY.strategyFunction;
var SPHERE_THRESHOLD_STRATEGY = new BrushStrategy("SphereThreshold", ...SPHERE_STRATEGY.compositions, compositions_default.dynamicThreshold, compositions_default.threshold);
var SPHERE_THRESHOLD_STRATEGY_ISLAND = new BrushStrategy("SphereThreshold", ...SPHERE_STRATEGY.compositions, compositions_default.dynamicThreshold, compositions_default.threshold, compositions_default.islandRemoval);
var thresholdInsideSphere = SPHERE_THRESHOLD_STRATEGY.strategyFunction;
var thresholdInsideSphereIsland = SPHERE_THRESHOLD_STRATEGY_ISLAND.strategyFunction;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js
var ERASE_SPHERE_STRATEGY = new BrushStrategy("EraseSphere", compositions_default.erase, ...SPHERE_STRATEGY.compositions);
var eraseInsideSphere = ERASE_SPHERE_STRATEGY.strategyFunction;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js
var ERASE_CIRCLE_STRATEGY = new BrushStrategy("EraseCircle", compositions_default.erase, ...CIRCLE_STRATEGY.compositions);
var eraseInsideCircle = ERASE_CIRCLE_STRATEGY.strategyFunction;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapMemo.js
var createLabelmapMemo_exports = {};
__export(createLabelmapMemo_exports, {
  createLabelmapMemo: () => createLabelmapMemo,
  createPreviewMemo: () => createPreviewMemo,
  createRleMemo: () => createRleMemo,
  restoreMemo: () => restoreMemo
});
var { VoxelManager: VoxelManager3, RLEVoxelMap: RLEVoxelMap2 } = utilities_exports;
function createLabelmapMemo(segmentationId, segmentationVoxelManager, preview) {
  return preview ? createPreviewMemo(segmentationId, preview) : createRleMemo(segmentationId, segmentationVoxelManager);
}
function restoreMemo(isUndo) {
  const { segmentationVoxelManager, undoVoxelManager, redoVoxelManager } = this;
  const useVoxelManager = isUndo === false ? redoVoxelManager : undoVoxelManager;
  useVoxelManager.forEach(({ value, pointIJK }) => {
    segmentationVoxelManager.setAtIJKPoint(pointIJK, value);
  });
  const slices = useVoxelManager.getArrayOfModifiedSlices();
  triggerSegmentationDataModified(this.segmentationId, slices);
}
function createRleMemo(segmentationId, segmentationVoxelManager) {
  const voxelManager = VoxelManager3.createRLEHistoryVoxelManager(segmentationVoxelManager);
  const state8 = {
    segmentationId,
    restoreMemo,
    commitMemo,
    segmentationVoxelManager,
    voxelManager
  };
  return state8;
}
function createPreviewMemo(segmentationId, preview) {
  const { memo: previewMemo, segmentationVoxelManager, previewVoxelManager } = preview;
  const state8 = {
    segmentationId,
    restoreMemo,
    commitMemo,
    segmentationVoxelManager,
    voxelManager: previewVoxelManager,
    memo: previewMemo,
    preview
  };
  return state8;
}
function commitMemo() {
  if (this.redoVoxelManager) {
    return true;
  }
  if (!this.voxelManager.modifiedSlices.size) {
    return false;
  }
  const { segmentationVoxelManager } = this;
  const undoVoxelManager = VoxelManager3.createRLEHistoryVoxelManager(segmentationVoxelManager);
  RLEVoxelMap2.copyMap(undoVoxelManager.map, this.voxelManager.map);
  for (const key of this.voxelManager.modifiedSlices.keys()) {
    undoVoxelManager.modifiedSlices.add(key);
  }
  this.undoVoxelManager = undoVoxelManager;
  const redoVoxelManager = VoxelManager3.createRLEVolumeVoxelManager({
    dimensions: this.segmentationVoxelManager.dimensions
  });
  this.redoVoxelManager = redoVoxelManager;
  undoVoxelManager.forEach(({ index, pointIJK, value }) => {
    const currentValue = segmentationVoxelManager.getAtIJKPoint(pointIJK);
    if (currentValue === value) {
      return;
    }
    redoVoxelManager.setAtIndex(index, currentValue);
  });
  return true;
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/index.js
var strategies_exports = {};
__export(strategies_exports, {
  fillInsideCircle: () => fillInsideCircle,
  fillInsideRectangle: () => fillInsideRectangle,
  fillOutsideCircle: () => fillOutsideCircle,
  thresholdInsideRectangle: () => thresholdInsideRectangle
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js
var { isEqual: isEqual6 } = utilities_exports;
var iAxis = vec3_exports.fromValues(1, 0, 0);
var jAxis = vec3_exports.fromValues(0, 1, 0);
var kAxis = vec3_exports.fromValues(0, 0, 1);
var axisList = [iAxis, jAxis, kAxis];
function isAxisAlignedRectangle(rectangleCornersIJK) {
  const rectangleVec1 = vec3_exports.subtract(vec3_exports.create(), rectangleCornersIJK[0], rectangleCornersIJK[1]);
  const rectangleVec2 = vec3_exports.subtract(vec3_exports.create(), rectangleCornersIJK[0], rectangleCornersIJK[2]);
  const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);
  const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);
  const isAligned = [...anglesVec1, ...anglesVec2].every((angle) => isEqual6(angle, 0) || isEqual6(angle, 90) || isEqual6(angle, 180) || isEqual6(angle, 270));
  return isAligned;
}
function calculateAnglesWithAxes(vec, axes) {
  return axes.map((axis) => vec3_exports.angle(vec, axis) * 180 / Math.PI);
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js
var { transformWorldToIndex: transformWorldToIndex6 } = utilities_exports;
var initializeRectangle = {
  [StrategyCallbacks_default.Initialize]: (operationData) => {
    const { points, imageVoxelManager, viewport, segmentationImageData, segmentationVoxelManager } = operationData;
    if (!points) {
      return;
    }
    const center = vec3_exports.fromValues(0, 0, 0);
    points.forEach((point) => {
      vec3_exports.add(center, center, point);
    });
    vec3_exports.scale(center, center, 1 / points.length);
    operationData.centerWorld = center;
    operationData.centerIJK = transformWorldToIndex6(segmentationImageData, center);
    const { boundsIJK, pointInShapeFn } = createPointInRectangle(viewport, points, segmentationImageData);
    operationData.isInObject = pointInShapeFn;
    operationData.isInObjectBoundsIJK = boundsIJK;
  }
};
function createPointInRectangle(viewport, points, segmentationImageData) {
  let rectangleCornersIJK = points.map((world) => {
    return transformWorldToIndex6(segmentationImageData, world);
  });
  rectangleCornersIJK = rectangleCornersIJK.map((point) => {
    return point.map((coord) => {
      return Math.round(coord);
    });
  });
  const boundsIJK = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, segmentationImageData.getDimensions());
  const isStackViewport = viewport instanceof StackViewport_default;
  const isAligned = isStackViewport || isAxisAlignedRectangle(rectangleCornersIJK);
  const direction = segmentationImageData.getDirection();
  const spacing = segmentationImageData.getSpacing();
  const { viewPlaneNormal } = viewport.getCamera();
  const EPS2 = utilities_exports.getSpacingInNormalDirection({
    direction,
    spacing
  }, viewPlaneNormal);
  const pointsBoundsLPS = getBoundingBoxAroundShapeWorld(points);
  let [[xMin, xMax], [yMin, yMax], [zMin, zMax]] = pointsBoundsLPS;
  xMin -= EPS2;
  xMax += EPS2;
  yMin -= EPS2;
  yMax += EPS2;
  zMin -= EPS2;
  zMax += EPS2;
  const pointInShapeFn = isAligned ? () => true : (pointLPS) => {
    const [x, y, z] = pointLPS;
    const xInside = x >= xMin && x <= xMax;
    const yInside = y >= yMin && y <= yMax;
    const zInside = z >= zMin && z <= zMax;
    return xInside && yInside && zInside;
  };
  return { boundsIJK, pointInShapeFn };
}
var RECTANGLE_STRATEGY = new BrushStrategy("Rectangle", compositions_default.regionFill, compositions_default.setValue, initializeRectangle, compositions_default.determineSegmentIndex, compositions_default.preview, compositions_default.labelmapStatistics);
var RECTANGLE_THRESHOLD_STRATEGY = new BrushStrategy("RectangleThreshold", compositions_default.regionFill, compositions_default.setValue, initializeRectangle, compositions_default.determineSegmentIndex, compositions_default.dynamicThreshold, compositions_default.threshold, compositions_default.preview, compositions_default.islandRemoval, compositions_default.labelmapStatistics);
var fillInsideRectangle = RECTANGLE_STRATEGY.strategyFunction;
var thresholdInsideRectangle = RECTANGLE_THRESHOLD_STRATEGY.strategyFunction;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js
var _LabelmapBaseTool = class _LabelmapBaseTool extends BaseTool_default {
  constructor(toolProps, defaultToolProps) {
    super(toolProps, defaultToolProps);
  }
  get _previewData() {
    return _LabelmapBaseTool.previewData;
  }
  createMemo(segmentId, segmentationVoxelManager, preview) {
    this.memo || (this.memo = createLabelmapMemo(segmentId, segmentationVoxelManager, preview));
    return this.memo;
  }
  createEditData(element) {
    var _a2, _b2;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const activeSegmentation = getActiveSegmentation(viewport.id);
    if (!activeSegmentation) {
      const event = new CustomEvent(enums_exports.Events.ERROR_EVENT, {
        detail: {
          type: "Segmentation",
          message: "No active segmentation detected, create a segmentation representation before using the brush tool"
        },
        cancelable: true
      });
      eventTarget_default.dispatchEvent(event);
      return null;
    }
    const { segmentationId } = activeSegmentation;
    const segmentsLocked = getLockedSegmentIndices(segmentationId);
    const { representationData } = getSegmentation(segmentationId);
    if (viewport instanceof BaseVolumeViewport_default) {
      const { volumeId } = representationData[SegmentationRepresentations_default.Labelmap];
      const actors = viewport.getActors();
      const isStackViewport = viewport instanceof getClosestImageIdForStackViewport;
      if (isStackViewport) {
        const event = new CustomEvent(enums_exports.Events.ERROR_EVENT, {
          detail: {
            type: "Segmentation",
            message: "Cannot perform brush operation on the selected viewport"
          },
          cancelable: true
        });
        eventTarget_default.dispatchEvent(event);
        return null;
      }
      const volumes = actors.map((actorEntry) => cache_default.getVolume(actorEntry.referencedId));
      const segmentationVolume = cache_default.getVolume(volumeId);
      const referencedVolumeIdToThreshold = ((_a2 = volumes.find((volume) => utilities_exports.isEqual(volume.dimensions, segmentationVolume.dimensions))) == null ? void 0 : _a2.volumeId) || ((_b2 = volumes[0]) == null ? void 0 : _b2.volumeId);
      return {
        volumeId,
        referencedVolumeId: this.configuration.thresholdVolumeId ?? referencedVolumeIdToThreshold,
        segmentsLocked
      };
    } else {
      const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);
      if (!segmentationImageId) {
        return;
      }
      if (this.configuration.activeStrategy.includes("SPHERE")) {
        const referencedImageIds = viewport.getImageIds();
        const isValidVolumeForSphere = utilities_exports.isValidVolume(referencedImageIds);
        if (!isValidVolumeForSphere) {
          throw new Error("Volume is not reconstructable for sphere manipulation");
        }
        const volumeId = `${segmentationId}_${viewport.id}`;
        const volume = cache_default.getVolume(volumeId);
        if (volume) {
          return {
            imageId: segmentationImageId,
            segmentsLocked,
            override: {
              voxelManager: volume.voxelManager,
              imageData: volume.imageData
            }
          };
        } else {
          const labelmapImageIds = getStackSegmentationImageIdsForViewport(viewport.id, segmentationId);
          if (!labelmapImageIds || labelmapImageIds.length === 1) {
            return {
              imageId: segmentationImageId,
              segmentsLocked
            };
          }
          const volume2 = volumeLoader_exports.createAndCacheVolumeFromImagesSync(volumeId, labelmapImageIds);
          return {
            imageId: segmentationImageId,
            segmentsLocked,
            override: {
              voxelManager: volume2.voxelManager,
              imageData: volume2.imageData
            }
          };
        }
      } else {
        return {
          imageId: segmentationImageId,
          segmentsLocked
        };
      }
    }
  }
  createHoverData(element, centerCanvas) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const camera = viewport.getCamera();
    const { viewPlaneNormal, viewUp } = camera;
    const viewportIdsToRender = [viewport.id];
    const { segmentIndex, segmentationId, segmentColor } = this.getActiveSegmentationData(viewport) || {};
    const brushCursor = {
      metadata: {
        viewPlaneNormal: [...viewPlaneNormal],
        viewUp: [...viewUp],
        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
        referencedImageId: "",
        toolName: this.getToolName(),
        segmentColor
      },
      data: {}
    };
    return {
      brushCursor,
      centerCanvas,
      segmentIndex,
      viewport,
      segmentationId,
      segmentColor,
      viewportIdsToRender
    };
  }
  getActiveSegmentationData(viewport) {
    const viewportId = viewport.id;
    const activeRepresentation = getActiveSegmentation(viewportId);
    if (!activeRepresentation) {
      return;
    }
    const { segmentationId } = activeRepresentation;
    const segmentIndex = getActiveSegmentIndex(segmentationId);
    if (!segmentIndex) {
      return;
    }
    const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);
    return {
      segmentIndex,
      segmentationId,
      segmentColor
    };
  }
  getOperationData(element) {
    var _a2, _b2, _c, _d;
    const editData = this._editData || this.createEditData(element);
    const { segmentIndex, segmentationId, brushCursor } = this._hoverData || this.createHoverData(element);
    const { data, metadata = {} } = brushCursor || {};
    const { viewPlaneNormal, viewUp } = metadata;
    const operationData = {
      ...editData,
      points: (_a2 = data == null ? void 0 : data.handles) == null ? void 0 : _a2.points,
      segmentIndex,
      previewColors: ((_b2 = this.configuration.preview) == null ? void 0 : _b2.enabled) || this._previewData.preview ? (_c = this.configuration.preview) == null ? void 0 : _c.previewColors : null,
      viewPlaneNormal,
      toolGroupId: this.toolGroupId,
      segmentationId,
      viewUp,
      strategySpecificConfiguration: this.configuration.strategySpecificConfiguration,
      preview: (_d = this._previewData) == null ? void 0 : _d.preview,
      createMemo: this.createMemo.bind(this)
    };
    return operationData;
  }
  addPreview(element = this._previewData.element, options) {
    const { _previewData } = this;
    const acceptReject = options == null ? void 0 : options.acceptReject;
    if (acceptReject === true) {
      this.acceptPreview(element);
    } else if (acceptReject === false) {
      this.rejectPreview(element);
    }
    const enabledElement = getEnabledElement(element);
    _previewData.preview = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks_default.AddPreview);
    _previewData.isDrag = true;
    return _previewData.preview;
  }
  rejectPreview(element = this._previewData.element) {
    if (!element || !this._previewData.preview) {
      return;
    }
    const enabledElement = getEnabledElement(element);
    this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks_default.RejectPreview);
    this._previewData.preview = null;
    this._previewData.isDrag = false;
  }
  acceptPreview(element = this._previewData.element) {
    if (!element) {
      return;
    }
    this.doneEditMemo();
    const enabledElement = getEnabledElement(element);
    this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks_default.AcceptPreview);
    this._previewData.isDrag = false;
    this._previewData.preview = null;
    this.doneEditMemo();
  }
  static viewportContoursToLabelmap(viewport, options) {
    var _a2;
    const removeContours = (options == null ? void 0 : options.removeContours) ?? true;
    const annotations = getAllAnnotations();
    const viewAnnotations = filterAnnotationsForDisplay(viewport, annotations);
    if (!(viewAnnotations == null ? void 0 : viewAnnotations.length)) {
      return;
    }
    const contourAnnotations = viewAnnotations.filter((annotation) => {
      var _a3, _b2;
      return (_b2 = (_a3 = annotation.data.contour) == null ? void 0 : _a3.polyline) == null ? void 0 : _b2.length;
    });
    if (!contourAnnotations.length) {
      return;
    }
    const brushInstance = new _LabelmapBaseTool({}, {
      configuration: {
        strategies: {
          FILL_INSIDE_CIRCLE: fillInsideCircle
        },
        activeStrategy: "FILL_INSIDE_CIRCLE"
      }
    });
    const preview = brushInstance.addPreview(viewport.element);
    const { memo, segmentationId } = preview;
    const previewVoxels = (memo == null ? void 0 : memo.voxelManager) || preview.previewVoxelManager;
    const segmentationVoxels = previewVoxels.sourceVoxelManager || previewVoxels;
    const { dimensions } = previewVoxels;
    const imageData = viewport.getDefaultActor().actor.getMapper().getInputData();
    for (const annotation of contourAnnotations) {
      const boundsIJK = [
        [Infinity, -Infinity],
        [Infinity, -Infinity],
        [Infinity, -Infinity]
      ];
      const { polyline } = annotation.data.contour;
      for (const point of polyline) {
        const indexPoint = imageData.worldToIndex(point);
        indexPoint.forEach((v, idx) => {
          boundsIJK[idx][0] = Math.min(boundsIJK[idx][0], v);
          boundsIJK[idx][1] = Math.max(boundsIJK[idx][1], v);
        });
      }
      boundsIJK.forEach((bound, idx) => {
        bound[0] = Math.round(Math.max(0, bound[0]));
        bound[1] = Math.round(Math.min(dimensions[idx] - 1, bound[1]));
      });
      const activeIndex = getActiveSegmentIndex(segmentationId);
      const startPoint = ((_a2 = annotation.data.handles) == null ? void 0 : _a2[0]) || polyline[0];
      const startIndex = imageData.worldToIndex(startPoint).map(Math.round);
      const startValue = segmentationVoxels.getAtIJKPoint(startIndex) || 0;
      let hasZeroIndex = false;
      let hasPositiveIndex = false;
      for (const polyPoint of polyline) {
        const polyIndex = imageData.worldToIndex(polyPoint).map(Math.round);
        const polyValue = segmentationVoxels.getAtIJKPoint(polyIndex);
        if (polyValue === startValue) {
          hasZeroIndex = true;
        } else if (polyValue >= 0) {
          hasPositiveIndex = true;
        }
      }
      const hasBoth = hasZeroIndex && hasPositiveIndex;
      const segmentIndex = hasBoth ? startValue : startValue === 0 ? activeIndex : 0;
      for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {
        for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {
          for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {
            const worldPoint = imageData.indexToWorld([i, j, k]);
            const isContained = isPointInsidePolyline3D(worldPoint, polyline);
            if (isContained) {
              previewVoxels.setAtIJK(i, j, k, segmentIndex);
            }
          }
        }
      }
      if (removeContours) {
        removeAnnotation(annotation.annotationUID);
      }
    }
    const slices = previewVoxels.getArrayOfModifiedSlices();
    triggerSegmentationDataModified(segmentationId, slices);
  }
};
_LabelmapBaseTool.previewData = {
  preview: null,
  element: null,
  timerStart: 0,
  timer: null,
  startPoint: [NaN, NaN],
  isDrag: false
};
var LabelmapBaseTool = _LabelmapBaseTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js
var BrushTool = class extends LabelmapBaseTool {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      strategies: {
        FILL_INSIDE_CIRCLE: fillInsideCircle,
        ERASE_INSIDE_CIRCLE: eraseInsideCircle,
        FILL_INSIDE_SPHERE: fillInsideSphere,
        ERASE_INSIDE_SPHERE: eraseInsideSphere,
        THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,
        THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,
        THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL: thresholdInsideSphereIsland
      },
      strategySpecificConfiguration: {
        THRESHOLD: {
          threshold: [-150, -70]
        }
      },
      defaultStrategy: "FILL_INSIDE_CIRCLE",
      activeStrategy: "FILL_INSIDE_CIRCLE",
      thresholdVolumeId: null,
      brushSize: 25,
      preview: {
        enabled: false,
        previewColors: {},
        previewTimeMs: 250,
        previewMoveDistance: 8,
        dragMoveDistance: 4,
        dragTimeMs: 500
      },
      actions: {
        [StrategyCallbacks_default.AcceptPreview]: {
          method: StrategyCallbacks_default.AcceptPreview,
          bindings: [
            {
              key: "Enter"
            }
          ]
        }
      }
    }
  }) {
    super(toolProps, defaultToolProps);
    this.onSetToolPassive = (evt) => {
      this.disableCursor();
    };
    this.onSetToolEnabled = () => {
      this.disableCursor();
    };
    this.onSetToolDisabled = (evt) => {
      this.disableCursor();
    };
    this.preMouseDownCallback = (evt) => {
      const eventData = evt.detail;
      const { element } = eventData;
      const enabledElement = getEnabledElement(element);
      this._editData = this.createEditData(element);
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      this._previewData.isDrag = false;
      this._previewData.timerStart = Date.now();
      const hoverData = this._hoverData || this.createHoverData(element);
      triggerAnnotationRenderForViewportIds_default(hoverData.viewportIdsToRender);
      const operationData = this.getOperationData(element);
      this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks_default.OnInteractionStart);
      return true;
    };
    this.mouseMoveCallback = (evt) => {
      if (this.mode === ToolModes_default.Active) {
        this.updateCursor(evt);
        if (!this.configuration.preview.enabled) {
          return;
        }
        const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;
        const { currentPoints, element } = evt.detail;
        const { canvas } = currentPoints;
        const { preview, startPoint, timer, timerStart, isDrag } = this._previewData;
        const delta = vec2_exports.distance(canvas, startPoint);
        const time = Date.now() - timerStart;
        if (delta > previewMoveDistance || time > previewTimeMs && delta > dragMoveDistance) {
          if (timer) {
            window.clearTimeout(timer);
            this._previewData.timer = null;
          }
          if (preview && !isDrag) {
            this.rejectPreview(element);
          }
        }
        if (!this._previewData.timer) {
          const timer2 = window.setTimeout(this.previewCallback, 250);
          Object.assign(this._previewData, {
            timerStart: Date.now(),
            timer: timer2,
            startPoint: canvas,
            element
          });
        }
      }
    };
    this.previewCallback = () => {
      this._previewData.timer = null;
      if (this._previewData.preview) {
        return;
      }
      this._previewData.preview = this.applyActiveStrategyCallback(getEnabledElement(this._previewData.element), this.getOperationData(this._previewData.element), StrategyCallbacks_default.Preview);
    };
    this._dragCallback = (evt) => {
      const eventData = evt.detail;
      const { element, currentPoints } = eventData;
      const enabledElement = getEnabledElement(element);
      this.updateCursor(evt);
      const { viewportIdsToRender } = this._hoverData;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      const delta = vec2_exports.distance(currentPoints.canvas, this._previewData.startPoint);
      const { dragTimeMs, dragMoveDistance } = this.configuration.preview;
      if (!this._previewData.isDrag && this._previewData.preview && Date.now() - this._previewData.timerStart < dragTimeMs && delta < dragMoveDistance) {
        return;
      }
      this._previewData.preview = this.applyActiveStrategy(enabledElement, this.getOperationData(element));
      this._previewData.element = element;
      this._previewData.timerStart = Date.now() + dragTimeMs;
      this._previewData.isDrag = true;
      this._previewData.startPoint = currentPoints.canvas;
    };
    this._endCallback = (evt) => {
      const eventData = evt.detail;
      const { element } = eventData;
      const enabledElement = getEnabledElement(element);
      const operationData = this.getOperationData(element);
      if (!this._previewData.preview && !this._previewData.isDrag) {
        this.applyActiveStrategy(enabledElement, operationData);
      }
      this.doneEditMemo();
      this._deactivateDraw(element);
      resetElementCursor(element);
      this.updateCursor(evt);
      this._editData = null;
      this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks_default.OnInteractionEnd);
      if (!this._previewData.isDrag) {
        this.acceptPreview(element);
      }
    };
    this._activateDraw = (element) => {
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
    };
    this._deactivateDraw = (element) => {
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
    };
  }
  disableCursor() {
    this._hoverData = void 0;
    this.rejectPreview();
  }
  updateCursor(evt) {
    const eventData = evt.detail;
    const { element } = eventData;
    const { currentPoints } = eventData;
    const centerCanvas = currentPoints.canvas;
    this._hoverData = this.createHoverData(element, centerCanvas);
    this._calculateCursor(element, centerCanvas);
    if (!this._hoverData) {
      return;
    }
    triggerAnnotationRenderForViewportIds_default(this._hoverData.viewportIdsToRender);
  }
  _calculateCursor(element, centerCanvas) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const { canvasToWorld } = viewport;
    const camera = viewport.getCamera();
    const { brushSize } = this.configuration;
    const viewUp = vec3_exports.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
    const viewPlaneNormal = vec3_exports.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
    const viewRight = vec3_exports.create();
    vec3_exports.cross(viewRight, viewUp, viewPlaneNormal);
    const centerCursorInWorld = canvasToWorld([
      centerCanvas[0],
      centerCanvas[1]
    ]);
    const bottomCursorInWorld = vec3_exports.create();
    const topCursorInWorld = vec3_exports.create();
    const leftCursorInWorld = vec3_exports.create();
    const rightCursorInWorld = vec3_exports.create();
    for (let i = 0; i <= 2; i++) {
      bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;
      topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;
      leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;
      rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;
    }
    if (!this._hoverData) {
      return;
    }
    const { brushCursor } = this._hoverData;
    const { data } = brushCursor;
    if (data.handles === void 0) {
      data.handles = {};
    }
    data.handles.points = [
      bottomCursorInWorld,
      topCursorInWorld,
      leftCursorInWorld,
      rightCursorInWorld
    ];
    const activeStrategy = this.configuration.activeStrategy;
    const strategy = this.configuration.strategies[activeStrategy];
    if (typeof (strategy == null ? void 0 : strategy.computeInnerCircleRadius) === "function") {
      strategy.computeInnerCircleRadius({
        configuration: this.configuration,
        viewport
      });
    }
    data.invalidated = false;
  }
  getStatistics(element, segmentIndices) {
    if (!element) {
      return;
    }
    const enabledElement = getEnabledElement(element);
    const stats = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks_default.GetStatistics, segmentIndices);
    return stats;
  }
  invalidateBrushCursor() {
    if (this._hoverData === void 0) {
      return;
    }
    const { data } = this._hoverData.brushCursor;
    const { viewport } = this._hoverData;
    data.invalidated = true;
    const { segmentColor } = this.getActiveSegmentationData(viewport) || {};
    this._hoverData.brushCursor.metadata.segmentColor = segmentColor;
  }
  renderAnnotation(enabledElement, svgDrawingHelper) {
    var _a2;
    if (!this._hoverData) {
      return;
    }
    const { viewport } = enabledElement;
    const viewportIdsToRender = this._hoverData.viewportIdsToRender;
    if (!viewportIdsToRender.includes(viewport.id)) {
      return;
    }
    const brushCursor = this._hoverData.brushCursor;
    if (brushCursor.data.invalidated === true) {
      const { centerCanvas } = this._hoverData;
      const { element } = viewport;
      this._calculateCursor(element, centerCanvas);
    }
    const toolMetadata = brushCursor.metadata;
    if (!toolMetadata) {
      return;
    }
    const annotationUID = toolMetadata.brushCursorUID;
    const data = brushCursor.data;
    const { points } = data.handles;
    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
    const bottom = canvasCoordinates[0];
    const top = canvasCoordinates[1];
    const center = [
      Math.floor((bottom[0] + top[0]) / 2),
      Math.floor((bottom[1] + top[1]) / 2)
    ];
    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
    const color = `rgb(${((_a2 = toolMetadata.segmentColor) == null ? void 0 : _a2.slice(0, 3)) || [0, 0, 0]})`;
    if (!viewport.getRenderingEngine()) {
      console.warn("Rendering Engine has been destroyed");
      return;
    }
    const circleUID = "0";
    drawCircle_default(svgDrawingHelper, annotationUID, circleUID, center, radius, {
      color
    });
    const activeStrategy = this.configuration.activeStrategy;
    const { dynamicRadiusInCanvas } = this.configuration.strategySpecificConfiguration[activeStrategy] || {
      dynamicRadiusInCanvas: 0
    };
    if (dynamicRadiusInCanvas) {
      const circleUID1 = "1";
      drawCircle_default(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {
        color
      });
    }
  }
};
BrushTool.toolName = "Brush";
var BrushTool_default = BrushTool;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js
function getBrushToolInstances(toolGroupId, toolName) {
  const toolGroup = getToolGroup_default(toolGroupId);
  if (toolGroup === void 0) {
    return;
  }
  const toolInstances = toolGroup._toolInstances;
  if (!Object.keys(toolInstances).length) {
    return;
  }
  if (toolName && toolInstances[toolName]) {
    return [toolInstances[toolName]];
  }
  const brushBasedToolInstances = Object.values(toolInstances).filter((toolInstance) => toolInstance instanceof BrushTool_default);
  return brushBasedToolInstances;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushSizeForToolGroup.js
function setBrushSizeForToolGroup(toolGroupId, brushSize, toolName) {
  const toolGroup = getToolGroup_default(toolGroupId);
  if (toolGroup === void 0) {
    return;
  }
  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);
  brushBasedToolInstances.forEach((tool) => {
    tool.configuration.brushSize = brushSize;
    tool.invalidateBrushCursor();
  });
  const viewportsInfo = toolGroup.getViewportsInfo();
  const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);
  if (!viewportsInfoArray.length) {
    return;
  }
  const { renderingEngineId } = viewportsInfoArray[0];
  const viewportIds = toolGroup.getViewportIds();
  const renderingEngine = getRenderingEngine(renderingEngineId);
  triggerAnnotationRenderForViewportIds_default(viewportIds);
}
function getBrushSizeForToolGroup(toolGroupId, toolName) {
  const toolGroup = getToolGroup_default(toolGroupId);
  if (toolGroup === void 0) {
    return;
  }
  const toolInstances = toolGroup._toolInstances;
  if (!Object.keys(toolInstances).length) {
    return;
  }
  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);
  const brushToolInstance = brushBasedToolInstances[0];
  if (!brushToolInstance) {
    return;
  }
  return brushToolInstance.configuration.brushSize;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushThresholdForToolGroup.js
function setBrushThresholdForToolGroup(toolGroupId, threshold, otherArgs = { isDynamic: false }) {
  const toolGroup = getToolGroup_default(toolGroupId);
  if (toolGroup === void 0) {
    return;
  }
  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);
  const configuration3 = {
    ...otherArgs,
    ...threshold !== void 0 && { threshold }
  };
  brushBasedToolInstances.forEach((tool) => {
    tool.configuration.strategySpecificConfiguration.THRESHOLD = {
      ...tool.configuration.strategySpecificConfiguration.THRESHOLD,
      ...configuration3
    };
  });
  const viewportsInfo = toolGroup.getViewportsInfo();
  if (!viewportsInfo.length) {
    return;
  }
  const { renderingEngineId } = viewportsInfo[0];
  const viewportIds = toolGroup.getViewportIds();
  const renderingEngine = getRenderingEngine(renderingEngineId);
  triggerAnnotationRenderForViewportIds_default(viewportIds);
}
function getBrushThresholdForToolGroup(toolGroupId) {
  const toolGroup = getToolGroup_default(toolGroupId);
  if (toolGroup === void 0) {
    return;
  }
  const toolInstances = toolGroup._toolInstances;
  if (!Object.keys(toolInstances).length) {
    return;
  }
  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);
  const brushToolInstance = brushBasedToolInstances[0];
  if (!brushToolInstance) {
    return;
  }
  return brushToolInstance.configuration.strategySpecificConfiguration.THRESHOLD.threshold;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdSegmentationByRange.js
function thresholdSegmentationByRange(segmentationVolume, segmentationIndex, thresholdVolumeInformation, overlapType) {
  const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);
  const { voxelManager } = volumeInfoList[baseVolumeIdx];
  const refVoxelManager = voxelManager;
  const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
  const segVoxelManager = segmentationVolume.voxelManager;
  volumeInfoList.forEach((volumeInfo) => {
    const { volumeSize } = volumeInfo;
    if (volumeSize === scalarDataLength) {
      _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo);
    } else {
      _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType);
    }
  });
  triggerSegmentationDataModified(segmentationVolume.volumeId);
  return segmentationVolume;
}
function _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType) {
  const { imageData, lower, upper, dimensions } = volumeInfo;
  let total, overlaps, range2;
  const segScalarDataLength = segVoxelManager.getScalarDataLength();
  for (let i = 0; i < segScalarDataLength; i++) {
    if (segScalarDataLength.getAtIndex(i) === segmentationIndex) {
      const overlapBounds = getVoxelOverlap(imageData, dimensions, volumeInfoList[baseVolumeIdx].spacing, volumeInfoList[baseVolumeIdx].imageData.getPoint(i));
      const callbackOverlap = ({ value }) => {
        total = total + 1;
        if (value >= range2.lower && value <= range2.upper) {
          overlaps = overlaps + 1;
        }
      };
      total = 0;
      overlaps = 0;
      range2 = { lower, upper };
      let overlapTest = false;
      segVoxelManager.forEach(callbackOverlap, {
        imageData,
        boundsIJK: overlapBounds
      });
      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;
      segVoxelManager.setAtIndex(i, overlapTest ? segmentationIndex : 0);
    }
  }
  return { total, range: range2, overlaps };
}
function _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo) {
  const { lower, upper } = volumeInfo;
  const scalarDataLength = segVoxelManager.getScalarDataLength();
  for (let i = 0; i < scalarDataLength; i++) {
    if (segVoxelManager.getAtIndex[i] === segmentationIndex) {
      const value = refVoxelManager.getAtIndex(i);
      segVoxelManager.setAtIndex(i, value >= lower && value <= upper ? segmentationIndex : 0);
    }
  }
}
var thresholdSegmentationByRange_default = thresholdSegmentationByRange;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/isLineInSegment.js
function isLineInSegment(point1, point2, isInSegment) {
  const ijk1 = isInSegment.toIJK(point1);
  const ijk2 = isInSegment.toIJK(point2);
  const testPoint = vec3_exports.create();
  const { testIJK } = isInSegment;
  const delta = vec3_exports.sub(vec3_exports.create(), ijk1, ijk2);
  const testSize = Math.round(Math.max(...delta.map(Math.abs)));
  if (testSize < 2) {
    return true;
  }
  const unitDelta = vec3_exports.scale(vec3_exports.create(), delta, 1 / testSize);
  for (let i = 1; i < testSize; i++) {
    vec3_exports.scaleAndAdd(testPoint, ijk2, unitDelta, i);
    if (!testIJK(testPoint)) {
      return false;
    }
  }
  return true;
}
function createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices) {
  const vol = cache_default.getVolume(segVolumeId);
  if (!vol) {
    console.warn(`No volume found for ${segVolumeId}`);
    return;
  }
  const voxelManager = vol.voxelManager;
  const width = vol.dimensions[0];
  const pixelsPerSlice = width * vol.dimensions[1];
  return {
    testCenter: (point1, point2) => {
      const point = vec3_exports.add(vec3_exports.create(), point1, point2).map((it) => it / 2);
      const ijk = vol.imageData.worldToIndex(point).map(Math.round);
      const [i, j, k] = ijk;
      const index = i + j * width + k * pixelsPerSlice;
      const value = voxelManager.getAtIndex(index);
      return value === segmentIndex || (containedSegmentIndices == null ? void 0 : containedSegmentIndices.has(value));
    },
    toIJK: (point) => vol.imageData.worldToIndex(point),
    testIJK: (ijk) => {
      const [i, j, k] = ijk;
      const index = Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;
      const value = voxelManager.getAtIndex(index);
      return value === segmentIndex || (containedSegmentIndices == null ? void 0 : containedSegmentIndices.has(value));
    }
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/findLargestBidirectional.js
var EPSILON7 = 0.01;
function findLargestBidirectional(contours, segVolumeId, segment) {
  const { sliceContours } = contours;
  const { segmentIndex, containedSegmentIndices } = segment;
  let maxBidirectional;
  const isInSegment = createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices);
  for (const sliceContour of sliceContours) {
    const bidirectional = createBidirectionalForSlice(sliceContour, isInSegment, maxBidirectional);
    if (!bidirectional) {
      continue;
    }
    maxBidirectional = bidirectional;
  }
  if (maxBidirectional) {
    Object.assign(maxBidirectional, segment);
  }
  return maxBidirectional;
}
function createBidirectionalForSlice(sliceContour, isInSegment, currentMax = { maxMajor: 0, maxMinor: 0 }) {
  const { points } = sliceContour.polyData;
  const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;
  let maxMajor = currentMaxMajor * currentMaxMajor;
  let maxMinor = currentMaxMinor * currentMaxMinor;
  let maxMajorPoints;
  for (let index1 = 0; index1 < points.length; index1++) {
    for (let index2 = index1 + 1; index2 < points.length; index2++) {
      const point1 = points[index1];
      const point2 = points[index2];
      const distance2 = vec3_exports.sqrDist(point1, point2);
      if (distance2 < maxMajor) {
        continue;
      }
      if (distance2 - EPSILON7 < maxMajor + EPSILON7 && maxMajorPoints) {
        continue;
      }
      if (!isInSegment.testCenter(point1, point2)) {
        continue;
      }
      if (!isLineInSegment(point1, point2, isInSegment)) {
        continue;
      }
      maxMajor = distance2 - EPSILON7;
      maxMajorPoints = [index1, index2];
      maxMinor = 0;
    }
  }
  if (!maxMajorPoints) {
    return;
  }
  maxMajor = Math.sqrt(maxMajor + EPSILON7);
  const handle0 = points[maxMajorPoints[0]];
  const handle1 = points[maxMajorPoints[1]];
  const unitMajor = vec3_exports.sub(vec3_exports.create(), handle0, handle1);
  vec3_exports.scale(unitMajor, unitMajor, 1 / maxMajor);
  let maxMinorPoints;
  for (let index1 = 0; index1 < points.length; index1++) {
    for (let index2 = index1 + 1; index2 < points.length; index2++) {
      const point1 = points[index1];
      const point2 = points[index2];
      const distance2 = vec3_exports.sqrDist(point1, point2);
      if (distance2 <= maxMinor) {
        continue;
      }
      const delta = vec3_exports.sub(vec3_exports.create(), point1, point2);
      const dot = Math.abs(vec3_exports.dot(delta, unitMajor)) / Math.sqrt(distance2);
      if (dot > EPSILON7) {
        continue;
      }
      if (!isInSegment.testCenter(point1, point2)) {
        continue;
      }
      if (!isLineInSegment(point1, point2, isInSegment)) {
        continue;
      }
      maxMinor = distance2;
      maxMinorPoints = [index1, index2];
    }
  }
  if (!maxMinorPoints) {
    return;
  }
  maxMinor = Math.sqrt(maxMinor);
  const handle2 = points[maxMinorPoints[0]];
  const handle3 = points[maxMinorPoints[1]];
  const bidirectional = {
    majorAxis: [handle0, handle1],
    minorAxis: [handle2, handle3],
    maxMajor,
    maxMinor,
    ...sliceContour
  };
  return bidirectional;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/contourAndFindLargestBidirectional.js
var { Labelmap: Labelmap2 } = SegmentationRepresentations_default;
function contourAndFindLargestBidirectional(segmentation) {
  const contours = generateContourSetsFromLabelmap({
    segmentations: segmentation
  });
  if (!(contours == null ? void 0 : contours.length) || !contours[0].sliceContours.length) {
    return;
  }
  const { representationData, segments = [
    null,
    { label: "Unspecified", color: null, containedSegmentIndices: null }
  ] } = segmentation;
  const { volumeId: segVolumeId } = representationData[Labelmap2];
  const segmentIndex = segments.findIndex((it) => !!it);
  if (segmentIndex === -1) {
    return;
  }
  segments[segmentIndex].segmentIndex = segmentIndex;
  return findLargestBidirectional(contours[0], segVolumeId, segments[segmentIndex]);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createBidirectionalToolData.js
function createBidirectionalToolData(bidirectionalData, viewport) {
  const { majorAxis, minorAxis, label = "", sliceIndex } = bidirectionalData;
  const [major0, major1] = majorAxis;
  const [minor0, minor1] = minorAxis;
  const points = [major0, major1, minor0, minor1];
  const bidirectionalToolData = {
    highlighted: true,
    invalidated: true,
    metadata: {
      toolName: "Bidirectional",
      ...viewport.getViewReference({ sliceIndex })
    },
    data: {
      handles: {
        points,
        textBox: {
          hasMoved: false,
          worldPosition: [0, 0, 0],
          worldBoundingBox: {
            topLeft: [0, 0, 0],
            topRight: [0, 0, 0],
            bottomLeft: [0, 0, 0],
            bottomRight: [0, 0, 0]
          }
        },
        activeHandleIndex: null
      },
      label,
      cachedStats: {}
    },
    isLocked: false,
    isVisible: true
  };
  return bidirectionalToolData;
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js
var { transformWorldToIndex: transformWorldToIndex7 } = utilities_exports;
var BidirectionalTool = class extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      preventHandleOutsideImage: false,
      getTextLines: defaultGetTextLines4
    }
  }) {
    super(toolProps, defaultToolProps);
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const { points } = data.handles;
      let canvasPoint1 = viewport.worldToCanvas(points[0]);
      let canvasPoint2 = viewport.worldToCanvas(points[1]);
      let line = {
        start: {
          x: canvasPoint1[0],
          y: canvasPoint1[1]
        },
        end: {
          x: canvasPoint2[0],
          y: canvasPoint2[1]
        }
      };
      let distanceToPoint5 = distanceToPoint3([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
      if (distanceToPoint5 <= proximity) {
        return true;
      }
      canvasPoint1 = viewport.worldToCanvas(points[2]);
      canvasPoint2 = viewport.worldToCanvas(points[3]);
      line = {
        start: {
          x: canvasPoint1[0],
          y: canvasPoint1[1]
        },
        end: {
          x: canvasPoint2[0],
          y: canvasPoint2[1]
        }
      };
      distanceToPoint5 = distanceToPoint3([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
      if (distanceToPoint5 <= proximity) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        movingTextBox: false
      };
      this._activateModify(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      hideElementCursor(element);
      evt.preventDefault();
    };
    this.handleSelectedCallback = (evt, annotation, handle) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const data = annotation.data;
      annotation.highlighted = true;
      let movingTextBox = false;
      let handleIndex;
      if (handle.worldPosition) {
        movingTextBox = true;
      } else {
        handleIndex = data.handles.points.findIndex((p) => p === handle);
      }
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      hideElementCursor(element);
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex,
        movingTextBox
      };
      this._activateModify(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      this.doneEditMemo();
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      const { renderingEngine } = getEnabledElement(element);
      if (this.editData.handleIndex !== void 0) {
        const { points } = data.handles;
        const firstLineSegmentLength = vec3_exports.distance(points[0], points[1]);
        const secondLineSegmentLength = vec3_exports.distance(points[2], points[3]);
        if (secondLineSegmentLength > firstLineSegmentLength) {
          const longAxis = [[...points[2]], [...points[3]]];
          const shortAxisPoint0 = [...points[0]];
          const shortAxisPoint1 = [...points[1]];
          const longAxisVector = vec2_exports.create();
          vec2_exports.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);
          const counterClockWisePerpendicularToLongAxis = vec2_exports.create();
          vec2_exports.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);
          const currentShortAxisVector = vec2_exports.create();
          vec2_exports.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);
          let shortAxis;
          if (vec2_exports.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {
            shortAxis = [shortAxisPoint0, shortAxisPoint1];
          } else {
            shortAxis = [shortAxisPoint1, shortAxisPoint0];
          }
          data.handles.points = [
            longAxis[0],
            longAxis[1],
            shortAxis[0],
            shortAxis[1]
          ];
        }
      }
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
      this.editData = null;
      this.isDrawing = false;
    };
    this._dragDrawCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { worldToCanvas } = viewport;
      const { annotation, viewportIdsToRender, handleIndex, newAnnotation } = this.editData;
      this.createMemo(element, annotation, { newAnnotation });
      const { data } = annotation;
      const worldPos = currentPoints.world;
      data.handles.points[handleIndex] = [...worldPos];
      const canvasCoordPoints = data.handles.points.map(worldToCanvas);
      const canvasCoords = {
        longLineSegment: {
          start: {
            x: canvasCoordPoints[0][0],
            y: canvasCoordPoints[0][1]
          },
          end: {
            x: canvasCoordPoints[1][0],
            y: canvasCoordPoints[1][1]
          }
        },
        shortLineSegment: {
          start: {
            x: canvasCoordPoints[2][0],
            y: canvasCoordPoints[2][1]
          },
          end: {
            x: canvasCoordPoints[3][0],
            y: canvasCoordPoints[3][1]
          }
        }
      };
      const dist = vec2_exports.distance(canvasCoordPoints[0], canvasCoordPoints[1]);
      const shortAxisDistFromCenter = dist / 3;
      const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;
      const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const vectorX = dx / length;
      const vectorY = dy / length;
      const xMid = (canvasCoords.longLineSegment.start.x + canvasCoords.longLineSegment.end.x) / 2;
      const yMid = (canvasCoords.longLineSegment.start.y + canvasCoords.longLineSegment.end.y) / 2;
      const startX = xMid + shortAxisDistFromCenter * vectorY;
      const startY = yMid - shortAxisDistFromCenter * vectorX;
      const endX = xMid - shortAxisDistFromCenter * vectorY;
      const endY = yMid + shortAxisDistFromCenter * vectorX;
      data.handles.points[2] = viewport.canvasToWorld([startX, startY]);
      data.handles.points[3] = viewport.canvasToWorld([endX, endY]);
      annotation.invalidated = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      this.editData.hasMoved = true;
    };
    this._dragModifyCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation } = this.editData;
      this.createMemo(element, annotation, { newAnnotation });
      const { data } = annotation;
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const points = data.handles.points;
        points.forEach((point) => {
          point[0] += worldPosDelta[0];
          point[1] += worldPosDelta[1];
          point[2] += worldPosDelta[2];
        });
        annotation.invalidated = true;
      } else {
        this._dragModifyHandle(evt);
        annotation.invalidated = true;
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._dragModifyHandle = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { annotation, handleIndex: movingHandleIndex } = this.editData;
      const { data } = annotation;
      const worldPos = currentPoints.world;
      const canvasCoordHandlesCurrent = [
        viewport.worldToCanvas(data.handles.points[0]),
        viewport.worldToCanvas(data.handles.points[1]),
        viewport.worldToCanvas(data.handles.points[2]),
        viewport.worldToCanvas(data.handles.points[3])
      ];
      const firstLineSegment = {
        start: {
          x: canvasCoordHandlesCurrent[0][0],
          y: canvasCoordHandlesCurrent[0][1]
        },
        end: {
          x: canvasCoordHandlesCurrent[1][0],
          y: canvasCoordHandlesCurrent[1][1]
        }
      };
      const secondLineSegment = {
        start: {
          x: canvasCoordHandlesCurrent[2][0],
          y: canvasCoordHandlesCurrent[2][1]
        },
        end: {
          x: canvasCoordHandlesCurrent[3][0],
          y: canvasCoordHandlesCurrent[3][1]
        }
      };
      const proposedPoint = [...worldPos];
      const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);
      if (movingHandleIndex === 0 || movingHandleIndex === 1) {
        const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;
        const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];
        const fixedHandleToProposedCoordVec = vec2_exports.set(vec2_exports.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);
        const fixedHandleToOldCoordVec = vec2_exports.set(vec2_exports.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] - fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] - fixedHandleCanvasCoord[1]);
        vec2_exports.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);
        vec2_exports.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);
        const proposedFirstLineSegment = {
          start: {
            x: fixedHandleCanvasCoord[0],
            y: fixedHandleCanvasCoord[1]
          },
          end: {
            x: proposedCanvasCoord[0],
            y: proposedCanvasCoord[1]
          }
        };
        if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {
          return;
        }
        const centerOfRotation = fixedHandleCanvasCoord;
        const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);
        let firstPointX = canvasCoordHandlesCurrent[2][0];
        let firstPointY = canvasCoordHandlesCurrent[2][1];
        let secondPointX = canvasCoordHandlesCurrent[3][0];
        let secondPointY = canvasCoordHandlesCurrent[3][1];
        firstPointX -= centerOfRotation[0];
        firstPointY -= centerOfRotation[1];
        secondPointX -= centerOfRotation[0];
        secondPointY -= centerOfRotation[1];
        const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);
        const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);
        const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);
        const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);
        firstPointX = rotatedFirstPoint + centerOfRotation[0];
        firstPointY = rotatedFirstPointY + centerOfRotation[1];
        secondPointX = rotatedSecondPoint + centerOfRotation[0];
        secondPointY = rotatedSecondPointY + centerOfRotation[1];
        const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);
        const newSecondPoint = viewport.canvasToWorld([
          secondPointX,
          secondPointY
        ]);
        data.handles.points[movingHandleIndex] = proposedPoint;
        data.handles.points[2] = newFirstPoint;
        data.handles.points[3] = newSecondPoint;
      } else {
        const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;
        const canvasCoordsCurrent = {
          longLineSegment: {
            start: firstLineSegment.start,
            end: firstLineSegment.end
          },
          shortLineSegment: {
            start: secondLineSegment.start,
            end: secondLineSegment.end
          }
        };
        const longLineSegmentVec = vec2_exports.subtract(vec2_exports.create(), [
          canvasCoordsCurrent.longLineSegment.end.x,
          canvasCoordsCurrent.longLineSegment.end.y
        ], [
          canvasCoordsCurrent.longLineSegment.start.x,
          canvasCoordsCurrent.longLineSegment.start.y
        ]);
        const longLineSegmentVecNormalized = vec2_exports.normalize(vec2_exports.create(), longLineSegmentVec);
        const proposedToCurrentVec = vec2_exports.subtract(vec2_exports.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [
          canvasCoordHandlesCurrent[movingHandleIndex][0],
          canvasCoordHandlesCurrent[movingHandleIndex][1]
        ]);
        const movementLength = vec2_exports.length(proposedToCurrentVec);
        const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);
        const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;
        const newTranslatedPoint = vec2_exports.scaleAndAdd(vec2_exports.create(), [
          canvasCoordHandlesCurrent[translateHandleIndex][0],
          canvasCoordHandlesCurrent[translateHandleIndex][1]
        ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);
        if (this._movingLongAxisWouldPutItThroughShortAxis({
          start: {
            x: proposedCanvasCoord[0],
            y: proposedCanvasCoord[1]
          },
          end: {
            x: newTranslatedPoint[0],
            y: newTranslatedPoint[1]
          }
        }, {
          start: {
            x: canvasCoordsCurrent.longLineSegment.start.x,
            y: canvasCoordsCurrent.longLineSegment.start.y
          },
          end: {
            x: canvasCoordsCurrent.longLineSegment.end.x,
            y: canvasCoordsCurrent.longLineSegment.end.y
          }
        })) {
          return;
        }
        const intersectionPoint = intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);
        if (!intersectionPoint) {
          return;
        }
        data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);
        data.handles.points[movingHandleIndex] = proposedPoint;
      }
    };
    this.cancel = (element) => {
      if (this.isDrawing) {
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        resetElementCursor(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        const { data } = annotation;
        annotation.highlighted = false;
        data.handles.activeHandleIndex = null;
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        if (newAnnotation) {
          triggerAnnotationCompleted(annotation);
        }
        this.editData = null;
        return annotation.annotationUID;
      }
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragDrawCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragDrawCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragDrawCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragDrawCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragDrawCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragDrawCallback);
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragModifyCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragModifyCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragModifyCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragModifyCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = true;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const targetId = this.getTargetId(viewport);
      const renderingEngine = viewport.getRenderingEngine();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { points, activeHandleIndex } = data.handles;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        if (!data.cachedStats[targetId] || data.cachedStats[targetId].unit == null) {
          data.cachedStats[targetId] = {
            length: null,
            width: null,
            unit: null
          };
          this._calculateCachedStats(annotation, renderingEngine, enabledElement);
        } else if (annotation.invalidated) {
          this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
        }
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        let activeHandleCanvasCoords;
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
            color
          });
        }
        const dataId1 = `${annotationUID}-line-1`;
        const dataId2 = `${annotationUID}-line-2`;
        const lineUID = "0";
        drawLine(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
          color,
          lineDash,
          lineWidth,
          shadow
        }, dataId1);
        const secondLineUID = "1";
        drawLine(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {
          color,
          lineDash,
          lineWidth,
          shadow
        }, dataId2);
        renderStatus = true;
        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        if (!options.visibility) {
          data.handles.textBox = {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          };
          continue;
        }
        const textLines = this.configuration.getTextLines(data, targetId);
        if (!textLines || textLines.length === 0) {
          continue;
        }
        let canvasTextBoxCoords;
        if (!data.handles.textBox.hasMoved) {
          canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);
          data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
        }
        const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
        const textBoxUID = "1";
        const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
        const { x: left, y: top, width, height } = boundingBox;
        data.handles.textBox.worldBoundingBox = {
          topLeft: viewport.canvasToWorld([left, top]),
          topRight: viewport.canvasToWorld([left + width, top]),
          bottomLeft: viewport.canvasToWorld([left, top + height]),
          bottomRight: viewport.canvasToWorld([left + width, top + height])
        };
      }
      return renderStatus;
    };
    this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {
      const vectorInSecondLineDirection = vec2_exports.create();
      vec2_exports.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);
      vec2_exports.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);
      const extendedSecondLineSegment = {
        start: {
          x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,
          y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10
        },
        end: {
          x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,
          y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10
        }
      };
      const proposedIntersectionPoint = intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);
      const wouldPutThroughShortAxis = !proposedIntersectionPoint;
      return wouldPutThroughShortAxis;
    };
    this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {
      const { data } = annotation;
      const { element } = enabledElement.viewport;
      const worldPos1 = data.handles.points[0];
      const worldPos2 = data.handles.points[1];
      const worldPos3 = data.handles.points[2];
      const worldPos4 = data.handles.points[3];
      const { cachedStats } = data;
      const targetIds = Object.keys(cachedStats);
      for (let i = 0; i < targetIds.length; i++) {
        const targetId = targetIds[i];
        const image = this.getTargetImageData(targetId);
        if (!image) {
          continue;
        }
        const { imageData, dimensions } = image;
        const index1 = transformWorldToIndex7(imageData, worldPos1);
        const index2 = transformWorldToIndex7(imageData, worldPos2);
        const index3 = transformWorldToIndex7(imageData, worldPos3);
        const index4 = transformWorldToIndex7(imageData, worldPos4);
        const handles1 = [index1, index2];
        const handles2 = [index3, index4];
        const { scale: scale1, unit: units1 } = getCalibratedLengthUnitsAndScale(image, handles1);
        const { scale: scale2, unit: units2 } = getCalibratedLengthUnitsAndScale(image, handles2);
        const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;
        const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;
        const length = dist1 > dist2 ? dist1 : dist2;
        const width = dist1 > dist2 ? dist2 : dist1;
        const unit = dist1 > dist2 ? units1 : units2;
        const widthUnit = dist1 > dist2 ? units2 : units1;
        this._isInsideVolume(index1, index2, index3, index4, dimensions) ? this.isHandleOutsideImage = false : this.isHandleOutsideImage = true;
        cachedStats[targetId] = {
          length,
          width,
          unit,
          widthUnit
        };
      }
      annotation.invalidated = false;
      triggerAnnotationModified(annotation, element);
      return cachedStats;
    };
    this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {
      return utilities_exports.indexWithinDimensions(index1, dimensions) && utilities_exports.indexWithinDimensions(index2, dimensions) && utilities_exports.indexWithinDimensions(index3, dimensions) && utilities_exports.indexWithinDimensions(index4, dimensions);
    };
    this._getSignedAngle = (vector1, vector2) => {
      return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
  addNewAnnotation(evt) {
    const eventDetail = evt.detail;
    const { currentPoints, element } = eventDetail;
    const worldPos = currentPoints.world;
    const enabledElement = getEnabledElement(element);
    const { viewport, renderingEngine } = enabledElement;
    this.isDrawing = true;
    const camera = viewport.getCamera();
    const { viewPlaneNormal, viewUp } = camera;
    const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
    const annotation = {
      highlighted: true,
      invalidated: true,
      metadata: {
        toolName: this.getToolName(),
        viewPlaneNormal: [...viewPlaneNormal],
        viewUp: [...viewUp],
        FrameOfReferenceUID,
        referencedImageId,
        ...viewport.getViewReference({ points: [worldPos] })
      },
      data: {
        handles: {
          points: [
            [...worldPos],
            [...worldPos],
            [...worldPos],
            [...worldPos]
          ],
          textBox: {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          },
          activeHandleIndex: null
        },
        label: "",
        cachedStats: {}
      }
    };
    addAnnotation(annotation, element);
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    this.editData = {
      annotation,
      viewportIdsToRender,
      handleIndex: 1,
      movingTextBox: false,
      newAnnotation: true,
      hasMoved: false
    };
    this._activateDraw(element);
    hideElementCursor(element);
    evt.preventDefault();
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    return annotation;
  }
  _calculateLength(pos1, pos2) {
    const dx = pos1[0] - pos2[0];
    const dy = pos1[1] - pos2[1];
    const dz = pos1[2] - pos2[2];
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }
};
function defaultGetTextLines4(data, targetId) {
  const { cachedStats, label } = data;
  const { length, width, unit } = cachedStats[targetId];
  const textLines = [];
  if (label) {
    textLines.push(label);
  }
  if (length === void 0) {
    return textLines;
  }
  textLines.push(`L: ${utilities_exports.roundNumber(length)} ${unit || unit}`, `W: ${utilities_exports.roundNumber(width)} ${unit}`);
  return textLines;
}
BidirectionalTool.toolName = "Bidirectional";
var BidirectionalTool_default = BidirectionalTool;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/segmentContourAction.js
function segmentContourAction(element, configuration3) {
  const { data: configurationData } = configuration3;
  const enabledElement = getEnabledElement(element);
  const segment = (configurationData.getSegment || defaultGetSegment)(enabledElement, configurationData);
  if (!segment) {
    return;
  }
  const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();
  const segmentationsList = getSegmentations();
  const { segmentIndex, segmentationId } = segment;
  const bidirectionals = state5.getAnnotations(this.toolName || BidirectionalTool_default.toolName, FrameOfReferenceUID);
  let hasExistingActiveSegment = false;
  const existingLargestBidirectionals = bidirectionals.filter((existingBidirectionalItem) => {
    const segment2 = existingBidirectionalItem.data.segment;
    if (!segment2) {
      return false;
    }
    if (segment2.segmentationId === segmentationId && segment2.segmentIndex === segmentIndex) {
      hasExistingActiveSegment = true;
      existingBidirectionalItem.data.segment = segment2;
    }
    return true;
  });
  if (!hasExistingActiveSegment) {
    existingLargestBidirectionals.push({
      data: { segment }
    });
  }
  let newBidirectional;
  existingLargestBidirectionals.forEach((existingLargestBidirectional) => {
    const segments = [];
    const updateSegment = existingLargestBidirectional.data.segment;
    const { segmentIndex: segmentIndex2, segmentationId: segmentationId2 } = updateSegment;
    segments[segmentIndex2] = updateSegment;
    state5.removeAnnotation(existingLargestBidirectional.annotationUID);
    const bidirectionalData = contourAndFindLargestBidirectional({
      ...segmentationsList.find((segmentation) => segmentation.segmentationId === segmentationId2),
      segments
    });
    if (!bidirectionalData) {
      return;
    }
    const bidirectionalToolData = createBidirectionalToolData(bidirectionalData, enabledElement.viewport);
    bidirectionalToolData.annotationUID = existingLargestBidirectional.annotationUID;
    bidirectionalToolData.data.segment = updateSegment;
    const annotationUID = state5.addAnnotation(bidirectionalToolData, FrameOfReferenceUID);
    if (updateSegment.segmentIndex === segment.segmentIndex && updateSegment.segmentationId === segment.segmentationId) {
      newBidirectional = bidirectionalData;
      const { style } = segment;
      if (style) {
        config_exports.style.setAnnotationStyles(annotationUID, style);
      }
    }
  });
  if (newBidirectional) {
    const { sliceIndex } = newBidirectional;
    const imageIds = enabledElement.viewport.getImageIds();
    utilities_exports.jumpToSlice(element, {
      imageIndex: imageIds.length - 1 - sliceIndex
    });
    enabledElement.viewport.render();
  } else {
    console.warn("No bidirectional found");
  }
  return newBidirectional;
}
function defaultGetSegment(enabledElement, configuration3) {
  var _a2;
  const segmentationsList = getSegmentations();
  if (!segmentationsList.length) {
    return;
  }
  const segmentationId = configuration3.segmentationId || segmentationsList[0].segmentationId;
  const segmentIndex = configuration3.segmentIndex ?? getActiveSegmentIndex(segmentationId);
  if (!segmentIndex) {
    return;
  }
  const segmentData = (_a2 = configuration3.segmentData) == null ? void 0 : _a2.get(segmentIndex);
  return {
    label: `Segment ${segmentIndex}`,
    segmentIndex,
    segmentationId,
    ...segmentData
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/invalidateBrushCursor.js
function invalidateBrushCursor(toolGroupId) {
  const toolGroup = getToolGroup_default(toolGroupId);
  if (toolGroup === void 0) {
    return;
  }
  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);
  brushBasedToolInstances.forEach((tool) => {
    tool.invalidateBrushCursor();
  });
  const viewportsInfo = toolGroup.getViewportsInfo();
  const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);
  if (!viewportsInfoArray.length) {
    return;
  }
  const viewportIds = toolGroup.getViewportIds();
  triggerAnnotationRenderForViewportIds_default(viewportIds);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtWorldPoint.js
function getSegmentIndexAtWorldPoint(segmentationId, worldPoint, options = {}) {
  const segmentation = getSegmentation(segmentationId);
  const representationData = segmentation.representationData;
  const desiredRepresentation = (options == null ? void 0 : options.representationType) ?? Object.keys(representationData)[0];
  if (!desiredRepresentation) {
    throw new Error(`Segmentation ${segmentationId} does not have any representations`);
  }
  switch (desiredRepresentation) {
    case SegmentationRepresentations_default.Labelmap:
      return getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, options);
    case SegmentationRepresentations_default.Contour:
      return getSegmentIndexAtWorldForContour(segmentation, worldPoint, options);
    default:
      return;
  }
}
function getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, { viewport }) {
  const labelmapData = segmentation.representationData.Labelmap;
  if (viewport instanceof BaseVolumeViewport_default) {
    const { volumeId } = labelmapData;
    const segmentationVolume = cache_default.getVolume(volumeId);
    if (!segmentationVolume) {
      return;
    }
    const segmentIndex2 = segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);
    return segmentIndex2;
  }
  const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentation.segmentationId);
  const image = cache_default.getImage(segmentationImageId);
  if (!image) {
    return;
  }
  const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentation.segmentationId);
  const imageData = segmentationActorEntry == null ? void 0 : segmentationActorEntry.actor.getMapper().getInputData();
  const indexIJK = utilities_exports.transformWorldToIndex(imageData, worldPoint);
  const dimensions = imageData.getDimensions();
  const voxelManager = imageData.voxelManager || utilities_exports.VoxelManager.createScalarVolumeVoxelManager({
    dimensions,
    scalarData: imageData.getPointData().getScalars().getData()
  });
  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);
  return segmentIndex;
}
function getSegmentIndexAtWorldForContour(segmentation, worldPoint, { viewport }) {
  const contourData = segmentation.representationData.Contour;
  const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());
  const { viewPlaneNormal } = viewport.getCamera();
  for (const segmentIndex of segmentIndices) {
    const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);
    if (!annotationsSet) {
      continue;
    }
    for (const annotationUID of annotationsSet) {
      const annotation = getAnnotation(annotationUID);
      if (!annotation) {
        continue;
      }
      const { polyline } = annotation.data.contour;
      if (!utilities_exports.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)) {
        continue;
      }
      if (isPointInsidePolyline3D(worldPoint, polyline)) {
        return Number(segmentIndex);
      }
    }
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtLabelmapBorder.js
function getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, { viewport, searchRadius }) {
  const segmentation = getSegmentation(segmentationId);
  const labelmapData = segmentation.representationData.Labelmap;
  if (viewport instanceof BaseVolumeViewport_default) {
    const { volumeId } = labelmapData;
    const segmentationVolume = cache_default.getVolume(volumeId);
    if (!segmentationVolume) {
      return;
    }
    const voxelManager2 = segmentationVolume.voxelManager;
    const imageData2 = segmentationVolume.imageData;
    const indexIJK2 = utilities_exports.transformWorldToIndex(imageData2, worldPoint);
    const segmentIndex2 = voxelManager2.getAtIJK(indexIJK2[0], indexIJK2[1], indexIJK2[2]);
    const canvasPoint = viewport.worldToCanvas(worldPoint);
    const onEdge2 = isSegmentOnEdgeCanvas(canvasPoint, segmentIndex2, viewport, imageData2, searchRadius);
    return onEdge2 ? segmentIndex2 : void 0;
  }
  const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);
  const image = cache_default.getImage(segmentationImageId);
  if (!image) {
    return;
  }
  const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);
  const imageData = segmentationActorEntry == null ? void 0 : segmentationActorEntry.actor.getMapper().getInputData();
  const indexIJK = utilities_exports.transformWorldToIndex(imageData, worldPoint);
  const dimensions = imageData.getDimensions();
  const voxelManager = imageData.voxelManager || utilities_exports.VoxelManager.createScalarVolumeVoxelManager({
    dimensions,
    scalarData: imageData.getPointData().getScalars().getData()
  });
  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);
  const onEdge = isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex);
  return onEdge ? segmentIndex : void 0;
}
function isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius = 1) {
  const neighborRange = Array.from({ length: 2 * searchRadius + 1 }, (_, i) => i - searchRadius);
  for (const deltaI of neighborRange) {
    for (const deltaJ of neighborRange) {
      for (const deltaK of neighborRange) {
        if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {
          continue;
        }
        const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);
        if (neighborIndex !== void 0 && segmentIndex !== neighborIndex) {
          return true;
        }
      }
    }
  }
  return false;
}
function isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex, searchRadius) {
  const getNeighborIndex = (deltaI, deltaJ, deltaK) => {
    const neighborIJK = [
      indexIJK[0] + deltaI,
      indexIJK[1] + deltaJ,
      indexIJK[2] + deltaK
    ];
    return voxelManager.getAtIJK(neighborIJK[0], neighborIJK[1], neighborIJK[2]);
  };
  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);
}
function isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius) {
  const getNeighborIndex = (deltaI, deltaJ) => {
    const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];
    const worldPoint = viewport.canvasToWorld(neighborCanvas);
    const voxelManager = imageData.get("voxelManager").voxelManager;
    const indexIJK = utilities_exports.transformWorldToIndex(imageData, worldPoint);
    return voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);
  };
  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getHoveredContourSegmentationAnnotation.js
function getHoveredContourSegmentationAnnotation(segmentationId) {
  const segmentation = getSegmentation(segmentationId);
  const { annotationUIDsMap } = segmentation.representationData.Contour;
  for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {
    const highlightedAnnotationUID = Array.from(annotationUIDs).find((annotationUID) => getAnnotation(annotationUID).highlighted);
    if (highlightedAnnotationUID) {
      return segmentIndex;
    }
  }
  return void 0;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/index.js
var growCut_exports = {};
__export(growCut_exports, {
  run: () => runGrowCut,
  runGrowCutForBoundingBox: () => runGrowCutForBoundingBox,
  runGrowCutForSphere: () => runGrowCutForSphere,
  runOneClickGrowCut: () => runOneClickGrowCut
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/growCutShader.js
var shader = `
const MAX_STRENGTH = 65535f;

// Workgroup soze - X*Y*Z must be multiple of 32 for better performance
// otherwise warps are sub allocated and some threads will not process anything
override workGroupSizeX = 1u;
override workGroupSizeY = 1u;
override workGroupSizeZ = 1u;

// Compare the current voxel to neighbors using a 9x9x9 window
override windowSize = 9i;

struct Params {
  size: vec3u,
  iteration: u32,
}

@group(0) @binding(0) var<uniform> params: Params;
@group(0) @binding(1) var<storage> volumePixelData: array<f32>;
@group(0) @binding(2) var<storage, read_write> labelmap: array<u32>;
@group(0) @binding(3) var<storage, read_write> strengthData: array<f32>;
@group(0) @binding(4) var<storage> prevLabelmap: array<u32>;
@group(0) @binding(5) var<storage> prevStrengthData: array<f32>;
@group(0) @binding(6) var<storage, read_write> updatedVoxelsCounter: array<atomic<u32>>;

fn getPixelIndex(ijkPos: vec3u) -> u32 {
  let numPixelsPerSlice = params.size.x * params.size.y;
  return ijkPos.x + ijkPos.y * params.size.x + ijkPos.z * numPixelsPerSlice;
}

@compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
fn main(
  @builtin(global_invocation_id) globalId: vec3u,
) {
  // Make sure it will not get out of bounds for volume with sizes that
  // are not multiple of workGroupSize
  if (
    globalId.x >= params.size.x ||
    globalId.y >= params.size.y ||
    globalId.z >= params.size.z
  ) {
    return;
  }

  let currentCoord = vec3i(globalId);
  let currentPixelIndex = getPixelIndex(globalId);

  let numPixels = arrayLength(&volumePixelData);
  let currentPixelValue = volumePixelData[currentPixelIndex];

  if (params.iteration == 0) {
    // All non-zero initial labels are given maximum strength
    strengthData[currentPixelIndex] = select(MAX_STRENGTH, 0., labelmap[currentPixelIndex] == 0);
    return;
  }

  // It should at least copy the values from previous state
  var newLabel = prevLabelmap[currentPixelIndex];
  var newStrength = prevStrengthData[currentPixelIndex];

  let window = i32(ceil(f32(windowSize - 1) * .5));
  let minWindow = -1i * window;
  let maxWindow = 1i * window;

  for (var k = minWindow; k <= maxWindow; k++) {
    for (var j = minWindow; j <= maxWindow; j++) {
      for (var i = minWindow; i <= maxWindow; i++) {
        // Skip current voxel
        if (i == 0 && j == 0 && k == 0) {
          continue;
        }

        let neighborCoord = currentCoord + vec3i(i, j, k);

        //  Boundary conditions. Do not grow outside of the volume
        if (
          neighborCoord.x < 0i || neighborCoord.x >= i32(params.size.x) ||
          neighborCoord.y < 0i || neighborCoord.y >= i32(params.size.y) ||
          neighborCoord.z < 0i || neighborCoord.z >= i32(params.size.z)
        ) {
          continue;
        }

        let neighborIndex = getPixelIndex(vec3u(neighborCoord));
        let neighborPixelValue = volumePixelData[neighborIndex];
        let prevNeighborStrength = prevStrengthData[neighborIndex];
        let strengthCost = abs(neighborPixelValue - currentPixelValue);
        let takeoverStrength = prevNeighborStrength - strengthCost;

        if (takeoverStrength > newStrength) {
          newLabel = prevLabelmap[neighborIndex];
          newStrength = takeoverStrength;
        }
      }
    }
  }

  if (labelmap[currentPixelIndex] != newLabel) {
    atomicAdd(&updatedVoxelsCounter[params.iteration], 1u);
  }

  labelmap[currentPixelIndex] = newLabel;
  strengthData[currentPixelIndex] = newStrength;
}
`;
var growCutShader_default = shader;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js
var GB = 1024 * 1024 * 1024;
var WEBGPU_MEMORY_LIMIT = 1.99 * GB;
var DEFAULT_GROWCUT_OPTIONS = {
  windowSize: 3,
  maxProcessingTime: 3e4,
  inspection: {
    numCyclesInterval: 5,
    numCyclesBelowThreshold: 3,
    threshold: 1e-4
  }
};
async function runGrowCut(referenceVolumeId, labelmapVolumeId, options = DEFAULT_GROWCUT_OPTIONS) {
  var _a2;
  const workGroupSize = [8, 8, 4];
  const { windowSize, maxProcessingTime } = Object.assign({}, DEFAULT_GROWCUT_OPTIONS, options);
  const inspection = Object.assign({}, DEFAULT_GROWCUT_OPTIONS.inspection, options.inspection);
  const volume = cache_default.getVolume(referenceVolumeId);
  const labelmap = cache_default.getVolume(labelmapVolumeId);
  const [columns, rows, numSlices] = volume.dimensions;
  if (labelmap.dimensions[0] !== columns || labelmap.dimensions[1] !== rows || labelmap.dimensions[2] !== numSlices) {
    throw new Error("Volume and labelmap must have the same size");
  }
  const numIterations = Math.floor(Math.sqrt(rows ** 2 + columns ** 2 + numSlices ** 2) / 2);
  const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();
  let volumePixelData = volume.voxelManager.getCompleteScalarDataArray();
  if (!(volumePixelData instanceof Float32Array)) {
    volumePixelData = new Float32Array(volumePixelData);
  }
  const requiredLimits = {
    maxStorageBufferBindingSize: WEBGPU_MEMORY_LIMIT,
    maxBufferSize: WEBGPU_MEMORY_LIMIT
  };
  const adapter = await ((_a2 = navigator.gpu) == null ? void 0 : _a2.requestAdapter());
  const device = await adapter.requestDevice({ requiredLimits });
  const BUFFER_SIZE = volumePixelData.byteLength;
  const UPDATED_VOXELS_COUNTER_BUFFER_SIZE = numIterations * Uint32Array.BYTES_PER_ELEMENT;
  const shaderModule = device.createShaderModule({
    code: growCutShader_default
  });
  const numIterationIndex = 3;
  const paramsArrayValues = new Uint32Array([
    columns,
    rows,
    numSlices,
    0
  ]);
  const gpuParamsBuffer = device.createBuffer({
    size: paramsArrayValues.byteLength,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });
  const gpuVolumePixelDataBuffer = device.createBuffer({
    size: BUFFER_SIZE,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(gpuVolumePixelDataBuffer, 0, volumePixelData);
  const gpuLabelmapBuffers = [0, 1].map(() => device.createBuffer({
    size: BUFFER_SIZE,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
  }));
  device.queue.writeBuffer(gpuLabelmapBuffers[0], 0, new Uint32Array(labelmapData));
  const gpuStrengthBuffers = [0, 1].map(() => {
    const strengthBuffer = device.createBuffer({
      size: BUFFER_SIZE,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    return strengthBuffer;
  });
  const gpuCounterBuffer = device.createBuffer({
    size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
  });
  const bindGroupLayout = device.createBindGroupLayout({
    entries: [
      {
        binding: 0,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: "uniform"
        }
      },
      {
        binding: 1,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: "read-only-storage"
        }
      },
      {
        binding: 2,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: "storage"
        }
      },
      {
        binding: 3,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: "storage"
        }
      },
      {
        binding: 4,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: "read-only-storage"
        }
      },
      {
        binding: 5,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: "read-only-storage"
        }
      },
      {
        binding: 6,
        visibility: GPUShaderStage.COMPUTE,
        buffer: {
          type: "storage"
        }
      }
    ]
  });
  const bindGroups = [0, 1].map((i) => {
    const outputLabelmapBuffer = gpuLabelmapBuffers[i];
    const outputStrengthBuffer = gpuStrengthBuffers[i];
    const previouLabelmapBuffer = gpuLabelmapBuffers[(i + 1) % 2];
    const previousStrengthBuffer = gpuStrengthBuffers[(i + 1) % 2];
    return device.createBindGroup({
      layout: bindGroupLayout,
      entries: [
        {
          binding: 0,
          resource: {
            buffer: gpuParamsBuffer
          }
        },
        {
          binding: 1,
          resource: {
            buffer: gpuVolumePixelDataBuffer
          }
        },
        {
          binding: 2,
          resource: {
            buffer: outputLabelmapBuffer
          }
        },
        {
          binding: 3,
          resource: {
            buffer: outputStrengthBuffer
          }
        },
        {
          binding: 4,
          resource: {
            buffer: previouLabelmapBuffer
          }
        },
        {
          binding: 5,
          resource: {
            buffer: previousStrengthBuffer
          }
        },
        {
          binding: 6,
          resource: {
            buffer: gpuCounterBuffer
          }
        }
      ]
    });
  });
  const pipeline = device.createComputePipeline({
    layout: device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    }),
    compute: {
      module: shaderModule,
      entryPoint: "main",
      constants: {
        workGroupSizeX: workGroupSize[0],
        workGroupSizeY: workGroupSize[1],
        workGroupSizeZ: workGroupSize[2],
        windowSize
      }
    }
  });
  const numWorkGroups = [
    Math.ceil(columns / workGroupSize[0]),
    Math.ceil(rows / workGroupSize[1]),
    Math.ceil(numSlices / workGroupSize[2])
  ];
  const gpuUpdatedVoxelsCounterStagingBuffer = device.createBuffer({
    size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,
    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
  });
  const labelmapStagingBufferTemp = device.createBuffer({
    size: BUFFER_SIZE,
    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
  });
  const limitProcessingTime = maxProcessingTime ? performance.now() + maxProcessingTime : 0;
  let currentInspectionNumCyclesInterval = inspection.numCyclesInterval;
  let belowThresholdCounter = 0;
  for (let i = 0; i < numIterations; i++) {
    paramsArrayValues[numIterationIndex] = i;
    device.queue.writeBuffer(gpuParamsBuffer, 0, paramsArrayValues);
    const commandEncoder2 = device.createCommandEncoder();
    const passEncoder = commandEncoder2.beginComputePass();
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(0, bindGroups[i % 2]);
    passEncoder.dispatchWorkgroups(numWorkGroups[0], numWorkGroups[1], numWorkGroups[2]);
    passEncoder.end();
    commandEncoder2.copyBufferToBuffer(gpuCounterBuffer, i * Uint32Array.BYTES_PER_ELEMENT, gpuUpdatedVoxelsCounterStagingBuffer, i * Uint32Array.BYTES_PER_ELEMENT, Uint32Array.BYTES_PER_ELEMENT);
    device.queue.submit([commandEncoder2.finish()]);
    const inspect = i > 0 && !(i % currentInspectionNumCyclesInterval);
    if (inspect) {
      await gpuUpdatedVoxelsCounterStagingBuffer.mapAsync(GPUMapMode.READ, 0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);
      const updatedVoxelsCounterResultBuffer = gpuUpdatedVoxelsCounterStagingBuffer.getMappedRange(0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);
      const updatedVoxelsCounterBufferData = new Uint32Array(updatedVoxelsCounterResultBuffer.slice(0));
      const updatedVoxelsRatio = updatedVoxelsCounterBufferData[i] / volumePixelData.length;
      gpuUpdatedVoxelsCounterStagingBuffer.unmap();
      if (i >= 1 && updatedVoxelsRatio < inspection.threshold) {
        currentInspectionNumCyclesInterval = 1;
        belowThresholdCounter++;
        if (belowThresholdCounter === inspection.numCyclesBelowThreshold) {
          break;
        }
      } else {
        currentInspectionNumCyclesInterval = inspection.numCyclesInterval;
      }
    }
    if (limitProcessingTime && performance.now() > limitProcessingTime) {
      console.warn(`Exceeded processing time limit (${maxProcessingTime})ms`);
      break;
    }
  }
  const commandEncoder = device.createCommandEncoder();
  const outputLabelmapBufferIndex = (numIterations + 1) % 2;
  const labelmapStagingBuffer = device.createBuffer({
    size: BUFFER_SIZE,
    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
  });
  commandEncoder.copyBufferToBuffer(gpuLabelmapBuffers[outputLabelmapBufferIndex], 0, labelmapStagingBuffer, 0, BUFFER_SIZE);
  device.queue.submit([commandEncoder.finish()]);
  await labelmapStagingBuffer.mapAsync(GPUMapMode.READ, 0, BUFFER_SIZE);
  const labelmapResultBuffer = labelmapStagingBuffer.getMappedRange(0, BUFFER_SIZE);
  const labelmapResult = new Uint32Array(labelmapResultBuffer);
  labelmapData.set(labelmapResult);
  labelmapStagingBuffer.unmap();
  labelmap.voxelManager.setCompleteScalarDataArray(labelmapData);
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForSphere.js
var { transformWorldToIndex: transformWorldToIndex8 } = utilities_exports;
var POSITIVE_SEED_VALUE = 254;
var NEGATIVE_SEED_VALUE = 255;
var POSITIVE_SEED_VARIANCE = 0.1;
var NEGATIVE_SEED_VARIANCE = 0.8;
function _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo) {
  const { topLeftWorld, bottomRightWorld } = sphereBoundsInfo;
  const topLeftIJK = transformWorldToIndex8(referencedVolume.imageData, topLeftWorld);
  const bottomRightIJK = transformWorldToIndex8(referencedVolume.imageData, bottomRightWorld);
  return {
    ...sphereBoundsInfo,
    topLeftIJK,
    bottomRightIJK
  };
}
function _getSphereBoundsInfo2(referencedVolume, sphereInfo) {
  const direction = referencedVolume.imageData.getDirection();
  const vecColumn = vec3_exports.fromValues(direction[3], direction[4], direction[5]);
  const { center: sphereCenterPoint, radius: sphereRadius } = sphereInfo;
  const refVolImageData = referencedVolume.imageData;
  const topCirclePoint = vec3_exports.scaleAndAdd(vec3_exports.create(), sphereCenterPoint, vecColumn, -sphereRadius);
  const bottomCirclePoint = vec3_exports.scaleAndAdd(vec3_exports.create(), sphereCenterPoint, vecColumn, sphereRadius);
  const sphereBoundsInfo = getSphereBoundsInfo([bottomCirclePoint, topCirclePoint], refVolImageData);
  return _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo);
}
function _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport) {
  const refVolImageData = referencedVolume.imageData;
  const camera = viewport.getCamera();
  const { ijkVecRowDir, ijkVecColDir } = utilities_exports.getVolumeDirectionVectors(refVolImageData, camera);
  const obliqueView = [ijkVecRowDir, ijkVecColDir].some((vec) => !utilities_exports.isEqual(Math.abs(vec[0]), 1) && !utilities_exports.isEqual(Math.abs(vec[1]), 1) && !utilities_exports.isEqual(Math.abs(vec[2]), 1));
  if (obliqueView) {
    console.warn("Oblique view is not supported!");
    return;
  }
  const { boundsIJK: sphereBoundsIJK } = _getSphereBoundsInfo2(referencedVolume, sphereInfo);
  const subVolumeBoundsIJK = {
    minX: sphereBoundsIJK[0][0],
    maxX: sphereBoundsIJK[0][1] + 1,
    minY: sphereBoundsIJK[1][0],
    maxY: sphereBoundsIJK[1][1] + 1,
    minZ: sphereBoundsIJK[2][0],
    maxZ: sphereBoundsIJK[2][1] + 1
  };
  return utilities_exports.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {
    targetBuffer: {
      type: "Float32Array"
    }
  });
}
function _setPositiveSeedValues(referencedVolume, labelmap, sphereInfo, options) {
  const refVolumePixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();
  const worldStartPos = sphereInfo.center;
  const [width, height, numSlices] = referencedVolume.dimensions;
  const numPixelsPerSlice = width * height;
  const ijkStartPosition = transformWorldToIndex8(referencedVolume.imageData, worldStartPos);
  const referencePixelValue = refVolumePixelData[ijkStartPosition[2] * numPixelsPerSlice + ijkStartPosition[1] * width + ijkStartPosition[0]];
  const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE;
  const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE;
  const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);
  const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;
  const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;
  const neighborsCoordDelta = [
    [-1, 0, 0],
    [1, 0, 0],
    [0, -1, 0],
    [0, 1, 0],
    [0, 0, -1],
    [0, 0, 1]
  ];
  const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice + ijkStartPosition[1] * width + ijkStartPosition[0];
  labelmap.voxelManager.setAtIndex(startVoxelIndex, positiveSeedValue);
  const queue = [ijkStartPosition];
  while (queue.length) {
    const ijkVoxel = queue.shift();
    const [x, y, z] = ijkVoxel;
    for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {
      const neighborCoordDelta = neighborsCoordDelta[i];
      const nx = x + neighborCoordDelta[0];
      const ny = y + neighborCoordDelta[1];
      const nz = z + neighborCoordDelta[2];
      if (nx < 0 || nx >= width || ny < 0 || ny >= height || nz < 0 || nz >= numSlices) {
        continue;
      }
      const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;
      const neighborPixelValue = refVolumePixelData[neighborVoxelIndex];
      const neighborLabelmapValue = labelmap.voxelManager.getAtIndex(neighborVoxelIndex);
      if (neighborLabelmapValue === positiveSeedValue || neighborPixelValue < minPositivePixelValue || neighborPixelValue > maxPositivePixelValue) {
        continue;
      }
      labelmap.voxelManager.setAtIndex(neighborVoxelIndex, positiveSeedValue);
      queue.push([nx, ny, nz]);
    }
  }
}
function _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options) {
  const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
  const [columns, rows, numSlices] = labelmap.dimensions;
  const numPixelsPerSlice = columns * rows;
  const { worldVecRowDir, worldVecSliceDir } = utilities_exports.getVolumeDirectionVectors(labelmap.imageData, viewport.getCamera());
  const ijkSphereCenter = transformWorldToIndex8(subVolume.imageData, sphereInfo.center);
  const referencePixelValue = subVolPixelData[ijkSphereCenter[2] * columns * rows + ijkSphereCenter[1] * columns + ijkSphereCenter[0]];
  const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE;
  const negativeSeedValue = (options == null ? void 0 : options.negativeSeedValue) ?? NEGATIVE_SEED_VALUE;
  const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);
  const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;
  const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;
  const numCirclePoints = 360;
  const rotationAngle = 2 * Math.PI / numCirclePoints;
  const worldQuat = quat_exports.setAxisAngle(quat_exports.create(), worldVecSliceDir, rotationAngle);
  const vecRotation = vec3_exports.clone(worldVecRowDir);
  for (let i = 0; i < numCirclePoints; i++) {
    const worldCircleBorderPoint = vec3_exports.scaleAndAdd(vec3_exports.create(), sphereInfo.center, vecRotation, sphereInfo.radius);
    const ijkCircleBorderPoint = transformWorldToIndex8(labelmap.imageData, worldCircleBorderPoint);
    const [x, y, z] = ijkCircleBorderPoint;
    vec3_exports.transformQuat(vecRotation, vecRotation, worldQuat);
    if (x < 0 || x >= columns || y < 0 || y >= rows || z < 0 || z >= numSlices) {
      continue;
    }
    const offset = x + y * columns + z * numPixelsPerSlice;
    const pixelValue = subVolPixelData[offset];
    if (pixelValue < minNegativePixelValue || pixelValue > maxNegativePixelValue) {
      labelmap.voxelManager.setAtIndex(offset, negativeSeedValue);
    }
  }
}
async function _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options) {
  const labelmap = await volumeLoader_exports.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);
  _setPositiveSeedValues(subVolume, labelmap, sphereInfo, options);
  _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options);
  return labelmap;
}
async function runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options) {
  const referencedVolume = cache_default.getVolume(referencedVolumeId);
  const subVolume = _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport);
  const labelmap = await _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options);
  await runGrowCut(subVolume.volumeId, labelmap.volumeId);
  return labelmap;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForBoundingBox.js
var POSITIVE_SEED_VALUE2 = 254;
var NEGATIVE_SEED_VALUE2 = 255;
var NEGATIVE_PIXEL_RANGE = [-Infinity, -995];
var POSITIVE_PIXEL_RANGE = [0, 1900];
function _setNegativeSeedValues2(subVolume, labelmap, options) {
  const { negativeSeedValue = NEGATIVE_SEED_VALUE2, negativePixelRange = NEGATIVE_PIXEL_RANGE } = options;
  const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
  const [width, height, numSlices] = labelmap.dimensions;
  const middleSliceIndex = Math.floor(numSlices / 2);
  const visited = new Array(width * height).fill(false);
  const sliceOffset = middleSliceIndex * width * height;
  const bfs = (startX, startY) => {
    const queue = [[startX, startY]];
    while (queue.length) {
      const [x, y] = queue.shift();
      const slicePixelIndex = y * width + x;
      if (x < 0 || x >= width || y < 0 || y >= height || visited[slicePixelIndex]) {
        continue;
      }
      visited[slicePixelIndex] = true;
      const volumeVoxelIndex = sliceOffset + slicePixelIndex;
      const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];
      if (volumeVoxelValue < negativePixelRange[0] || volumeVoxelValue > negativePixelRange[1]) {
        continue;
      }
      labelmap.voxelManager.setAtIndex(volumeVoxelIndex, negativeSeedValue);
      queue.push([x - 1, y]);
      queue.push([x + 1, y]);
      queue.push([x, y - 1]);
      queue.push([x, y + 1]);
    }
  };
  const scanLine = (startX, limitX, incX, y) => {
    for (let x = startX; x !== limitX; x += incX) {
      const slicePixelIndex = y * width + x;
      const volumeVoxelIndex = sliceOffset + slicePixelIndex;
      const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];
      if (volumeVoxelValue < negativePixelRange[0] || volumeVoxelValue > negativePixelRange[1]) {
        break;
      }
      if (!visited[slicePixelIndex]) {
        bfs(x, y);
      }
    }
  };
  for (let y = 0; y < height; y++) {
    scanLine(0, width - 1, 1, y);
    scanLine(width - 1, 0, -1, y);
  }
}
function _setPositiveSeedValues2(subVolume, labelmap, options) {
  const { positiveSeedValue = POSITIVE_SEED_VALUE2, positivePixelRange = POSITIVE_PIXEL_RANGE } = options;
  const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
  const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();
  const [width, height, numSlices] = labelmap.dimensions;
  const middleSliceIndex = Math.floor(numSlices / 2);
  const startSliceIndex = Math.max(middleSliceIndex - 3, 0);
  const stopSliceIndex = Math.max(startSliceIndex + 5, numSlices);
  const pixelsPerSlice = width * height;
  for (let z = startSliceIndex; z < stopSliceIndex; z++) {
    const zOffset = z * pixelsPerSlice;
    for (let y = 0; y < height; y++) {
      const yOffset = y * width;
      for (let x = 0; x < width; x++) {
        const index = zOffset + yOffset + x;
        const pixelValue = subVolPixelData[index];
        const isPositiveValue = pixelValue >= positivePixelRange[0] && pixelValue <= positivePixelRange[1];
        if (isPositiveValue) {
          labelmap.voxelManager.setAtIndex(index, positiveSeedValue);
        }
      }
    }
  }
}
async function _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options) {
  const labelmap = volumeLoader_exports.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);
  _setPositiveSeedValues2(subVolume, labelmap, options);
  _setNegativeSeedValues2(subVolume, labelmap, options);
  return labelmap;
}
async function runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options) {
  const { boundingBox } = boundingBoxInfo;
  const { ijkTopLeft, ijkBottomRight } = boundingBox;
  const subVolumeBoundsIJK = {
    minX: ijkTopLeft[0],
    maxX: ijkBottomRight[0],
    minY: ijkTopLeft[1],
    maxY: ijkBottomRight[1],
    minZ: ijkTopLeft[2],
    maxZ: ijkBottomRight[2]
  };
  const subVolume = utilities_exports.createSubVolume(referencedVolumeId, subVolumeBoundsIJK, {
    targetBuffer: {
      type: "Float32Array"
    }
  });
  const labelmap = await _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options);
  await runGrowCut(subVolume.volumeId, labelmap.volumeId);
  return labelmap;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js
var { transformWorldToIndex: transformWorldToIndex9, transformIndexToWorld } = utilities_exports;
var POSITIVE_SEED_VALUE3 = 254;
var NEGATIVE_SEED_VALUE3 = 255;
var POSITIVE_SEED_VARIANCE2 = 0.1;
var NEGATIVE_SEED_VARIANCE2 = 0.8;
var SUBVOLUME_PADDING_PERCENTAGE = 0.2;
var SUBVOLUME_MIN_PADDING = 5;
function _createSubVolume(referencedVolume, positiveRegionData, options) {
  const { dimensions } = referencedVolume;
  const positiveRegionSize = vec3_exports.sub(vec3_exports.create(), positiveRegionData.boundingBox.bottomRight, positiveRegionData.boundingBox.topLeft);
  let subVolumePaddingPercentage = (options == null ? void 0 : options.subVolumePaddingPercentage) ?? SUBVOLUME_PADDING_PERCENTAGE;
  let subVolumeMinPadding = (options == null ? void 0 : options.subVolumeMinPadding) ?? SUBVOLUME_MIN_PADDING;
  if (typeof subVolumePaddingPercentage === "number") {
    subVolumePaddingPercentage = [
      subVolumePaddingPercentage,
      subVolumePaddingPercentage,
      subVolumePaddingPercentage
    ];
  }
  if (typeof subVolumeMinPadding === "number") {
    subVolumeMinPadding = [
      subVolumeMinPadding,
      subVolumeMinPadding,
      subVolumeMinPadding
    ];
  }
  const padding = vec3_exports.mul(vec3_exports.create(), positiveRegionSize, subVolumePaddingPercentage);
  vec3_exports.round(padding, padding);
  vec3_exports.max(padding, padding, subVolumeMinPadding);
  const subVolumeSize = vec3_exports.scaleAndAdd(vec3_exports.create(), positiveRegionSize, padding, 2);
  const ijkTopLeft = vec3_exports.sub(vec3_exports.create(), positiveRegionData.boundingBox.topLeft, padding);
  const ijkBottomRight = vec3_exports.add(vec3_exports.create(), ijkTopLeft, subVolumeSize);
  vec3_exports.max(ijkTopLeft, ijkTopLeft, [0, 0, 0]);
  vec3_exports.min(ijkTopLeft, ijkTopLeft, dimensions);
  vec3_exports.max(ijkBottomRight, ijkBottomRight, [0, 0, 0]);
  vec3_exports.min(ijkBottomRight, ijkBottomRight, dimensions);
  const subVolumeBoundsIJK = {
    minX: ijkTopLeft[0],
    maxX: ijkBottomRight[0],
    minY: ijkTopLeft[1],
    maxY: ijkBottomRight[1],
    minZ: ijkTopLeft[2],
    maxZ: ijkBottomRight[2]
  };
  return utilities_exports.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {
    targetBuffer: {
      type: "Float32Array"
    }
  });
}
function _getPositiveRegionData(referencedVolume, worldPosition, options) {
  const [width, height, numSlices] = referencedVolume.dimensions;
  const subVolPixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();
  const numPixelsPerSlice = width * height;
  const ijkStartPosition = transformWorldToIndex9(referencedVolume.imageData, worldPosition);
  const referencePixelValue = subVolPixelData[ijkStartPosition[2] * numPixelsPerSlice + ijkStartPosition[1] * width + ijkStartPosition[0]];
  const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE2;
  const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);
  const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;
  const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;
  const neighborsCoordDelta = [
    [-1, 0, 0],
    [1, 0, 0],
    [0, -1, 0],
    [0, 1, 0],
    [0, 0, -1],
    [0, 0, 1]
  ];
  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice + ijkStartPosition[1] * width + ijkStartPosition[0];
  const voxelIndexesSet = /* @__PURE__ */ new Set([startVoxelIndex]);
  const worldVoxelSet = /* @__PURE__ */ new Set([worldPosition]);
  const queue = [ijkStartPosition];
  while (queue.length) {
    const ijkVoxel = queue.shift();
    const [x, y, z] = ijkVoxel;
    minX = ijkVoxel[0] < minX ? ijkVoxel[0] : minX;
    minY = ijkVoxel[1] < minY ? ijkVoxel[1] : minY;
    minZ = ijkVoxel[2] < minZ ? ijkVoxel[2] : minZ;
    maxX = ijkVoxel[0] > maxX ? ijkVoxel[0] : maxX;
    maxY = ijkVoxel[1] > maxY ? ijkVoxel[1] : maxY;
    maxZ = ijkVoxel[2] > maxZ ? ijkVoxel[2] : maxZ;
    for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {
      const neighborCoordDelta = neighborsCoordDelta[i];
      const nx = x + neighborCoordDelta[0];
      const ny = y + neighborCoordDelta[1];
      const nz = z + neighborCoordDelta[2];
      if (nx < 0 || nx >= width || ny < 0 || ny >= height || nz < 0 || nz >= numSlices) {
        continue;
      }
      const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;
      const neighborPixelValue = subVolPixelData[neighborVoxelIndex];
      if (voxelIndexesSet.has(neighborVoxelIndex) || neighborPixelValue < minPositivePixelValue || neighborPixelValue > maxPositivePixelValue) {
        continue;
      }
      const ijkVoxel2 = [nx, ny, nz];
      const worldVoxel = transformIndexToWorld(referencedVolume.imageData, ijkVoxel2);
      voxelIndexesSet.add(neighborVoxelIndex);
      worldVoxelSet.add(worldVoxel);
      queue.push(ijkVoxel2);
    }
  }
  return {
    worldVoxels: Array.from(worldVoxelSet),
    boundingBox: {
      topLeft: [minX, minY, minZ],
      bottomRight: [maxX, maxY, maxZ]
    }
  };
}
function _setPositiveSeedValues3(labelmap, positiveRegionData, options) {
  const { dimensions } = labelmap;
  const [width, height] = dimensions;
  const numPixelsPerSlice = width * height;
  const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE3;
  const { worldVoxels } = positiveRegionData;
  for (let i = 0, len = worldVoxels.length; i < len; i++) {
    const worldVoxel = worldVoxels[i];
    const ijkVoxel = transformWorldToIndex9(labelmap.imageData, worldVoxel);
    const voxelIndex = ijkVoxel[2] * numPixelsPerSlice + ijkVoxel[1] * width + ijkVoxel[0];
    labelmap.voxelManager.setAtIndex(voxelIndex, positiveSeedValue);
  }
}
function _setNegativeSeedValues3(subVolume, labelmap, worldPosition, options) {
  const [width, height] = subVolume.dimensions;
  const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
  const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();
  const ijkPosition = transformWorldToIndex9(subVolume.imageData, worldPosition);
  const referencePixelValue = subVolPixelData[ijkPosition[2] * width * height + ijkPosition[1] * width + ijkPosition[0]];
  const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE2;
  const negativeSeedValue = options.negativeSeedValue ?? NEGATIVE_SEED_VALUE3;
  const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);
  const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;
  const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;
  for (let i = 0, len = subVolPixelData.length; i < len; i++) {
    const pixelValue = subVolPixelData[i];
    if (!labelmapData[i] && (pixelValue < minNegativePixelValue || pixelValue > maxNegativePixelValue)) {
      labelmap.voxelManager.setAtIndex(i, negativeSeedValue);
    }
  }
}
async function _createAndCacheSegmentation(subVolume, positiveRegionData, worldPosition, options) {
  const labelmap = volumeLoader_exports.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);
  _setPositiveSeedValues3(labelmap, positiveRegionData, options);
  _setNegativeSeedValues3(subVolume, labelmap, worldPosition, options);
  return labelmap;
}
async function runOneClickGrowCut(referencedVolumeId, worldPosition, viewport, options) {
  const referencedVolume = cache_default.getVolume(referencedVolumeId);
  const positiveRegionData = _getPositiveRegionData(referencedVolume, worldPosition, options);
  const subVolume = _createSubVolume(referencedVolume, positiveRegionData, options);
  const labelmap = await _createAndCacheSegmentation(subVolume, positiveRegionData, worldPosition, options);
  await runGrowCut(subVolume.volumeId, labelmap.volumeId);
  return labelmap;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/index.js
var orientation_exports = {};
__export(orientation_exports, {
  getOrientationStringLPS: () => getOrientationStringLPS,
  invertOrientationStringLPS: () => invertOrientationStringLPS
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/getOrientationStringLPS.js
function getOrientationStringLPS(vector) {
  let orientation2 = "";
  const orientationX = vector[0] < 0 ? "R" : "L";
  const orientationY = vector[1] < 0 ? "A" : "P";
  const orientationZ = vector[2] < 0 ? "F" : "H";
  const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];
  const MIN = 1e-4;
  for (let i = 0; i < 3; i++) {
    if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {
      orientation2 += orientationX;
      abs[0] = 0;
    } else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {
      orientation2 += orientationY;
      abs[1] = 0;
    } else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {
      orientation2 += orientationZ;
      abs[2] = 0;
    } else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {
      orientation2 += orientationX + orientationY;
      abs[0] = 0;
      abs[1] = 0;
    } else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {
      orientation2 += orientationX + orientationZ;
      abs[0] = 0;
      abs[2] = 0;
    } else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {
      orientation2 += orientationY + orientationZ;
      abs[1] = 0;
      abs[2] = 0;
    } else {
      break;
    }
  }
  return orientation2;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/invertOrientationStringLPS.js
function invertOrientationStringLPS(orientationString) {
  let inverted = orientationString.replace("H", "f");
  inverted = inverted.replace("F", "h");
  inverted = inverted.replace("R", "l");
  inverted = inverted.replace("L", "r");
  inverted = inverted.replace("A", "p");
  inverted = inverted.replace("P", "a");
  inverted = inverted.toUpperCase();
  return inverted;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/index.js
var cine_exports = {};
__export(cine_exports, {
  Events: () => events_default,
  addToolState: () => addToolState,
  getToolState: () => getToolState,
  playClip: () => playClip,
  stopClip: () => stopClip
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/events.js
var Events2;
(function(Events4) {
  Events4["CLIP_STOPPED"] = "CORNERSTONE_CINE_TOOL_STOPPED";
  Events4["CLIP_STARTED"] = "CORNERSTONE_CINE_TOOL_STARTED";
})(Events2 || (Events2 = {}));
var events_default = Events2;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/state.js
var state6 = {};
function addToolState(element, data) {
  const enabledElement = getEnabledElement(element);
  const { viewportId } = enabledElement;
  state6[viewportId] = data;
}
function getToolState(element) {
  const enabledElement = getEnabledElement(element);
  const { viewportId } = enabledElement;
  return state6[viewportId];
}
function getToolStateByViewportId(viewportId) {
  return state6[viewportId];
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/playClip.js
var { ViewportStatus } = enums_exports;
var { triggerEvent: triggerEvent2 } = utilities_exports;
var debounced = true;
var dynamicVolumesPlayingMap = /* @__PURE__ */ new Map();
function playClip(element, playClipOptions) {
  let playClipTimeouts;
  let playClipIsTimeVarying;
  if (element === void 0) {
    throw new Error("playClip: element must not be undefined");
  }
  const enabledElement = getEnabledElement(element);
  if (!enabledElement) {
    throw new Error("playClip: element must be a valid Cornerstone enabled element");
  }
  if (!playClipOptions) {
    playClipOptions = {};
  }
  playClipOptions.dynamicCineEnabled = playClipOptions.dynamicCineEnabled ?? true;
  const { viewport } = enabledElement;
  const playClipContext = _createCinePlayContext(viewport, playClipOptions);
  let playClipData = getToolState(element);
  const isDynamicCinePlaying = playClipOptions.dynamicCineEnabled;
  if (isDynamicCinePlaying) {
    _stopDynamicVolumeCine(element);
  }
  if (!playClipData) {
    playClipData = {
      intervalId: void 0,
      framesPerSecond: 30,
      lastFrameTimeStamp: void 0,
      ignoreFrameTimeVector: false,
      usingFrameTimeVector: false,
      frameTimeVector: playClipOptions.frameTimeVector ?? void 0,
      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,
      reverse: playClipOptions.reverse ?? false,
      loop: playClipOptions.loop ?? true
    };
    addToolState(element, playClipData);
  } else {
    _stopClip(element, {
      stopDynamicCine: !isDynamicCinePlaying,
      viewportId: viewport.id
    });
  }
  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;
  if (playClipOptions.framesPerSecond < 0 || playClipOptions.framesPerSecond > 0) {
    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);
    playClipData.reverse = playClipData.framesPerSecond < 0;
    playClipData.ignoreFrameTimeVector = true;
  }
  if (playClipData.ignoreFrameTimeVector !== true && playClipData.frameTimeVector && playClipData.frameTimeVector.length === playClipContext.numScrollSteps && playClipContext.frameTimeVectorEnabled) {
    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(playClipData.frameTimeVector, playClipData.speed);
    playClipTimeouts = timeouts;
    playClipIsTimeVarying = isTimeVarying;
  }
  const playClipAction = () => {
    const { numScrollSteps, currentStepIndex } = playClipContext;
    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);
    const newStepIndexOutOfRange = newStepIndex < 0 || newStepIndex >= numScrollSteps;
    if (!playClipData.loop && newStepIndexOutOfRange) {
      _stopClip(element, {
        stopDynamicCine: !isDynamicCinePlaying,
        viewportId: viewport.id
      });
      const eventDetail2 = { element };
      triggerEvent2(element, events_default.CLIP_STOPPED, eventDetail2);
      return;
    }
    if (newStepIndex >= numScrollSteps) {
      newStepIndex = 0;
    } else if (newStepIndex < 0) {
      newStepIndex = numScrollSteps - 1;
    }
    const delta = newStepIndex - currentStepIndex;
    if (delta) {
      try {
        playClipContext.scroll(delta);
      } catch (e) {
        console.warn("Play clip not scrolling", e);
        _stopClipWithData(playClipData);
        triggerEvent2(element, events_default.CLIP_STOPPED, eventDetail);
        return;
      }
    }
  };
  if (isDynamicCinePlaying) {
    const volume = _getVolumeFromViewport(viewport);
    if (volume) {
      dynamicVolumesPlayingMap.set(volume.volumeId, element);
    }
  }
  if (playClipContext.play) {
    playClipData.framesPerSecond = playClipContext.play(playClipOptions.framesPerSecond);
  } else if (playClipTimeouts && playClipTimeouts.length > 0 && playClipIsTimeVarying) {
    playClipData.usingFrameTimeVector = true;
    playClipData.intervalId = window.setTimeout(function playClipTimeoutHandler() {
      playClipData.intervalId = window.setTimeout(playClipTimeoutHandler, playClipTimeouts[playClipContext.currentStepIndex]);
      playClipAction();
    }, 0);
  } else {
    playClipData.usingFrameTimeVector = false;
    playClipData.intervalId = window.setInterval(playClipAction, 1e3 / Math.abs(playClipData.framesPerSecond));
  }
  const eventDetail = {
    element
  };
  triggerEvent2(element, events_default.CLIP_STARTED, eventDetail);
}
function stopClip(element, options = {}) {
  _stopClip(element, {
    stopDynamicCine: true,
    ...options
  });
}
function _stopClip(element, options = { stopDynamicCine: true, viewportId: void 0 }) {
  const { stopDynamicCine, viewportId } = options;
  const enabledElement = getEnabledElement(element);
  let toolState;
  const viewport = enabledElement == null ? void 0 : enabledElement.viewport;
  if (!enabledElement) {
    if (viewportId) {
      toolState = getToolStateByViewportId(viewportId);
    } else {
      return;
    }
  } else {
    const { viewport: viewport2 } = enabledElement;
    toolState = getToolState(viewport2.element);
  }
  if (toolState) {
    _stopClipWithData(toolState);
  }
  if (viewport instanceof VideoViewport_default) {
    viewport.pause();
  } else if (stopDynamicCine && viewport instanceof BaseVolumeViewport_default) {
    _stopDynamicVolumeCine(element);
  }
}
function _stopDynamicVolumeCine(element) {
  const { viewport } = getEnabledElement(element);
  if (viewport instanceof VolumeViewport_default) {
    const volume = _getVolumeFromViewport(viewport);
    if (volume == null ? void 0 : volume.isDynamicVolume()) {
      const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);
      dynamicVolumesPlayingMap.delete(volume.volumeId);
      if (dynamicCineElement && dynamicCineElement !== element) {
        stopClip(dynamicCineElement);
      }
    }
  }
}
function _getPlayClipTimeouts(vector, speed) {
  let i;
  let sample;
  let delay;
  let sum = 0;
  const limit = vector.length;
  const timeouts = [];
  let isTimeVarying = false;
  if (typeof speed !== "number" || speed <= 0) {
    speed = 1;
  }
  for (i = 1; i < limit; i++) {
    delay = Number(vector[i]) / speed | 0;
    timeouts.push(delay);
    if (i === 1) {
      sample = delay;
    } else if (delay !== sample) {
      isTimeVarying = true;
    }
    sum += delay;
  }
  if (timeouts.length > 0) {
    if (isTimeVarying) {
      delay = sum / timeouts.length | 0;
    } else {
      delay = timeouts[0];
    }
    timeouts.push(delay);
  }
  return { timeouts, isTimeVarying };
}
function _stopClipWithData(playClipData) {
  const id = playClipData.intervalId;
  if (typeof id !== "undefined") {
    playClipData.intervalId = void 0;
    if (playClipData.usingFrameTimeVector) {
      clearTimeout(id);
    } else {
      clearInterval(id);
    }
  }
}
function _getVolumeFromViewport(viewport) {
  if (!(viewport instanceof VolumeViewport_default)) {
    return void 0;
  }
  const volumeIds = viewport.getAllVolumeIds();
  if (!(volumeIds == null ? void 0 : volumeIds.length)) {
    return void 0;
  }
  const dynamicVolumeId = volumeIds.find((volumeId2) => {
    var _a2;
    return (_a2 = cache_default.getVolume(volumeId2)) == null ? void 0 : _a2.isDynamicVolume();
  });
  const volumeId = dynamicVolumeId ?? volumeIds[0];
  return cache_default.getVolume(volumeId);
}
function _createStackViewportCinePlayContext(viewport, waitForRendered) {
  const imageIds = viewport.getImageIds();
  return {
    get numScrollSteps() {
      return imageIds.length;
    },
    get currentStepIndex() {
      return viewport.getTargetImageIdIndex();
    },
    get frameTimeVectorEnabled() {
      return true;
    },
    waitForRenderedCount: 0,
    scroll(delta) {
      if (this.waitForRenderedCount <= waitForRendered && viewport.viewportStatus !== ViewportStatus.RENDERED) {
        this.waitForRenderedCount++;
        return;
      }
      this.waitForRenderedCount = 0;
      utilities_exports.scroll(viewport, { delta, debounceLoading: debounced });
    }
  };
}
function _createVideoViewportCinePlayContext(viewport, waitForRendered) {
  return {
    get numScrollSteps() {
      return viewport.getNumberOfSlices();
    },
    get currentStepIndex() {
      return viewport.getSliceIndex();
    },
    get frameTimeVectorEnabled() {
      return true;
    },
    waitForRenderedCount: 0,
    scroll(delta) {
      if (this.waitForRenderedCount <= waitForRendered && viewport.viewportStatus !== ViewportStatus.RENDERED) {
        this.waitForRenderedCount++;
        return;
      }
      this.waitForRenderedCount = 0;
      utilities_exports.scroll(viewport, { delta, debounceLoading: debounced });
    },
    play(fps) {
      if (fps) {
        viewport.setPlaybackRate(fps / 24);
      }
      viewport.play();
      return viewport.getFrameRate();
    }
  };
}
function _createVolumeViewportCinePlayContext(viewport, volume) {
  const { volumeId } = volume;
  const cachedScrollInfo = {
    viewPlaneNormal: vec3_exports.create(),
    scrollInfo: null
  };
  const getScrollInfo = () => {
    const camera = viewport.getCamera();
    const updateCache = !cachedScrollInfo.scrollInfo || !vec3_exports.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);
    if (updateCache) {
      const scrollInfo = utilities_exports.getVolumeViewportScrollInfo(viewport, volumeId);
      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;
      cachedScrollInfo.scrollInfo = scrollInfo;
    }
    return cachedScrollInfo.scrollInfo;
  };
  return {
    get numScrollSteps() {
      return getScrollInfo().numScrollSteps;
    },
    get currentStepIndex() {
      return getScrollInfo().currentStepIndex;
    },
    get frameTimeVectorEnabled() {
      const camera = viewport.getCamera();
      const volumeViewPlaneNormal = volume.direction.slice(6, 9).map((x) => -x);
      const dot = vec3_exports.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);
      return common_exports.equals(dot, 1);
    },
    scroll(delta) {
      getScrollInfo().currentStepIndex += delta;
      utilities_exports.scroll(viewport, { delta });
    }
  };
}
function _createDynamicVolumeViewportCinePlayContext(volume) {
  return {
    get numScrollSteps() {
      return volume.numTimePoints;
    },
    get currentStepIndex() {
      return volume.timePointIndex;
    },
    get frameTimeVectorEnabled() {
      return false;
    },
    scroll(delta) {
      volume.scroll(delta);
    }
  };
}
function _createCinePlayContext(viewport, playClipOptions) {
  if (viewport instanceof StackViewport_default) {
    return _createStackViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);
  }
  if (viewport instanceof VolumeViewport_default) {
    const volume = _getVolumeFromViewport(viewport);
    if (playClipOptions.dynamicCineEnabled && (volume == null ? void 0 : volume.isDynamicVolume())) {
      return _createDynamicVolumeViewportCinePlayContext(volume);
    }
    return _createVolumeViewportCinePlayContext(viewport, volume);
  }
  if (viewport instanceof VideoViewport_default) {
    return _createVideoViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);
  }
  throw new Error("Unknown viewport type");
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js
var planarFreehandROITool_exports = {};
__export(planarFreehandROITool_exports, {
  default: () => planarFreehandROITool_default,
  smoothAnnotation: () => smoothAnnotation
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothAnnotation.js
function shouldPreventInterpolation(annotation, options) {
  var _a2, _b2, _c;
  const knotsRatioPercentage = (options == null ? void 0 : options.knotsRatioPercentage) || 30;
  if (!((_c = (_b2 = (_a2 = annotation == null ? void 0 : annotation.data) == null ? void 0 : _a2.contour) == null ? void 0 : _b2.polyline) == null ? void 0 : _c.length) || knotsRatioPercentage <= 0) {
    return true;
  }
  return false;
}
function rotateMatrix(normal, focal) {
  const mat = mat4_exports.create();
  const eye = vec3_exports.add(vec3_exports.create(), focal, normal);
  const up = Math.abs(normal[0]) > 0.1 ? vec3_exports.fromValues(-normal[1], normal[0], 0) : vec3_exports.fromValues(0, -normal[2], normal[1]);
  mat4_exports.lookAt(mat, focal, eye, up);
  return mat;
}
function rotate(list, count = Math.floor(Math.random() * (list.length - 1))) {
  if (count === 0) {
    return 0;
  }
  const srcList = [...list];
  const { length } = list;
  for (let i = 0; i < length; i++) {
    list[i] = srcList[(i + count + length) % length];
  }
  return count;
}
function smoothAnnotation(annotation, options) {
  if (shouldPreventInterpolation(annotation, options)) {
    return false;
  }
  const { viewPlaneNormal } = annotation.metadata;
  const { closed: closed2, polyline } = annotation.data.contour;
  const rotateMat = rotateMatrix(viewPlaneNormal, annotation.data.contour.polyline[0]);
  const canvasPoints = annotation.data.contour.polyline.map((p) => {
    const planeP = vec3_exports.transformMat4(vec3_exports.create(), p, rotateMat);
    return [planeP[0], planeP[1]];
  });
  let rotation = closed2 ? rotate(canvasPoints) : 0;
  let interpolatedCanvasPoints = interpolateSegmentPoints(canvasPoints, 0, canvasPoints.length, (options == null ? void 0 : options.knotsRatioPercentage) || 30);
  if (interpolatedCanvasPoints === canvasPoints) {
    return false;
  }
  rotate(interpolatedCanvasPoints, -rotation);
  for (let i = 1; i < (options == null ? void 0 : options.loop); i++) {
    rotation = closed2 ? rotate(interpolatedCanvasPoints) : 0;
    interpolatedCanvasPoints = interpolateSegmentPoints(interpolatedCanvasPoints, 0, canvasPoints.length, (options == null ? void 0 : options.knotsRatioPercentage) || 30);
    rotate(interpolatedCanvasPoints, -rotation);
  }
  const unRotate = mat4_exports.invert(mat4_exports.create(), rotateMat);
  annotation.data.contour.polyline = interpolatedCanvasPoints.map((p) => vec3_exports.transformMat4([0, 0, 0], [...p, 0], unRotate));
  return true;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js
var planarFreehandROITool_default = {
  smoothAnnotation
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/index.js
var rectangleROITool_exports = {};
__export(rectangleROITool_exports, {
  getBoundsIJKFromRectangleAnnotations: () => getBoundsIJKFromRectangleAnnotations_default,
  isAxisAlignedRectangle: () => isAxisAlignedRectangle
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/state.js
var state7 = {};
function addToolState2(element, data) {
  const enabledElement = getEnabledElement(element);
  const { viewportId } = enabledElement;
  state7[viewportId] = data;
}
function getToolState2(element) {
  const enabledElement = getEnabledElement(element);
  const { viewportId } = enabledElement;
  return state7[viewportId];
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetchUtils.js
var requestType = enums_exports.RequestType.Prefetch;
var priority = 0;
function range(lowEnd, highEnd) {
  lowEnd = Math.round(lowEnd) || 0;
  highEnd = Math.round(highEnd) || 0;
  const arr = [];
  let c = highEnd - lowEnd + 1;
  if (c <= 0) {
    return arr;
  }
  while (c--) {
    arr[c] = highEnd--;
  }
  return arr;
}
function nearestIndex(arr, x) {
  let low = 0;
  let high = arr.length - 1;
  arr.forEach((v, idx) => {
    if (v < x) {
      low = Math.max(idx, low);
    } else if (v > x) {
      high = Math.min(idx, high);
    }
  });
  return { low, high };
}
function getStackData(element) {
  const enabledElement = getEnabledElement(element);
  if (!enabledElement) {
    return null;
  }
  const { viewport } = enabledElement;
  if (!(viewport instanceof StackViewport_default)) {
    return null;
  }
  return {
    currentImageIdIndex: viewport.getCurrentImageIdIndex(),
    imageIds: viewport.getImageIds()
  };
}
function getPromiseRemovedHandler(element) {
  return function(e) {
    const eventData = e.detail;
    let stackData;
    try {
      stackData = getStackData(element);
    } catch (error) {
      return;
    }
    if (!stackData || !stackData.imageIds || stackData.imageIds.length === 0) {
      return;
    }
    const stack = stackData;
    const imageIdIndex = stack.imageIds.indexOf(eventData.imageId);
    if (imageIdIndex < 0) {
      return;
    }
    const stackPrefetchData = getToolState2(element);
    if (!stackPrefetchData || !stackPrefetchData.indicesToRequest || !stackPrefetchData.indicesToRequest.length) {
      return;
    }
    stackPrefetchData.indicesToRequest.push(imageIdIndex);
  };
}
var clearFromImageIds = (stack) => {
  const imageIdSet = new Set(stack.imageIds);
  return (requestDetails) => requestDetails.type !== requestType || !imageIdSet.has(requestDetails.additionalDetails.imageId);
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetch.js
var configuration = {
  maxImagesToPrefetch: Infinity,
  preserveExistingPool: true
};
var resetPrefetchTimeout;
var resetPrefetchDelay = 10;
function prefetch(element) {
  var _a2, _b2;
  const stackPrefetchData = getToolState2(element);
  if (!stackPrefetchData) {
    return;
  }
  const stackPrefetch2 = stackPrefetchData || {};
  const stack = getStackData(element);
  if (!((_a2 = stack == null ? void 0 : stack.imageIds) == null ? void 0 : _a2.length)) {
    console.warn("CornerstoneTools.stackPrefetch: No images in stack.");
    return;
  }
  const { currentImageIdIndex } = stack;
  stackPrefetch2.enabled = stackPrefetch2.enabled && (((_b2 = stackPrefetch2.indicesToRequest) == null ? void 0 : _b2.length) ?? 0) > 0;
  if (stackPrefetch2.enabled === false) {
    return;
  }
  function removeFromList(imageIdIndex) {
    const index = stackPrefetch2.indicesToRequest.indexOf(imageIdIndex);
    if (index > -1) {
      stackPrefetch2.indicesToRequest.splice(index, 1);
    }
  }
  stackPrefetchData.indicesToRequest.sort((a, b) => a - b);
  const indicesToRequestCopy = stackPrefetch2.indicesToRequest.slice();
  indicesToRequestCopy.forEach(function(imageIdIndex) {
    const imageId2 = stack.imageIds[imageIdIndex];
    if (!imageId2) {
      return;
    }
    const distance = Math.abs(currentImageIdIndex - imageIdIndex);
    const imageCached = distance < 6 ? cache_default.getImageLoadObject(imageId2) : cache_default.isLoaded(imageId2);
    if (imageCached) {
      removeFromList(imageIdIndex);
    }
  });
  if (!stackPrefetch2.indicesToRequest.length) {
    return;
  }
  if (!configuration.preserveExistingPool) {
    imageLoadPoolManager_default.clearRequestStack(requestType);
  }
  const nearest = nearestIndex(stackPrefetch2.indicesToRequest, stack.currentImageIdIndex);
  let imageId;
  let nextImageIdIndex;
  const preventCache = false;
  function doneCallback(image) {
    console.log("prefetch done: %s", image.imageId);
    const imageIdIndex = stack.imageIds.indexOf(image.imageId);
    removeFromList(imageIdIndex);
  }
  let lowerIndex = nearest.low;
  let higherIndex = nearest.high;
  const imageIdsToPrefetch = [];
  while (lowerIndex >= 0 || higherIndex < stackPrefetch2.indicesToRequest.length) {
    const currentIndex = stack.currentImageIdIndex;
    const shouldSkipLower = currentIndex - stackPrefetch2.indicesToRequest[lowerIndex] > configuration.maxImagesToPrefetch;
    const shouldSkipHigher = stackPrefetch2.indicesToRequest[higherIndex] - currentIndex > configuration.maxImagesToPrefetch;
    const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;
    const shouldLoadHigher = !shouldSkipHigher && higherIndex < stackPrefetch2.indicesToRequest.length;
    if (!shouldLoadHigher && !shouldLoadLower) {
      break;
    }
    if (shouldLoadLower) {
      nextImageIdIndex = stackPrefetch2.indicesToRequest[lowerIndex--];
      imageId = stack.imageIds[nextImageIdIndex];
      imageIdsToPrefetch.push(imageId);
    }
    if (shouldLoadHigher) {
      nextImageIdIndex = stackPrefetch2.indicesToRequest[higherIndex++];
      imageId = stack.imageIds[nextImageIdIndex];
      imageIdsToPrefetch.push(imageId);
    }
  }
  const requestFn = (imageId2, options) => imageLoader_exports.loadAndCacheImage(imageId2, options);
  imageIdsToPrefetch.forEach((imageId2) => {
    const options = {
      requestType
    };
    imageLoadPoolManager_default.addRequest(requestFn.bind(null, imageId2, options), requestType, {
      imageId: imageId2
    }, priority);
  });
}
function onImageUpdated(e) {
  clearTimeout(resetPrefetchTimeout);
  resetPrefetchTimeout = setTimeout(function() {
    const element = e.target;
    try {
      prefetch(element);
    } catch (error) {
      return;
    }
  }, resetPrefetchDelay);
}
function enable15(element) {
  const stack = getStackData(element);
  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {
    console.warn("CornerstoneTools.stackPrefetch: No images in stack.");
    return;
  }
  const stackPrefetchData = {
    indicesToRequest: range(0, stack.imageIds.length - 1),
    enabled: true,
    direction: 1
  };
  const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(stack.currentImageIdIndex);
  stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);
  addToolState2(element, stackPrefetchData);
  prefetch(element);
  element.removeEventListener(enums_exports.Events.STACK_NEW_IMAGE, onImageUpdated);
  element.addEventListener(enums_exports.Events.STACK_NEW_IMAGE, onImageUpdated);
  const promiseRemovedHandler = getPromiseRemovedHandler(element);
  eventTarget_default.removeEventListener(enums_exports.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
  eventTarget_default.addEventListener(enums_exports.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
}
function disable15(element) {
  clearTimeout(resetPrefetchTimeout);
  element.removeEventListener(enums_exports.Events.STACK_NEW_IMAGE, onImageUpdated);
  const promiseRemovedHandler = getPromiseRemovedHandler(element);
  eventTarget_default.removeEventListener(enums_exports.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
  const stackPrefetchData = getToolState2(element);
  if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {
    stackPrefetchData.enabled = false;
    imageLoadPoolManager_default.clearRequestStack(requestType);
  }
}
function getConfiguration2() {
  return configuration;
}
function setConfiguration(config) {
  configuration = config;
}
var stackPrefetch = { enable: enable15, disable: disable15, getConfiguration: getConfiguration2, setConfiguration };
var stackPrefetch_default = stackPrefetch;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackContextPrefetch.js
var configuration2 = {
  maxImagesToPrefetch: Infinity,
  minBefore: 2,
  maxAfter: 2,
  directionExtraImages: 10,
  preserveExistingPool: false
};
var resetPrefetchTimeout2;
var resetPrefetchDelay2 = 5;
var enable16 = (element) => {
  var _a2;
  const stack = getStackData(element);
  if (!stack) {
    return;
  }
  if (!((_a2 = stack.imageIds) == null ? void 0 : _a2.length)) {
    console.warn("CornerstoneTools.stackPrefetch: No images in stack.");
    return;
  }
  updateToolState(element);
  prefetch2(element);
  element.removeEventListener(enums_exports.Events.STACK_NEW_IMAGE, onImageUpdated2);
  element.addEventListener(enums_exports.Events.STACK_NEW_IMAGE, onImageUpdated2);
  const promiseRemovedHandler = getPromiseRemovedHandler(element);
  eventTarget_default.removeEventListener(enums_exports.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
  eventTarget_default.addEventListener(enums_exports.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
};
function prefetch2(element) {
  var _a2, _b2;
  const stack = getStackData(element);
  if (!stack) {
    return;
  }
  if (!((_a2 = stack == null ? void 0 : stack.imageIds) == null ? void 0 : _a2.length)) {
    console.warn("CornerstoneTools.stackPrefetch: No images in stack.");
    return;
  }
  const stackPrefetchData = getToolState2(element);
  if (!stackPrefetchData) {
    return;
  }
  const stackPrefetch2 = stackPrefetchData || {};
  stackPrefetch2.enabled = stackPrefetch2.enabled && (((_b2 = stackPrefetch2.indicesToRequest) == null ? void 0 : _b2.length) ?? 0) > 0;
  if (stackPrefetch2.enabled === false) {
    return;
  }
  function removeFromList(imageIdIndex) {
    const index = stackPrefetch2.indicesToRequest.indexOf(imageIdIndex);
    if (index > -1) {
      stackPrefetch2.indicesToRequest.splice(index, 1);
    }
  }
  const indicesToRequestCopy = stackPrefetch2.indicesToRequest.slice();
  const { currentImageIdIndex } = stack;
  indicesToRequestCopy.forEach((imageIdIndex) => {
    const imageId = stack.imageIds[imageIdIndex];
    if (!imageId) {
      return;
    }
    const distance = Math.abs(currentImageIdIndex - imageIdIndex);
    const imageCached = distance < 6 ? cache_default.getImageLoadObject(imageId) : cache_default.isLoaded(imageId);
    if (imageCached) {
      removeFromList(imageIdIndex);
    }
  });
  if (!stackPrefetch2.indicesToRequest.length) {
    return;
  }
  if (!configuration2.preserveExistingPool) {
    imageLoadPoolManager_default.filterRequests(clearFromImageIds(stack));
  }
  function doneCallback(imageId) {
    var _a3, _b3;
    const imageIdIndex = stack.imageIds.indexOf(imageId);
    removeFromList(imageIdIndex);
    const image = cache_default.getCachedImageBasedOnImageURI(imageId);
    const { stats } = stackPrefetch2;
    const decodeTimeInMS = ((_a3 = image == null ? void 0 : image.image) == null ? void 0 : _a3.decodeTimeInMS) || 0;
    if (decodeTimeInMS) {
      stats.imageIds.set(imageId, decodeTimeInMS);
      stats.decodeTimeInMS += decodeTimeInMS;
      const loadTimeInMS = ((_b3 = image == null ? void 0 : image.image) == null ? void 0 : _b3.loadTimeInMS) || 0;
      stats.loadTimeInMS += loadTimeInMS;
    }
    if (!stackPrefetch2.indicesToRequest.length) {
      if (image == null ? void 0 : image.sizeInBytes) {
        const { sizeInBytes } = image;
        const usage = cache_default.getMaxCacheSize() / 4 / sizeInBytes;
        if (!stackPrefetch2.cacheFill) {
          stats.initialTime = Date.now() - stats.start;
          stats.initialSize = stats.imageIds.size;
          updateToolState(element, usage);
          prefetch2(element);
        } else if (stats.imageIds.size) {
          stats.fillTime = Date.now() - stats.start;
          const { size } = stats.imageIds;
          stats.fillSize = size;
        }
      }
    }
  }
  const requestFn = (imageId, options) => imageLoader_exports.loadAndCacheImage(imageId, options).then(() => doneCallback(imageId));
  stackPrefetch2.indicesToRequest.forEach((imageIdIndex) => {
    const imageId = stack.imageIds[imageIdIndex];
    const options = {
      requestType
    };
    imageLoadPoolManager_default.addRequest(requestFn.bind(null, imageId, options), requestType, {
      imageId
    }, priority);
  });
}
function onImageUpdated2(e) {
  clearTimeout(resetPrefetchTimeout2);
  resetPrefetchTimeout2 = setTimeout(function() {
    const element = e.target;
    try {
      updateToolState(element);
      prefetch2(element);
    } catch (error) {
      return;
    }
  }, resetPrefetchDelay2);
}
var signum = (x) => x < 0 ? -1 : 1;
var updateToolState = (element, usage) => {
  var _a2;
  const stack = getStackData(element);
  if (!stack) {
    return;
  }
  if (!((_a2 = stack.imageIds) == null ? void 0 : _a2.length)) {
    console.warn("CornerstoneTools.stackPrefetch: No images in stack.");
    return;
  }
  const { currentImageIdIndex } = stack;
  let { maxAfter = 2, minBefore = 2 } = configuration2;
  const { directionExtraImages = 10 } = configuration2;
  const stackPrefetchData = getToolState2(element) || {
    indicesToRequest: [],
    currentImageIdIndex,
    stackCount: 0,
    enabled: true,
    direction: 1,
    stats: {
      start: Date.now(),
      imageIds: /* @__PURE__ */ new Map(),
      decodeTimeInMS: 0,
      loadTimeInMS: 0,
      totalBytes: 0
    }
  };
  const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;
  stackPrefetchData.direction = signum(delta);
  stackPrefetchData.currentImageIdIndex = currentImageIdIndex;
  stackPrefetchData.enabled = true;
  if (stackPrefetchData.stackCount < 100) {
    stackPrefetchData.stackCount += directionExtraImages;
  }
  if (Math.abs(delta) > maxAfter || !delta) {
    stackPrefetchData.stackCount = 0;
    if (usage) {
      const positionFraction = currentImageIdIndex / stack.imageIds.length;
      minBefore = Math.ceil(usage * positionFraction);
      maxAfter = Math.ceil(usage * (1 - positionFraction));
      stackPrefetchData.cacheFill = true;
    } else {
      stackPrefetchData.cacheFill = false;
    }
  } else if (delta < 0) {
    minBefore += stackPrefetchData.stackCount;
    maxAfter = 0;
  } else {
    maxAfter += stackPrefetchData.stackCount;
    minBefore = 0;
  }
  const minIndex = Math.max(0, currentImageIdIndex - minBefore);
  const maxIndex = Math.min(stack.imageIds.length - 1, currentImageIdIndex + maxAfter);
  const indicesToRequest = [];
  for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {
    indicesToRequest.push(i);
  }
  for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {
    indicesToRequest.push(i);
  }
  stackPrefetchData.indicesToRequest = indicesToRequest;
  addToolState2(element, stackPrefetchData);
};
function disable16(element) {
  clearTimeout(resetPrefetchTimeout2);
  element.removeEventListener(enums_exports.Events.STACK_NEW_IMAGE, onImageUpdated2);
  const promiseRemovedHandler = getPromiseRemovedHandler(element);
  eventTarget_default.removeEventListener(enums_exports.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
  const stackPrefetchData = getToolState2(element);
  if (stackPrefetchData) {
    stackPrefetchData.enabled = false;
  }
}
function getConfiguration3() {
  return configuration2;
}
function setConfiguration2(config) {
  configuration2 = config;
}
var stackContextPrefetch = {
  enable: enable16,
  disable: disable16,
  getConfiguration: getConfiguration3,
  setConfiguration: setConfiguration2
};
var stackContextPrefetch_default = stackContextPrefetch;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/index.js
var viewport_exports = {};
__export(viewport_exports, {
  isViewportPreScaled: () => isViewportPreScaled
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/index.js
var dynamicVolume_exports = {};
__export(dynamicVolume_exports, {
  generateImageFromTimeData: () => generateImageFromTimeData,
  getDataInTime: () => getDataInTime_default,
  updateVolumeFromTimeData: () => updateVolumeFromTimeData
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/getDataInTime.js
function getDataInTime(dynamicVolume, options) {
  let dataInTime;
  const frames = options.frameNumbers || [
    ...Array(dynamicVolume.numTimePoints).keys()
  ];
  if (!options.maskVolumeId && !options.worldCoordinate) {
    throw new Error("You should provide either maskVolumeId or imageCoordinate");
  }
  if (options.maskVolumeId && options.worldCoordinate) {
    throw new Error("You can only use one of maskVolumeId or imageCoordinate");
  }
  if (options.maskVolumeId) {
    const segmentationVolume = cache_default.getVolume(options.maskVolumeId);
    if (!segmentationVolume) {
      throw new Error("Segmentation volume not found");
    }
    const [dataInTime2, ijkCoords] = _getTimePointDataMask(frames, dynamicVolume, segmentationVolume);
    return [dataInTime2, ijkCoords];
  }
  if (options.worldCoordinate) {
    const dataInTime2 = _getTimePointDataCoordinate(frames, options.worldCoordinate, dynamicVolume);
    return dataInTime2;
  }
  return dataInTime;
}
function _getTimePointDataCoordinate(frames, coordinate, volume) {
  const { dimensions, imageData } = volume;
  const index = imageData.worldToIndex(coordinate);
  index[0] = Math.floor(index[0]);
  index[1] = Math.floor(index[1]);
  index[2] = Math.floor(index[2]);
  if (!utilities_exports.indexWithinDimensions(index, dimensions)) {
    throw new Error("outside bounds");
  }
  const yMultiple = dimensions[0];
  const zMultiple = dimensions[0] * dimensions[1];
  const value = [];
  frames.forEach((frame) => {
    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];
    value.push(volume.voxelManager.getAtIndexAndTimePoint(scalarIndex, frame));
  });
  return value;
}
function _getTimePointDataMask(frames, dynamicVolume, segmentationVolume) {
  const { imageData: maskImageData } = segmentationVolume;
  const segVoxelManager = segmentationVolume.voxelManager;
  const scalarDataLength = segVoxelManager.getScalarDataLength();
  const nonZeroVoxelIndices = [];
  nonZeroVoxelIndices.length = scalarDataLength;
  let actualLen = 0;
  for (let i = 0, len = scalarDataLength; i < len; i++) {
    if (segVoxelManager.getAtIndex(i) !== 0) {
      nonZeroVoxelIndices[actualLen++] = i;
    }
  }
  nonZeroVoxelIndices.length = actualLen;
  const nonZeroVoxelValuesInTime = [];
  const isSameVolume = dynamicVolume.voxelManager.getScalarDataLength() === scalarDataLength && JSON.stringify(dynamicVolume.spacing) === JSON.stringify(segmentationVolume.spacing);
  const ijkCoords = [];
  if (isSameVolume) {
    for (let i = 0; i < nonZeroVoxelIndices.length; i++) {
      const valuesInTime = [];
      const index = nonZeroVoxelIndices[i];
      for (let j = 0; j < frames.length; j++) {
        valuesInTime.push(dynamicVolume.voxelManager.getAtIndexAndTimePoint(index, frames[j]));
      }
      nonZeroVoxelValuesInTime.push(valuesInTime);
      ijkCoords.push(segVoxelManager.toIJK(index));
    }
    return [nonZeroVoxelValuesInTime, ijkCoords];
  }
  const callback = ({ pointLPS: segPointLPS, value: segValue, pointIJK: segPointIJK }) => {
    if (segValue === 0) {
      return;
    }
    const overlapIJKMinMax = getVoxelOverlap(dynamicVolume.imageData, dynamicVolume.dimensions, dynamicVolume.spacing, segPointLPS);
    let count = 0;
    const perFrameSum = /* @__PURE__ */ new Map();
    frames.forEach((frame) => perFrameSum.set(frame, 0));
    const averageCallback = ({ index }) => {
      for (let i = 0; i < frames.length; i++) {
        const value = dynamicVolume.voxelManager.getAtIndexAndTimePoint(index, frames[i]);
        const frame = frames[i];
        perFrameSum.set(frame, perFrameSum.get(frame) + value);
      }
      count++;
    };
    dynamicVolume.voxelManager.forEach(averageCallback, {
      imageData: dynamicVolume.imageData,
      boundsIJK: overlapIJKMinMax
    });
    const averageValues = [];
    perFrameSum.forEach((sum) => {
      averageValues.push(sum / count);
    });
    ijkCoords.push(segPointIJK);
    nonZeroVoxelValuesInTime.push(averageValues);
  };
  segmentationVolume.voxelManager.forEach(callback, {
    imageData: maskImageData
  });
  return [nonZeroVoxelValuesInTime, ijkCoords];
}
var getDataInTime_default = getDataInTime;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/generateImageFromTimeData.js
function sumOverFrames(voxelManager, frames) {
  const arrayLength = voxelManager.getScalarDataLength();
  const resultArray = new Float32Array(arrayLength);
  for (const timepoint of frames) {
    const scalarData = voxelManager.getTimePointScalarData(timepoint);
    for (let i = 0; i < arrayLength; i++) {
      resultArray[i] += scalarData[i];
    }
  }
  return resultArray;
}
function averageOverFrames(voxelManager, frames) {
  const sumArray = sumOverFrames(voxelManager, frames);
  const numFrames = frames.length;
  for (let i = 0; i < sumArray.length; i++) {
    sumArray[i] /= numFrames;
  }
  return sumArray;
}
var operationFunctions = {
  [enums_exports.GenerateImageType.SUM]: (voxelManager, frames, callback) => {
    const resultArray = sumOverFrames(voxelManager, frames);
    for (let i = 0; i < resultArray.length; i++) {
      callback(i, resultArray[i]);
    }
  },
  [enums_exports.GenerateImageType.AVERAGE]: (voxelManager, frames, callback) => {
    const resultArray = averageOverFrames(voxelManager, frames);
    for (let i = 0; i < resultArray.length; i++) {
      callback(i, resultArray[i]);
    }
  },
  [enums_exports.GenerateImageType.SUBTRACT]: (voxelManager, frames, callback) => {
    if (frames.length !== 2) {
      throw new Error("Please provide only 2 time points for subtraction.");
    }
    const arrayLength = voxelManager.getScalarDataLength();
    const scalarData1 = voxelManager.getTimePointScalarData(frames[0]);
    const scalarData2 = voxelManager.getTimePointScalarData(frames[1]);
    for (let i = 0; i < arrayLength; i++) {
      const difference = scalarData1[i] - scalarData2[i];
      callback(i, difference);
    }
  }
};
function generateImageFromTimeData(dynamicVolume, operation, options) {
  const { frameNumbers } = options;
  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];
  if (frames.length <= 1) {
    throw new Error("Please provide two or more time points");
  }
  const voxelManager = dynamicVolume.voxelManager;
  const arrayLength = voxelManager.getScalarDataLength();
  const operationFunction = operationFunctions[operation];
  if (!operationFunction) {
    throw new Error(`Unsupported operation: ${operation}`);
  }
  const resultArray = new Float32Array(arrayLength);
  operationFunction(voxelManager, frames, (index, value) => {
    resultArray[index] = value;
  });
  return resultArray;
}
function updateVolumeFromTimeData(dynamicVolume, operation, options) {
  const { frameNumbers, targetVolume } = options;
  if (!targetVolume) {
    throw new Error("A target volume must be provided");
  }
  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];
  if (frames.length <= 1) {
    throw new Error("Please provide two or more time points");
  }
  const voxelManager = dynamicVolume.voxelManager;
  const targetVoxelManager = targetVolume.voxelManager;
  const operationFunction = operationFunctions[operation];
  if (!operationFunction) {
    throw new Error(`Unsupported operation: ${operation}`);
  }
  operationFunction(voxelManager, frames, (index, value) => {
    targetVoxelManager.setAtIndex(index, value);
  });
  targetVoxelManager.resetModifiedSlices();
  for (let k = 0; k < targetVolume.dimensions[2]; k++) {
    targetVoxelManager.modifiedSlices.add(k);
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js
var utils_exports = {};
__export(utils_exports, {
  getPoint: () => getPoint,
  getPolyDataPointIndexes: () => getPolyDataPointIndexes,
  getPolyDataPoints: () => getPolyDataPoints
});
function getPoint(points, idx) {
  const idx3 = idx * 3;
  if (idx3 < points.length) {
    return vec3_exports.fromValues(points[idx3], points[idx3 + 1], points[idx3 + 2]);
  }
}
function getPolyDataPointIndexes(polyData) {
  const linesData = polyData.getLines().getData();
  let idx = 0;
  const lineSegments = /* @__PURE__ */ new Map();
  while (idx < linesData.length) {
    const segmentSize = linesData[idx++];
    const segment = [];
    for (let i = 0; i < segmentSize; i++) {
      segment.push(linesData[idx + i]);
    }
    lineSegments.set(segment[0], segment);
    idx += segmentSize;
  }
  const contours = [];
  const findStartingPoint = (map) => {
    for (const [key, value] of map.entries()) {
      if (value !== void 0) {
        return key;
      }
    }
    return -1;
  };
  let startPoint = findStartingPoint(lineSegments);
  while (startPoint !== -1) {
    const contour = [startPoint];
    while (lineSegments.has(startPoint)) {
      const nextPoint = lineSegments.get(startPoint)[1];
      if (lineSegments.has(nextPoint)) {
        contour.push(nextPoint);
      }
      lineSegments.delete(startPoint);
      startPoint = nextPoint;
    }
    contours.push(contour);
    startPoint = findStartingPoint(lineSegments);
  }
  return contours.length ? contours : void 0;
}
function getPolyDataPoints(polyData) {
  const contoursIndexes = getPolyDataPointIndexes(polyData);
  if (!contoursIndexes) {
    return;
  }
  const rawPointsData = polyData.getPoints().getData();
  return contoursIndexes.map((contourIndexes) => contourIndexes.map((index) => getPoint(rawPointsData, index)));
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/index.js
var voi_exports = {};
__export(voi_exports, {
  colorbar: () => colorbar_exports,
  windowLevel: () => windowlevel_exports
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/index.js
var colorbar_exports = {};
__export(colorbar_exports, {
  Colorbar: () => Colorbar,
  Enums: () => enums_exports3,
  ViewportColorbar: () => ViewportColorbar
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/index.js
var enums_exports3 = {};
__export(enums_exports3, {
  ColorbarRangeTextPosition: () => ColorbarRangeTextPosition
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js
var ColorbarRangeTextPosition;
(function(ColorbarRangeTextPosition2) {
  ColorbarRangeTextPosition2["Top"] = "top";
  ColorbarRangeTextPosition2["Left"] = "left";
  ColorbarRangeTextPosition2["Bottom"] = "bottom";
  ColorbarRangeTextPosition2["Right"] = "right";
})(ColorbarRangeTextPosition || (ColorbarRangeTextPosition = {}));

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isRangeValid.js
var isRangeValid = (range2) => {
  return range2 && range2.upper > range2.lower;
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isColorbarSizeValid.js
var isColorbarSizeValid = (size) => {
  return !!size && size.width > 0 && size.height > 0;
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/areColorbarRangesEqual.js
var areColorbarRangesEqual = (a, b) => {
  return !!a && !!b && a.lower === b.lower && a.upper === b.upper;
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/areColorbarSizesEqual.js
var areColorbarSizesEqual = (a, b) => {
  return !!a && !!b && a.width === b.width && a.height === b.height;
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec3/interpolateVec3.js
var interpolateVec3 = (a, b, t) => {
  return [
    a[0] * (1 - t) + b[0] * t,
    a[1] * (1 - t) + b[1] * t,
    a[2] * (1 - t) + b[2] * t
  ];
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarCanvas.js
var { clamp } = utilities_exports;
var ColorbarCanvas = class _ColorbarCanvas {
  constructor(props) {
    _ColorbarCanvas.validateProps(props);
    const { colormap, size = { width: 20, height: 100 }, imageRange = { lower: 0, upper: 1 }, voiRange = { lower: 0, upper: 1 }, container, showFullPixelValueRange = false } = props;
    this._colormap = colormap;
    this._imageRange = imageRange;
    this._voiRange = voiRange;
    this._showFullImageRange = showFullPixelValueRange;
    this._canvas = this._createRootElement(size);
    if (container) {
      this.appendTo(container);
    }
  }
  get colormap() {
    return this._colormap;
  }
  set colormap(colormap) {
    this._colormap = colormap;
    this.render();
  }
  get size() {
    const { width, height } = this._canvas;
    return { width, height };
  }
  set size(size) {
    const { _canvas: canvas } = this;
    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {
      return;
    }
    this._setCanvasSize(canvas, size);
    this.render();
  }
  get imageRange() {
    return { ...this._imageRange };
  }
  set imageRange(imageRange) {
    if (!isRangeValid(imageRange) || areColorbarRangesEqual(imageRange, this._imageRange)) {
      return;
    }
    this._imageRange = imageRange;
    this.render();
  }
  get voiRange() {
    return { ...this._voiRange };
  }
  set voiRange(voiRange) {
    if (!isRangeValid(voiRange) || areColorbarRangesEqual(voiRange, this._voiRange)) {
      return;
    }
    this._voiRange = voiRange;
    this.render();
  }
  get showFullImageRange() {
    return this._showFullImageRange;
  }
  set showFullImageRange(showFullImageRange) {
    if (showFullImageRange === this._showFullImageRange) {
      return;
    }
    this._showFullImageRange = showFullImageRange;
    this.render();
  }
  appendTo(container) {
    container.appendChild(this._canvas);
    this.render();
  }
  dispose() {
    const { _canvas: canvas } = this;
    const { parentElement } = canvas;
    parentElement == null ? void 0 : parentElement.removeChild(canvas);
  }
  static validateProps(props) {
    const { size, imageRange, voiRange } = props;
    if (size && !isColorbarSizeValid(size)) {
      throw new Error('Invalid "size"');
    }
    if (imageRange && !isRangeValid(imageRange)) {
      throw new Error('Invalid "imageRange"');
    }
    if (voiRange && !isRangeValid(voiRange)) {
      throw new Error('Invalid "voiRange"');
    }
  }
  _setCanvasSize(canvas, size) {
    const { width, height } = size;
    canvas.width = width;
    canvas.height = height;
    Object.assign(canvas.style, {
      width: `${width}px`,
      height: `${height}px`
    });
  }
  _createRootElement(size) {
    const canvas = document.createElement("canvas");
    Object.assign(canvas.style, {
      position: "absolute",
      top: "0",
      left: "0",
      pointerEvents: "none",
      boxSizing: "border-box"
    });
    this._setCanvasSize(canvas, size);
    return canvas;
  }
  render() {
    if (!this._canvas.isConnected) {
      return;
    }
    const { _colormap: colormap } = this;
    const { RGBPoints: rgbPoints } = colormap;
    const colorsCount = rgbPoints.length / 4;
    const getColorPoint = (index) => {
      const offset = 4 * index;
      if (index < 0 || index >= colorsCount) {
        return;
      }
      return {
        index,
        position: rgbPoints[offset],
        color: [
          rgbPoints[offset + 1],
          rgbPoints[offset + 2],
          rgbPoints[offset + 3]
        ]
      };
    };
    const { width, height } = this._canvas;
    const canvasContext = this._canvas.getContext("2d");
    if (!canvasContext) {
      return;
    }
    const isHorizontal = width > height;
    const maxValue = isHorizontal ? width : height;
    const { _voiRange: voiRange } = this;
    const range2 = this._showFullImageRange ? this._imageRange : { ...voiRange };
    const { windowWidth } = utilities_exports.windowLevel.toWindowLevel(voiRange.lower, voiRange.upper);
    let previousColorPoint = void 0;
    let currentColorPoint = getColorPoint(0);
    const incRawPixelValue = (range2.upper - range2.lower) / (maxValue - 1);
    let rawPixelValue = range2.lower;
    for (let i = 0; i < maxValue; i++) {
      const tVoiRange = (rawPixelValue - voiRange.lower) / windowWidth;
      if (currentColorPoint) {
        for (let i2 = currentColorPoint.index; i2 < colorsCount; i2++) {
          if (tVoiRange <= currentColorPoint.position) {
            break;
          }
          previousColorPoint = currentColorPoint;
          currentColorPoint = getColorPoint(i2 + 1);
        }
      }
      let normColor;
      if (!previousColorPoint) {
        normColor = [...currentColorPoint.color];
      } else if (!currentColorPoint) {
        normColor = [...previousColorPoint.color];
      } else {
        const tColorRange = (tVoiRange - previousColorPoint.position) / (currentColorPoint.position - previousColorPoint.position);
        normColor = interpolateVec3(previousColorPoint.color, currentColorPoint.color, tColorRange);
      }
      const color = normColor.map((color2) => clamp(Math.round(color2 * 255), 0, 255));
      canvasContext.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
      if (isHorizontal) {
        canvasContext.fillRect(i, 0, 1, height);
      } else {
        canvasContext.fillRect(0, height - i - 1, width, 1);
      }
      rawPixelValue += incRawPixelValue;
    }
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarTicks.js
var DEFAULTS = {
  FONT: "10px Arial",
  COLOR: "white",
  TICK_SIZE: 5,
  TICK_WIDTH: 1,
  TICK_LABEL_MARGIN: 3,
  MAX_NUM_TICKS: 8,
  TICKS_STEPS: [1, 2.5, 5, 10]
};
var ColorbarTicks = class _ColorbarTicks {
  constructor(props) {
    _ColorbarTicks.validateProps(props);
    const { top = 0, left = 0, size = { width: 20, height: 100 }, imageRange = { lower: 0, upper: 1 }, voiRange = { lower: 0, upper: 1 }, ticks: ticksProps, container, showFullPixelValueRange = false } = props;
    const { style: ticksStyle, position: rangeTextPosition } = ticksProps ?? {};
    this._imageRange = imageRange;
    this._voiRange = voiRange;
    this._font = (ticksStyle == null ? void 0 : ticksStyle.font) ?? DEFAULTS.FONT;
    this._color = (ticksStyle == null ? void 0 : ticksStyle.color) ?? DEFAULTS.COLOR;
    this._tickSize = (ticksStyle == null ? void 0 : ticksStyle.tickSize) ?? DEFAULTS.TICK_SIZE;
    this._tickWidth = (ticksStyle == null ? void 0 : ticksStyle.tickWidth) ?? DEFAULTS.TICK_WIDTH;
    this._labelMargin = (ticksStyle == null ? void 0 : ticksStyle.labelMargin) ?? DEFAULTS.TICK_LABEL_MARGIN;
    this._maxNumTicks = (ticksStyle == null ? void 0 : ticksStyle.maxNumTicks) ?? DEFAULTS.MAX_NUM_TICKS;
    this._rangeTextPosition = rangeTextPosition ?? ColorbarRangeTextPosition.Right;
    this._showFullPixelValueRange = showFullPixelValueRange;
    this._canvas = this._createCanvasElement(size, top, left);
    if (container) {
      this.appendTo(container);
    }
  }
  get size() {
    const { width, height } = this._canvas;
    return { width, height };
  }
  set size(size) {
    const { _canvas: canvas } = this;
    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {
      return;
    }
    this._setCanvasSize(canvas, size);
    this.render();
  }
  get top() {
    return Number.parseInt(this._canvas.style.top);
  }
  set top(top) {
    const { _canvas: canvas } = this;
    const currentTop = this.top;
    if (top === currentTop) {
      return;
    }
    canvas.style.top = `${top}px`;
    this.render();
  }
  get left() {
    return Number.parseInt(this._canvas.style.left);
  }
  set left(left) {
    const { _canvas: canvas } = this;
    const currentLeft = this.left;
    if (left === currentLeft) {
      return;
    }
    canvas.style.left = `${left}px`;
    this.render();
  }
  get imageRange() {
    return { ...this._imageRange };
  }
  set imageRange(imageRange) {
    if (!isRangeValid(imageRange) || areColorbarRangesEqual(imageRange, this._imageRange)) {
      return;
    }
    this._imageRange = imageRange;
    this.render();
  }
  get voiRange() {
    return { ...this._voiRange };
  }
  set voiRange(voiRange) {
    if (!isRangeValid(voiRange) || areColorbarRangesEqual(voiRange, this._voiRange)) {
      return;
    }
    this._voiRange = voiRange;
    this.render();
  }
  get tickSize() {
    return this._tickSize;
  }
  set tickSize(tickSize) {
    if (tickSize === this._tickSize) {
      return;
    }
    this._tickSize = tickSize;
    this.render();
  }
  get tickWidth() {
    return this._tickWidth;
  }
  set tickWidth(tickWidth) {
    if (tickWidth === this._tickWidth) {
      return;
    }
    this._tickWidth = tickWidth;
    this.render();
  }
  get color() {
    return this._color;
  }
  set color(color) {
    if (color === this._color) {
      return;
    }
    this._color = color;
    this.render();
  }
  get showFullPixelValueRange() {
    return this._showFullPixelValueRange;
  }
  set showFullPixelValueRange(showFullRange) {
    if (showFullRange === this._showFullPixelValueRange) {
      return;
    }
    this._showFullPixelValueRange = showFullRange;
    this.render();
  }
  get visible() {
    return this._canvas.style.display === "block";
  }
  set visible(visible) {
    if (visible === this.visible) {
      return;
    }
    this._canvas.style.display = visible ? "block" : "none";
    if (visible) {
      this.render();
    }
  }
  appendTo(container) {
    container.appendChild(this._canvas);
    this.render();
  }
  static validateProps(props) {
    const { size, imageRange, voiRange } = props;
    if (size && !isColorbarSizeValid(size)) {
      throw new Error('Invalid "size"');
    }
    if (imageRange && !isRangeValid(imageRange)) {
      throw new Error('Invalid "imageRange"');
    }
    if (voiRange && !isRangeValid(voiRange)) {
      throw new Error('Invalid "voiRange"');
    }
  }
  _setCanvasSize(canvas, size) {
    const { width, height } = size;
    canvas.width = width;
    canvas.height = height;
    Object.assign(canvas.style, {
      width: `${width}px`,
      height: `${height}px`
    });
  }
  _createCanvasElement(size, top, left) {
    const canvas = document.createElement("canvas");
    Object.assign(canvas.style, {
      display: "none",
      position: "absolute",
      boxSizing: "border-box",
      top: `${top}px`,
      left: `${left}px`
    });
    this._setCanvasSize(canvas, size);
    return canvas;
  }
  _getTicks(range2) {
    const { lower, upper } = range2;
    const rangeValue = upper - lower;
    const roughStep = rangeValue / (this._maxNumTicks - 1);
    const stepPower = Math.pow(10, -Math.floor(Math.log10(Math.abs(roughStep))));
    const roughtStepNormalized = roughStep * stepPower;
    const normalizedStep = DEFAULTS.TICKS_STEPS.find((n) => n >= roughtStepNormalized);
    const step = normalizedStep / stepPower;
    const scaleMax = Math.ceil(upper / step) * step;
    const scaleMin = Math.floor(lower / step) * step;
    const ticksCount = Math.round((scaleMax - scaleMin) / step) + 1;
    const ticks = [];
    for (let i = 0; i < ticksCount; i++) {
      ticks.push(scaleMin + i * step);
    }
    return { scaleMin, scaleMax, step, ticks };
  }
  _getLeftTickInfo({ position, labelMeasure }) {
    const { width } = this._canvas;
    const labelX = width - this.tickSize - labelMeasure.width - this._labelMargin;
    const labelPoint = [labelX, position];
    const tickPoints = {
      start: [width - this._tickSize, position],
      end: [width, position]
    };
    return { labelPoint, tickPoints };
  }
  _getRightTickInfo({ position }) {
    const labelPoint = [this._tickSize + this._labelMargin, position];
    const tickPoints = {
      start: [0, position],
      end: [this._tickSize, position]
    };
    return { labelPoint, tickPoints };
  }
  _getTopTickInfo({ position, labelMeasure }) {
    throw new Error("Not implemented");
  }
  _getBottomTickInfo({ position, labelMeasure }) {
    throw new Error("Not implemented");
  }
  render() {
    const { _canvas: canvas } = this;
    if (!canvas.isConnected || !this.visible) {
      return;
    }
    const { width, height } = canvas;
    const isHorizontal = width >= height;
    const maxCanvasPixelValue = isHorizontal ? width : height;
    const canvasContext = canvas.getContext("2d");
    const { _voiRange: voiRange } = this;
    const range2 = this._showFullPixelValueRange ? this._imageRange : { ...voiRange };
    const rangeWidth = range2.upper - range2.lower;
    const { ticks } = this._getTicks(range2);
    canvasContext.clearRect(0, 0, width, height);
    canvasContext.font = this._font;
    canvasContext.textBaseline = "middle";
    canvasContext.fillStyle = this._color;
    canvasContext.strokeStyle = this._color;
    canvasContext.lineWidth = this.tickWidth;
    ticks.forEach((tick) => {
      let position = Math.round(maxCanvasPixelValue * ((tick - range2.lower) / rangeWidth));
      if (!isHorizontal) {
        position = height - position;
      }
      if (position < 0 || position > maxCanvasPixelValue) {
        return;
      }
      const label = tick.toString();
      const labelMeasure = canvasContext.measureText(label);
      let tickInfo;
      if (isHorizontal) {
        if (this._rangeTextPosition === ColorbarRangeTextPosition.Top) {
          tickInfo = this._getTopTickInfo({ position, labelMeasure });
        } else {
          tickInfo = this._getBottomTickInfo({ position, labelMeasure });
        }
      } else {
        if (this._rangeTextPosition === ColorbarRangeTextPosition.Left) {
          tickInfo = this._getLeftTickInfo({ position, labelMeasure });
        } else {
          tickInfo = this._getRightTickInfo({ position });
        }
      }
      const { labelPoint, tickPoints } = tickInfo;
      const { start: tickStart, end: tickEnd } = tickPoints;
      canvasContext.beginPath();
      canvasContext.moveTo(tickStart[0], tickStart[1]);
      canvasContext.lineTo(tickEnd[0], tickEnd[1]);
      canvasContext.fillText(label, labelPoint[0], labelPoint[1]);
      canvasContext.stroke();
      return position;
    });
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isRangeTextPositionValid.js
function isRangeTextPositionValid(colorbarWidth, colorbarHeight, rangeTextPosition) {
  const isHorizontal = colorbarWidth >= colorbarHeight;
  const validRangeTextPositions = isHorizontal ? [ColorbarRangeTextPosition.Top, ColorbarRangeTextPosition.Bottom] : [ColorbarRangeTextPosition.Left, ColorbarRangeTextPosition.Right];
  return validRangeTextPositions.includes(rangeTextPosition);
}

// node_modules/@cornerstonejs/tools/dist/esm/widgets/Widget.js
var Widget = class {
  constructor({ id, container }) {
    this._containerResizeCallback = (entries) => {
      let width;
      let height;
      const { contentRect, contentBoxSize } = entries[0];
      if (contentRect) {
        width = contentRect.width;
        height = contentRect.height;
      } else if (contentBoxSize == null ? void 0 : contentBoxSize.length) {
        width = contentBoxSize[0].inlineSize;
        height = contentBoxSize[0].blockSize;
      }
      this._containerSize = { width, height };
      this.onContainerResize();
    };
    this._id = id;
    this._containerSize = { width: 0, height: 0 };
    this._rootElement = this.createRootElement(id);
    this._containerResizeObserver = new ResizeObserver(this._containerResizeCallback);
    if (container) {
      this.appendTo(container);
    }
  }
  get id() {
    return this._id;
  }
  get rootElement() {
    return this._rootElement;
  }
  appendTo(container) {
    const { _rootElement: rootElement, _containerResizeObserver: resizeObserver } = this;
    const { parentElement: currentContainer } = rootElement;
    if (!container || container === currentContainer) {
      return;
    }
    if (currentContainer) {
      resizeObserver.unobserve(currentContainer);
    }
    container.appendChild(rootElement);
    resizeObserver.observe(container);
  }
  destroy() {
    const { _rootElement: rootElement, _containerResizeObserver: resizeObserver } = this;
    const { parentElement } = rootElement;
    parentElement == null ? void 0 : parentElement.removeChild(rootElement);
    resizeObserver.disconnect();
  }
  get containerSize() {
    return { ...this._containerSize };
  }
  createRootElement(id) {
    const rootElement = document.createElement("div");
    rootElement.id = id;
    rootElement.classList.add("widget");
    Object.assign(rootElement.style, {
      width: "100%",
      height: "100%"
    });
    return rootElement;
  }
  onContainerResize() {
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/Colorbar.js
var DEFAULTS2 = {
  MULTIPLIER: 1,
  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,
  TICKS_BAR_SIZE: 50
};
var Colorbar = class _Colorbar extends Widget {
  constructor(props) {
    var _a2;
    super(props);
    this._isMouseOver = false;
    this._isInteracting = false;
    this._mouseOverCallback = (evt) => {
      this._isMouseOver = true;
      this.showTicks();
      evt.stopPropagation();
    };
    this._mouseOutCallback = (evt) => {
      this._isMouseOver = false;
      this.hideTicks();
      evt.stopPropagation();
    };
    this._mouseDownCallback = (evt) => {
      this._isInteracting = true;
      this.showTicks();
      this._addVOIEventListeners(evt);
      evt.stopPropagation();
    };
    this._mouseDragCallback = (evt, initialState) => {
      const multipliers = this.getVOIMultipliers();
      const currentPoints = this._getPointsFromMouseEvent(evt);
      const { points: startPoints, voiRange: startVOIRange } = initialState;
      const canvasDelta = vec2_exports.sub(vec2_exports.create(), currentPoints.local, startPoints.local);
      const wwDelta = canvasDelta[0] * multipliers[0];
      const wcDelta = canvasDelta[1] * multipliers[1];
      if (!wwDelta && !wcDelta) {
        return;
      }
      const { lower: voiLower, upper: voiUpper } = startVOIRange;
      let { windowWidth, windowCenter } = utilities_exports.windowLevel.toWindowLevel(voiLower, voiUpper);
      windowWidth = Math.max(windowWidth + wwDelta, 1);
      windowCenter += wcDelta;
      const newVoiRange = utilities_exports.windowLevel.toLowHighRange(windowWidth, windowCenter);
      this.voiRange = newVoiRange;
      evt.stopPropagation();
      evt.preventDefault();
    };
    this._mouseUpCallback = (evt) => {
      this._isInteracting = false;
      this.hideTicks();
      this._removeVOIEventListeners();
      evt.stopPropagation();
    };
    this._eventListenersManager = new utilities_exports.eventListener.MultiTargetEventListenerManager();
    this._colormaps = _Colorbar.getColormapsMap(props);
    this._activeColormapName = _Colorbar.getInitialColormapName(props);
    this._canvas = this._createCanvas(props);
    this._ticksBar = this._createTicksBar(props);
    this._rangeTextPosition = ((_a2 = props.ticks) == null ? void 0 : _a2.position) ?? DEFAULTS2.RANGE_TEXT_POSITION;
    this._canvas.appendTo(this.rootElement);
    this._ticksBar.appendTo(this.rootElement);
    this._addRootElementEventListeners();
  }
  get activeColormapName() {
    return this._activeColormapName;
  }
  set activeColormapName(colormapName) {
    if (colormapName === this._activeColormapName) {
      return;
    }
    const colormap = this._colormaps.get(colormapName);
    if (!colormap) {
      console.warn(`Invalid colormap name (${colormapName})`);
      return;
    }
    this._activeColormapName = colormapName;
    this._canvas.colormap = colormap;
  }
  get imageRange() {
    return this._canvas.imageRange;
  }
  set imageRange(imageRange) {
    this._canvas.imageRange = imageRange;
    this._ticksBar.imageRange = imageRange;
  }
  get voiRange() {
    return this._canvas.voiRange;
  }
  set voiRange(voiRange) {
    const { voiRange: currentVoiRange } = this._canvas;
    if (!isRangeValid(voiRange) || areColorbarRangesEqual(voiRange, currentVoiRange)) {
      return;
    }
    this._canvas.voiRange = voiRange;
    this._ticksBar.voiRange = voiRange;
    this.onVoiChange(voiRange);
  }
  get showFullImageRange() {
    return this._canvas.showFullImageRange;
  }
  set showFullImageRange(value) {
    this._canvas.showFullImageRange = value;
    this._ticksBar.showFullPixelValueRange = value;
  }
  destroy() {
    super.destroy();
    this._eventListenersManager.reset();
  }
  createRootElement() {
    const rootElement = document.createElement("div");
    Object.assign(rootElement.style, {
      position: "relative",
      fontSize: "0",
      width: "100%",
      height: "100%"
    });
    return rootElement;
  }
  onContainerResize() {
    super.onContainerResize();
    this.updateTicksBar();
    this._canvas.size = this.containerSize;
  }
  getVOIMultipliers() {
    return [DEFAULTS2.MULTIPLIER, DEFAULTS2.MULTIPLIER];
  }
  onVoiChange(voiRange) {
  }
  showTicks() {
    this.updateTicksBar();
    this._ticksBar.visible = true;
  }
  hideTicks() {
    if (this._isInteracting || this._isMouseOver) {
      return;
    }
    this._ticksBar.visible = false;
  }
  static getColormapsMap(props) {
    const { colormaps } = props;
    return colormaps.reduce((items, item) => items.set(item.Name, item), /* @__PURE__ */ new Map());
  }
  static getInitialColormapName(props) {
    const { activeColormapName, colormaps } = props;
    const colormapExists = !!activeColormapName && colormaps.some((cm) => cm.Name === activeColormapName);
    return colormapExists ? activeColormapName : colormaps[0].Name;
  }
  _createCanvas(props) {
    const { imageRange, voiRange, showFullPixelValueRange } = props;
    const colormap = this._colormaps.get(this._activeColormapName);
    return new ColorbarCanvas({
      colormap,
      imageRange,
      voiRange,
      showFullPixelValueRange
    });
  }
  _createTicksBar(props) {
    const ticksProps = props.ticks;
    return new ColorbarTicks({
      imageRange: props.imageRange,
      voiRange: props.voiRange,
      ticks: ticksProps,
      showFullPixelValueRange: props.showFullPixelValueRange
    });
  }
  _getPointsFromMouseEvent(evt) {
    const { rootElement: element } = this;
    const clientPoint = [evt.clientX, evt.clientY];
    const pagePoint = [evt.pageX, evt.pageY];
    const rect = element.getBoundingClientRect();
    const localPoints = [
      pagePoint[0] - rect.left - window.pageXOffset,
      pagePoint[1] - rect.top - window.pageYOffset
    ];
    return { client: clientPoint, page: pagePoint, local: localPoints };
  }
  updateTicksBar() {
    const { width: containerWidth, height: containerHeight } = this.containerSize;
    if (containerWidth === 0 && containerHeight === 0) {
      return;
    }
    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;
    const isHorizontal = containerWidth >= containerHeight;
    const width = isHorizontal ? containerWidth : DEFAULTS2.TICKS_BAR_SIZE;
    const height = isHorizontal ? DEFAULTS2.TICKS_BAR_SIZE : containerHeight;
    if (!isRangeTextPositionValid(containerWidth, containerHeight, rangeTextPosition)) {
      throw new Error("Invalid rangeTextPosition value for the current colobar orientation");
    }
    let ticksBarTop;
    let ticksBarLeft;
    ticksBar.size = { width, height };
    if (isHorizontal) {
      ticksBarLeft = 0;
      ticksBarTop = rangeTextPosition === ColorbarRangeTextPosition.Top ? -height : containerHeight;
    } else {
      ticksBarTop = 0;
      ticksBarLeft = rangeTextPosition === ColorbarRangeTextPosition.Left ? -width : containerWidth;
    }
    ticksBar.top = ticksBarTop;
    ticksBar.left = ticksBarLeft;
  }
  _addRootElementEventListeners() {
    const { _eventListenersManager: manager } = this;
    const { rootElement: element } = this;
    manager.addEventListener(element, "mouseover", this._mouseOverCallback);
    manager.addEventListener(element, "mouseout", this._mouseOutCallback);
    manager.addEventListener(element, "mousedown", this._mouseDownCallback);
  }
  _addVOIEventListeners(evt) {
    const { _eventListenersManager: manager } = this;
    const points = this._getPointsFromMouseEvent(evt);
    const voiRange = { ...this._canvas.voiRange };
    const initialDragState = { points, voiRange };
    this._removeVOIEventListeners();
    manager.addEventListener(document, "voi.mouseup", this._mouseUpCallback);
    manager.addEventListener(document, "voi.mousemove", (evt2) => this._mouseDragCallback(evt2, initialDragState));
  }
  _removeVOIEventListeners() {
    const { _eventListenersManager: manager } = this;
    manager.removeEventListener(document, "voi.mouseup");
    manager.removeEventListener(document, "voi.mousemove");
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/getVOIMultipliers.js
var DEFAULT_MULTIPLIER = 4;
function getVOIMultipliers(viewport, volumeId, options) {
  const modality = utilities_exports.getViewportModality(viewport, volumeId);
  if (modality === "PT") {
    const { clientWidth, clientHeight } = viewport.element;
    const ptMultiplier = 5 / Math.max(clientWidth, clientHeight);
    const isPreScaled = isViewportPreScaled(viewport, volumeId);
    const { fixedPTWindowWidth = true } = options ?? {};
    const xMultiplier = fixedPTWindowWidth ? 0 : ptMultiplier;
    return isPreScaled ? [xMultiplier, ptMultiplier] : [xMultiplier, DEFAULT_MULTIPLIER];
  }
  return [DEFAULT_MULTIPLIER, DEFAULT_MULTIPLIER];
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ViewportColorbar.js
var { Events: Events3 } = enums_exports;
var defaultImageRange = { lower: -1e3, upper: 1e3 };
var ViewportColorbar = class _ViewportColorbar extends Colorbar {
  constructor(props) {
    const { element, volumeId } = props;
    const imageRange = _ViewportColorbar._getImageRange(element, volumeId);
    const voiRange = _ViewportColorbar._getVOIRange(element, volumeId);
    super({ ...props, imageRange, voiRange });
    this.autoHideTicks = () => {
      if (this._hideTicksTimeoutId) {
        return;
      }
      const timeLeft = this._hideTicksTime - Date.now();
      if (timeLeft <= 0) {
        this.hideTicks();
      } else {
        this._hideTicksTimeoutId = window.setTimeout(() => {
          this._hideTicksTimeoutId = 0;
          this.autoHideTicks();
        }, timeLeft);
      }
    };
    this._stackNewImageCallback = () => {
      this.imageRange = _ViewportColorbar._getImageRange(this._element);
    };
    this._imageVolumeModifiedCallback = (evt) => {
      const { volumeId: volumeId2 } = evt.detail;
      if (volumeId2 !== this._volumeId) {
        return;
      }
      const { _element: element2 } = this;
      this.imageRange = _ViewportColorbar._getImageRange(element2, volumeId2);
    };
    this._viewportVOIModifiedCallback = (evt) => {
      const { viewportId, volumeId: volumeId2, range: voiRange2, colormap } = evt.detail;
      const { viewport } = this.enabledElement;
      if (viewportId !== viewport.id || volumeId2 !== this._volumeId) {
        return;
      }
      this.voiRange = voiRange2;
      if (colormap) {
        this.activeColormapName = colormap.name;
      }
      this.showAndAutoHideTicks();
    };
    this._viewportColormapModifiedCallback = (evt) => {
      const { viewportId, colormap, volumeId: volumeId2 } = evt.detail;
      const { viewport } = this.enabledElement;
      if (viewportId !== viewport.id || volumeId2 !== this._volumeId) {
        return;
      }
      this.activeColormapName = colormap.name;
    };
    this._element = element;
    this._volumeId = volumeId;
    this._addCornerstoneEventListener();
  }
  get element() {
    return this._element;
  }
  get enabledElement() {
    return getEnabledElement(this._element);
  }
  getVOIMultipliers() {
    const { viewport } = this.enabledElement;
    return getVOIMultipliers(viewport, this._volumeId);
  }
  onVoiChange(voiRange) {
    super.onVoiChange(voiRange);
    const { viewport } = this.enabledElement;
    if (viewport instanceof StackViewport_default) {
      viewport.setProperties({
        voiRange
      });
      viewport.render();
    } else if (viewport instanceof VolumeViewport_default) {
      const { _volumeId: volumeId } = this;
      const viewportsContainingVolumeUID = utilities_exports.getViewportsWithVolumeId(volumeId);
      viewport.setProperties({ voiRange }, volumeId);
      viewportsContainingVolumeUID.forEach((vp) => vp.render());
    }
  }
  static _getImageRange(element, volumeId) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const actor = viewport.getImageActor(volumeId);
    if (!actor) {
      return defaultImageRange;
    }
    const imageData = actor.getMapper().getInputData();
    const scalarData = imageData.getPointData().getScalars();
    let imageRange;
    if (!scalarData) {
      if (!volumeId) {
        throw new Error("volumeId is required when scalarData is not available");
      }
      const volume = cache_default.getVolume(volumeId);
      const [minValue, maxValue] = volume.voxelManager.getRange();
      imageRange = [minValue, maxValue];
    } else {
      imageRange = scalarData.getRange();
    }
    return imageRange[0] === 0 && imageRange[1] === 0 ? defaultImageRange : { lower: imageRange[0], upper: imageRange[1] };
  }
  static _getVOIRange(element, volumeId) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const actor = viewport.getImageActor(volumeId);
    if (!actor) {
      return defaultImageRange;
    }
    const voiRange = actor.getProperty().getRGBTransferFunction(0).getRange();
    return voiRange[0] === 0 && voiRange[1] === 0 ? defaultImageRange : { lower: voiRange[0], upper: voiRange[1] };
  }
  showAndAutoHideTicks(interval = 1e3) {
    this._hideTicksTime = Date.now() + interval;
    this.showTicks();
    this.autoHideTicks();
  }
  _addCornerstoneEventListener() {
    const { _element: element } = this;
    eventTarget_default.addEventListener(Events3.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);
    element.addEventListener(Events3.STACK_NEW_IMAGE, this._stackNewImageCallback);
    element.addEventListener(Events3.VOI_MODIFIED, this._viewportVOIModifiedCallback);
    element.addEventListener(Events3.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/index.js
var windowlevel_exports = {};
__export(windowlevel_exports, {
  calculateMinMaxMean: () => calculateMinMaxMean,
  extractWindowLevelRegionToolData: () => extractWindowLevelRegionToolData,
  getLuminanceFromRegion: () => getLuminanceFromRegion
});

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/getLuminanceFromRegion.js
function getLuminanceFromRegion(imageData, x, y, width, height) {
  const luminance = [];
  let index = 0;
  const pixelData = imageData.scalarData;
  let spIndex, row, column;
  if (imageData.color) {
    for (row = 0; row < height; row++) {
      for (column = 0; column < width; column++) {
        spIndex = ((row + y) * imageData.columns + (column + x)) * 4;
        const red = pixelData[spIndex];
        const green = pixelData[spIndex + 1];
        const blue = pixelData[spIndex + 2];
        luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;
      }
    }
  } else {
    for (row = 0; row < height; row++) {
      for (column = 0; column < width; column++) {
        spIndex = (row + y) * imageData.columns + (column + x);
        luminance[index++] = pixelData[spIndex];
      }
    }
  }
  return luminance;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/calculateMinMaxMean.js
function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {
  const numPixels = pixelLuminance.length;
  let min = globalMax;
  let max2 = globalMin;
  let sum = 0;
  if (numPixels < 2) {
    return {
      min,
      max: max2,
      mean: (globalMin + globalMax) / 2
    };
  }
  for (let index = 0; index < numPixels; index++) {
    const spv = pixelLuminance[index];
    min = Math.min(min, spv);
    max2 = Math.max(max2, spv);
    sum += spv;
  }
  return {
    min,
    max: max2,
    mean: sum / numPixels
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/extractWindowLevelRegionToolData.js
function extractWindowLevelRegionToolData(viewport) {
  if (viewport instanceof VolumeViewport_default) {
    return extractImageDataVolume(viewport);
  }
  if (viewport instanceof StackViewport_default) {
    return extractImageDataStack(viewport);
  }
  throw new Error("Viewport not supported");
}
function extractImageDataVolume(viewport) {
  const { scalarData, width, height } = utilities_exports.getCurrentVolumeViewportSlice(viewport);
  const { min: minPixelValue, max: maxPixelValue } = utilities_exports.getMinMax(scalarData);
  return {
    scalarData,
    minPixelValue,
    maxPixelValue,
    width,
    height,
    rows: width,
    columns: height
  };
}
function extractImageDataStack(viewport) {
  const imageData = viewport.getImageData();
  const { scalarData } = imageData;
  const { min: minPixelValue, max: maxPixelValue } = utilities_exports.getMinMax(scalarData);
  const width = imageData.dimensions[0];
  const height = imageData.dimensions[1];
  const { rows, columns, color } = viewport.getCornerstoneImage();
  return {
    scalarData,
    width,
    height,
    minPixelValue,
    maxPixelValue,
    rows,
    columns,
    color
  };
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js
var { transformWorldToIndex: transformWorldToIndex10 } = utilities_exports;
function pointInSurroundingSphereCallback(imageData, circlePoints, callback, viewport) {
  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(circlePoints, imageData, viewport);
  const sphereObj = {
    center: centerWorld,
    radius: radiusWorld
  };
  const dimensions = imageData.getDimensions();
  const voxelManager = utilities_exports.VoxelManager.createScalarVolumeVoxelManager({
    dimensions,
    scalarData: imageData.getPointData().getScalars().getData()
  });
  voxelManager.forEach(callback, {
    boundsIJK,
    isInObject: (pointLPS) => pointInSphere(sphereObj, pointLPS),
    imageData
  });
}
function _getBounds(circlePoints, imageData, viewport) {
  const [bottom, top] = circlePoints;
  const centerWorld = vec3_exports.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);
  const radiusWorld = vec3_exports.distance(bottom, top) / 2;
  let boundsIJK;
  if (!viewport) {
    const centerIJK = transformWorldToIndex10(imageData, centerWorld);
    const spacings = imageData.getSpacing();
    const minSpacing = Math.min(...spacings);
    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);
    boundsIJK = [
      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],
      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],
      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK]
    ];
    return {
      boundsIJK,
      centerWorld,
      radiusWorld
    };
  }
  boundsIJK = _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld);
  return {
    boundsIJK,
    centerWorld,
    radiusWorld
  };
}
function _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld) {
  const [bottom, top] = circlePoints;
  const dimensions = imageData.getDimensions();
  const camera = viewport.getCamera();
  const viewUp = vec3_exports.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
  const viewPlaneNormal = vec3_exports.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
  const viewRight = vec3_exports.create();
  vec3_exports.cross(viewRight, viewUp, viewPlaneNormal);
  const topLeftWorld = vec3_exports.create();
  const bottomRightWorld = vec3_exports.create();
  vec3_exports.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);
  vec3_exports.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);
  vec3_exports.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);
  vec3_exports.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);
  const sphereCornersIJK = [
    transformWorldToIndex10(imageData, topLeftWorld),
    transformWorldToIndex10(imageData, bottomRightWorld)
  ];
  const boundsIJK = getBoundingBoxAroundShapeIJK(sphereCornersIJK, dimensions);
  return boundsIJK;
}

// node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js
var roundNumber = utilities_exports.roundNumber;

// node_modules/@cornerstonejs/tools/dist/esm/index.js
var Types = __toESM(require_types());

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js
var segmentation_exports2 = {};
__export(segmentation_exports2, {
  activeSegmentation: () => activeSegmentation_exports,
  addContourRepresentationToViewport: () => addContourRepresentationToViewport,
  addContourRepresentationToViewportMap: () => addContourRepresentationToViewportMap,
  addLabelmapRepresentationToViewport: () => addLabelmapRepresentationToViewport,
  addLabelmapRepresentationToViewportMap: () => addLabelmapRepresentationToViewportMap,
  addRepresentationData: () => internalAddRepresentationData_default,
  addSegmentationRepresentations: () => addSegmentationRepresentations,
  addSegmentations: () => addSegmentations,
  addSurfaceRepresentationToViewport: () => addSurfaceRepresentationToViewport,
  addSurfaceRepresentationToViewportMap: () => addSurfaceRepresentationToViewportMap,
  config: () => config_exports2,
  getLabelmapImageIds: () => getLabelmapImageIds,
  helpers: () => helpers,
  polySeg: () => polySeg_exports,
  removeAllSegmentationRepresentations: () => removeAllSegmentationRepresentations,
  removeAllSegmentations: () => removeAllSegmentations,
  removeContourRepresentation: () => removeContourRepresentation,
  removeLabelmapRepresentation: () => removeLabelmapRepresentation,
  removeSegment: () => removeSegment,
  removeSegmentation: () => removeSegmentation,
  removeSegmentationRepresentation: () => removeSegmentationRepresentation,
  removeSegmentationRepresentations: () => removeSegmentationRepresentations,
  removeSurfaceRepresentation: () => removeSurfaceRepresentation,
  segmentIndex: () => segmentIndex_exports,
  segmentLocking: () => segmentLocking_exports,
  state: () => segmentationState_exports,
  strategies: () => strategies_exports,
  triggerSegmentationEvents: () => triggerSegmentationEvents_exports,
  updateSegmentations: () => updateSegmentations
});

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateSegmentations.js
function updateSegmentations(segmentationUpdateArray, suppressEvents) {
  const segmentationStateManager = defaultSegmentationStateManager;
  segmentationUpdateArray.forEach((segmentationUpdate) => {
    segmentationStateManager.updateSegmentation(segmentationUpdate.segmentationId, segmentationUpdate.payload);
    if (!suppressEvents) {
      triggerSegmentationModified(segmentationUpdate.segmentationId);
    }
  });
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js
var config_exports2 = {};
__export(config_exports2, {
  color: () => segmentationColor_exports,
  style: () => styleHelpers_exports,
  visibility: () => segmentationVisibility_exports
});

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js
var segmentationVisibility_exports = {};
__export(segmentationVisibility_exports, {
  getHiddenSegmentIndices: () => getHiddenSegmentIndices,
  getSegmentIndexVisibility: () => getSegmentIndexVisibility,
  getSegmentationRepresentationVisibility: () => getSegmentationRepresentationVisibility2,
  setSegmentIndexVisibility: () => setSegmentIndexVisibility,
  setSegmentationRepresentationVisibility: () => setSegmentationRepresentationVisibility2
});

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setSegmentationRepresentationVisibility.js
function setSegmentationRepresentationVisibility(viewportId, specifier, visible) {
  const segmentationStateManager = defaultSegmentationStateManager;
  segmentationStateManager.setSegmentationRepresentationVisibility(viewportId, specifier, visible);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js
function setSegmentationRepresentationVisibility2(viewportId, specifier, visibility) {
  const representations = getSegmentationRepresentations(viewportId, specifier);
  if (!representations) {
    return;
  }
  representations.forEach((representation) => {
    setSegmentationRepresentationVisibility(viewportId, {
      segmentationId: representation.segmentationId,
      type: representation.type
    }, visibility);
  });
}
function getSegmentationRepresentationVisibility2(viewportId, specifier) {
  return getSegmentationRepresentationVisibility(viewportId, specifier);
}
function setSegmentIndexVisibility(viewportId, specifier, segmentIndex, visibility) {
  const representations = getSegmentationRepresentations(viewportId, specifier);
  if (!representations) {
    return;
  }
  representations.forEach((representation) => {
    representation.segments[segmentIndex].visible = visibility;
  });
  triggerSegmentationRenderBySegmentationId(specifier.segmentationId);
  triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId);
}
function getSegmentIndexVisibility(viewportId, specifier, segmentIndex) {
  const hiddenSegments = getHiddenSegmentIndices(viewportId, specifier);
  return !hiddenSegments.has(segmentIndex);
}
function getHiddenSegmentIndices(viewportId, specifier) {
  const representation = getSegmentationRepresentation(viewportId, specifier);
  if (!representation) {
    return /* @__PURE__ */ new Set();
  }
  const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {
    if (!segment.visible) {
      acc.add(Number(segmentIndex));
    }
    return acc;
  }, /* @__PURE__ */ new Set());
  return segmentsHidden;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js
var styleHelpers_exports = {};
__export(styleHelpers_exports, {
  getRenderInactiveSegmentations: () => getRenderInactiveSegmentations,
  getStyle: () => getStyle,
  hasCustomStyle: () => hasCustomStyle,
  resetToGlobalStyle: () => resetToGlobalStyle,
  setRenderInactiveSegmentations: () => setRenderInactiveSegmentations,
  setStyle: () => setStyle
});
function getStyle(specifier) {
  return segmentationStyle.getStyle(specifier);
}
function setStyle(specifier, style) {
  segmentationStyle.setStyle(specifier, style);
  if (!specifier.viewportId && !specifier.segmentationId) {
    const segmentations = getSegmentations();
    segmentations.forEach((segmentation) => {
      triggerSegmentationRender(segmentation.segmentationId);
    });
  }
  triggerSegmentationRepresentationModified(specifier.viewportId, specifier.segmentationId, specifier.type);
}
function setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {
  segmentationStyle.setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations);
  triggerSegmentationRender(viewportId);
  const segmentations = getViewportSegmentations(viewportId);
  segmentations.forEach((segmentation) => {
    triggerSegmentationRepresentationModified(viewportId, segmentation.segmentationId);
  });
}
function getRenderInactiveSegmentations(viewportId) {
  return segmentationStyle.getRenderInactiveSegmentations(viewportId);
}
function resetToGlobalStyle() {
  segmentationStyle.resetToGlobalStyle();
  triggerSegmentationRender();
}
function hasCustomStyle(specifier) {
  return segmentationStyle.hasCustomStyle(specifier);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js
var segmentIndex_exports = {};
__export(segmentIndex_exports, {
  getActiveSegmentIndex: () => getActiveSegmentIndex,
  setActiveSegmentIndex: () => setActiveSegmentIndex
});
function setActiveSegmentIndex(segmentationId, segmentIndex) {
  const segmentation = getSegmentation(segmentationId);
  if (typeof segmentIndex === "string") {
    console.warn("segmentIndex is a string, converting to number");
    segmentIndex = Number(segmentIndex);
  }
  Object.values(segmentation.segments).forEach((segment) => {
    segment.active = false;
  });
  if (!segmentation.segments[segmentIndex]) {
    segmentation.segments[segmentIndex] = {
      segmentIndex,
      label: "",
      locked: false,
      cachedStats: {},
      active: false
    };
  }
  if (segmentation.segments[segmentIndex].active !== true) {
    segmentation.segments[segmentIndex].active = true;
    triggerSegmentationModified(segmentationId);
  }
  const viewportIds = getViewportIdsWithSegmentation(segmentationId);
  viewportIds.forEach((viewportId) => {
    const representations = getSegmentationRepresentations(viewportId, {
      segmentationId
    });
    representations.forEach((representation) => {
      if (!representation.segments[segmentIndex]) {
        representation.segments[segmentIndex] = {
          visible: true
        };
      }
    });
  });
  viewportIds.forEach((viewportId) => {
    const toolGroup = getToolGroupForViewport_default(viewportId);
    invalidateBrushCursor(toolGroup.id);
  });
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/convertStackToVolumeLabelmap.js
async function convertStackToVolumeLabelmap(args) {
  const result = internalConvertStackToVolumeLabelmap(args);
  triggerSegmentationModified(args.segmentationId);
  return result;
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/index.js
var polySeg_exports = {};
__export(polySeg_exports, {
  canComputeRequestedRepresentation: () => canComputeRequestedRepresentation,
  computeAndAddContourRepresentation: () => computeAndAddContourRepresentation,
  computeAndAddLabelmapRepresentation: () => computeAndAddLabelmapRepresentation,
  computeAndAddSurfaceRepresentation: () => computeAndAddSurfaceRepresentation
});

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clearSegmentValue.js
function clearSegmentValue(segmentationId, segmentIndex) {
  const segmentation = getSegmentation(segmentationId);
  if (segmentation.representationData.Labelmap) {
    const { representationData } = segmentation;
    const labelmapData = representationData.Labelmap;
    if ("imageIds" in labelmapData || "volumeId" in labelmapData) {
      const items = "imageIds" in labelmapData ? labelmapData.imageIds.map((imageId) => cache_default.getImage(imageId)) : [cache_default.getVolume(labelmapData.volumeId)];
      items.forEach((item) => {
        if (!item) {
          return;
        }
        const { voxelManager } = item;
        voxelManager.forEach(({ value, index }) => {
          if (value === segmentIndex) {
            voxelManager.setAtIndex(index, 0);
          }
        });
      });
    }
    triggerSegmentationDataModified(segmentationId);
  } else {
    throw new Error("Invalid segmentation type, only labelmap is supported right now");
  }
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegment.js
function removeSegment(segmentationId, segmentIndex, options = {
  setNextSegmentAsActive: true
}) {
  clearSegmentValue(segmentationId, segmentIndex);
  const isThisSegmentActive = getActiveSegmentIndex(segmentationId) === segmentIndex;
  const segmentation = getSegmentation(segmentationId);
  const { segments } = segmentation;
  delete segments[segmentIndex];
  const updatedSegments = {
    ...segments
  };
  updateSegmentations([
    {
      segmentationId,
      payload: {
        segments: updatedSegments
      }
    }
  ]);
  if (isThisSegmentActive && options.setNextSegmentAsActive) {
    const segmentIndices = Object.keys(segments).map(Number).sort((a, b) => a - b);
    const currentIndex = segmentIndices.indexOf(segmentIndex);
    const nextSegmentIndex = segmentIndices[currentIndex + 1];
    const previousSegmentIndex = segmentIndices[currentIndex - 1];
    if (nextSegmentIndex !== void 0) {
      setActiveSegmentIndex(segmentationId, nextSegmentIndex);
    } else if (previousSegmentIndex !== void 0) {
      setActiveSegmentIndex(segmentationId, previousSegmentIndex);
    }
  }
  const viewportIds = getViewportIdsWithSegmentation(segmentationId);
  viewportIds.forEach((viewportId) => {
    const representations = getSegmentationRepresentations(viewportId, {
      segmentationId
    });
    representations.forEach((representation) => {
      delete representation.segments[segmentIndex];
    });
  });
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getLabelmapImageIds.js
function getLabelmapImageIds(segmentationId) {
  const segmentationStateManager = defaultSegmentationStateManager;
  const segmentation = getSegmentation(segmentationId);
  return segmentationStateManager.getLabelmapImageIds(segmentation.representationData);
}

// node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js
var helpers = {
  clearSegmentValue,
  convertStackToVolumeLabelmap,
  computeVolumeLabelmapFromStack,
  convertVolumeToStackLabelmap
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/index.js
var splines_exports = {};
__export(splines_exports, {
  BSpline: () => BSpline,
  CardinalSpline: () => CardinalSpline,
  CatmullRomSpline: () => CatmullRomSpline,
  CubicSpline: () => CubicSpline,
  LinearSpline: () => LinearSpline,
  QuadraticBezier: () => QuadraticBezier,
  QuadraticSpline: () => QuadraticSpline,
  Spline: () => Spline
});

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js
var Spline = class {
  constructor(props) {
    this._controlPoints = [];
    this._invalidated = false;
    this._length = 0;
    this._controlPoints = [];
    this._resolution = (props == null ? void 0 : props.resolution) ?? 20;
    this._fixedResolution = (props == null ? void 0 : props.fixedResolution) ?? false;
    this._closed = (props == null ? void 0 : props.closed) ?? false;
    this._invalidated = true;
  }
  get controlPoints() {
    return this._controlPoints;
  }
  get numControlPoints() {
    return this._controlPoints.length;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(resolution) {
    if (this._fixedResolution || this._resolution === resolution) {
      return;
    }
    this._resolution = resolution;
    this.invalidated = true;
  }
  get fixedResolution() {
    return this._fixedResolution;
  }
  get closed() {
    return this._closed;
  }
  set closed(closed2) {
    if (this._closed === closed2) {
      return;
    }
    this._closed = closed2;
    this.invalidated = true;
  }
  get aabb() {
    this._update();
    return this._aabb;
  }
  get length() {
    this._update();
    return this._length;
  }
  get invalidated() {
    return this._invalidated;
  }
  set invalidated(invalidated) {
    this._invalidated = invalidated;
  }
  hasTangentPoints() {
    return false;
  }
  addControlPoint(point) {
    this._controlPoints.push([point[0], point[1]]);
    this.invalidated = true;
  }
  addControlPoints(points) {
    points.forEach((point) => this.addControlPoint(point));
  }
  addControlPointAtU(u) {
    const lineSegment = this._getLineSegmentAt(u);
    const { start: startPoint, end: endPoint } = lineSegment.points;
    const curveSegmentIndex = Math.floor(u);
    const curveSegment = this._curveSegments[curveSegmentIndex];
    const t = u - Math.floor(curveSegmentIndex);
    const controlPointPos = [
      startPoint[0] + t * (endPoint[0] - startPoint[0]),
      startPoint[1] + t * (endPoint[1] - startPoint[1])
    ];
    const insertIndex = this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;
    this._controlPoints.splice(insertIndex, 0, controlPointPos);
    this.invalidated = true;
    return {
      index: insertIndex,
      point: controlPointPos
    };
  }
  deleteControlPointByIndex(index) {
    const minControlPoints = this._closed ? 3 : 1;
    const canDelete = index >= 0 && index < this._controlPoints.length && this._controlPoints.length > minControlPoints;
    if (!canDelete) {
      return false;
    }
    this._controlPoints.splice(index, 1);
    this.invalidated = true;
    return true;
  }
  clearControlPoints() {
    this._controlPoints = [];
    this.invalidated = true;
  }
  setControlPoints(points) {
    this.clearControlPoints();
    this.addControlPoints(points);
  }
  updateControlPoint(index, newControlPoint) {
    if (index < 0 || index >= this._controlPoints.length) {
      throw new Error("Index out of bounds");
    }
    this._controlPoints[index] = [...newControlPoint];
    this.invalidated = true;
  }
  getControlPoints() {
    return this._controlPoints.map((controlPoint) => [
      controlPoint[0],
      controlPoint[1]
    ]);
  }
  getClosestControlPoint(point) {
    const controlPoints = this._controlPoints;
    let minSquaredDist = Infinity;
    let closestPointIndex = -1;
    for (let i = 0, len = controlPoints.length; i < len; i++) {
      const controlPoint = controlPoints[i];
      const dx = point[0] - controlPoint[0];
      const dy = point[1] - controlPoint[1];
      const squaredDist = dx * dx + dy * dy;
      if (squaredDist < minSquaredDist) {
        minSquaredDist = squaredDist;
        closestPointIndex = i;
      }
    }
    return {
      index: closestPointIndex,
      point: closestPointIndex === -1 ? void 0 : [...controlPoints[closestPointIndex]],
      distance: Math.sqrt(minSquaredDist)
    };
  }
  getClosestControlPointWithinDistance(point, maxDist) {
    const closestControlPoint = this.getClosestControlPoint(point);
    return closestControlPoint.distance <= maxDist ? closestControlPoint : void 0;
  }
  getClosestPoint(point) {
    this._update();
    const curveSegmentsDistInfo = this._getCurveSegmmentsDistanceSquaredInfo(point);
    if (!curveSegmentsDistInfo.length) {
      return;
    }
    curveSegmentsDistInfo.sort((csA, csB) => csA.distanceSquared - csB.distanceSquared);
    let closestPoint;
    let closestPointCurveSegmentIndex = -1;
    let minDistSquared = Infinity;
    let minDistCurveSegment;
    let minDistLineSegment;
    for (let i = 0; i < curveSegmentsDistInfo.length; i++) {
      const curveSegmentDistInfo = curveSegmentsDistInfo[i];
      if (curveSegmentDistInfo.distanceSquared > minDistSquared) {
        continue;
      }
      const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;
      const { lineSegments } = curveSegment;
      for (let j = 0; j < lineSegments.length; j++) {
        const lineSegment = lineSegments[j];
        const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = line_exports.distanceToPointSquaredInfo(lineSegment.points.start, lineSegment.points.end, point);
        if (lineSegDistSquared < minDistSquared) {
          minDistLineSegment = lineSegment;
          closestPointCurveSegmentIndex = curveSegmentIndex;
          minDistCurveSegment = curveSegmentDistInfo.curveSegment;
          closestPoint = lineSegPoint;
          minDistSquared = lineSegDistSquared;
        }
      }
    }
    const curveSegmentLengthToPoint = minDistLineSegment.previousLineSegmentsLength + point_exports.distanceToPoint(minDistLineSegment.points.start, closestPoint);
    const t = curveSegmentLengthToPoint / minDistCurveSegment.length;
    const u = closestPointCurveSegmentIndex + t;
    return {
      point: closestPoint,
      uValue: u,
      distance: Math.sqrt(minDistSquared)
    };
  }
  getClosestPointOnControlPointLines(point) {
    const linePoints = [...this._controlPoints];
    if (this._closed) {
      linePoints.push(this._controlPoints[0]);
    }
    if (!linePoints.length) {
      return;
    }
    let closestPoint;
    let minDistSquared = Infinity;
    let startPoint = linePoints[0];
    for (let i = 1, len = linePoints.length; i < len; i++) {
      const endPoint = linePoints[i];
      const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = line_exports.distanceToPointSquaredInfo(startPoint, endPoint, point);
      if (lineSegDistSquared < minDistSquared) {
        closestPoint = lineSegPoint;
        minDistSquared = lineSegDistSquared;
      }
      startPoint = endPoint;
    }
    return {
      point: closestPoint,
      distance: Math.sqrt(minDistSquared)
    };
  }
  getPolylinePoints() {
    this._update();
    return this._convertCurveSegmentsToPolyline(this._curveSegments);
  }
  getPreviewPolylinePoints(controlPointPreview, closeDistance) {
    if (this._closed) {
      return [];
    }
    this._update();
    const closestControlPoint = this.getClosestControlPointWithinDistance(controlPointPreview, closeDistance);
    const closeSpline = (closestControlPoint == null ? void 0 : closestControlPoint.index) === 0;
    const previewCurveSegments = this.getPreviewCurveSegments(controlPointPreview, closeSpline);
    return (previewCurveSegments == null ? void 0 : previewCurveSegments.length) ? this._convertCurveSegmentsToPolyline(previewCurveSegments) : [];
  }
  isPointNearCurve(point, maxDist) {
    this._update();
    const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);
    const maxDistSquared = maxDist * maxDist;
    for (let i = 0; i < curveSegments.length; i++) {
      const { lineSegments } = curveSegments[i];
      for (let j = 0; j < lineSegments.length; j++) {
        const lineSegment = lineSegments[j];
        const lineDistSquared = line_exports.distanceToPointSquared(lineSegment.points.start, lineSegment.points.end, point);
        if (lineDistSquared <= maxDistSquared) {
          return true;
        }
      }
    }
    return false;
  }
  containsPoint(point) {
    this._update();
    const controlPoints = this._controlPoints;
    if (controlPoints.length < 3) {
      return false;
    }
    const curveSegments = [...this._curveSegments];
    const closingCurveSegment = this._getClosingCurveSegmentWithStraightLineSegment();
    if (closingCurveSegment) {
      curveSegments.push(closingCurveSegment);
    }
    let numIntersections = 0;
    for (let i = 0; i < curveSegments.length; i++) {
      const curveSegment = curveSegments[i];
      const { aabb: curveSegAABB } = curveSegment;
      const mayIntersectCurveSegment = point[0] <= curveSegAABB.maxX && point[1] >= curveSegAABB.minY && point[1] < curveSegAABB.maxY;
      if (!mayIntersectCurveSegment) {
        continue;
      }
      const { lineSegments } = curveSegment;
      for (let i2 = 0; i2 < lineSegments.length; i2++) {
        const lineSegment = lineSegments[i2];
        const { aabb: lineSegmentAABB } = lineSegment;
        const mayIntersectLineSegment = point[0] <= lineSegmentAABB.maxX && point[1] >= lineSegmentAABB.minY && point[1] < lineSegmentAABB.maxY;
        if (mayIntersectLineSegment) {
          const { start: p1, end: p2 } = lineSegment.points;
          const isVerticalLine = p1[0] === p2[0];
          const xIntersection = (point[1] - p1[1]) * (p2[0] - p1[0]) / (p2[1] - p1[1]) + p1[0];
          numIntersections += isVerticalLine || point[0] <= xIntersection ? 1 : 0;
        }
      }
    }
    return numIntersections % 2 === 1;
  }
  _update() {
    if (!this._invalidated) {
      return;
    }
    const curveSegments = this.getSplineCurves();
    let length = 0;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = 0, len = curveSegments.length; i < len; i++) {
      const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];
      minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;
      minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;
      maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;
      maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;
      length += curveSegLength;
    }
    this._curveSegments = curveSegments;
    this._aabb = { minX, minY, maxX, maxY };
    this._length = length;
    this._invalidated = false;
  }
  _convertCurveSegmentsToPolyline(curveSegments) {
    this._update();
    const polylinePoints = [];
    curveSegments.forEach(({ lineSegments }, curveSegIndex) => {
      lineSegments.forEach((lineSegment, lineSegIndex) => {
        if (curveSegIndex === 0 && lineSegIndex === 0) {
          polylinePoints.push([...lineSegment.points.start]);
        }
        polylinePoints.push([...lineSegment.points.end]);
      });
    });
    return polylinePoints;
  }
  _getCurveSegmmentsDistanceSquaredInfo(point) {
    this._update();
    const curveSegmentsDistanceSquared = [];
    const { _curveSegments: curveSegments } = this;
    for (let i = 0; i < curveSegments.length; i++) {
      const curveSegment = curveSegments[i];
      const distanceSquared = aabb_exports.distanceToPointSquared(curveSegment.aabb, point);
      curveSegmentsDistanceSquared.push({
        curveSegmentIndex: i,
        curveSegment,
        distanceSquared
      });
    }
    return curveSegmentsDistanceSquared;
  }
  _getCurveSegmmentsWithinDistance(point, maxDist) {
    this._update();
    const maxDistSquared = maxDist * maxDist;
    if (aabb_exports.distanceToPointSquared(this.aabb, point) > maxDistSquared) {
      return [];
    }
    const curveSegmentsDistance = this._getCurveSegmmentsDistanceSquaredInfo(point);
    const curveSegmentsWithinRange = [];
    for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {
      const { curveSegment, distanceSquared: curveSegmentDistSquared } = curveSegmentsDistance[i];
      if (curveSegmentDistSquared <= maxDistSquared) {
        curveSegmentsWithinRange.push(curveSegment);
      }
    }
    return curveSegmentsWithinRange;
  }
  _getLineSegmentAt(u) {
    this._update();
    const curveSegmentIndex = Math.floor(u);
    const t = u - curveSegmentIndex;
    const curveSegment = this._curveSegments[curveSegmentIndex];
    const { lineSegments } = curveSegment;
    const pointLength = curveSegment.length * t;
    for (let i = 0; i < lineSegments.length; i++) {
      const lineSegment = lineSegments[i];
      const lengthEnd = lineSegment.previousLineSegmentsLength + lineSegment.length;
      if (pointLength >= lineSegment.previousLineSegmentsLength && pointLength <= lengthEnd) {
        return lineSegment;
      }
    }
  }
  _getClosingCurveSegmentWithStraightLineSegment() {
    if (this.closed) {
      return;
    }
    const controlPoints = this._controlPoints;
    const startControlPoint = controlPoints[0];
    const endControlPoint = controlPoints[controlPoints.length - 1];
    const closingLineSegment = {
      points: {
        start: [...startControlPoint],
        end: [...endControlPoint]
      },
      aabb: {
        minX: Math.min(startControlPoint[0], endControlPoint[0]),
        minY: Math.min(startControlPoint[1], endControlPoint[1]),
        maxX: Math.max(startControlPoint[0], endControlPoint[0]),
        maxY: Math.max(startControlPoint[1], endControlPoint[1])
      }
    };
    return {
      aabb: {
        minX: closingLineSegment.aabb.minX,
        minY: closingLineSegment.aabb.minY,
        maxX: closingLineSegment.aabb.maxX,
        maxY: closingLineSegment.aabb.maxY
      },
      lineSegments: [closingLineSegment]
    };
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js
var MAX_U_ERROR = 1e-8;
var CubicSpline = class extends Spline {
  getPreviewCurveSegments(controlPointPreview, closeSpline) {
    const previewNumCurveSegments = this._getNumCurveSegments() + 1;
    const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);
    const endCurveSegIndex = closeSpline ? previewNumCurveSegments : previewNumCurveSegments - 1;
    const transformMatrix = this.getTransformMatrix();
    const controlPoints = [...this.controlPoints];
    const curveSegments = [];
    if (!closeSpline) {
      controlPoints.push(controlPointPreview);
    }
    for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {
      const curveSegment = this._getCurveSegment(i, transformMatrix, controlPoints, closeSpline);
      curveSegments.push(curveSegment);
    }
    return curveSegments;
  }
  getSplineCurves() {
    const numCurveSegments = this._getNumCurveSegments();
    const curveSegments = new Array(numCurveSegments);
    if (numCurveSegments <= 0) {
      return [];
    }
    const transformMatrix = this.getTransformMatrix();
    let previousCurveSegmentsLength = 0;
    for (let i = 0; i < numCurveSegments; i++) {
      const curveSegment = this._getCurveSegment(i, transformMatrix);
      curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;
      curveSegments[i] = curveSegment;
      previousCurveSegmentsLength += curveSegment.length;
    }
    return curveSegments;
  }
  _getNumCurveSegments(controlPoints = this.controlPoints, closed2 = this.closed) {
    return closed2 ? controlPoints.length : Math.max(0, controlPoints.length - 1);
  }
  _getPoint(u, transformMatrix, controlPoints = this.controlPoints, closed2 = this.closed) {
    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed2);
    const uInt = Math.floor(u);
    let curveSegmentIndex = uInt % numCurveSegments;
    const t = u - uInt;
    const curveSegmentIndexOutOfBounds = curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;
    if (curveSegmentIndexOutOfBounds) {
      if (this.closed) {
        curveSegmentIndex = (numCurveSegments + curveSegmentIndex) % numCurveSegments;
      } else {
        return;
      }
    }
    const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed2);
    const tt = t * t;
    const ttt = tt * t;
    const tValues = vec4_exports.fromValues(1, t, tt, ttt);
    const qValues = vec4_exports.transformMat4(vec4_exports.create(), tValues, transformMatrix);
    return [
      vec4_exports.dot(qValues, vec4_exports.fromValues(p0[0], p1[0], p2[0], p3[0])),
      vec4_exports.dot(qValues, vec4_exports.fromValues(p0[1], p1[1], p2[1], p3[1]))
    ];
  }
  _getCurveSegmentPoints(curveSegmentIndex, controlPoints = this.controlPoints, closed2 = this.closed) {
    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed2);
    const p1Index = curveSegmentIndex;
    const p0Index = p1Index - 1;
    const p2Index = closed2 ? (p1Index + 1) % numCurveSegments : p1Index + 1;
    const p3Index = p2Index + 1;
    const p1 = controlPoints[p1Index];
    const p2 = controlPoints[p2Index];
    let p0;
    let p3;
    if (p0Index >= 0) {
      p0 = controlPoints[p0Index];
    } else {
      p0 = closed2 ? controlPoints[controlPoints.length - 1] : point_exports.mirror(p2, p1);
    }
    if (p3Index < controlPoints.length) {
      p3 = controlPoints[p3Index];
    } else {
      p3 = closed2 ? controlPoints[0] : point_exports.mirror(p1, p2);
    }
    return { p0, p1, p2, p3 };
  }
  _getLineSegments(curveSegmentIndex, transformMatrix, controlPoints = this.controlPoints, closed2 = this.closed) {
    const numCurveSegments = this._getNumCurveSegments(controlPoints, closed2);
    const numLineSegments = this.resolution + 1;
    const inc = 1 / numLineSegments;
    const minU = curveSegmentIndex;
    let maxU = minU + 1;
    if (!closed2 && curveSegmentIndex === numCurveSegments - 1) {
      maxU -= MAX_U_ERROR;
    }
    const lineSegments = [];
    let startPoint;
    let endPoint;
    let previousLineSegmentsLength = 0;
    for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {
      u = u > maxU ? maxU : u;
      const point = this._getPoint(u, transformMatrix, controlPoints, closed2);
      if (!i) {
        startPoint = point;
        continue;
      }
      endPoint = point;
      const dx = endPoint[0] - startPoint[0];
      const dy = endPoint[1] - startPoint[1];
      const length = Math.sqrt(dx ** 2 + dy ** 2);
      const aabb = {
        minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],
        maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],
        minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],
        maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1]
      };
      lineSegments.push({
        points: {
          start: startPoint,
          end: endPoint
        },
        aabb,
        length,
        previousLineSegmentsLength
      });
      startPoint = endPoint;
      previousLineSegmentsLength += length;
    }
    return lineSegments;
  }
  _getCurveSegment(curveSegmentIndex, transformMatrix = this.getTransformMatrix(), controlPoints = this.controlPoints, closed2 = this.closed) {
    const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed2);
    const lineSegments = this._getLineSegments(curveSegmentIndex, transformMatrix, controlPoints, closed2);
    let curveSegmentLength = 0;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {
      minX = Math.min(minX, lineSegAABB.minX);
      minY = Math.min(minY, lineSegAABB.minY);
      maxX = Math.max(maxX, lineSegAABB.maxX);
      maxY = Math.max(maxY, lineSegAABB.maxY);
      curveSegmentLength += lineSegLength;
    });
    return {
      controlPoints: { p0, p1, p2, p3 },
      aabb: { minX, minY, maxX, maxY },
      length: curveSegmentLength,
      previousCurveSegmentsLength: 0,
      lineSegments
    };
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js
var TRANSFORM_MATRIX = mat4_exports.multiplyScalar(mat4_exports.create(), mat4_exports.fromValues(1, 4, 1, 0, -3, 0, 3, 0, 3, -6, 3, 0, -1, 3, -3, 1), 1 / 6);
var BSpline = class extends CubicSpline {
  getTransformMatrix() {
    return TRANSFORM_MATRIX;
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js
var CardinalSpline = class extends CubicSpline {
  constructor(props) {
    super(props);
    this._scale = (props == null ? void 0 : props.scale) ?? 0.5;
    this._fixedScale = (props == null ? void 0 : props.fixedScale) ?? false;
  }
  get scale() {
    return this._scale;
  }
  set scale(scale) {
    if (this._fixedScale || this._scale === scale) {
      return;
    }
    this._scale = scale;
    this.invalidated = true;
  }
  get fixedScale() {
    return this._fixedScale;
  }
  getTransformMatrix() {
    const { scale: s } = this;
    const s2 = 2 * s;
    return [
      0,
      1,
      0,
      0,
      -s,
      0,
      s,
      0,
      s2,
      s - 3,
      3 - s2,
      -s,
      -s,
      2 - s,
      s - 2,
      s
    ];
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js
var CatmullRomSpline = class extends CardinalSpline {
  constructor() {
    super({ scale: 0.5, fixedScale: true });
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js
var LinearSpline = class extends CardinalSpline {
  constructor() {
    super({ resolution: 0, fixedResolution: true, scale: 0, fixedScale: true });
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticSpline.js
var QuadraticSpline = class extends Spline {
  getSplineCurves() {
    return [];
  }
  getLineSegments() {
    return [];
  }
  getPreviewCurveSegments(controlPointPreview, closeSpline) {
    return [];
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticBezier.js
var TRANSFORM_MATRIX2 = [
  1,
  0,
  0,
  -2,
  2,
  0,
  1,
  -2,
  1
];
var QuadraticBezier = class extends QuadraticSpline {
  hasTangentPoints() {
    return true;
  }
  getTransformMatrix() {
    return TRANSFORM_MATRIX2;
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js
var PanTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"]
  }) {
    super(toolProps, defaultToolProps);
  }
  touchDragCallback(evt) {
    this._dragCallback(evt);
  }
  mouseDragCallback(evt) {
    this._dragCallback(evt);
  }
  _dragCallback(evt) {
    const { element, deltaPoints } = evt.detail;
    const enabledElement = getEnabledElement(element);
    const deltaPointsWorld = deltaPoints.world;
    if (deltaPointsWorld[0] === 0 && deltaPointsWorld[1] === 0 && deltaPointsWorld[2] === 0) {
      return;
    }
    const camera = enabledElement.viewport.getCamera();
    const { focalPoint, position } = camera;
    const updatedPosition = [
      position[0] - deltaPointsWorld[0],
      position[1] - deltaPointsWorld[1],
      position[2] - deltaPointsWorld[2]
    ];
    const updatedFocalPoint = [
      focalPoint[0] - deltaPointsWorld[0],
      focalPoint[1] - deltaPointsWorld[1],
      focalPoint[2] - deltaPointsWorld[2]
    ];
    enabledElement.viewport.setCamera({
      focalPoint: updatedFocalPoint,
      position: updatedPosition
    });
    enabledElement.viewport.render();
  }
};
PanTool.toolName = "Pan";
var PanTool_default = PanTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js
var TrackballRotateTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      rotateIncrementDegrees: 2
    }
  }) {
    super(toolProps, defaultToolProps);
    this._resizeObservers = /* @__PURE__ */ new Map();
    this._hasResolutionChanged = false;
    this.preMouseDownCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const actorEntry = viewport.getDefaultActor();
      const actor = actorEntry.actor;
      const mapper = actor.getMapper();
      const hasSampleDistance = "getSampleDistance" in mapper || "getCurrentSampleDistance" in mapper;
      if (!hasSampleDistance) {
        return true;
      }
      const originalSampleDistance = mapper.getSampleDistance();
      if (!this._hasResolutionChanged) {
        mapper.setSampleDistance(originalSampleDistance * 2);
        this._hasResolutionChanged = true;
        if (this.cleanUp !== null) {
          document.removeEventListener("mouseup", this.cleanUp);
        }
        this.cleanUp = () => {
          mapper.setSampleDistance(originalSampleDistance);
          viewport.render();
          this._hasResolutionChanged = false;
        };
        document.addEventListener("mouseup", this.cleanUp, { once: true });
      }
      return true;
    };
    this._getViewportsInfo = () => {
      const viewports = getToolGroup_default(this.toolGroupId).viewportsInfo;
      return viewports;
    };
    this.onSetToolActive = () => {
      const subscribeToElementResize = () => {
        const viewportsInfo = this._getViewportsInfo();
        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
          if (!this._resizeObservers.has(viewportId)) {
            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId) || { viewport: null };
            if (!viewport) {
              return;
            }
            const { element } = viewport;
            const resizeObserver = new ResizeObserver(() => {
              const element2 = getEnabledElementByIds(viewportId, renderingEngineId);
              if (!element2) {
                return;
              }
              const { viewport: viewport2 } = element2;
              const viewPresentation = viewport2.getViewPresentation();
              viewport2.resetCamera();
              viewport2.setViewPresentation(viewPresentation);
              viewport2.render();
            });
            resizeObserver.observe(element);
            this._resizeObservers.set(viewportId, resizeObserver);
          }
        });
      };
      subscribeToElementResize();
      this._viewportAddedListener = (evt) => {
        if (evt.detail.toolGroupId === this.toolGroupId) {
          subscribeToElementResize();
        }
      };
      eventTarget_default.addEventListener(Events_default.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
    };
    this.onSetToolDisabled = () => {
      this._resizeObservers.forEach((resizeObserver, viewportId) => {
        resizeObserver.disconnect();
        this._resizeObservers.delete(viewportId);
      });
      if (this._viewportAddedListener) {
        eventTarget_default.removeEventListener(Events_default.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
        this._viewportAddedListener = null;
      }
    };
    this.rotateCamera = (viewport, centerWorld, axis, angle) => {
      const vtkCamera = viewport.getVtkActiveCamera();
      const viewUp = vtkCamera.getViewUp();
      const focalPoint = vtkCamera.getFocalPoint();
      const position = vtkCamera.getPosition();
      const newPosition = [0, 0, 0];
      const newFocalPoint = [0, 0, 0];
      const newViewUp = [0, 0, 0];
      const transform = mat4_exports.identity(new Float32Array(16));
      mat4_exports.translate(transform, transform, centerWorld);
      mat4_exports.rotate(transform, transform, angle, axis);
      mat4_exports.translate(transform, transform, [
        -centerWorld[0],
        -centerWorld[1],
        -centerWorld[2]
      ]);
      vec3_exports.transformMat4(newPosition, position, transform);
      vec3_exports.transformMat4(newFocalPoint, focalPoint, transform);
      mat4_exports.identity(transform);
      mat4_exports.rotate(transform, transform, angle, axis);
      vec3_exports.transformMat4(newViewUp, viewUp, transform);
      viewport.setCamera({
        position: newPosition,
        viewUp: newViewUp,
        focalPoint: newFocalPoint
      });
    };
    this.touchDragCallback = this._dragCallback.bind(this);
    this.mouseDragCallback = this._dragCallback.bind(this);
  }
  _dragCallback(evt) {
    const { element, currentPoints, lastPoints } = evt.detail;
    const currentPointsCanvas = currentPoints.canvas;
    const lastPointsCanvas = lastPoints.canvas;
    const { rotateIncrementDegrees } = this.configuration;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const camera = viewport.getCamera();
    const width = element.clientWidth;
    const height = element.clientHeight;
    const normalizedPosition = [
      currentPointsCanvas[0] / width,
      currentPointsCanvas[1] / height
    ];
    const normalizedPreviousPosition = [
      lastPointsCanvas[0] / width,
      lastPointsCanvas[1] / height
    ];
    const center = [width * 0.5, height * 0.5];
    const centerWorld = viewport.canvasToWorld(center);
    const normalizedCenter = [0.5, 0.5];
    const radsq = (1 + Math.abs(normalizedCenter[0])) ** 2;
    const op = [normalizedPreviousPosition[0], 0, 0];
    const oe = [normalizedPosition[0], 0, 0];
    const opsq = op[0] ** 2;
    const oesq = oe[0] ** 2;
    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);
    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);
    const nop = [op[0], 0, lop];
    vtkMath.normalize(nop);
    const noe = [oe[0], 0, loe];
    vtkMath.normalize(noe);
    const dot = vtkMath.dot(nop, noe);
    if (Math.abs(dot) > 1e-4) {
      const angleX = -2 * Math.acos(vtkMath.clampValue(dot, -1, 1)) * Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) * rotateIncrementDegrees;
      const upVec = camera.viewUp;
      const atV = camera.viewPlaneNormal;
      const rightV = [0, 0, 0];
      const forwardV = [0, 0, 0];
      vtkMath.cross(upVec, atV, rightV);
      vtkMath.normalize(rightV);
      vtkMath.cross(atV, rightV, forwardV);
      vtkMath.normalize(forwardV);
      vtkMath.normalize(upVec);
      this.rotateCamera(viewport, centerWorld, forwardV, angleX);
      const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) * rotateIncrementDegrees;
      this.rotateCamera(viewport, centerWorld, rightV, angleY);
      viewport.render();
    }
  }
};
TrackballRotateTool.toolName = "TrackballRotate";
var TrackballRotateTool_default = TrackballRotateTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js
var DEFAULT_MULTIPLIER2 = 4;
var DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;
var PT = "PT";
var WindowLevelTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"]
  }) {
    super(toolProps, defaultToolProps);
    this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {
      const middleSliceIndex = Math.floor(dimensions[2] / 2);
      const frameLength = dimensions[0] * dimensions[1];
      let bytesPerVoxel;
      let TypedArrayConstructor;
      if (scalarData instanceof Float32Array) {
        bytesPerVoxel = 4;
        TypedArrayConstructor = Float32Array;
      } else if (scalarData instanceof Uint8Array) {
        bytesPerVoxel = 1;
        TypedArrayConstructor = Uint8Array;
      } else if (scalarData instanceof Uint16Array) {
        bytesPerVoxel = 2;
        TypedArrayConstructor = Uint16Array;
      } else if (scalarData instanceof Int16Array) {
        bytesPerVoxel = 2;
        TypedArrayConstructor = Int16Array;
      }
      const buffer = scalarData.buffer;
      const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;
      const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);
      const { max: max2, min } = this._getMinMax(frame, frameLength);
      return max2 - min;
    };
  }
  touchDragCallback(evt) {
    this.mouseDragCallback(evt);
  }
  mouseDragCallback(evt) {
    var _a2, _b2;
    const { element, deltaPoints } = evt.detail;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;
    let isPreScaled = false;
    const properties = viewport.getProperties();
    if (viewport instanceof VolumeViewport_default) {
      volumeId = viewport.getVolumeId();
      viewportsContainingVolumeUID = utilities_exports.getViewportsWithVolumeId(volumeId);
      ({ lower, upper } = properties.voiRange);
      const volume = cache_default.getVolume(volumeId);
      if (!volume) {
        throw new Error("Volume not found " + volumeId);
      }
      modality = volume.metadata.Modality;
      isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;
    } else if (properties.voiRange) {
      modality = viewport.modality;
      ({ lower, upper } = properties.voiRange);
      const { preScale = { scaled: false } } = ((_a2 = viewport.getImageData) == null ? void 0 : _a2.call(viewport)) || {};
      isPreScaled = preScale.scaled && ((_b2 = preScale.scalingParameters) == null ? void 0 : _b2.suvbw) !== void 0;
    } else {
      throw new Error("Viewport is not a valid type");
    }
    if (modality === PT && isPreScaled) {
      newRange = this.getPTScaledNewRange({
        deltaPointsCanvas: deltaPoints.canvas,
        lower,
        upper,
        clientHeight: element.clientHeight,
        isPreScaled,
        viewport,
        volumeId
      });
    } else {
      newRange = this.getNewRange({
        viewport,
        deltaPointsCanvas: deltaPoints.canvas,
        volumeId,
        lower,
        upper
      });
    }
    if (newRange.lower >= newRange.upper) {
      return;
    }
    viewport.setProperties({
      voiRange: newRange
    });
    viewport.render();
    if (viewport instanceof VolumeViewport_default) {
      viewportsContainingVolumeUID.forEach((vp) => {
        if (viewport !== vp) {
          vp.render();
        }
      });
      return;
    }
  }
  getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled }) {
    let multiplier = DEFAULT_MULTIPLIER2;
    if (isPreScaled) {
      multiplier = 5 / clientHeight;
    } else {
      multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) || DEFAULT_MULTIPLIER2;
    }
    const deltaY = deltaPointsCanvas[1];
    const wcDelta = deltaY * multiplier;
    upper -= wcDelta;
    upper = isPreScaled ? Math.max(upper, 0.1) : upper;
    return { lower, upper };
  }
  getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {
    const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) || DEFAULT_MULTIPLIER2;
    const wwDelta = deltaPointsCanvas[0] * multiplier;
    const wcDelta = deltaPointsCanvas[1] * multiplier;
    let { windowWidth, windowCenter } = utilities_exports.windowLevel.toWindowLevel(lower, upper);
    windowWidth += wwDelta;
    windowCenter += wcDelta;
    windowWidth = Math.max(windowWidth, 1);
    const voiLutFunction = viewport.getProperties().VOILUTFunction;
    return utilities_exports.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);
  }
  _getMultiplierFromDynamicRange(viewport, volumeId) {
    var _a2;
    let imageDynamicRange;
    if (volumeId) {
      const imageVolume = cache_default.getVolume(volumeId);
      const { voxelManager } = viewport.getImageData();
      const middleSlicePixelData = voxelManager.getMiddleSliceData();
      const calculatedDynamicRange = middleSlicePixelData.reduce((acc, pixel) => {
        return [Math.min(acc[0], pixel), Math.max(acc[1], pixel)];
      }, [Infinity, -Infinity]);
      const BitsStored = (_a2 = imageVolume == null ? void 0 : imageVolume.metadata) == null ? void 0 : _a2.BitsStored;
      const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;
      imageDynamicRange = Math.min(calculatedDynamicRange, metadataDynamicRange);
    } else {
      imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);
    }
    const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;
    return ratio > 1 ? Math.round(ratio) : ratio;
  }
  _getImageDynamicRangeFromViewport(viewport) {
    const { imageData, voxelManager } = viewport.getImageData();
    if (voxelManager == null ? void 0 : voxelManager.getRange) {
      const range3 = voxelManager.getRange();
      return range3[1] - range3[0];
    }
    const dimensions = imageData.getDimensions();
    if (imageData.getRange) {
      const imageDataRange = imageData.getRange();
      return imageDataRange[1] - imageDataRange[0];
    }
    let scalarData;
    if (imageData.getScalarData) {
      scalarData = imageData.getScalarData();
    } else {
      scalarData = imageData.getPointData().getScalars().getData();
    }
    if (dimensions[2] !== 1) {
      return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);
    }
    let range2;
    if (scalarData.getRange) {
      range2 = scalarData.getRange();
    } else {
      const { min, max: max2 } = this._getMinMax(scalarData, scalarData.length);
      range2 = [min, max2];
    }
    return range2[1] - range2[0];
  }
  _getMinMax(frame, frameLength) {
    let min = Infinity;
    let max2 = -Infinity;
    for (let i = 0; i < frameLength; i++) {
      const voxel = frame[i];
      if (voxel < min) {
        min = voxel;
      }
      if (voxel > max2) {
        max2 = voxel;
      }
    }
    return { max: max2, min };
  }
};
WindowLevelTool.toolName = "WindowLevel";
var WindowLevelTool_default = WindowLevelTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js
var WindowLevelRegionTool = class extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      minWindowWidth: 10
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        invalidated: true,
        highlighted: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId
        },
        data: {
          handles: {
            points: [
              [...worldPos],
              [...worldPos],
              [...worldPos],
              [...worldPos]
            ]
          },
          cachedStats: {}
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender
      };
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender } = this.editData;
      this._deactivateDraw(element);
      resetElementCursor(element);
      this.editData = null;
      this.isDrawing = false;
      removeAnnotation(annotation.annotationUID);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      triggerAnnotationCompleted(annotation);
      this.applyWindowLevelRegion(annotation, element);
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender } = this.editData;
      const { data } = annotation;
      const { currentPoints } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
      const worldPos = currentPoints.world;
      const { points } = data.handles;
      const DEFAULT_HANDLE_INDEX = 3;
      points[DEFAULT_HANDLE_INDEX] = [...worldPos];
      const bottomLeftCanvas = worldToCanvas(points[0]);
      const topRightCanvas = worldToCanvas(points[3]);
      const bottomRightCanvas = [
        topRightCanvas[0],
        bottomLeftCanvas[1]
      ];
      const topLeftCanvas = [
        bottomLeftCanvas[0],
        topRightCanvas[1]
      ];
      const bottomRightWorld = canvasToWorld(bottomRightCanvas);
      const topLeftWorld = canvasToWorld(topLeftCanvas);
      points[1] = bottomRightWorld;
      points[2] = topLeftWorld;
      annotation.invalidated = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { points } = data.handles;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth, lineDash } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        const dataId = `${annotationUID}-rect`;
        const rectangleUID = "0";
        drawRect(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
          color,
          lineDash,
          lineWidth
        }, dataId);
        renderStatus = true;
      }
      return renderStatus;
    };
    this.applyWindowLevelRegion = (annotation, element) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const imageData = windowlevel_exports.extractWindowLevelRegionToolData(viewport);
      const { data } = annotation;
      const { points } = data.handles;
      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
      const startCanvas = canvasCoordinates[0];
      const endCanvas = canvasCoordinates[3];
      let left = Math.min(startCanvas[0], endCanvas[0]);
      let top = Math.min(startCanvas[1], endCanvas[1]);
      let width = Math.abs(startCanvas[0] - endCanvas[0]);
      let height = Math.abs(startCanvas[1] - endCanvas[1]);
      left = utilities_exports.clip(left, 0, imageData.width);
      top = utilities_exports.clip(top, 0, imageData.height);
      width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));
      height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));
      const pixelLuminanceData = windowlevel_exports.getLuminanceFromRegion(imageData, Math.round(left), Math.round(top), width, height);
      const minMaxMean = windowlevel_exports.calculateMinMaxMean(pixelLuminanceData, imageData.minPixelValue, imageData.maxPixelValue);
      if (this.configuration.minWindowWidth === void 0) {
        this.configuration.minWindowWidth = 10;
      }
      const windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), this.configuration.minWindowWidth);
      const windowCenter = minMaxMean.mean;
      const voiLutFunction = viewport.getProperties().VOILUTFunction;
      const voiRange = utilities_exports.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);
      viewport.setProperties({ voiRange });
      viewport.render();
    };
    this.cancel = () => {
      return null;
    };
    this.isPointNearTool = () => {
      return null;
    };
    this.toolSelectedCallback = () => {
      return null;
    };
    this.handleSelectedCallback = () => {
      return null;
    };
    this._activateModify = () => {
      return null;
    };
    this._deactivateModify = () => {
      return null;
    };
  }
};
WindowLevelRegionTool.toolName = "WindowLevelRegion";
var WindowLevelRegionTool_default = WindowLevelRegionTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js
var StackScrollTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      invert: false,
      debounceIfNotLoaded: true,
      loop: false
    }
  }) {
    super(toolProps, defaultToolProps);
    this.deltaY = 1;
  }
  mouseWheelCallback(evt) {
    this._scroll(evt);
  }
  mouseDragCallback(evt) {
    this._dragCallback(evt);
  }
  touchDragCallback(evt) {
    this._dragCallback(evt);
  }
  _dragCallback(evt) {
    this._scrollDrag(evt);
  }
  _scrollDrag(evt) {
    const { deltaPoints, viewportId, renderingEngineId } = evt.detail;
    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);
    const { debounceIfNotLoaded, invert, loop } = this.configuration;
    const deltaPointY = deltaPoints.canvas[1];
    let volumeId;
    if (viewport instanceof VolumeViewport_default) {
      volumeId = viewport.getVolumeId();
    }
    const pixelsPerImage = this._getPixelPerImage(viewport);
    const deltaY = deltaPointY + this.deltaY;
    if (!pixelsPerImage) {
      return;
    }
    if (Math.abs(deltaY) >= pixelsPerImage) {
      const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);
      utilities_exports.scroll(viewport, {
        delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,
        volumeId,
        debounceLoading: debounceIfNotLoaded,
        loop
      });
      this.deltaY = deltaY % pixelsPerImage;
    } else {
      this.deltaY = deltaY;
    }
  }
  _scroll(evt) {
    const { wheel, element } = evt.detail;
    const { direction } = wheel;
    const { invert } = this.configuration;
    const { viewport } = getEnabledElement(element);
    const delta = direction * (invert ? -1 : 1);
    utilities_exports.scroll(viewport, {
      delta,
      debounceLoading: this.configuration.debounceIfNotLoaded,
      loop: this.configuration.loop,
      volumeId: viewport instanceof BaseVolumeViewport_default ? viewport.getVolumeId() : void 0,
      scrollSlabs: this.configuration.scrollSlabs
    });
  }
  _getPixelPerImage(viewport) {
    const { element } = viewport;
    const numberOfSlices = viewport.getNumberOfSlices();
    return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));
  }
};
StackScrollTool.toolName = "StackScroll";
var StackScrollTool_default = StackScrollTool;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js
function angleBetween3DLines(line1, line2) {
  const [p1, p2] = line1;
  const [p3, p4] = line2;
  const v1 = vec3_exports.sub(vec3_exports.create(), p2, p1);
  const v2 = vec3_exports.sub(vec3_exports.create(), p3, p4);
  const dot = vec3_exports.dot(v1, v2);
  const v1Length = vec3_exports.length(v1);
  const v2Length = vec3_exports.length(v2);
  const cos = dot / (v1Length * v2Length);
  const radian = Math.acos(cos);
  return radian * 180 / Math.PI;
}
function angleBetween2DLines(line1, line2) {
  const [p1, p2] = line1;
  const [p3, p4] = line2;
  const v1 = vec2_exports.sub(vec2_exports.create(), p2, p1);
  const v2 = vec2_exports.sub(vec2_exports.create(), p3, p4);
  const dot = vec2_exports.dot(v1, v2);
  const v1Length = vec2_exports.length(v1);
  const v2Length = vec2_exports.length(v2);
  const cos = dot / (v1Length * v2Length);
  return Math.acos(cos) * (180 / Math.PI);
}
function angleBetweenLines(line1, line2) {
  const is3D = line1[0].length === 3;
  return is3D ? angleBetween3DLines(line1, line2) : angleBetween2DLines(line1, line2);
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js
var PlanarRotateTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"]
  }) {
    super(toolProps, defaultToolProps);
    this.mouseWheelCallback = (evt) => {
      const { element, wheel } = evt.detail;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { invert } = this.configuration;
      const angle = wheel.direction * 10 * (invert ? -1 : 1);
      this.setAngle(viewport, angle);
    };
    this.touchDragCallback = this._dragCallback.bind(this);
    this.mouseDragCallback = this._dragCallback.bind(this);
  }
  _dragCallback(evt) {
    const { element, currentPoints, startPoints } = evt.detail;
    const currentPointWorld = currentPoints.world;
    const startPointWorld = startPoints.world;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const camera = viewport.getCamera();
    const width = element.clientWidth;
    const height = element.clientHeight;
    const centerCanvas = [width * 0.5, height * 0.5];
    const centerWorld = viewport.canvasToWorld(centerCanvas);
    let angle = angleBetweenLines([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);
    const { viewPlaneNormal } = camera;
    const v1 = vec3_exports.sub(vec3_exports.create(), centerWorld, startPointWorld);
    const v2 = vec3_exports.sub(vec3_exports.create(), centerWorld, currentPointWorld);
    const cross = vec3_exports.cross(vec3_exports.create(), v1, v2);
    if (vec3_exports.dot(viewPlaneNormal, cross) > 0) {
      angle = -angle;
    }
    if (Number.isNaN(angle)) {
      return;
    }
    this.setAngle(viewport, angle);
  }
  setAngle(viewport, angle) {
    const { viewPlaneNormal, viewUp } = viewport.getCamera();
    if (viewport instanceof BaseVolumeViewport_default) {
      const rotAngle = (angle + 360) % 360 * Math.PI / 180;
      const rotMat = mat4_exports.identity(new Float32Array(16));
      mat4_exports.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);
      const rotatedViewUp = vec3_exports.transformMat4(vec3_exports.create(), viewUp, rotMat);
      viewport.setCamera({ viewUp: rotatedViewUp });
    } else {
      const { rotation } = viewport.getViewPresentation();
      viewport.setViewPresentation({
        rotation: (rotation + angle + 360) % 360
      });
    }
    viewport.render();
  }
};
PlanarRotateTool.toolName = "PlanarRotate";
var PlanarRotateTool_default = PlanarRotateTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js
var ZoomTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      zoomToCenter: false,
      minZoomScale: 1e-3,
      maxZoomScale: 3e3,
      pinchToZoom: true,
      pan: true,
      invert: false
    }
  }) {
    super(toolProps, defaultToolProps);
    this.preMouseDownCallback = (evt) => {
      const eventData = evt.detail;
      const { element, currentPoints } = eventData;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const camera = enabledElement.viewport.getCamera();
      const { focalPoint } = camera;
      this.initialMousePosWorld = worldPos;
      let dirVec = vec3_exports.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);
      dirVec = vec3_exports.normalize(vec3_exports.create(), dirVec);
      this.dirVec = dirVec;
      return false;
    };
    this.preTouchStartCallback = (evt) => {
      if (!this.configuration.pinchToZoom) {
        return this.preMouseDownCallback(evt);
      }
    };
    this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {
      const { element, deltaPoints } = evt.detail;
      const deltaY = pinch ? evt.detail.deltaDistance.canvas : deltaPoints.canvas[1];
      const size = [element.clientWidth, element.clientHeight];
      const { parallelScale, focalPoint, position } = camera;
      const zoomScale = 5 / size[1];
      const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);
      const parallelScaleToSet = (1 - k) * parallelScale;
      let focalPointToSet = focalPoint;
      let positionToSet = position;
      if (!this.configuration.zoomToCenter) {
        const distanceToCanvasCenter = vec3_exports.distance(focalPoint, this.initialMousePosWorld);
        positionToSet = vec3_exports.scaleAndAdd(vec3_exports.create(), position, this.dirVec, -distanceToCanvasCenter * k);
        focalPointToSet = vec3_exports.scaleAndAdd(vec3_exports.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);
      }
      const imageData = viewport.getImageData();
      let spacing = [1, 1, 1];
      if (imageData) {
        spacing = imageData.spacing;
      }
      const { minZoomScale, maxZoomScale } = this.configuration;
      const t = element.clientHeight * spacing[1] * 0.5;
      const scale = t / parallelScaleToSet;
      let cappedParallelScale = parallelScaleToSet;
      let thresholdExceeded = false;
      if (imageData) {
        if (scale < minZoomScale) {
          cappedParallelScale = t / minZoomScale;
          thresholdExceeded = true;
        } else if (scale >= maxZoomScale) {
          cappedParallelScale = t / maxZoomScale;
          thresholdExceeded = true;
        }
      }
      viewport.setCamera({
        parallelScale: cappedParallelScale,
        focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,
        position: thresholdExceeded ? position : positionToSet
      });
    };
    this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {
      const { element, deltaPoints } = evt.detail;
      const deltaY = pinch ? evt.detail.deltaDistance.canvas : deltaPoints.canvas[1];
      const size = [element.clientWidth, element.clientHeight];
      const { position, focalPoint, viewPlaneNormal } = camera;
      const distance = vtkMath.distance2BetweenPoints(position, focalPoint);
      const zoomScale = Math.sqrt(distance) / size[1];
      const directionOfProjection = [
        -viewPlaneNormal[0],
        -viewPlaneNormal[1],
        -viewPlaneNormal[2]
      ];
      const k = this.configuration.invert ? deltaY / zoomScale : deltaY * zoomScale;
      let tmp = k * directionOfProjection[0];
      position[0] += tmp;
      focalPoint[0] += tmp;
      tmp = k * directionOfProjection[1];
      position[1] += tmp;
      focalPoint[1] += tmp;
      tmp = k * directionOfProjection[2];
      position[2] += tmp;
      focalPoint[2] += tmp;
      viewport.setCamera({ position, focalPoint });
    };
    this.initialMousePosWorld = [0, 0, 0];
    this.dirVec = [0, 0, 0];
    if (this.configuration.pinchToZoom) {
      this.touchDragCallback = this._pinchCallback.bind(this);
    } else {
      this.touchDragCallback = this._dragCallback.bind(this);
    }
    this.mouseDragCallback = this._dragCallback.bind(this);
  }
  _pinchCallback(evt) {
    const pointsList = evt.detail.currentPointsList;
    if (pointsList.length > 1) {
      const { element, currentPoints } = evt.detail;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const camera = viewport.getCamera();
      const worldPos = currentPoints.world;
      const { focalPoint } = camera;
      this.initialMousePosWorld = worldPos;
      let dirVec = vec3_exports.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);
      dirVec = vec3_exports.normalize(vec3_exports.create(), dirVec);
      this.dirVec = dirVec;
      if (camera.parallelProjection) {
        this._dragParallelProjection(evt, viewport, camera, true);
      } else {
        this._dragPerspectiveProjection(evt, viewport, camera, true);
      }
      viewport.render();
    }
    if (this.configuration.pan) {
      this._panCallback(evt);
    }
  }
  _dragCallback(evt) {
    const { element } = evt.detail;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const camera = viewport.getCamera();
    if (camera.parallelProjection) {
      this._dragParallelProjection(evt, viewport, camera);
    } else {
      this._dragPerspectiveProjection(evt, viewport, camera);
    }
    viewport.render();
  }
  _panCallback(evt) {
    const { element, deltaPoints } = evt.detail;
    const enabledElement = getEnabledElement(element);
    const deltaPointsWorld = deltaPoints.world;
    const camera = enabledElement.viewport.getCamera();
    const { focalPoint, position } = camera;
    const updatedPosition = [
      position[0] - deltaPointsWorld[0],
      position[1] - deltaPointsWorld[1],
      position[2] - deltaPointsWorld[2]
    ];
    const updatedFocalPoint = [
      focalPoint[0] - deltaPointsWorld[0],
      focalPoint[1] - deltaPointsWorld[1],
      focalPoint[2] - deltaPointsWorld[2]
    ];
    enabledElement.viewport.setCamera({
      focalPoint: updatedFocalPoint,
      position: updatedPosition
    });
    enabledElement.viewport.render();
  }
};
ZoomTool.toolName = "Zoom";
var ZoomTool_default = ZoomTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js
var MIPJumpToClickTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      targetViewportIds: []
    }
  }) {
    super(toolProps, defaultToolProps);
  }
  mouseClickCallback(evt) {
    const { element, currentPoints } = evt.detail;
    const enabledElement = getEnabledElement(element);
    const { viewport, renderingEngine } = enabledElement;
    const volumeId = viewport.getVolumeId();
    if (!volumeId) {
      throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);
    }
    let maxIntensity = -Infinity;
    const maxFn = (intensity, point) => {
      if (intensity > maxIntensity) {
        maxIntensity = intensity;
        return point;
      }
    };
    const brightestPoint = getPointInLineOfSightWithCriteria(viewport, currentPoints.world, volumeId, maxFn);
    if (!brightestPoint || !brightestPoint.length) {
      return;
    }
    const { targetViewportIds, toolGroupId } = this.configuration;
    const viewports = renderingEngine.getViewports().filter((vp) => {
      if ((targetViewportIds == null ? void 0 : targetViewportIds.indexOf(vp.id)) >= 0) {
        return true;
      }
      const foundToolGroup = getToolGroupForViewport_default(vp.id, renderingEngine.id);
      if (toolGroupId && toolGroupId === (foundToolGroup == null ? void 0 : foundToolGroup.id)) {
        return true;
      }
      return false;
    });
    viewports.forEach((viewport2) => {
      if (viewport2 instanceof VolumeViewport_default) {
        viewport2.jumpToWorld(brightestPoint);
      } else {
        console.warn("Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport");
      }
    });
  }
};
MIPJumpToClickTool.toolName = "MIPJumpToClickTool";
var MIPJumpToClickTool_default = MIPJumpToClickTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js
var { RENDERING_DEFAULTS } = constants_exports;
function defaultReferenceLineColor() {
  return "rgb(0, 200, 0)";
}
function defaultReferenceLineControllable() {
  return true;
}
function defaultReferenceLineDraggableRotatable() {
  return true;
}
function defaultReferenceLineSlabThicknessControlsOn() {
  return true;
}
var OPERATION = {
  DRAG: 1,
  ROTATE: 2,
  SLAB: 3
};
var CrosshairsTool = class extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse"],
    configuration: {
      shadow: true,
      viewportIndicators: false,
      viewportIndicatorsConfig: {
        radius: 5,
        x: null,
        y: null
      },
      autoPan: {
        enabled: false,
        panSize: 10
      },
      referenceLinesCenterGapRadius: 20,
      filterActorUIDsToSetSlabThickness: [],
      slabThicknessBlendMode: enums_exports.BlendModes.MAXIMUM_INTENSITY_BLEND,
      mobile: {
        enabled: false,
        opacity: 0.8,
        handleRadius: 9
      }
    }
  }) {
    var _a2, _b2, _c, _d;
    super(toolProps, defaultToolProps);
    this.toolCenter = [0, 0, 0];
    this.initializeViewport = ({ renderingEngineId, viewportId }) => {
      const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);
      const { FrameOfReferenceUID, viewport } = enabledElement;
      const { element } = viewport;
      const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();
      let annotations = this._getAnnotations(enabledElement);
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (annotations == null ? void 0 : annotations.length) {
        removeAnnotation(annotations[0].annotationUID);
      }
      const annotation = {
        highlighted: false,
        metadata: {
          cameraPosition: [...position],
          cameraFocalPoint: [...focalPoint],
          FrameOfReferenceUID,
          toolName: this.getToolName()
        },
        data: {
          handles: {
            rotationPoints: [],
            slabThicknessPoints: [],
            toolCenter: this.toolCenter
          },
          activeOperation: null,
          activeViewportIds: [],
          viewportId
        }
      };
      addAnnotation(annotation, element);
      return {
        normal: viewPlaneNormal,
        point: viewport.canvasToWorld([
          viewport.canvas.clientWidth / 2,
          viewport.canvas.clientHeight / 2
        ])
      };
    };
    this._getViewportsInfo = () => {
      const viewports = getToolGroup_default(this.toolGroupId).viewportsInfo;
      return viewports;
    };
    this.resetCrosshairs = () => {
      const viewportsInfo = this._getViewportsInfo();
      for (const viewportInfo of viewportsInfo) {
        const { viewportId, renderingEngineId } = viewportInfo;
        const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);
        const viewport = enabledElement.viewport;
        const resetPan = true;
        const resetZoom = true;
        const resetToCenter = true;
        const resetRotation = true;
        const suppressEvents = true;
        viewport.resetCamera({
          resetPan,
          resetZoom,
          resetToCenter,
          resetRotation,
          suppressEvents
        });
        viewport.resetSlabThickness();
        const { element } = viewport;
        let annotations = this._getAnnotations(enabledElement);
        annotations = this.filterInteractableAnnotationsForElement(element, annotations);
        if (annotations.length) {
          removeAnnotation(annotations[0].annotationUID);
        }
        viewport.render();
      }
      this._computeToolCenter(viewportsInfo);
    };
    this.computeToolCenter = () => {
      const viewportsInfo = this._getViewportsInfo();
      this._computeToolCenter(viewportsInfo);
    };
    this._computeToolCenter = (viewportsInfo) => {
      if (!viewportsInfo.length || viewportsInfo.length === 1) {
        console.warn("For crosshairs to operate, at least two viewports must be given.");
        return;
      }
      const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;
      const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);
      const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);
      let normal3 = [0, 0, 0];
      let point3 = vec3_exports.create();
      if (thirdViewport) {
        ({ normal: normal3, point: point3 } = this.initializeViewport(thirdViewport));
      } else {
        vec3_exports.add(point3, point1, point2);
        vec3_exports.scale(point3, point3, 0.5);
        vec3_exports.cross(normal3, normal1, normal2);
      }
      const firstPlane = utilities_exports.planar.planeEquation(normal1, point1);
      const secondPlane = utilities_exports.planar.planeEquation(normal2, point2);
      const thirdPlane = utilities_exports.planar.planeEquation(normal3, point3);
      this.toolCenter = utilities_exports.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);
      triggerAnnotationRenderForViewportIds_default(viewportsInfo.map(({ viewportId }) => viewportId));
    };
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { currentPoints } = eventDetail;
      const jumpWorld = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      this._jump(enabledElement, jumpWorld);
      const annotations = this._getAnnotations(enabledElement);
      const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);
      const { data } = filteredAnnotations[0];
      const { rotationPoints } = data.handles;
      const viewportIdArray = [];
      for (let i = 0; i < rotationPoints.length - 1; ++i) {
        const otherViewport = rotationPoints[i][1];
        const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
        if (!viewportControllable || !viewportDraggableRotatable) {
          continue;
        }
        viewportIdArray.push(otherViewport.id);
        i++;
      }
      data.activeViewportIds = [...viewportIdArray];
      data.handles.activeOperation = OPERATION.DRAG;
      evt.preventDefault();
      hideElementCursor(element);
      this._activateModify(element);
      return filteredAnnotations[0];
    };
    this.cancel = () => {
      console.log("Not implemented yet");
    };
    this.handleSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      this._activateModify(element);
      hideElementCursor(element);
      evt.preventDefault();
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      if (this._pointNearTool(element, annotation, canvasCoords, 6)) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation, interactionType) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      this._activateModify(element);
      hideElementCursor(element);
      evt.preventDefault();
    };
    this.onCameraModified = (evt) => {
      var _a3;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      const viewport = enabledElement.viewport;
      const annotations = this._getAnnotations(enabledElement);
      const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
      const viewportAnnotation = filteredToolAnnotations[0];
      if (!viewportAnnotation) {
        return;
      }
      const currentCamera = viewport.getCamera();
      const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;
      const deltaCameraPosition = [0, 0, 0];
      vtkMath.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);
      const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;
      const deltaCameraFocalPoint = [0, 0, 0];
      vtkMath.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);
      viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];
      viewportAnnotation.metadata.cameraFocalPoint = [
        ...currentCamera.focalPoint
      ];
      const viewportControllable = this._getReferenceLineControllable(viewport.id);
      const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);
      if (!utilities_exports.isEqual(currentCamera.position, oldCameraPosition, 1e-3) && viewportControllable && viewportDraggableRotatable) {
        let isRotation = false;
        const cameraModifiedSameForPosAndFocalPoint = utilities_exports.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);
        if (!cameraModifiedSameForPosAndFocalPoint) {
          isRotation = true;
        }
        const cameraModifiedInPlane = Math.abs(vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 0.01;
        if (!isRotation && !cameraModifiedInPlane) {
          this.toolCenter[0] += deltaCameraPosition[0];
          this.toolCenter[1] += deltaCameraPosition[1];
          this.toolCenter[2] += deltaCameraPosition[2];
        }
      }
      if ((_a3 = this.configuration.autoPan) == null ? void 0 : _a3.enabled) {
        const toolGroup = getToolGroupForViewport_default(viewport.id, renderingEngine.id);
        const otherViewportIds = toolGroup.getViewportIds().filter((id) => id !== viewport.id);
        otherViewportIds.forEach((viewportId) => {
          this._autoPanViewportIfNecessary(viewportId, renderingEngine);
        });
      }
      const requireSameOrientation = false;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.onResetCamera = (evt) => {
      this.resetCrosshairs();
    };
    this.mouseMoveCallback = (evt, filteredToolAnnotations) => {
      const { element, currentPoints } = evt.detail;
      const canvasCoords = currentPoints.canvas;
      let imageNeedsUpdate = false;
      for (let i = 0; i < filteredToolAnnotations.length; i++) {
        const annotation = filteredToolAnnotations[i];
        if (isAnnotationLocked(annotation.annotationUID)) {
          continue;
        }
        const { data, highlighted } = annotation;
        if (!data.handles) {
          continue;
        }
        const previousActiveOperation = data.handles.activeOperation;
        const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0 ? [...data.activeViewportIds] : [];
        data.activeViewportIds = [];
        data.handles.activeOperation = null;
        const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);
        let near = false;
        if (handleNearImagePoint) {
          near = true;
        } else {
          near = this._pointNearTool(element, annotation, canvasCoords, 6);
        }
        const nearToolAndNotMarkedActive = near && !highlighted;
        const notNearToolAndMarkedActive = !near && highlighted;
        if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {
          annotation.highlighted = !highlighted;
          imageNeedsUpdate = true;
        } else if (data.handles.activeOperation !== previousActiveOperation || !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {
          imageNeedsUpdate = true;
        }
      }
      return imageNeedsUpdate;
    };
    this.filterInteractableAnnotationsForElement = (element, annotations) => {
      if (!annotations || !annotations.length) {
        return [];
      }
      const enabledElement = getEnabledElement(element);
      const { viewportId } = enabledElement;
      const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);
      return viewportUIDSpecificCrosshairs;
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport, renderingEngine } = enabledElement;
      const { element } = viewport;
      const annotations = this._getAnnotations(enabledElement);
      const camera = viewport.getCamera();
      const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
      const viewportAnnotation = filteredToolAnnotations[0];
      if (!(annotations == null ? void 0 : annotations.length) || !(viewportAnnotation == null ? void 0 : viewportAnnotation.data)) {
        return renderStatus;
      }
      const annotationUID = viewportAnnotation.annotationUID;
      const { clientWidth, clientHeight } = viewport.canvas;
      const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
      const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);
      const data = viewportAnnotation.data;
      const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);
      const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);
      const referenceLines = [];
      const canvasBox = [0, 0, clientWidth, clientHeight];
      otherViewportAnnotations.forEach((annotation) => {
        const { data: data2 } = annotation;
        data2.handles.toolCenter = this.toolCenter;
        const otherViewport = renderingEngine.getViewport(data2.viewportId);
        const otherCamera = otherViewport.getCamera();
        const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
        const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
        const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
        const { clientWidth: clientWidth2, clientHeight: clientHeight2 } = otherViewport.canvas;
        const otherCanvasDiagonalLength = Math.sqrt(clientWidth2 * clientWidth2 + clientHeight2 * clientHeight2);
        const otherCanvasCenter = [
          clientWidth2 * 0.5,
          clientHeight2 * 0.5
        ];
        const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);
        const direction = [0, 0, 0];
        vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);
        vtkMath.normalize(direction);
        vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);
        const pointWorld0 = [0, 0, 0];
        vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);
        const pointWorld1 = [0, 0, 0];
        vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);
        const pointCanvas0 = viewport.worldToCanvas(pointWorld0);
        const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);
        const canvasUnitVectorFromCenter = vec2_exports.create();
        vec2_exports.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);
        vec2_exports.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
        const canvasVectorFromCenterLong = vec2_exports.create();
        vec2_exports.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);
        const canvasVectorFromCenterMid = vec2_exports.create();
        vec2_exports.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);
        const canvasVectorFromCenterShort = vec2_exports.create();
        vec2_exports.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);
        const canvasVectorFromCenterStart = vec2_exports.create();
        const centerGap = this.configuration.referenceLinesCenterGapRadius;
        vec2_exports.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);
        const refLinePointOne = vec2_exports.create();
        const refLinePointTwo = vec2_exports.create();
        const refLinePointThree = vec2_exports.create();
        const refLinePointFour = vec2_exports.create();
        let refLinesCenter = vec2_exports.clone(crosshairCenterCanvas);
        if (!otherViewportDraggableRotatable || !otherViewportControllable) {
          refLinesCenter = vec2_exports.clone(otherViewportCenterCanvas);
        }
        vec2_exports.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);
        vec2_exports.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);
        vec2_exports.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);
        vec2_exports.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);
        clip(refLinePointOne, refLinePointTwo, canvasBox);
        clip(refLinePointThree, refLinePointFour, canvasBox);
        const rotHandleOne = vec2_exports.create();
        vec2_exports.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);
        const rotHandleTwo = vec2_exports.create();
        vec2_exports.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);
        let stHandlesCenterCanvas = vec2_exports.clone(crosshairCenterCanvas);
        if (!otherViewportDraggableRotatable && otherViewportSlabThicknessControlsOn) {
          stHandlesCenterCanvas = vec2_exports.clone(otherViewportCenterCanvas);
        }
        let stHandlesCenterWorld = [...this.toolCenter];
        if (!otherViewportDraggableRotatable && otherViewportSlabThicknessControlsOn) {
          stHandlesCenterWorld = [...otherViewportCenterWorld];
        }
        const worldUnitVectorFromCenter = [0, 0, 0];
        vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);
        vtkMath.normalize(worldUnitVectorFromCenter);
        const { viewPlaneNormal } = camera;
        const { matrix } = vtkMatrixBuilder.buildFromDegree().rotate(90, viewPlaneNormal);
        const worldUnitOrthoVectorFromCenter = [0, 0, 0];
        vec3_exports.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);
        const slabThicknessValue = otherViewport.getSlabThickness();
        const worldOrthoVectorFromCenter = [
          ...worldUnitOrthoVectorFromCenter
        ];
        vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);
        const worldVerticalRefPoint = [0, 0, 0];
        vtkMath.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);
        const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);
        const canvasOrthoVectorFromCenter = vec2_exports.create();
        vec2_exports.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);
        const stLinePointOne = vec2_exports.create();
        vec2_exports.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);
        vec2_exports.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);
        const stLinePointTwo = vec2_exports.create();
        vec2_exports.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);
        vec2_exports.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);
        clip(stLinePointOne, stLinePointTwo, canvasBox);
        const stLinePointThree = vec2_exports.create();
        vec2_exports.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);
        vec2_exports.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);
        const stLinePointFour = vec2_exports.create();
        vec2_exports.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);
        vec2_exports.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);
        clip(stLinePointThree, stLinePointFour, canvasBox);
        const stHandleOne = vec2_exports.create();
        const stHandleTwo = vec2_exports.create();
        const stHandleThree = vec2_exports.create();
        const stHandleFour = vec2_exports.create();
        vec2_exports.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);
        vec2_exports.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);
        vec2_exports.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);
        vec2_exports.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);
        vec2_exports.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);
        vec2_exports.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);
        vec2_exports.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);
        vec2_exports.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);
        referenceLines.push([
          otherViewport,
          refLinePointOne,
          refLinePointTwo,
          refLinePointThree,
          refLinePointFour,
          stLinePointOne,
          stLinePointTwo,
          stLinePointThree,
          stLinePointFour,
          rotHandleOne,
          rotHandleTwo,
          stHandleOne,
          stHandleTwo,
          stHandleThree,
          stHandleFour
        ]);
      });
      const newRtpoints = [];
      const newStpoints = [];
      const viewportColor = this._getReferenceLineColor(viewport.id);
      const color = viewportColor !== void 0 ? viewportColor : "rgb(200, 200, 200)";
      referenceLines.forEach((line, lineIndex) => {
        var _a3, _b3, _c2, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
        const otherViewport = line[0];
        const viewportColor2 = this._getReferenceLineColor(otherViewport.id);
        const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) || ((_a3 = this.configuration.mobile) == null ? void 0 : _a3.enabled);
        const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) || ((_b3 = this.configuration.mobile) == null ? void 0 : _b3.enabled);
        const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);
        let color2 = viewportColor2 !== void 0 ? viewportColor2 : "rgb(200, 200, 200)";
        let lineWidth = 1;
        const lineActive = data.handles.activeOperation !== null && data.handles.activeOperation === OPERATION.DRAG && selectedViewportId;
        if (lineActive) {
          lineWidth = 2.5;
        }
        let lineUID = `${lineIndex}`;
        if (viewportControllable && viewportDraggableRotatable) {
          lineUID = `${lineIndex}One`;
          drawLine(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {
            color: color2,
            lineWidth
          });
          lineUID = `${lineIndex}Two`;
          drawLine(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {
            color: color2,
            lineWidth
          });
        } else {
          drawLine(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {
            color: color2,
            lineWidth
          });
        }
        if (viewportControllable) {
          color2 = viewportColor2 !== void 0 ? viewportColor2 : "rgb(200, 200, 200)";
          const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;
          const rotationHandles = [line[9], line[10]];
          const rotHandleWorldOne = [
            viewport.canvasToWorld(line[9]),
            otherViewport,
            line[1],
            line[2]
          ];
          const rotHandleWorldTwo = [
            viewport.canvasToWorld(line[10]),
            otherViewport,
            line[3],
            line[4]
          ];
          newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);
          const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;
          const slabThicknessHandles = [line[11], line[12], line[13], line[14]];
          const slabThicknessHandleWorldOne = [
            viewport.canvasToWorld(line[11]),
            otherViewport,
            line[5],
            line[6]
          ];
          const slabThicknessHandleWorldTwo = [
            viewport.canvasToWorld(line[12]),
            otherViewport,
            line[5],
            line[6]
          ];
          const slabThicknessHandleWorldThree = [
            viewport.canvasToWorld(line[13]),
            otherViewport,
            line[7],
            line[8]
          ];
          const slabThicknessHandleWorldFour = [
            viewport.canvasToWorld(line[14]),
            otherViewport,
            line[7],
            line[8]
          ];
          newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);
          if ((lineActive || ((_c2 = this.configuration.mobile) == null ? void 0 : _c2.enabled)) && !rotHandlesActive && !slabThicknessHandlesActive && viewportDraggableRotatable && viewportSlabThicknessControlsOn) {
            let handleUID = `${lineIndex}One`;
            drawHandles_default(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
              color: color2,
              handleRadius: ((_d2 = this.configuration.mobile) == null ? void 0 : _d2.enabled) ? (_e = this.configuration.mobile) == null ? void 0 : _e.handleRadius : 3,
              opacity: ((_f = this.configuration.mobile) == null ? void 0 : _f.enabled) ? (_g = this.configuration.mobile) == null ? void 0 : _g.opacity : 1,
              type: "circle"
            });
            handleUID = `${lineIndex}Two`;
            drawHandles_default(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
              color: color2,
              handleRadius: ((_h = this.configuration.mobile) == null ? void 0 : _h.enabled) ? (_i = this.configuration.mobile) == null ? void 0 : _i.handleRadius : 3,
              opacity: ((_j = this.configuration.mobile) == null ? void 0 : _j.enabled) ? (_k = this.configuration.mobile) == null ? void 0 : _k.opacity : 1,
              type: "rect"
            });
          } else if (lineActive && !rotHandlesActive && !slabThicknessHandlesActive && viewportDraggableRotatable) {
            const handleUID = `${lineIndex}`;
            drawHandles_default(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
              color: color2,
              handleRadius: ((_l = this.configuration.mobile) == null ? void 0 : _l.enabled) ? (_m = this.configuration.mobile) == null ? void 0 : _m.handleRadius : 3,
              opacity: ((_n = this.configuration.mobile) == null ? void 0 : _n.enabled) ? (_o = this.configuration.mobile) == null ? void 0 : _o.opacity : 1,
              type: "circle"
            });
          } else if (selectedViewportId && !rotHandlesActive && !slabThicknessHandlesActive && viewportSlabThicknessControlsOn) {
            const handleUID = `${lineIndex}`;
            drawHandles_default(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
              color: color2,
              handleRadius: ((_p = this.configuration.mobile) == null ? void 0 : _p.enabled) ? (_q = this.configuration.mobile) == null ? void 0 : _q.handleRadius : 3,
              opacity: ((_r = this.configuration.mobile) == null ? void 0 : _r.enabled) ? (_s = this.configuration.mobile) == null ? void 0 : _s.opacity : 1,
              type: "rect"
            });
          } else if (rotHandlesActive && viewportDraggableRotatable) {
            const handleUID = `${lineIndex}`;
            drawHandles_default(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
              color: color2,
              handleRadius: 2,
              fill: color2,
              type: "circle"
            });
          } else if (slabThicknessHandlesActive && selectedViewportId && viewportSlabThicknessControlsOn) {
            drawHandles_default(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {
              color: color2,
              handleRadius: 2,
              fill: color2,
              type: "rect"
            });
          }
          const slabThicknessValue = otherViewport.getSlabThickness();
          if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {
            lineUID = `${lineIndex}STOne`;
            drawLine(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {
              color: color2,
              width: 1,
              lineDash: [2, 3]
            });
            lineUID = `${lineIndex}STTwo`;
            drawLine(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {
              color: color2,
              width: line,
              lineDash: [2, 3]
            });
          }
        }
      });
      renderStatus = true;
      data.handles.rotationPoints = newRtpoints;
      data.handles.slabThicknessPoints = newStpoints;
      if (this.configuration.viewportIndicators) {
        const { viewportIndicatorsConfig } = this.configuration;
        const xOffset = (viewportIndicatorsConfig == null ? void 0 : viewportIndicatorsConfig.xOffset) || 0.95;
        const yOffset = (viewportIndicatorsConfig == null ? void 0 : viewportIndicatorsConfig.yOffset) || 0.05;
        const referenceColorCoordinates = [
          clientWidth * xOffset,
          clientHeight * yOffset
        ];
        const circleRadius = (viewportIndicatorsConfig == null ? void 0 : viewportIndicatorsConfig.circleRadius) || canvasDiagonalLength * 0.01;
        const circleUID = "0";
        drawCircle_default(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });
      }
      return renderStatus;
    };
    this._getAnnotations = (enabledElement) => {
      const { viewport } = enabledElement;
      const annotations = getAnnotations(this.getToolName(), viewport.element) || [];
      const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);
      const toolGroupAnnotations = annotations.filter((annotation) => {
        const { data } = annotation;
        return viewportIds.includes(data.viewportId);
      });
      return toolGroupAnnotations;
    };
    this._onNewVolume = () => {
      const viewportsInfo = this._getViewportsInfo();
      this._computeToolCenter(viewportsInfo);
    };
    this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {
      if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {
        return false;
      }
      viewportIdArrayOne.forEach((id) => {
        let itemFound = false;
        for (let i = 0; i < viewportIdArrayTwo.length; ++i) {
          if (id === viewportIdArrayTwo[i]) {
            itemFound = true;
            break;
          }
        }
        if (itemFound === false) {
          return false;
        }
      });
      return true;
    };
    this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {
      const { viewportId, renderingEngine, viewport } = enabledElement;
      const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);
      if (!otherViewportAnnotations || !otherViewportAnnotations.length) {
        return [];
      }
      const camera = viewport.getCamera();
      const { viewPlaneNormal, position } = camera;
      const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {
        const { viewportId: viewportId2 } = annotation.data;
        const targetViewport = renderingEngine.getViewport(viewportId2);
        const cameraOfTarget = targetViewport.getCamera();
        return !(utilities_exports.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 0.01) && utilities_exports.isEqual(cameraOfTarget.position, position, 1));
      });
      return viewportsWithDifferentCameras;
    };
    this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {
      const { renderingEngine } = enabledElement;
      const { data } = referenceAnnotation;
      const viewport = renderingEngine.getViewport(data.viewportId);
      const linkedViewportAnnotations = annotations.filter((annotation) => {
        const { data: data2 } = annotation;
        const otherViewport = renderingEngine.getViewport(data2.viewportId);
        const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
        return otherViewportControllable === true;
      });
      if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {
        return [];
      }
      const camera = viewport.getCamera();
      const viewPlaneNormal = camera.viewPlaneNormal;
      vtkMath.normalize(viewPlaneNormal);
      const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {
        const { viewportId } = annotation.data;
        const otherViewport = renderingEngine.getViewport(viewportId);
        const otherCamera = otherViewport.getCamera();
        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
        vtkMath.normalize(otherViewPlaneNormal);
        return utilities_exports.isEqual(viewPlaneNormal, otherViewPlaneNormal, 0.01) && utilities_exports.isEqual(camera.viewUp, otherCamera.viewUp, 0.01);
      });
      return otherViewportsAnnotationsWithSameCameraDirection;
    };
    this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {
      const { renderingEngine, viewport } = enabledElement;
      const camera = viewport.getCamera();
      const viewPlaneNormal = camera.viewPlaneNormal;
      vtkMath.normalize(viewPlaneNormal);
      const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
        const { data } = annotation;
        const otherViewport = renderingEngine.getViewport(data.viewportId);
        const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
        return viewport !== otherViewport && otherViewportControllable === true;
      });
      const otherViewportsAnnotationsWithUniqueCameras = [];
      for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {
        const annotation = otherLinkedViewportAnnotationsFromSameScene[i];
        const { viewportId } = annotation.data;
        const otherViewport = renderingEngine.getViewport(viewportId);
        const otherCamera = otherViewport.getCamera();
        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
        vtkMath.normalize(otherViewPlaneNormal);
        if (utilities_exports.isEqual(viewPlaneNormal, otherViewPlaneNormal, 0.01) || utilities_exports.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 0.01)) {
          continue;
        }
        let cameraFound = false;
        for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
          const annotation2 = otherViewportsAnnotationsWithUniqueCameras[jj];
          const { viewportId: viewportId2 } = annotation2.data;
          const stockedViewport = renderingEngine.getViewport(viewportId2);
          const cameraOfStocked = stockedViewport.getCamera();
          if (utilities_exports.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 0.01) && utilities_exports.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
            cameraFound = true;
          }
        }
        if (!cameraFound) {
          otherViewportsAnnotationsWithUniqueCameras.push(annotation);
        }
      }
      const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
        const { data } = annotation;
        const otherViewport = renderingEngine.getViewport(data.viewportId);
        const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
        return viewport !== otherViewport && otherViewportControllable !== true;
      });
      for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {
        const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];
        const { viewportId } = annotation.data;
        const otherViewport = renderingEngine.getViewport(viewportId);
        const otherCamera = otherViewport.getCamera();
        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
        vtkMath.normalize(otherViewPlaneNormal);
        if (utilities_exports.isEqual(viewPlaneNormal, otherViewPlaneNormal, 0.01) || utilities_exports.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 0.01)) {
          continue;
        }
        let cameraFound = false;
        for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
          const annotation2 = otherViewportsAnnotationsWithUniqueCameras[jj];
          const { viewportId: viewportId2 } = annotation2.data;
          const stockedViewport = renderingEngine.getViewport(viewportId2);
          const cameraOfStocked = stockedViewport.getCamera();
          if (utilities_exports.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 0.01) && utilities_exports.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
            cameraFound = true;
          }
        }
        if (!cameraFound) {
          otherViewportsAnnotationsWithUniqueCameras.push(annotation);
        }
      }
      const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
      for (let i = 0; i < otherViewportAnnotations.length; ++i) {
        const annotation = otherViewportAnnotations[i];
        if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {
          continue;
        }
        const { viewportId } = annotation.data;
        const otherViewport = renderingEngine.getViewport(viewportId);
        const otherCamera = otherViewport.getCamera();
        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
        vtkMath.normalize(otherViewPlaneNormal);
        if (utilities_exports.isEqual(viewPlaneNormal, otherViewPlaneNormal, 0.01) || utilities_exports.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 0.01)) {
          continue;
        }
        let cameraFound = false;
        for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
          const annotation2 = otherViewportsAnnotationsWithUniqueCameras[jj];
          const { viewportId: viewportId2 } = annotation2.data;
          const stockedViewport = renderingEngine.getViewport(viewportId2);
          const cameraOfStocked = stockedViewport.getCamera();
          if (utilities_exports.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 0.01) && utilities_exports.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
            cameraFound = true;
          }
        }
        if (!cameraFound) {
          otherViewportsAnnotationsWithUniqueCameras.push(annotation);
        }
      }
      return otherViewportsAnnotationsWithUniqueCameras;
    };
    this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {
      const volumeIds = viewport.getAllVolumeIds();
      const otherVolumeIds = otherViewport.getAllVolumeIds();
      return volumeIds.length === otherVolumeIds.length && volumeIds.every((id) => otherVolumeIds.includes(id));
    };
    this._jump = (enabledElement, jumpWorld) => {
      state.isInteractingWithTool = true;
      const { viewport, renderingEngine } = enabledElement;
      const annotations = this._getAnnotations(enabledElement);
      const delta = [0, 0, 0];
      vtkMath.subtract(jumpWorld, this.toolCenter, delta);
      const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
        const { data } = annotation;
        const otherViewport = renderingEngine.getViewport(data.viewportId);
        const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);
        return this._getReferenceLineControllable(otherViewport.id) && this._getReferenceLineDraggableRotatable(otherViewport.id) && sameScene;
      });
      if (viewportsAnnotationsToUpdate.length === 0) {
        state.isInteractingWithTool = false;
        return false;
      }
      this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
      state.isInteractingWithTool = false;
      return true;
    };
    this._activateModify = (element) => {
      var _a3;
      state.isInteractingWithTool = !((_a3 = this.configuration.mobile) == null ? void 0 : _a3.enabled);
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      this.editData.annotation.data.handles.activeOperation = null;
      this.editData.annotation.data.activeViewportIds = [];
      this._deactivateModify(element);
      resetElementCursor(element);
      this.editData = null;
      const requireSameOrientation = false;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._dragCallback = (evt) => {
      const eventDetail = evt.detail;
      const delta = eventDetail.deltaPoints.world;
      if (Math.abs(delta[0]) < 1e-3 && Math.abs(delta[1]) < 1e-3 && Math.abs(delta[2]) < 1e-3) {
        return;
      }
      const { element } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine, viewport } = enabledElement;
      const annotations = this._getAnnotations(enabledElement);
      const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
      const viewportAnnotation = filteredToolAnnotations[0];
      if (!viewportAnnotation) {
        return;
      }
      const { handles } = viewportAnnotation.data;
      const { currentPoints } = evt.detail;
      const canvasCoords = currentPoints.canvas;
      if (handles.activeOperation === OPERATION.DRAG) {
        const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
        const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
          const { data } = annotation;
          const otherViewport = renderingEngine.getViewport(data.viewportId);
          const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
          const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
          return otherViewportControllable === true && otherViewportDraggableRotatable === true && viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id);
        });
        this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
      } else if (handles.activeOperation === OPERATION.ROTATE) {
        const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
        const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
          const { data } = annotation;
          const otherViewport = renderingEngine.getViewport(data.viewportId);
          const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
          const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
          return otherViewportControllable === true && otherViewportDraggableRotatable === true;
        });
        const dir1 = vec2_exports.create();
        const dir2 = vec2_exports.create();
        const center = [
          this.toolCenter[0],
          this.toolCenter[1],
          this.toolCenter[2]
        ];
        const centerCanvas = viewport.worldToCanvas(center);
        const finalPointCanvas = eventDetail.currentPoints.canvas;
        const originalPointCanvas = vec2_exports.create();
        vec2_exports.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);
        vec2_exports.sub(dir1, originalPointCanvas, centerCanvas);
        vec2_exports.sub(dir2, finalPointCanvas, centerCanvas);
        let angle = vec2_exports.angle(dir1, dir2);
        if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {
          angle *= -1;
        }
        angle = Math.round(angle * 100) / 100;
        const rotationAxis = viewport.getCamera().viewPlaneNormal;
        const { matrix } = vtkMatrixBuilder.buildFromRadian().translate(center[0], center[1], center[2]).rotate(angle, rotationAxis).translate(-center[0], -center[1], -center[2]);
        const otherViewportsIds = [];
        viewportsAnnotationsToUpdate.forEach((annotation) => {
          const { data } = annotation;
          data.handles.toolCenter = center;
          const otherViewport = renderingEngine.getViewport(data.viewportId);
          const camera = otherViewport.getCamera();
          const { viewUp, position, focalPoint } = camera;
          viewUp[0] += position[0];
          viewUp[1] += position[1];
          viewUp[2] += position[2];
          vec3_exports.transformMat4(focalPoint, focalPoint, matrix);
          vec3_exports.transformMat4(position, position, matrix);
          vec3_exports.transformMat4(viewUp, viewUp, matrix);
          viewUp[0] -= position[0];
          viewUp[1] -= position[1];
          viewUp[2] -= position[2];
          otherViewport.setCamera({
            position,
            viewUp,
            focalPoint
          });
          otherViewportsIds.push(otherViewport.id);
        });
        renderingEngine.renderViewports(otherViewportsIds);
      } else if (handles.activeOperation === OPERATION.SLAB) {
        const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
        const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {
          const { data } = annotation;
          const otherViewport = renderingEngine.getViewport(data.viewportId);
          const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
          const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
          return otherViewportControllable === true && otherViewportSlabThicknessControlsOn === true && viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id);
        });
        if (referenceAnnotations.length === 0) {
          return;
        }
        const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);
        const viewportsIds = [];
        viewportsIds.push(viewport.id);
        viewportsAnnotationsToUpdate.forEach((annotation) => {
          const { data } = annotation;
          const otherViewport = renderingEngine.getViewport(data.viewportId);
          const camera = otherViewport.getCamera();
          const normal = camera.viewPlaneNormal;
          const dotProd = vtkMath.dot(delta, normal);
          const projectedDelta = [...normal];
          vtkMath.multiplyScalar(projectedDelta, dotProd);
          if (Math.abs(projectedDelta[0]) > 1e-3 || Math.abs(projectedDelta[1]) > 1e-3 || Math.abs(projectedDelta[2]) > 1e-3) {
            const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] + projectedDelta[1] * projectedDelta[1] + projectedDelta[2] * projectedDelta[2]);
            const currentPoint = eventDetail.lastPoints.world;
            const direction = [0, 0, 0];
            const currentCenter = [
              this.toolCenter[0],
              this.toolCenter[1],
              this.toolCenter[2]
            ];
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
            if (!viewportDraggableRotatable) {
              const { rotationPoints } = this.editData.annotation.data.handles;
              const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);
              if (otherViewportRotationPoints.length === 2) {
                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);
                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);
                vtkMath.add(point1, point2, currentCenter);
                vtkMath.multiplyScalar(currentCenter, 0.5);
              }
            }
            vtkMath.subtract(currentPoint, currentCenter, direction);
            const dotProdDirection = vtkMath.dot(direction, normal);
            const projectedDirection = [...normal];
            vtkMath.multiplyScalar(projectedDirection, dotProdDirection);
            const normalizedProjectedDirection = [
              projectedDirection[0],
              projectedDirection[1],
              projectedDirection[2]
            ];
            vec3_exports.normalize(normalizedProjectedDirection, normalizedProjectedDirection);
            const normalizedProjectedDelta = [
              projectedDelta[0],
              projectedDelta[1],
              projectedDelta[2]
            ];
            vec3_exports.normalize(normalizedProjectedDelta, normalizedProjectedDelta);
            let slabThicknessValue = otherViewport.getSlabThickness();
            if (utilities_exports.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {
              slabThicknessValue -= mod;
            } else {
              slabThicknessValue += mod;
            }
            slabThicknessValue = Math.abs(slabThicknessValue);
            slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);
            const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);
            if (near) {
              slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
            }
            const toolGroup = getToolGroupForViewport_default(otherViewport.id, renderingEngine.id);
            const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());
            crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);
            viewportsIds.push(otherViewport.id);
          }
        });
        renderingEngine.renderViewports(viewportsIds);
      }
    };
    this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {
      const { data } = annotation;
      const { rotationPoints } = data.handles;
      for (let i = 0; i < rotationPoints.length - 1; ++i) {
        const otherViewport = rotationPoints[i][1];
        if (otherViewport.id !== lineViewport.id) {
          continue;
        }
        const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
        if (!viewportControllable) {
          continue;
        }
        const lineSegment1 = {
          start: {
            x: rotationPoints[i][2][0],
            y: rotationPoints[i][2][1]
          },
          end: {
            x: rotationPoints[i][3][0],
            y: rotationPoints[i][3][1]
          }
        };
        const distanceToPoint1 = distanceToPoint3([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
        const lineSegment2 = {
          start: {
            x: rotationPoints[i + 1][2][0],
            y: rotationPoints[i + 1][2][1]
          },
          end: {
            x: rotationPoints[i + 1][3][0],
            y: rotationPoints[i + 1][3][1]
          }
        };
        const distanceToPoint22 = distanceToPoint3([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
        if (distanceToPoint1 <= proximity || distanceToPoint22 <= proximity) {
          return true;
        }
        i++;
      }
      return false;
    };
    this._getReferenceLineColor = ((_a2 = toolProps.configuration) == null ? void 0 : _a2.getReferenceLineColor) || defaultReferenceLineColor;
    this._getReferenceLineControllable = ((_b2 = toolProps.configuration) == null ? void 0 : _b2.getReferenceLineControllable) || defaultReferenceLineControllable;
    this._getReferenceLineDraggableRotatable = ((_c = toolProps.configuration) == null ? void 0 : _c.getReferenceLineDraggableRotatable) || defaultReferenceLineDraggableRotatable;
    this._getReferenceLineSlabThicknessControlsOn = ((_d = toolProps.configuration) == null ? void 0 : _d.getReferenceLineSlabThicknessControlsOn) || defaultReferenceLineSlabThicknessControlsOn;
  }
  onSetToolActive() {
    const viewportsInfo = this._getViewportsInfo();
    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
    this._subscribeToViewportNewVolumeSet(viewportsInfo);
    this._computeToolCenter(viewportsInfo);
  }
  onSetToolPassive() {
    const viewportsInfo = this._getViewportsInfo();
    this._computeToolCenter(viewportsInfo);
  }
  onSetToolEnabled() {
    const viewportsInfo = this._getViewportsInfo();
    this._computeToolCenter(viewportsInfo);
  }
  onSetToolDisabled() {
    const viewportsInfo = this._getViewportsInfo();
    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
    viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
      const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);
      if (!enabledElement) {
        return;
      }
      const annotations = this._getAnnotations(enabledElement);
      if (annotations == null ? void 0 : annotations.length) {
        annotations.forEach((annotation) => {
          removeAnnotation(annotation.annotationUID);
        });
      }
    });
  }
  getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
    if (point !== null) {
      return point;
    }
    point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
    if (point !== null) {
      return point;
    }
  }
  _unsubscribeToViewportNewVolumeSet(viewportsInfo) {
    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
      const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);
      const { element } = viewport;
      element.removeEventListener(enums_exports.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
    });
  }
  _subscribeToViewportNewVolumeSet(viewports) {
    viewports.forEach(({ viewportId, renderingEngineId }) => {
      const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);
      const { element } = viewport;
      element.addEventListener(enums_exports.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
    });
  }
  _autoPanViewportIfNecessary(viewportId, renderingEngine) {
    const viewport = renderingEngine.getViewport(viewportId);
    const { clientWidth, clientHeight } = viewport.canvas;
    const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);
    const pan = this.configuration.autoPan.panSize;
    const visiblePointCanvas = [
      toolCenterCanvas[0],
      toolCenterCanvas[1]
    ];
    if (toolCenterCanvas[0] < 0) {
      visiblePointCanvas[0] = pan;
    } else if (toolCenterCanvas[0] > clientWidth) {
      visiblePointCanvas[0] = clientWidth - pan;
    }
    if (toolCenterCanvas[1] < 0) {
      visiblePointCanvas[1] = pan;
    } else if (toolCenterCanvas[1] > clientHeight) {
      visiblePointCanvas[1] = clientHeight - pan;
    }
    if (visiblePointCanvas[0] === toolCenterCanvas[0] && visiblePointCanvas[1] === toolCenterCanvas[1]) {
      return;
    }
    const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);
    const deltaPointsWorld = [
      visiblePointWorld[0] - this.toolCenter[0],
      visiblePointWorld[1] - this.toolCenter[1],
      visiblePointWorld[2] - this.toolCenter[2]
    ];
    const camera = viewport.getCamera();
    const { focalPoint, position } = camera;
    const updatedPosition = [
      position[0] - deltaPointsWorld[0],
      position[1] - deltaPointsWorld[1],
      position[2] - deltaPointsWorld[2]
    ];
    const updatedFocalPoint = [
      focalPoint[0] - deltaPointsWorld[0],
      focalPoint[1] - deltaPointsWorld[1],
      focalPoint[2] - deltaPointsWorld[2]
    ];
    viewport.setCamera({
      focalPoint: updatedFocalPoint,
      position: updatedPosition
    });
    viewport.render();
  }
  setSlabThickness(viewport, slabThickness) {
    let actorUIDs;
    const { filterActorUIDsToSetSlabThickness } = this.configuration;
    if (filterActorUIDsToSetSlabThickness && filterActorUIDsToSetSlabThickness.length > 0) {
      actorUIDs = filterActorUIDsToSetSlabThickness;
    }
    let blendModeToUse = this.configuration.slabThicknessBlendMode;
    if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {
      blendModeToUse = enums_exports.BlendModes.COMPOSITE;
    }
    const immediate = false;
    viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);
    viewport.setSlabThickness(slabThickness, actorUIDs);
  }
  _isClockWise(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;
  }
  _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {
    viewportsAnnotationsToUpdate.forEach((annotation) => {
      this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);
    });
  }
  _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {
    const { data } = annotation;
    const viewport = renderingEngine.getViewport(data.viewportId);
    const camera = viewport.getCamera();
    const normal = camera.viewPlaneNormal;
    const dotProd = vtkMath.dot(delta, normal);
    const projectedDelta = [...normal];
    vtkMath.multiplyScalar(projectedDelta, dotProd);
    if (Math.abs(projectedDelta[0]) > 1e-3 || Math.abs(projectedDelta[1]) > 1e-3 || Math.abs(projectedDelta[2]) > 1e-3) {
      const newFocalPoint = [0, 0, 0];
      const newPosition = [0, 0, 0];
      vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);
      vtkMath.add(camera.position, projectedDelta, newPosition);
      viewport.setCamera({
        focalPoint: newFocalPoint,
        position: newPosition
      });
      viewport.render();
    }
  }
  _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
    const { data } = annotation;
    const { rotationPoints } = data.handles;
    for (let i = 0; i < rotationPoints.length; i++) {
      const point = rotationPoints[i][0];
      const otherViewport = rotationPoints[i][1];
      const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
      if (!viewportControllable) {
        continue;
      }
      const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
      if (!viewportDraggableRotatable) {
        continue;
      }
      const annotationCanvasCoordinate = viewport.worldToCanvas(point);
      if (vec2_exports.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
        data.handles.activeOperation = OPERATION.ROTATE;
        this.editData = {
          annotation
        };
        return point;
      }
    }
    return null;
  }
  _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
    const { data } = annotation;
    const { slabThicknessPoints } = data.handles;
    for (let i = 0; i < slabThicknessPoints.length; i++) {
      const point = slabThicknessPoints[i][0];
      const otherViewport = slabThicknessPoints[i][1];
      const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
      if (!viewportControllable) {
        continue;
      }
      const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
      if (!viewportSlabThicknessControlsOn) {
        continue;
      }
      const annotationCanvasCoordinate = viewport.worldToCanvas(point);
      if (vec2_exports.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
        data.handles.activeOperation = OPERATION.SLAB;
        data.activeViewportIds = [otherViewport.id];
        this.editData = {
          annotation
        };
        return point;
      }
    }
    return null;
  }
  _pointNearTool(element, annotation, canvasCoords, proximity) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const { clientWidth, clientHeight } = viewport.canvas;
    const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
    const { data } = annotation;
    const { rotationPoints } = data.handles;
    const { slabThicknessPoints } = data.handles;
    const viewportIdArray = [];
    for (let i = 0; i < rotationPoints.length - 1; ++i) {
      const otherViewport = rotationPoints[i][1];
      const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
      const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
      if (!viewportControllable || !viewportDraggableRotatable) {
        continue;
      }
      const lineSegment1 = {
        start: {
          x: rotationPoints[i][2][0],
          y: rotationPoints[i][2][1]
        },
        end: {
          x: rotationPoints[i][3][0],
          y: rotationPoints[i][3][1]
        }
      };
      const distanceToPoint1 = distanceToPoint3([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
      const lineSegment2 = {
        start: {
          x: rotationPoints[i + 1][2][0],
          y: rotationPoints[i + 1][2][1]
        },
        end: {
          x: rotationPoints[i + 1][3][0],
          y: rotationPoints[i + 1][3][1]
        }
      };
      const distanceToPoint22 = distanceToPoint3([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
      if (distanceToPoint1 <= proximity || distanceToPoint22 <= proximity) {
        viewportIdArray.push(otherViewport.id);
        data.handles.activeOperation = OPERATION.DRAG;
      }
      i++;
    }
    for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {
      const otherViewport = slabThicknessPoints[i][1];
      if (viewportIdArray.find((id) => id === otherViewport.id)) {
        continue;
      }
      const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
      const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
      if (!viewportControllable || !viewportSlabThicknessControlsOn) {
        continue;
      }
      const stPointLineCanvas1 = slabThicknessPoints[i][2];
      const stPointLineCanvas2 = slabThicknessPoints[i][3];
      const centerCanvas = vec2_exports.create();
      vec2_exports.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);
      vec2_exports.scale(centerCanvas, centerCanvas, 0.5);
      const canvasUnitVectorFromCenter = vec2_exports.create();
      vec2_exports.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);
      vec2_exports.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
      const canvasVectorFromCenterStart = vec2_exports.create();
      vec2_exports.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);
      const stPointLineCanvas1Start = vec2_exports.create();
      const stPointLineCanvas2Start = vec2_exports.create();
      vec2_exports.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);
      vec2_exports.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);
      const lineSegment1 = {
        start: {
          x: stPointLineCanvas1Start[0],
          y: stPointLineCanvas1Start[1]
        },
        end: {
          x: stPointLineCanvas1[0],
          y: stPointLineCanvas1[1]
        }
      };
      const distanceToPoint1 = distanceToPoint3([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
      const lineSegment2 = {
        start: {
          x: stPointLineCanvas2Start[0],
          y: stPointLineCanvas2Start[1]
        },
        end: {
          x: stPointLineCanvas2[0],
          y: stPointLineCanvas2[1]
        }
      };
      const distanceToPoint22 = distanceToPoint3([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
      if (distanceToPoint1 <= proximity || distanceToPoint22 <= proximity) {
        viewportIdArray.push(otherViewport.id);
        data.handles.activeOperation = null;
      }
      i++;
    }
    data.activeViewportIds = [...viewportIdArray];
    this.editData = {
      annotation
    };
    return data.handles.activeOperation === OPERATION.DRAG ? true : false;
  }
};
CrosshairsTool.toolName = "Crosshairs";
var CrosshairsTool_default = CrosshairsTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js
var MAGNIFY_VIEWPORT_ID = "magnify-viewport";
var MagnifyTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      magnifySize: 10,
      magnifyWidth: 250,
      magnifyHeight: 250
    }
  }) {
    super(toolProps, defaultToolProps);
    this._hasBeenRemoved = false;
    this.preMouseDownCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element, currentPoints } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      if (!(viewport instanceof StackViewport_default)) {
        throw new Error("MagnifyTool only works on StackViewports");
      }
      const referencedImageId = this._getReferencedImageId(viewport);
      if (!referencedImageId) {
        throw new Error("MagnifyTool: No referenced image id found, reconstructed planes not supported yet");
      }
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        referencedImageId,
        viewportIdsToRender,
        enabledElement,
        renderingEngine,
        currentPoints
      };
      this._createMagnificationViewport();
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return true;
    };
    this.preTouchStartCallback = (evt) => {
      this.preMouseDownCallback(evt);
    };
    this._createMagnificationViewport = () => {
      const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints } = this.editData;
      const { viewport } = enabledElement;
      const { element } = viewport;
      const viewportProperties = viewport.getProperties();
      const { canvas: canvasPos, world: worldPos } = currentPoints;
      let magnifyToolElement;
      magnifyToolElement = element.querySelector(".magnifyTool");
      if (magnifyToolElement === null) {
        const magnifyElement = document.createElement("div");
        magnifyElement.classList.add("magnifyTool");
        magnifyElement.style.display = "block";
        magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;
        magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;
        magnifyElement.style.position = "absolute";
        magnifyToolElement = magnifyElement;
        const viewportElement = element.querySelector(".viewport-element");
        viewportElement.appendChild(magnifyElement);
        const viewportInput = {
          viewportId: MAGNIFY_VIEWPORT_ID,
          type: enums_exports.ViewportType.STACK,
          element: magnifyToolElement
        };
        renderingEngine.enableElement(viewportInput);
      }
      magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;
      magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;
      const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);
      magnifyViewport.setStack([referencedImageId]).then(() => {
        if (this._hasBeenRemoved) {
          return;
        }
        magnifyViewport.setProperties(viewportProperties);
        const { parallelScale } = viewport.getCamera();
        const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();
        const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) + Math.pow(focalPoint[1] - position[1], 2) + Math.pow(focalPoint[2] - position[2], 2));
        const updatedFocalPoint = [
          worldPos[0],
          worldPos[1],
          worldPos[2]
        ];
        const updatedPosition = [
          updatedFocalPoint[0] + distance * viewPlaneNormal[0],
          updatedFocalPoint[1] + distance * viewPlaneNormal[1],
          updatedFocalPoint[2] + distance * viewPlaneNormal[2]
        ];
        magnifyViewport.setCamera({
          parallelScale: parallelScale * (1 / this.configuration.magnifySize),
          focalPoint: updatedFocalPoint,
          position: updatedPosition
        });
        magnifyViewport.render();
      });
      magnifyToolElement.style.display = "block";
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._dragCallback = (evt) => {
      const eventDetail = evt.detail;
      const { deltaPoints, element, currentPoints } = eventDetail;
      const deltaPointsWorld = deltaPoints.world;
      const canvasPos = currentPoints.canvas;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);
      const magnifyElement = element.querySelector(".magnifyTool");
      if (!magnifyElement) {
        return;
      }
      magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;
      magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;
      const { focalPoint, position } = magnifyViewport.getCamera();
      const updatedPosition = [
        position[0] + deltaPointsWorld[0],
        position[1] + deltaPointsWorld[1],
        position[2] + deltaPointsWorld[2]
      ];
      const updatedFocalPoint = [
        focalPoint[0] + deltaPointsWorld[0],
        focalPoint[1] + deltaPointsWorld[1],
        focalPoint[2] + deltaPointsWorld[2]
      ];
      magnifyViewport.setCamera({
        focalPoint: updatedFocalPoint,
        position: updatedPosition
      });
      magnifyViewport.render();
    };
    this._dragEndCallback = (evt) => {
      const { element } = evt.detail;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);
      const viewportElement = element.querySelector(".viewport-element");
      const magnifyToolElement = viewportElement.querySelector(".magnifyTool");
      viewportElement.removeChild(magnifyToolElement);
      this._deactivateDraw(element);
      resetElementCursor(element);
      this._hasBeenRemoved = true;
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      this._hasBeenRemoved = false;
      element.addEventListener(Events_default.MOUSE_UP, this._dragEndCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._dragEndCallback);
      element.addEventListener(Events_default.TOUCH_END, this._dragEndCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._dragEndCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._dragEndCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._dragEndCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
  }
  _getReferencedImageId(viewport) {
    const targetId = this.getTargetId(viewport);
    let referencedImageId;
    if (viewport instanceof StackViewport_default) {
      referencedImageId = targetId.split("imageId:")[1];
    }
    return referencedImageId;
  }
};
MagnifyTool.toolName = "Magnify";
var MagnifyTool_default = MagnifyTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js
var MAGNIFY_CLASSNAME = "advancedMagnifyTool";
var MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;
var { Events: csEvents } = enums_exports;
var isSegmentation = (actor) => actor.uid !== actor.referencedId;
var AdvancedMagnifyToolActions;
(function(AdvancedMagnifyToolActions2) {
  AdvancedMagnifyToolActions2["ShowZoomFactorsList"] = "showZoomFactorsList";
})(AdvancedMagnifyToolActions || (AdvancedMagnifyToolActions = {}));
var ADVANCED_MAGNIFY_TOOL_NAME = "AdvancedMagnify";
var PARALLEL_THRESHOLD4 = 1 - constants_exports.EPSILON;
var _AdvancedMagnifyTool = class _AdvancedMagnifyTool extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      shadow: true,
      magnifyingGlass: {
        radius: 125,
        zoomFactor: 3,
        zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],
        autoPan: {
          enabled: true,
          padding: 10
        }
      },
      actions: {
        showZoomFactorsList: {
          method: "showZoomFactorsList",
          bindings: [
            {
              mouseButton: MouseBindings.Secondary,
              modifierKey: KeyboardBindings.Shift
            }
          ]
        }
      }
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      const worldPos = currentPoints.world;
      const canvasPos = currentPoints.canvas;
      const { magnifyingGlass: config } = this.configuration;
      const { radius, zoomFactor, autoPan } = config;
      const canvasHandlePoints = this._getCanvasHandlePoints(canvasPos, radius);
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const annotationUID = utilities_exports.uuidv4();
      const magnifyViewportId = utilities_exports.uuidv4();
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        annotationUID,
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId
        },
        data: {
          sourceViewportId: viewport.id,
          magnifyViewportId,
          zoomFactor,
          isCanvasAnnotation: true,
          handles: {
            points: canvasHandlePoints,
            activeHandleIndex: null
          }
        }
      };
      this.magnifyViewportManager.createViewport(annotation, {
        magnifyViewportId,
        sourceEnabledElement: enabledElement,
        position: canvasPos,
        radius,
        zoomFactor,
        autoPan: {
          enabled: autoPan.enabled,
          padding: autoPan.padding,
          callback: (data) => {
            const annotationPoints = annotation.data.handles.points;
            const { canvas: canvasDelta } = data.delta;
            for (let i = 0, len = annotationPoints.length; i < len; i++) {
              const point = annotationPoints[i];
              point[0] += canvasDelta[0];
              point[1] += canvasDelta[1];
              annotation.invalidated = true;
            }
          }
        }
      });
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.onSetToolDisabled = () => {
      this.magnifyViewportManager.dispose();
      const annotations = getAllAnnotations();
      annotations.forEach((annotation) => {
        if (annotation.metadata.toolName === this.getToolName()) {
          removeAnnotation(annotation.annotationUID);
        }
      });
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const { data } = annotation;
      const { points } = data.handles;
      const canvasCoordinates = points;
      const canvasTop = canvasCoordinates[0];
      const canvasBottom = canvasCoordinates[2];
      const canvasLeft = canvasCoordinates[3];
      const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
      const center = [
        canvasLeft[0] + radius,
        canvasTop[1] + radius
      ];
      const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);
      if (Math.abs(radiusPoint - radius) < proximity * 2) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender
      };
      hideElementCursor(element);
      this._activateModify(element);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this.handleSelectedCallback = (evt, annotation, handle) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { data } = annotation;
      annotation.highlighted = true;
      const { points } = data.handles;
      const handleIndex = points.findIndex((p) => p === handle);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex
      };
      this._activateModify(element);
      hideElementCursor(element);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
      const { data } = annotation;
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      resetElementCursor(element);
      this.editData = null;
      this.isDrawing = false;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
    };
    this._dragDrawCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { deltaPoints } = eventDetail;
      const canvasDelta = (deltaPoints == null ? void 0 : deltaPoints.canvas) ?? [0, 0, 0];
      const { annotation, viewportIdsToRender } = this.editData;
      const { points } = annotation.data.handles;
      points.forEach((point) => {
        point[0] += canvasDelta[0];
        point[1] += canvasDelta[1];
      });
      annotation.invalidated = true;
      this.editData.hasMoved = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._dragModifyCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex } = this.editData;
      const { data } = annotation;
      if (handleIndex === void 0) {
        const { deltaPoints } = eventDetail;
        const canvasDelta = deltaPoints.canvas;
        const points = data.handles.points;
        points.forEach((point) => {
          point[0] += canvasDelta[0];
          point[1] += canvasDelta[1];
        });
        annotation.invalidated = true;
      } else {
        this._dragHandle(evt);
        annotation.invalidated = true;
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._dragHandle = (evt) => {
      const eventDetail = evt.detail;
      const { annotation } = this.editData;
      const { data } = annotation;
      const { points } = data.handles;
      const canvasCoordinates = points;
      const canvasTop = canvasCoordinates[0];
      const canvasBottom = canvasCoordinates[2];
      const canvasLeft = canvasCoordinates[3];
      const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
      const canvasCenter = [
        canvasLeft[0] + radius,
        canvasTop[1] + radius
      ];
      const { currentPoints } = eventDetail;
      const currentCanvasPoints = currentPoints.canvas;
      const newRadius = getCanvasCircleRadius([
        canvasCenter,
        currentCanvasPoints
      ]);
      const newCanvasHandlePoints = this._getCanvasHandlePoints(canvasCenter, newRadius);
      points[0] = newCanvasHandlePoints[0];
      points[1] = newCanvasHandlePoints[1];
      points[2] = newCanvasHandlePoints[2];
      points[3] = newCanvasHandlePoints[3];
    };
    this.cancel = (element) => {
      if (!this.isDrawing) {
        return;
      }
      this.isDrawing = false;
      this._deactivateModify(element);
      resetElementCursor(element);
      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
      const { data } = annotation;
      annotation.highlighted = false;
      data.handles.activeHandleIndex = null;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
      this.editData = null;
      return annotation.annotationUID;
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragModifyCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragModifyCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragModifyCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragModifyCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = annotations == null ? void 0 : annotations.filter((annotation) => annotation.data.sourceViewportId === viewport.id);
      const filteredAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(filteredAnnotations == null ? void 0 : filteredAnnotations.length)) {
        return renderStatus;
      }
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < filteredAnnotations.length; i++) {
        const annotation = filteredAnnotations[i];
        const { annotationUID, data } = annotation;
        const { magnifyViewportId, zoomFactor, handles } = data;
        const { points, activeHandleIndex } = handles;
        styleSpecifier.annotationUID = annotationUID;
        const lineWidth = this.getStyle("lineWidth", styleSpecifier, annotation);
        const lineDash = this.getStyle("lineDash", styleSpecifier, annotation);
        const color = this.getStyle("color", styleSpecifier, annotation);
        const canvasCoordinates = points;
        const canvasTop = canvasCoordinates[0];
        const canvasBottom = canvasCoordinates[2];
        const canvasLeft = canvasCoordinates[3];
        const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
        const center = [
          canvasLeft[0] + radius,
          canvasTop[1] + radius
        ];
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        let activeHandleCanvasCoords;
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
            color
          });
        }
        const dataId = `${annotationUID}-advancedMagnify`;
        const circleUID = "0";
        drawCircle_default(svgDrawingHelper, annotationUID, circleUID, center, radius, {
          color,
          lineWidth: 5
        }, dataId);
        const magnifyViewport = this.magnifyViewportManager.getViewport(magnifyViewportId);
        magnifyViewport.position = center;
        magnifyViewport.radius = radius;
        magnifyViewport.zoomFactor = zoomFactor;
        magnifyViewport.update();
        renderStatus = true;
      }
      return renderStatus;
    };
    this._getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {
      return [
        [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0],
        [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0],
        [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0],
        [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0]
      ];
    };
    this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();
  }
  showZoomFactorsList(evt, annotation) {
    const { element, currentPoints } = evt.detail;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const { canvas: canvasPoint } = currentPoints;
    const viewportElement = element.querySelector(":scope .viewport-element");
    const currentZoomFactor = annotation.data.zoomFactor;
    const remove = () => dropdown.parentElement.removeChild(dropdown);
    const dropdown = this._getZoomFactorsListDropdown(currentZoomFactor, (newZoomFactor) => {
      if (newZoomFactor !== void 0) {
        annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);
        annotation.invalidated = true;
      }
      remove();
      viewport.render();
    });
    Object.assign(dropdown.style, {
      left: `${canvasPoint[0]}px`,
      top: `${canvasPoint[1]}px`
    });
    viewportElement.appendChild(dropdown);
    dropdown.focus();
  }
  _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {
    const { zoomFactorList } = this.configuration.magnifyingGlass;
    const dropdown = document.createElement("select");
    dropdown.size = 5;
    Object.assign(dropdown.style, {
      width: "50px",
      position: "absolute"
    });
    ["mousedown", "mouseup", "mousemove", "click"].forEach((eventName2) => {
      dropdown.addEventListener(eventName2, (evt) => evt.stopPropagation());
    });
    dropdown.addEventListener("change", (evt) => {
      evt.stopPropagation();
      onChangeCallback(dropdown.value);
    });
    dropdown.addEventListener("keydown", (evt) => {
      var _a2;
      const shouldCancel = (evt.keyCode ?? evt.which === 27) || ((_a2 = evt.key) == null ? void 0 : _a2.toLowerCase()) === "escape";
      if (shouldCancel) {
        evt.stopPropagation();
        onChangeCallback();
      }
    });
    zoomFactorList.forEach((zoomFactor) => {
      const option = document.createElement("option");
      option.label = zoomFactor;
      option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;
      option.value = zoomFactor;
      option.defaultSelected = zoomFactor === currentZoomFactor;
      dropdown.add(option);
    });
    return dropdown;
  }
};
_AdvancedMagnifyTool.Actions = AdvancedMagnifyToolActions;
var AdvancedMagnifyTool = _AdvancedMagnifyTool;
var AdvancedMagnifyViewportManager = class _AdvancedMagnifyViewportManager {
  constructor() {
    this.createViewport = (annotation, viewportInfo) => {
      const { magnifyViewportId, sourceEnabledElement, position, radius, zoomFactor, autoPan } = viewportInfo;
      const { viewport: sourceViewport } = sourceEnabledElement;
      const { element: sourceElement } = sourceViewport;
      const magnifyViewport = new AdvancedMagnifyViewport({
        magnifyViewportId,
        sourceEnabledElement,
        radius,
        position,
        zoomFactor,
        autoPan
      });
      this._addSourceElementEventListener(sourceElement);
      this._magnifyViewportsMap.set(magnifyViewport.viewportId, {
        annotation,
        magnifyViewport,
        magnifyViewportInfo: viewportInfo
      });
      return magnifyViewport;
    };
    this._annotationRemovedCallback = (evt) => {
      const { annotation } = evt.detail;
      if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {
        return;
      }
      this.destroyViewport(annotation.data.magnifyViewportId);
    };
    this._newStackImageCallback = (evt) => {
      const { viewportId: sourceViewportId, imageId } = evt.detail;
      const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
      const { viewport } = getEnabledElementByViewportId(sourceViewportId);
      if (viewport.stackActorReInitialized) {
        this._reset(sourceViewportId);
      }
      magnifyViewportsMapEntries.forEach(({ annotation }) => {
        annotation.metadata.referencedImageId = imageId;
        annotation.invalidated = true;
      });
    };
    this._newVolumeImageCallback = (evt) => {
      const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;
      const renderingEngine = getRenderingEngine(renderingEngineId);
      const sourceViewport = renderingEngine.getViewport(sourceViewportId);
      const { viewPlaneNormal: currentViewPlaneNormal } = sourceViewport.getCamera();
      const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
      magnifyViewportsMapEntries.forEach(({ annotation }) => {
        const { viewPlaneNormal } = annotation.metadata;
        const isParallel = Math.abs(vec3_exports.dot(viewPlaneNormal, currentViewPlaneNormal)) > PARALLEL_THRESHOLD4;
        if (!isParallel) {
          return;
        }
        const { handles } = annotation.data;
        const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);
        const vecHandleToImagePlane = vec3_exports.sub(vec3_exports.create(), worldImagePlanePoint, handles.points[0]);
        const worldDist = vec3_exports.dot(vecHandleToImagePlane, currentViewPlaneNormal);
        const worldDelta = vec3_exports.scale(vec3_exports.create(), currentViewPlaneNormal, worldDist);
        for (let i = 0, len = handles.points.length; i < len; i++) {
          const point = handles.points[i];
          point[0] += worldDelta[0];
          point[1] += worldDelta[1];
          point[2] += worldDelta[2];
        }
        annotation.invalidated = true;
      });
    };
    this._magnifyViewportsMap = /* @__PURE__ */ new Map();
    this._initialize();
  }
  static getInstance() {
    _AdvancedMagnifyViewportManager._singleton = _AdvancedMagnifyViewportManager._singleton ?? new _AdvancedMagnifyViewportManager();
    return _AdvancedMagnifyViewportManager._singleton;
  }
  getViewport(magnifyViewportId) {
    var _a2;
    return (_a2 = this._magnifyViewportsMap.get(magnifyViewportId)) == null ? void 0 : _a2.magnifyViewport;
  }
  dispose() {
    this._removeEventListeners();
    this._destroyViewports();
  }
  destroyViewport(magnifyViewportId) {
    const magnifyViewportMapEntry = this._magnifyViewportsMap.get(magnifyViewportId);
    if (magnifyViewportMapEntry) {
      const { magnifyViewport } = magnifyViewportMapEntry;
      const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;
      const { element: sourceElement } = sourceViewport;
      this._removeSourceElementEventListener(sourceElement);
      magnifyViewport.dispose();
      this._magnifyViewportsMap.delete(magnifyViewportId);
    }
  }
  _destroyViewports() {
    const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());
    magnifyViewportIds.forEach((magnifyViewportId) => this.destroyViewport(magnifyViewportId));
  }
  _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {
    const magnifyViewportsMapEntries = Array.from(this._magnifyViewportsMap.values());
    return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {
      const { viewport } = magnifyViewport.sourceEnabledElement;
      return viewport.id === sourceViewportId;
    });
  }
  _reset(sourceViewportId) {
    const magnifyViewports = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
    magnifyViewports.forEach(({ magnifyViewport, annotation, magnifyViewportInfo }) => {
      this.destroyViewport(magnifyViewport.viewportId);
      const newEnabledElement = getEnabledElementByViewportId(sourceViewportId);
      this.createViewport(annotation, {
        ...magnifyViewportInfo,
        sourceEnabledElement: {
          ...newEnabledElement
        }
      });
    });
  }
  _addEventListeners() {
    eventTarget_default.addEventListener(Events_default.ANNOTATION_REMOVED, this._annotationRemovedCallback);
  }
  _removeEventListeners() {
    eventTarget_default.removeEventListener(Events_default.ANNOTATION_REMOVED, this._annotationRemovedCallback);
  }
  _addSourceElementEventListener(element) {
    element.addEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);
    const newStackHandler = (evt) => {
      const { viewportId: sourceViewportId } = evt.detail;
      this._reset(sourceViewportId);
    };
    element.addEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, newStackHandler);
    const newVolumeHandler = (evt) => {
      const { viewportId: sourceViewportId } = evt.detail;
      this._reset(sourceViewportId);
    };
    element.addEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, newVolumeHandler);
    element.addEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);
    element.newStackHandler = newStackHandler;
    element.newVolumeHandler = newVolumeHandler;
  }
  _removeSourceElementEventListener(element) {
    element.removeEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);
    element.removeEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);
    element.removeEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, element.newStackHandler);
    element.removeEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, element.newVolumeHandler);
    delete element.newStackHandler;
    delete element.newVolumeHandler;
  }
  _initialize() {
    this._addEventListeners();
  }
};
var AdvancedMagnifyViewport = class {
  constructor({ magnifyViewportId, sourceEnabledElement, radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS, position = [0, 0], zoomFactor, autoPan }) {
    this._enabledElement = null;
    this._sourceToolGroup = null;
    this._magnifyToolGroup = null;
    this._isViewportReady = false;
    this._radius = 0;
    this._resized = false;
    this._canAutoPan = false;
    this._viewportId = magnifyViewportId ?? utilities_exports.uuidv4();
    this._sourceEnabledElement = sourceEnabledElement;
    this._autoPan = autoPan;
    this.radius = radius;
    this.position = position;
    this.zoomFactor = zoomFactor;
    this.visible = true;
    this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);
    this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);
    this._handleToolModeChanged = this._handleToolModeChanged.bind(this);
    this._mouseDragCallback = this._mouseDragCallback.bind(this);
    this._resizeViewportAsync = debounce_default(this._resizeViewport.bind(this), 1);
    this._initialize();
  }
  get sourceEnabledElement() {
    return this._sourceEnabledElement;
  }
  get viewportId() {
    return this._viewportId;
  }
  get radius() {
    return this._radius;
  }
  set radius(radius) {
    if (Math.abs(this._radius - radius) > 1e-5) {
      this._radius = radius;
      this._resized = true;
    }
  }
  update() {
    const { radius, position, visible } = this;
    const { viewport } = this._enabledElement;
    const { element } = viewport;
    const size = 2 * radius;
    const [x, y] = position;
    if (this._resized) {
      this._resizeViewportAsync();
      this._resized = false;
    }
    Object.assign(element.style, {
      display: visible ? "block" : "hidden",
      width: `${size}px`,
      height: `${size}px`,
      left: `${-radius}px`,
      top: `${-radius}px`,
      transform: `translate(${x}px, ${y}px)`
    });
    if (this._isViewportReady) {
      this._syncViewports();
      viewport.render();
    }
  }
  dispose() {
    const { viewport } = this._enabledElement;
    const { element } = viewport;
    const renderingEngine = viewport.getRenderingEngine();
    this._removeEventListeners(element);
    renderingEngine.disableElement(viewport.id);
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
  _handleToolModeChanged(evt) {
    var _a2;
    const { _magnifyToolGroup: magnifyToolGroup } = this;
    const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;
    if (((_a2 = this._sourceToolGroup) == null ? void 0 : _a2.id) !== toolGroupId) {
      return;
    }
    switch (mode) {
      case ToolModes_default.Active:
        magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);
        break;
      case ToolModes_default.Passive:
        magnifyToolGroup.setToolPassive(toolName);
        break;
      case ToolModes_default.Enabled:
        magnifyToolGroup.setToolEnabled(toolName);
        break;
      case ToolModes_default.Disabled:
        magnifyToolGroup.setToolDisabled(toolName);
        break;
      default:
        throw new Error(`Unknow tool mode (${mode})`);
    }
  }
  _inheritBorderRadius(magnifyElement) {
    const viewport = magnifyElement.querySelector(".viewport-element");
    const canvas = magnifyElement.querySelector(".cornerstone-canvas");
    viewport.style.borderRadius = "inherit";
    canvas.style.borderRadius = "inherit";
  }
  _createViewportNode() {
    const magnifyElement = document.createElement("div");
    const { radius } = this;
    const size = radius * 2;
    magnifyElement.classList.add(MAGNIFY_CLASSNAME);
    Object.assign(magnifyElement.style, {
      display: "block",
      width: `${size}px`,
      height: `${size}px`,
      position: "absolute",
      overflow: "hidden",
      borderRadius: "50%",
      boxSizing: "border-box",
      left: `${-radius}px`,
      top: `${-radius}px`,
      transform: `translate(-1000px, -1000px)`
    });
    return magnifyElement;
  }
  _convertZoomFactorToParallelScale(viewport, magnifyViewport, zoomFactor) {
    const { parallelScale } = viewport.getCamera();
    const canvasRatio = magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;
    return parallelScale * (1 / zoomFactor) * canvasRatio;
  }
  _isStackViewport(viewport) {
    return "setStack" in viewport;
  }
  _isVolumeViewport(viewport) {
    return "addVolumes" in viewport;
  }
  _cloneToolGroups(sourceViewport, magnifyViewport) {
    const sourceActors = sourceViewport.getActors();
    const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;
    const sourceToolGroup = getToolGroupForViewport_default(sourceViewport.id, sourceViewport.renderingEngineId);
    const magnifyToolGroup = sourceToolGroup.clone(magnifyToolGroupId, (toolName) => {
      const toolInstance = sourceToolGroup.getToolInstance(toolName);
      const isAnnotationTool = toolInstance instanceof AnnotationTool_default && !(toolInstance instanceof AdvancedMagnifyTool);
      return isAnnotationTool;
    });
    magnifyToolGroup.addViewport(magnifyViewport.id, magnifyViewport.renderingEngineId);
    sourceActors.filter(isSegmentation).forEach((actor) => {
      addSegmentationRepresentations(this.viewportId, [
        {
          segmentationId: actor.referencedId,
          type: SegmentationRepresentations_default.Labelmap
        }
      ]);
    });
    return { sourceToolGroup, magnifyToolGroup };
  }
  _cloneStack(sourceViewport, magnifyViewport) {
    const imageIds = sourceViewport.getImageIds();
    magnifyViewport.setStack(imageIds).then(() => {
      this._isViewportReady = true;
      this.update();
    });
  }
  _cloneVolumes(sourceViewport, magnifyViewport) {
    const actors = sourceViewport.getActors();
    const volumeInputArray = actors.filter((actor) => !isSegmentation(actor)).map((actor) => ({ volumeId: actor.uid }));
    magnifyViewport.setVolumes(volumeInputArray).then(() => {
      this._isViewportReady = true;
      this.update();
    });
    return magnifyViewport;
  }
  _cloneViewport(sourceViewport, magnifyElement) {
    const { viewportId: magnifyViewportId } = this;
    const renderingEngine = sourceViewport.getRenderingEngine();
    const { options: sourceViewportOptions } = sourceViewport;
    const viewportInput = {
      element: magnifyElement,
      viewportId: magnifyViewportId,
      type: sourceViewport.type,
      defaultOptions: { ...sourceViewportOptions }
    };
    renderingEngine.enableElement(viewportInput);
    const magnifyViewport = renderingEngine.getViewport(magnifyViewportId);
    if (this._isStackViewport(sourceViewport)) {
      this._cloneStack(sourceViewport, magnifyViewport);
    } else if (this._isVolumeViewport(sourceViewport)) {
      this._cloneVolumes(sourceViewport, magnifyViewport);
    }
    this._inheritBorderRadius(magnifyElement);
    const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);
    this._sourceToolGroup = toolGroups.sourceToolGroup;
    this._magnifyToolGroup = toolGroups.magnifyToolGroup;
  }
  _cancelMouseEventCallback(evt) {
    evt.stopPropagation();
    evt.preventDefault();
  }
  _browserMouseUpCallback(evt) {
    const { element } = this._enabledElement.viewport;
    document.removeEventListener("mouseup", this._browserMouseUpCallback);
    element.addEventListener("mouseup", this._cancelMouseEventCallback);
    element.addEventListener("mousemove", this._cancelMouseEventCallback);
  }
  _browserMouseDownCallback(evt) {
    var _a2;
    const { element } = this._enabledElement.viewport;
    this._canAutoPan = !!((_a2 = evt.target) == null ? void 0 : _a2.closest(".advancedMagnifyTool"));
    document.addEventListener("mouseup", this._browserMouseUpCallback);
    element.removeEventListener("mouseup", this._cancelMouseEventCallback);
    element.removeEventListener("mousemove", this._cancelMouseEventCallback);
  }
  _mouseDragCallback(evt) {
    if (!state.isInteractingWithTool) {
      return;
    }
    const { _autoPan: autoPan } = this;
    if (!autoPan.enabled || !this._canAutoPan) {
      return;
    }
    const { currentPoints } = evt.detail;
    const { viewport } = this._enabledElement;
    const { canvasToWorld } = viewport;
    const { canvas: canvasCurrent } = currentPoints;
    const { radius: magnifyRadius } = this;
    const canvasCenter = [magnifyRadius, magnifyRadius];
    const dist = distanceToPoint2(canvasCenter, canvasCurrent);
    const maxDist = magnifyRadius - autoPan.padding;
    if (dist <= maxDist) {
      return;
    }
    const panDist = dist - maxDist;
    const canvasDeltaPos = vec2_exports.sub(vec2_exports.create(), canvasCurrent, canvasCenter);
    vec2_exports.normalize(canvasDeltaPos, canvasDeltaPos);
    vec2_exports.scale(canvasDeltaPos, canvasDeltaPos, panDist);
    const newCanvasPosition = vec2_exports.add(vec2_exports.create(), this.position, canvasDeltaPos);
    const currentWorldPos = canvasToWorld(this.position);
    const newWorldPos = canvasToWorld(newCanvasPosition);
    const worldDeltaPos = vec3_exports.sub(vec3_exports.create(), newWorldPos, currentWorldPos);
    const autoPanCallbackData = {
      points: {
        currentPosition: {
          canvas: this.position,
          world: currentWorldPos
        },
        newPosition: {
          canvas: newCanvasPosition,
          world: newWorldPos
        }
      },
      delta: {
        canvas: canvasDeltaPos,
        world: worldDeltaPos
      }
    };
    autoPan.callback(autoPanCallbackData);
  }
  _addBrowserEventListeners(element) {
    document.addEventListener("mousedown", this._browserMouseDownCallback, true);
    element.addEventListener("mousedown", this._cancelMouseEventCallback);
    element.addEventListener("mouseup", this._cancelMouseEventCallback);
    element.addEventListener("mousemove", this._cancelMouseEventCallback);
    element.addEventListener("dblclick", this._cancelMouseEventCallback);
  }
  _removeBrowserEventListeners(element) {
    document.removeEventListener("mousedown", this._browserMouseDownCallback, true);
    document.removeEventListener("mouseup", this._browserMouseUpCallback);
    element.removeEventListener("mousedown", this._cancelMouseEventCallback);
    element.removeEventListener("mouseup", this._cancelMouseEventCallback);
    element.removeEventListener("mousemove", this._cancelMouseEventCallback);
    element.removeEventListener("dblclick", this._cancelMouseEventCallback);
  }
  _addEventListeners(element) {
    eventTarget_default.addEventListener(Events_default.TOOL_MODE_CHANGED, this._handleToolModeChanged);
    element.addEventListener(Events_default.MOUSE_MOVE, this._mouseDragCallback);
    element.addEventListener(Events_default.MOUSE_DRAG, this._mouseDragCallback);
    this._addBrowserEventListeners(element);
  }
  _removeEventListeners(element) {
    eventTarget_default.removeEventListener(Events_default.TOOL_MODE_CHANGED, this._handleToolModeChanged);
    element.addEventListener(Events_default.MOUSE_MOVE, this._mouseDragCallback);
    element.addEventListener(Events_default.MOUSE_DRAG, this._mouseDragCallback);
    this._removeBrowserEventListeners(element);
  }
  _initialize() {
    const { _sourceEnabledElement: sourceEnabledElement } = this;
    const { viewport: sourceViewport } = sourceEnabledElement;
    const { canvas: sourceCanvas } = sourceViewport;
    const magnifyElement = this._createViewportNode();
    sourceCanvas.parentNode.appendChild(magnifyElement);
    this._addEventListeners(magnifyElement);
    this._cloneViewport(sourceViewport, magnifyElement);
    this._enabledElement = getEnabledElement(magnifyElement);
  }
  _syncViewportsCameras(sourceViewport, magnifyViewport) {
    const worldPos = sourceViewport.canvasToWorld(this.position);
    const parallelScale = this._convertZoomFactorToParallelScale(sourceViewport, magnifyViewport, this.zoomFactor);
    const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();
    const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) + Math.pow(focalPoint[1] - position[1], 2) + Math.pow(focalPoint[2] - position[2], 2));
    const updatedFocalPoint = [
      worldPos[0],
      worldPos[1],
      worldPos[2]
    ];
    const updatedPosition = [
      updatedFocalPoint[0] + distance * viewPlaneNormal[0],
      updatedFocalPoint[1] + distance * viewPlaneNormal[1],
      updatedFocalPoint[2] + distance * viewPlaneNormal[2]
    ];
    magnifyViewport.setCamera({
      parallelScale,
      focalPoint: updatedFocalPoint,
      position: updatedPosition
    });
  }
  _syncStackViewports(sourceViewport, magnifyViewport) {
    magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());
  }
  _syncViewports() {
    const { viewport: sourceViewport } = this._sourceEnabledElement;
    const { viewport: magnifyViewport } = this._enabledElement;
    const sourceProperties = sourceViewport.getProperties();
    const imageData = magnifyViewport.getImageData();
    if (!imageData) {
      return;
    }
    magnifyViewport.setProperties(sourceProperties);
    this._syncViewportsCameras(sourceViewport, magnifyViewport);
    if (this._isStackViewport(sourceViewport)) {
      this._syncStackViewports(sourceViewport, magnifyViewport);
    }
    this._syncViewportsCameras(sourceViewport, magnifyViewport);
    magnifyViewport.render();
  }
  _resizeViewport() {
    const { viewport } = this._enabledElement;
    const renderingEngine = viewport.getRenderingEngine();
    renderingEngine.resize();
  }
};
AdvancedMagnifyTool.toolName = "AdvancedMagnify";

// node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js
var { EPSILON: EPSILON8 } = constants_exports;
var ReferenceLines = class extends AnnotationDisplayTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      sourceViewportId: "",
      enforceSameFrameOfReference: true,
      showFullDimension: false
    }
  }) {
    super(toolProps, defaultToolProps);
    this.editData = null;
    this._init = () => {
      var _a2;
      const renderingEngines = getRenderingEngines();
      const renderingEngine = renderingEngines[0];
      if (!renderingEngine) {
        return;
      }
      let viewports = renderingEngine.getViewports();
      viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());
      const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);
      if (!(sourceViewport == null ? void 0 : sourceViewport.getImageData())) {
        return;
      }
      const { element } = sourceViewport;
      const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();
      const sourceViewportCanvasCornersInWorld = utilities_exports.getViewportImageCornersInWorld(sourceViewport);
      let annotation = (_a2 = this.editData) == null ? void 0 : _a2.annotation;
      const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();
      if (!annotation) {
        const newAnnotation = {
          highlighted: true,
          invalidated: true,
          metadata: {
            toolName: this.getToolName(),
            viewPlaneNormal: [...viewPlaneNormal],
            viewUp: [...viewUp],
            FrameOfReferenceUID,
            referencedImageId: null
          },
          data: {
            handles: {
              points: sourceViewportCanvasCornersInWorld
            }
          }
        };
        addAnnotation(newAnnotation, element);
        annotation = newAnnotation;
      } else {
        this.editData.annotation.data.handles.points = sourceViewportCanvasCornersInWorld;
      }
      this.editData = {
        sourceViewportId: sourceViewport.id,
        renderingEngine,
        annotation
      };
      triggerAnnotationRenderForViewportIds_default(viewports.filter((viewport) => viewport.id !== sourceViewport.id).map((viewport) => viewport.id));
    };
    this.onSetToolEnabled = () => {
      this._init();
    };
    this.onSetToolConfiguration = () => {
      this._init();
    };
    this.onCameraModified = (evt) => {
      this._init();
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      var _a2, _b2;
      const { viewport: targetViewport } = enabledElement;
      if (!this.editData) {
        return false;
      }
      const { annotation, sourceViewportId } = this.editData;
      let renderStatus = false;
      const { viewport: sourceViewport } = getEnabledElementByViewportId(sourceViewportId) || {};
      if (!sourceViewport) {
        return renderStatus;
      }
      if (sourceViewport.id === targetViewport.id) {
        return renderStatus;
      }
      if (!annotation || !((_b2 = (_a2 = annotation == null ? void 0 : annotation.data) == null ? void 0 : _a2.handles) == null ? void 0 : _b2.points)) {
        return renderStatus;
      }
      if (this.configuration.enforceSameFrameOfReference && sourceViewport.getFrameOfReferenceUID() !== targetViewport.getFrameOfReferenceUID()) {
        return renderStatus;
      }
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      const topLeft = annotation.data.handles.points[0];
      const topRight = annotation.data.handles.points[1];
      const bottomLeft = annotation.data.handles.points[2];
      const bottomRight = annotation.data.handles.points[3];
      const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();
      const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();
      if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {
        return renderStatus;
      }
      const targetViewportPlane = utilities_exports.planar.planeEquation(viewPlaneNormal, focalPoint);
      const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
      const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];
      let pointSetToUse = pointSet1;
      let topBottomVec = vec3_exports.subtract(vec3_exports.create(), pointSet1[0], pointSet1[1]);
      topBottomVec = vec3_exports.normalize(vec3_exports.create(), topBottomVec);
      let topRightVec = vec3_exports.subtract(vec3_exports.create(), pointSet1[2], pointSet1[0]);
      topRightVec = vec3_exports.normalize(vec3_exports.create(), topRightVec);
      const newNormal = vec3_exports.cross(vec3_exports.create(), topBottomVec, topRightVec);
      if (this.isParallel(newNormal, viewPlaneNormal)) {
        return renderStatus;
      }
      if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {
        pointSetToUse = pointSet2;
      }
      const lineStartWorld = utilities_exports.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);
      const lineEndWorld = utilities_exports.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);
      const { annotationUID } = annotation;
      styleSpecifier.annotationUID = annotationUID;
      const lineWidth = this.getStyle("lineWidth", styleSpecifier, annotation);
      const lineDash = this.getStyle("lineDash", styleSpecifier, annotation);
      const color = this.getStyle("color", styleSpecifier, annotation);
      const shadow = this.getStyle("shadow", styleSpecifier, annotation);
      let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));
      if (this.configuration.showFullDimension) {
        canvasCoordinates = this.handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates);
      }
      if (canvasCoordinates.length < 2) {
        return renderStatus;
      }
      const dataId = `${annotationUID}-line`;
      const lineUID = "1";
      drawLine(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
        color,
        width: lineWidth,
        lineDash,
        shadow
      }, dataId);
      renderStatus = true;
      return renderStatus;
    };
    this.isPerpendicular = (vec1, vec2) => {
      const dot = vec3_exports.dot(vec1, vec2);
      return Math.abs(dot) < EPSILON8;
    };
  }
  handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates) {
    const renderingEngine = targetViewport.getRenderingEngine();
    const targetId = this.getTargetId(targetViewport);
    const targetImage = this.getTargetImageData(targetId);
    const referencedImageId = this.getReferencedImageId(targetViewport, lineStartWorld, viewPlaneNormal, viewUp);
    if (referencedImageId && targetImage) {
      try {
        const { imageData, dimensions } = targetImage;
        const [topLeftImageCoord, topRightImageCoord, bottomRightImageCoord, bottomLeftImageCoord] = [
          imageData.indexToWorld([0, 0, 0]),
          imageData.indexToWorld([dimensions[0] - 1, 0, 0]),
          imageData.indexToWorld([
            dimensions[0] - 1,
            dimensions[1] - 1,
            0
          ]),
          imageData.indexToWorld([0, dimensions[1] - 1, 0])
        ].map((world) => utilities_exports.worldToImageCoords(referencedImageId, world));
        const [lineStartImageCoord, lineEndImageCoord] = [
          lineStartWorld,
          lineEndWorld
        ].map((world) => utilities_exports.worldToImageCoords(referencedImageId, world));
        canvasCoordinates = [
          [topLeftImageCoord, topRightImageCoord],
          [topRightImageCoord, bottomRightImageCoord],
          [bottomLeftImageCoord, bottomRightImageCoord],
          [topLeftImageCoord, bottomLeftImageCoord]
        ].map(([start, end]) => this.intersectInfiniteLines(start, end, lineStartImageCoord, lineEndImageCoord)).filter((point) => point && this.isInBound(point, dimensions)).map((point) => {
          const world = utilities_exports.imageToWorldCoords(referencedImageId, point);
          return targetViewport.worldToCanvas(world);
        });
      } catch (err2) {
        console.log(err2);
      }
    }
    return canvasCoordinates;
  }
  intersectInfiniteLines(line1Start, line1End, line2Start, line2End) {
    const [x1, y1] = line1Start;
    const [x2, y2] = line1End;
    const [x3, y3] = line2Start;
    const [x4, y4] = line2End;
    const a1 = y2 - y1;
    const b1 = x1 - x2;
    const c1 = x2 * y1 - x1 * y2;
    const a2 = y4 - y3;
    const b22 = x3 - x4;
    const c2 = x4 * y3 - x3 * y4;
    if (Math.abs(a1 * b22 - a2 * b1) < EPSILON8) {
      return;
    }
    const x = (b1 * c2 - b22 * c1) / (a1 * b22 - a2 * b1);
    const y = (a2 * c1 - a1 * c2) / (a1 * b22 - a2 * b1);
    return [x, y];
  }
  isParallel(vec1, vec2) {
    return Math.abs(vec3_exports.dot(vec1, vec2)) > 1 - EPSILON8;
  }
  isInBound(point, dimensions) {
    return point[0] >= 0 && point[0] <= dimensions[0] && point[1] >= 0 && point[1] <= dimensions[1];
  }
};
ReferenceLines.toolName = "ReferenceLines";
var ReferenceLinesTool_default = ReferenceLines;

// node_modules/@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js
var { EPSILON: EPSILON9 } = constants_exports;
var OverlayGridTool = class extends AnnotationDisplayTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      sourceImageIds: []
    }
  }) {
    super(toolProps, defaultToolProps);
    this.onSetToolEnabled = () => {
      this._init();
    };
    this.onSetToolActive = () => {
      this._init();
    };
    this._init = () => {
      const sourceImageIds = this.configuration.sourceImageIds;
      if (!(sourceImageIds == null ? void 0 : sourceImageIds.length)) {
        console.warn("OverlayGridTool: No sourceImageIds provided in configuration");
        return;
      }
      const imagePlaneModule = metaData_exports.get("imagePlaneModule", sourceImageIds[0]);
      if (!imagePlaneModule) {
        console.warn("OverlayGridTool: No imagePlaneModule found for sourceImageIds");
        return;
      }
      const { frameOfReferenceUID } = imagePlaneModule;
      const viewportsInfo = getToolGroup_default(this.toolGroupId).viewportsInfo;
      if (!(viewportsInfo == null ? void 0 : viewportsInfo.length)) {
        console.warn("OverlayGridTool: No viewports found");
        return;
      }
      const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);
      if (!(annotations == null ? void 0 : annotations.length)) {
        const pointSets = sourceImageIds.map((id) => {
          return this.calculateImageIdPointSets(id);
        });
        const newAnnotation = {
          highlighted: true,
          invalidated: true,
          metadata: {
            toolName: this.getToolName(),
            FrameOfReferenceUID: frameOfReferenceUID,
            referencedImageId: null
          },
          data: {
            viewportData: /* @__PURE__ */ new Map(),
            pointSets
          }
        };
        addAnnotation(newAnnotation, frameOfReferenceUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportsInfo.map(({ viewportId }) => viewportId));
    };
    this.calculateImageIdPointSets = (imageId) => {
      const { imagePositionPatient, rows, columns, rowCosines, columnCosines, rowPixelSpacing, columnPixelSpacing } = metaData_exports.get("imagePlaneModule", imageId);
      const topLeft = [...imagePositionPatient];
      const topRight = [...imagePositionPatient];
      const bottomLeft = [...imagePositionPatient];
      const bottomRight = [...imagePositionPatient];
      vec3_exports.scaleAndAdd(topRight, imagePositionPatient, columnCosines, columns * columnPixelSpacing);
      vec3_exports.scaleAndAdd(bottomLeft, imagePositionPatient, rowCosines, rows * rowPixelSpacing);
      vec3_exports.scaleAndAdd(bottomRight, bottomLeft, columnCosines, columns * columnPixelSpacing);
      const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
      const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];
      return { pointSet1, pointSet2 };
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      const sourceImageIds = this.configuration.sourceImageIds;
      let renderStatus = false;
      if (!(sourceImageIds == null ? void 0 : sourceImageIds.length)) {
        return renderStatus;
      }
      const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;
      const targetImageIds = targetViewport.getImageIds();
      if (targetImageIds.length < 2) {
        return renderStatus;
      }
      const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const annotation = annotations[0];
      const { annotationUID } = annotation;
      const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      const imageIdNormal = this.getImageIdNormal(sourceImageIds[0]);
      if (this.isParallel(viewPlaneNormal, imageIdNormal)) {
        return renderStatus;
      }
      const targetViewportPlane = utilities_exports.planar.planeEquation(viewPlaneNormal, focalPoint);
      const pointSets = annotation.data.pointSets;
      const viewportData = annotation.data.viewportData;
      for (let i = 0; i < sourceImageIds.length; i++) {
        const { pointSet1, pointSet2 } = pointSets[i];
        const targetData = viewportData.get(targetViewport.id) || this.initializeViewportData(viewportData, targetViewport.id);
        if (!targetData.pointSetsToUse[i]) {
          let pointSetToUse = pointSet1;
          let topBottomVec = vec3_exports.subtract(vec3_exports.create(), pointSet1[0], pointSet1[1]);
          topBottomVec = vec3_exports.normalize(vec3_exports.create(), topBottomVec);
          if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {
            pointSetToUse = pointSet2;
          }
          targetData.pointSetsToUse[i] = pointSetToUse;
          targetData.lineStartsWorld[i] = utilities_exports.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);
          targetData.lineEndsWorld[i] = utilities_exports.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);
        }
        const lineStartWorld = targetData.lineStartsWorld[i];
        const lineEndWorld = targetData.lineEndsWorld[i];
        styleSpecifier.annotationUID = annotationUID;
        const lineWidth = this.getStyle("lineWidth", styleSpecifier, annotation);
        const lineDash = this.getStyle("lineDash", styleSpecifier, annotation);
        const color = this.getStyle("color", styleSpecifier, annotation);
        const shadow = this.getStyle("shadow", styleSpecifier, annotation);
        const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));
        const dataId = `${annotationUID}-line`;
        const lineUID = `${i}`;
        drawLine(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
          color,
          width: lineWidth,
          lineDash,
          shadow
        }, dataId);
      }
      renderStatus = true;
      return renderStatus;
    };
    this.initializeViewportData = (viewportData, id) => {
      viewportData.set(id, {
        pointSetsToUse: [],
        lineStartsWorld: [],
        lineEndsWorld: []
      });
      return viewportData.get(id);
    };
    this.isPerpendicular = (vec1, vec2) => {
      const dot = vec3_exports.dot(vec1, vec2);
      return Math.abs(dot) < EPSILON9;
    };
  }
  isParallel(vec1, vec2) {
    return Math.abs(vec3_exports.dot(vec1, vec2)) > 1 - EPSILON9;
  }
  getImageIdNormal(imageId) {
    const { imageOrientationPatient } = metaData_exports.get("imagePlaneModule", imageId);
    const rowCosineVec = vec3_exports.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
    const colCosineVec = vec3_exports.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
    return vec3_exports.cross(vec3_exports.create(), rowCosineVec, colCosineVec);
  }
};
OverlayGridTool.toolName = "OverlayGrid";
var OverlayGridTool_default = OverlayGridTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js
var SegmentationIntersectionTool = class extends AnnotationDisplayTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    configuration: {
      opacity: 0.5
    }
  }) {
    super(toolProps, defaultToolProps);
    this._init = () => {
      var _a2;
      const viewportsInfo = getToolGroup_default(this.toolGroupId).viewportsInfo;
      if (!(viewportsInfo == null ? void 0 : viewportsInfo.length)) {
        console.warn(this.getToolName() + "Tool: No viewports found");
        return;
      }
      const firstViewport = (_a2 = getRenderingEngine(viewportsInfo[0].renderingEngineId)) == null ? void 0 : _a2.getViewport(viewportsInfo[0].viewportId);
      if (!firstViewport) {
        return;
      }
      const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();
      const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);
      if (!(annotations == null ? void 0 : annotations.length)) {
        const actorsWorldPointsMap = /* @__PURE__ */ new Map();
        calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo);
        const newAnnotation = {
          highlighted: true,
          invalidated: true,
          metadata: {
            toolName: this.getToolName(),
            FrameOfReferenceUID: frameOfReferenceUID,
            referencedImageId: null
          },
          data: {
            actorsWorldPointsMap
          }
        };
        addAnnotation(newAnnotation, frameOfReferenceUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportsInfo.map(({ viewportId }) => viewportId));
    };
    this.onSetToolEnabled = () => {
      this._init();
    };
    this.onCameraModified = (evt) => {
      this._init();
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      const { viewport, FrameOfReferenceUID } = enabledElement;
      let renderStatus = false;
      const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const annotation = annotations[0];
      const { annotationUID } = annotation;
      const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;
      calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);
      const actorEntries = viewport.getActors();
      const cacheId = getCacheId(viewport);
      actorEntries.forEach((actorEntry) => {
        if (!(actorEntry == null ? void 0 : actorEntry.clippingFilter)) {
          return;
        }
        const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);
        if (!actorWorldPointMap) {
          return;
        }
        if (!actorWorldPointMap.get(cacheId)) {
          return;
        }
        let polyLineIdx = 1;
        const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);
        for (let i = 0; i < worldPointsSet.length; i++) {
          const worldPoints = worldPointsSet[i];
          const canvasPoints = worldPoints.map((point) => viewport.worldToCanvas(point));
          const options = {
            color,
            fillColor: color,
            fillOpacity: this.configuration.opacity,
            closePath: true,
            lineWidth: 2
          };
          const polyLineUID = actorEntry.uid + "#" + polyLineIdx;
          drawPath(svgDrawingHelper, annotationUID, polyLineUID, canvasPoints, options);
          polyLineIdx++;
        }
      });
      renderStatus = true;
      return renderStatus;
    };
  }
};
function calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo) {
  viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
    var _a2;
    const viewport = (_a2 = getRenderingEngine(renderingEngineId)) == null ? void 0 : _a2.getViewport(viewportId);
    calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);
  });
}
function calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport) {
  const actorEntries = viewport.getActors();
  const cacheId = getCacheId(viewport);
  actorEntries.forEach((actorEntry) => {
    if (!(actorEntry == null ? void 0 : actorEntry.clippingFilter)) {
      return;
    }
    let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);
    if (!actorWorldPointsMap) {
      actorWorldPointsMap = /* @__PURE__ */ new Map();
      actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);
    }
    if (!actorWorldPointsMap.get(cacheId)) {
      const polyData = actorEntry.clippingFilter.getOutputData();
      const worldPointsSet = utils_exports.getPolyDataPoints(polyData);
      if (!worldPointsSet) {
        return;
      }
      const colorArray = actorEntry.actor.getProperty().getColor();
      const color = colorToString(colorArray);
      actorWorldPointsMap.set(cacheId, { worldPointsSet, color });
    }
  });
}
function getCacheId(viewport) {
  const { viewPlaneNormal } = viewport.getCamera();
  const imageIndex = viewport.getCurrentImageIdIndex();
  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;
}
function colorToString(colorArray) {
  function colorComponentToString(component) {
    let componentString = Math.floor(component * 255).toString(16);
    if (componentString.length === 1) {
      componentString = "0" + componentString;
    }
    return componentString;
  }
  return "#" + colorComponentToString(colorArray[0]) + colorComponentToString(colorArray[1]) + colorComponentToString(colorArray[2]);
}
SegmentationIntersectionTool.toolName = "SegmentationIntersection";
var SegmentationIntersectionTool_default = SegmentationIntersectionTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js
var ReferenceCursors = class extends AnnotationDisplayTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      shadow: true,
      preventHandleOutsideImage: false,
      displayThreshold: 5,
      positionSync: true,
      disableCursor: false
    }
  }) {
    super(toolProps, defaultToolProps);
    this.isDrawing = false;
    this.isHandleOutsideImage = false;
    this._elementWithCursor = null;
    this._currentCursorWorldPosition = null;
    this._currentCanvasPosition = null;
    this._disableCursorEnabled = false;
    this.mouseMoveCallback = (evt) => {
      const { detail } = evt;
      const { element, currentPoints } = detail;
      this._currentCursorWorldPosition = currentPoints.world;
      this._currentCanvasPosition = currentPoints.canvas;
      this._elementWithCursor = element;
      const annotation = this.getActiveAnnotation(element);
      if (annotation === null) {
        this.createInitialAnnotation(currentPoints.world, element);
        return false;
      }
      this.updateAnnotationPosition(element, annotation);
      return false;
    };
    this.createInitialAnnotation = (worldPos, element) => {
      const enabledElement = getEnabledElement(element);
      if (!enabledElement) {
        throw new Error("No enabled element found");
      }
      const { viewport, renderingEngine } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      if (!viewPlaneNormal || !viewUp) {
        throw new Error("Camera not found");
      }
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId
        },
        data: {
          label: "",
          handles: {
            points: [[...worldPos]],
            activeHandleIndex: null,
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            }
          }
        }
      };
      const annotations = getAnnotations(this.getToolName(), element);
      if (annotations.length > 0) {
        return null;
      }
      const annotationId = addAnnotation(annotation, element);
      if (annotationId === null) {
        return;
      }
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.onCameraModified = (evt) => {
      const eventDetail = evt.detail;
      const { element, previousCamera, camera } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const viewport = enabledElement.viewport;
      if (element !== this._elementWithCursor) {
        return;
      }
      const oldFocalPoint = previousCamera.focalPoint;
      const cameraNormal = camera.viewPlaneNormal;
      const newFocalPoint = camera.focalPoint;
      const deltaCameraFocalPoint = [0, 0, 0];
      vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);
      if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {
        return;
      }
      const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);
      if (Math.abs(dotProduct) < 0.01) {
        return;
      }
      if (!this._currentCanvasPosition) {
        return;
      }
      const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);
      this._currentCursorWorldPosition = newWorldPos;
      this.updateAnnotationPosition(element, this.getActiveAnnotation(element));
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport, FrameOfReferenceUID } = enabledElement;
      const isElementWithCursor = this._elementWithCursor === viewport.element;
      if (this.configuration.positionSync && !isElementWithCursor) {
        this.updateViewportImage(viewport);
      }
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { handles } = data;
        const { points } = handles;
        if (!annotationUID) {
          return renderStatus;
        }
        styleSpecifier.annotationUID = annotationUID;
        const lineWidthBase = parseFloat(this.getStyle("lineWidth", styleSpecifier, annotation));
        const lineWidth = typeof lineWidthBase === "number" && isElementWithCursor ? lineWidthBase : lineWidthBase;
        const lineDash = this.getStyle("lineDash", styleSpecifier, annotation);
        const color = this.getStyle("color", styleSpecifier, annotation);
        if (points[0].some((e) => isNaN(e))) {
          return renderStatus;
        }
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        const crosshairUIDs = {
          upper: "upper",
          right: "right",
          lower: "lower",
          left: "left"
        };
        const [x, y] = canvasCoordinates[0];
        const centerSpace = isElementWithCursor ? 20 : 7;
        const lineLength = isElementWithCursor ? 5 : 7;
        drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });
        drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });
        drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });
        drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });
        renderStatus = true;
      }
      return renderStatus;
    };
    this._disableCursorEnabled = this.configuration.disableCursor;
  }
  onSetToolActive() {
    this._disableCursorEnabled = this.configuration.disableCursor;
    if (!this._disableCursorEnabled) {
      return;
    }
    const viewportIds = getToolGroup_default(this.toolGroupId).viewportsInfo;
    if (!viewportIds) {
      return;
    }
    const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));
    enabledElements.forEach((element) => {
      if (element) {
        hideElementCursor(element.viewport.element);
      }
    });
  }
  onSetToolDisabled() {
    if (!this._disableCursorEnabled) {
      return;
    }
    const viewportIds = getToolGroup_default(this.toolGroupId).viewportsInfo;
    if (!viewportIds) {
      return;
    }
    const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));
    enabledElements.forEach((element) => {
      if (element) {
        resetElementCursor(element.viewport.element);
      }
    });
  }
  getActiveAnnotation(element) {
    const annotations = getAnnotations(this.getToolName(), element);
    if (!annotations.length) {
      return null;
    }
    const targetAnnotation = annotations[0];
    return targetAnnotation;
  }
  updateAnnotationPosition(element, annotation) {
    var _a2, _b2;
    const worldPos = this._currentCursorWorldPosition;
    if (!worldPos) {
      return;
    }
    if (!((_b2 = (_a2 = annotation.data) == null ? void 0 : _a2.handles) == null ? void 0 : _b2.points)) {
      return;
    }
    annotation.data.handles.points = [[...worldPos]];
    annotation.invalidated = true;
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);
    const enabledElement = getEnabledElement(element);
    if (!enabledElement) {
      return;
    }
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
  }
  filterInteractableAnnotationsForElement(element, annotations) {
    var _a2, _b2, _c;
    if (!(annotations instanceof Array) || annotations.length === 0) {
      return [];
    }
    const annotation = annotations[0];
    const viewport = (_a2 = getEnabledElement(element)) == null ? void 0 : _a2.viewport;
    if (!viewport) {
      return [];
    }
    const camera = viewport.getCamera();
    const { viewPlaneNormal, focalPoint } = camera;
    if (!viewPlaneNormal || !focalPoint) {
      return [];
    }
    const points = (_c = (_b2 = annotation.data) == null ? void 0 : _b2.handles) == null ? void 0 : _c.points;
    if (!(points instanceof Array) || points.length !== 1) {
      return [];
    }
    const worldPos = points[0];
    const plane = utilities_exports.planar.planeEquation(viewPlaneNormal, focalPoint);
    const distance = utilities_exports.planar.planeDistanceToPoint(plane, worldPos);
    return distance < this.configuration.displayThreshold ? [annotation] : [];
  }
  updateViewportImage(viewport) {
    const currentMousePosition = this._currentCursorWorldPosition;
    if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {
      return;
    }
    if (viewport instanceof StackViewport_default) {
      const closestIndex = utilities_exports.getClosestStackImageIndexForPoint(currentMousePosition, viewport);
      if (closestIndex === null) {
        return;
      }
      if (closestIndex !== viewport.getCurrentImageIdIndex()) {
        viewport.setImageIdIndex(closestIndex);
      }
    } else if (viewport instanceof VolumeViewport_default) {
      const { focalPoint, viewPlaneNormal } = viewport.getCamera();
      if (!focalPoint || !viewPlaneNormal) {
        return;
      }
      const plane = utilities_exports.planar.planeEquation(viewPlaneNormal, focalPoint);
      const currentDistance = utilities_exports.planar.planeDistanceToPoint(plane, currentMousePosition, true);
      if (Math.abs(currentDistance) < 0.5) {
        return;
      }
      const normalizedViewPlane = vec3_exports.normalize(vec3_exports.create(), vec3_exports.fromValues(...viewPlaneNormal));
      const scaledPlaneNormal = vec3_exports.scale(vec3_exports.create(), normalizedViewPlane, currentDistance);
      const newFocalPoint = vec3_exports.add(vec3_exports.create(), vec3_exports.fromValues(...focalPoint), scaledPlaneNormal);
      const isInBounds = true;
      if (isInBounds) {
        viewport.setCamera({ focalPoint: newFocalPoint });
        const renderingEngine = viewport.getRenderingEngine();
        if (renderingEngine) {
          renderingEngine.renderViewport(viewport.id);
        }
      }
    }
  }
};
ReferenceCursors.toolName = "ReferenceCursors";
var ReferenceCursors_default = ReferenceCursors;

// node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js
var viewportsWithAnnotations = [];
var ScaleOverlayTool = class extends AnnotationDisplayTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    configuration: {
      viewportId: "",
      scaleLocation: "bottom"
    }
  }) {
    super(toolProps, defaultToolProps);
    this.editData = null;
    this._init = () => {
      var _a2, _b2;
      const renderingEngines = getRenderingEngines();
      const renderingEngine = renderingEngines[0];
      if (!renderingEngine) {
        return;
      }
      const viewportIds = getToolGroup_default(this.toolGroupId).viewportsInfo;
      if (!viewportIds) {
        return;
      }
      const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));
      let { viewport } = enabledElements[0];
      const { FrameOfReferenceUID } = enabledElements[0];
      if (this.configuration.viewportId) {
        enabledElements.forEach((element) => {
          if (element.viewport.id == this.configuration.viewportId) {
            viewport = element.viewport;
          }
        });
      }
      if (!viewport) {
        return;
      }
      const { viewUp, viewPlaneNormal } = viewport.getCamera();
      const viewportCanvasCornersInWorld = utilities_exports.getViewportImageCornersInWorld(viewport);
      let annotation = (_a2 = this.editData) == null ? void 0 : _a2.annotation;
      const annotations = getAnnotations(this.getToolName(), viewport.element);
      if (annotations.length) {
        annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];
      }
      enabledElements.forEach((element) => {
        const { viewport: viewport2 } = element;
        if (!viewportsWithAnnotations.includes(viewport2.id)) {
          const newAnnotation = {
            metadata: {
              toolName: this.getToolName(),
              viewPlaneNormal: [...viewPlaneNormal],
              viewUp: [...viewUp],
              FrameOfReferenceUID,
              referencedImageId: null
            },
            data: {
              handles: {
                points: utilities_exports.getViewportImageCornersInWorld(viewport2)
              },
              viewportId: viewport2.id
            }
          };
          viewportsWithAnnotations.push(viewport2.id);
          addAnnotation(newAnnotation, viewport2.element);
          annotation = newAnnotation;
        }
      });
      if (((_b2 = this.editData) == null ? void 0 : _b2.annotation) && this.editData.annotation.data.viewportId == viewport.id) {
        this.editData.annotation.data.handles.points = viewportCanvasCornersInWorld;
        this.editData.annotation.data.viewportId = viewport.id;
      }
      this.editData = {
        viewport,
        renderingEngine,
        annotation
      };
    };
    this.onSetToolEnabled = () => {
      this._init();
    };
    this.onCameraModified = (evt) => {
      this.configuration.viewportId = evt.detail.viewportId;
      this._init();
    };
    this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {
      const scaleSizes = [
        16e3,
        8e3,
        4e3,
        2e3,
        1e3,
        500,
        250,
        100,
        50,
        25,
        10,
        5,
        2
      ];
      let currentScaleSize;
      if (location == "top" || location == "bottom") {
        currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 && scaleSize > worldWidthViewport * 0.2);
      } else {
        currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 && scaleSize > worldHeightViewport * 0.2);
      }
      return currentScaleSize[0];
    };
    this.computeEndScaleTicks = (canvasCoordinates, location) => {
      const locationTickOffset = {
        bottom: [
          [0, -10],
          [0, -10]
        ],
        top: [
          [0, 10],
          [0, 10]
        ],
        left: [
          [0, 0],
          [10, 0]
        ],
        right: [
          [0, 0],
          [-10, 0]
        ]
      };
      const endTick1 = [
        [
          canvasCoordinates[1][0] + locationTickOffset[location][0][0],
          canvasCoordinates[1][1] + locationTickOffset[location][0][0]
        ],
        [
          canvasCoordinates[1][0] + locationTickOffset[location][1][0],
          canvasCoordinates[1][1] + locationTickOffset[location][1][1]
        ]
      ];
      const endTick2 = [
        [
          canvasCoordinates[0][0] + locationTickOffset[location][0][0],
          canvasCoordinates[0][1] + locationTickOffset[location][0][0]
        ],
        [
          canvasCoordinates[0][0] + locationTickOffset[location][1][0],
          canvasCoordinates[0][1] + locationTickOffset[location][1][1]
        ]
      ];
      return {
        endTick1,
        endTick2
      };
    };
    this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {
      let canvasScaleSize;
      if (location == "bottom" || location == "top") {
        canvasScaleSize = rightTick[0][0] - leftTick[0][0];
      } else if (location == "left" || location == "right") {
        canvasScaleSize = rightTick[0][1] - leftTick[0][1];
      }
      const tickIds = [];
      const tickUIDs = [];
      const tickCoordinates = [];
      let numberSmallTicks = scaleSize;
      if (scaleSize >= 50) {
        numberSmallTicks = scaleSize / 10;
      }
      const tickSpacing = canvasScaleSize / numberSmallTicks;
      for (let i = 0; i < numberSmallTicks - 1; i++) {
        const locationOffset = {
          bottom: [
            [tickSpacing * (i + 1), 0],
            [tickSpacing * (i + 1), 5]
          ],
          top: [
            [tickSpacing * (i + 1), 0],
            [tickSpacing * (i + 1), -5]
          ],
          left: [
            [0, tickSpacing * (i + 1)],
            [-5, tickSpacing * (i + 1)]
          ],
          right: [
            [0, tickSpacing * (i + 1)],
            [5, tickSpacing * (i + 1)]
          ]
        };
        tickIds.push(`${annotationUID}-tick${i}`);
        tickUIDs.push(`tick${i}`);
        if ((i + 1) % 5 == 0) {
          tickCoordinates.push([
            [
              leftTick[0][0] + locationOffset[location][0][0],
              leftTick[0][1] + locationOffset[location][0][1]
            ],
            [
              leftTick[1][0] + locationOffset[location][0][0],
              leftTick[1][1] + locationOffset[location][0][1]
            ]
          ]);
        } else {
          tickCoordinates.push([
            [
              leftTick[0][0] + locationOffset[location][0][0],
              leftTick[0][1] + locationOffset[location][0][1]
            ],
            [
              leftTick[1][0] + locationOffset[location][1][0],
              leftTick[1][1] + locationOffset[location][1][1]
            ]
          ]);
        }
      }
      return { tickIds, tickUIDs, tickCoordinates };
    };
    this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {
      let worldCoordinates;
      let topBottomVec = vec3_exports.subtract(vec3_exports.create(), pointSet[0], pointSet[1]);
      topBottomVec = vec3_exports.normalize(vec3_exports.create(), topBottomVec);
      let topRightVec = vec3_exports.subtract(vec3_exports.create(), pointSet[2], pointSet[0]);
      topRightVec = vec3_exports.normalize(vec3_exports.create(), topRightVec);
      const midpointLocation = {
        bottom: [pointSet[1], pointSet[2]],
        top: [pointSet[0], pointSet[3]],
        right: [pointSet[2], pointSet[3]],
        left: [pointSet[0], pointSet[1]]
      };
      const midpoint = vec3_exports.add(vec3_exports.create(), midpointLocation[location][0], midpointLocation[location][0]).map((i) => i / 2);
      const offset = scaleSize / 2 / Math.sqrt(Math.pow(topBottomVec[0], 2) + Math.pow(topBottomVec[1], 2) + Math.pow(topBottomVec[2], 2));
      if (location == "top" || location == "bottom") {
        worldCoordinates = [
          vec3_exports.subtract(vec3_exports.create(), midpoint, topRightVec.map((i) => i * offset)),
          vec3_exports.add(vec3_exports.create(), midpoint, topRightVec.map((i) => i * offset))
        ];
      } else if (location == "left" || location == "right") {
        worldCoordinates = [
          vec3_exports.add(vec3_exports.create(), midpoint, topBottomVec.map((i) => i * offset)),
          vec3_exports.subtract(vec3_exports.create(), midpoint, topBottomVec.map((i) => i * offset))
        ];
      }
      return worldCoordinates;
    };
    this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {
      let scaleCanvasCoordinates;
      if (location == "top" || location == "bottom") {
        const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];
        scaleCanvasCoordinates = [
          [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],
          [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height]
        ];
      } else if (location == "left" || location == "right") {
        const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];
        scaleCanvasCoordinates = [
          [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],
          [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2]
        ];
      }
      return scaleCanvasCoordinates;
    };
    this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {
      const hReduction = horizontalReduction * Math.min(1e3, canvasSize.width);
      const vReduction = verticalReduction * Math.min(1e3, canvasSize.height);
      const locationBounds = {
        bottom: [-vReduction, -hReduction],
        top: [vReduction, hReduction],
        left: [vReduction, hReduction],
        right: [-vReduction, -hReduction]
      };
      const canvasBounds = {
        bottom: [canvasSize.height, canvasSize.width],
        top: [0, canvasSize.width],
        left: [canvasSize.height, 0],
        right: [canvasSize.height, canvasSize.width]
      };
      return {
        height: canvasBounds[location][0] + locationBounds[location][0],
        width: canvasBounds[location][1] + locationBounds[location][1]
      };
    };
  }
  renderAnnotation(enabledElement, svgDrawingHelper) {
    if (!this.editData || !this.editData.viewport) {
      return;
    }
    const location = this.configuration.scaleLocation;
    const { viewport } = enabledElement;
    const annotations = getAnnotations(this.getToolName(), viewport.element);
    const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];
    const canvas = enabledElement.viewport.canvas;
    const renderStatus = false;
    if (!viewport) {
      return renderStatus;
    }
    const styleSpecifier = {
      toolGroupId: this.toolGroupId,
      toolName: this.getToolName(),
      viewportId: enabledElement.viewport.id
    };
    const canvasSize = {
      width: canvas.width / window.devicePixelRatio || 1,
      height: canvas.height / window.devicePixelRatio || 1
    };
    const topLeft = annotation.data.handles.points[0];
    const topRight = annotation.data.handles.points[1];
    const bottomLeft = annotation.data.handles.points[2];
    const bottomRight = annotation.data.handles.points[3];
    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
    const worldWidthViewport = vec3_exports.distance(bottomLeft, bottomRight);
    const worldHeightViewport = vec3_exports.distance(topLeft, bottomLeft);
    const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);
    const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);
    const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);
    const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));
    const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);
    const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);
    const { annotationUID } = annotation;
    styleSpecifier.annotationUID = annotationUID;
    const lineWidth = this.getStyle("lineWidth", styleSpecifier, annotation);
    const lineDash = this.getStyle("lineDash", styleSpecifier, annotation);
    const color = this.getStyle("color", styleSpecifier, annotation);
    const shadow = this.getStyle("shadow", styleSpecifier, annotation);
    const scaleId = `${annotationUID}-scaleline`;
    const scaleLineUID = "1";
    drawLine(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {
      color,
      width: lineWidth,
      lineDash,
      shadow
    }, scaleId);
    const leftTickId = `${annotationUID}-left`;
    const leftTickUID = "2";
    drawLine(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {
      color,
      width: lineWidth,
      lineDash,
      shadow
    }, leftTickId);
    const rightTickId = `${annotationUID}-right`;
    const rightTickUID = "3";
    drawLine(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {
      color,
      width: lineWidth,
      lineDash,
      shadow
    }, rightTickId);
    const locationTextOffest = {
      bottom: [-10, -42],
      top: [-12, -35],
      left: [-40, -20],
      right: [-50, -20]
    };
    const textCanvasCoordinates = [
      scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],
      scaleCanvasCoordinates[0][1] + locationTextOffest[location][1]
    ];
    const textBoxLines = this._getTextLines(scaleSize);
    const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);
    for (let i = 0; i < tickUIDs.length; i++) {
      drawLine(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {
        color,
        width: lineWidth,
        lineDash,
        shadow
      }, tickIds[i]);
    }
    const textUID = "text0";
    drawTextBox_default(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {
      fontFamily: "Helvetica Neue, Helvetica, Arial, sans-serif",
      fontSize: "14px",
      lineDash: "2,3",
      lineWidth: "1",
      shadow: true,
      color
    });
    return renderStatus;
  }
  _getTextLines(scaleSize) {
    let scaleSizeDisplayValue;
    let scaleSizeUnits;
    if (scaleSize >= 50) {
      scaleSizeDisplayValue = scaleSize / 10;
      scaleSizeUnits = " cm";
    } else {
      scaleSizeDisplayValue = scaleSize;
      scaleSizeUnits = " mm";
    }
    const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];
    return textLines;
  }
};
ScaleOverlayTool.toolName = "ScaleOverlay";
var ScaleOverlayTool_default = ScaleOverlayTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/distancePointToContour.js
var distancePointToContour = (viewport, annotation, coords) => {
  var _a2, _b2, _c;
  if (!((_c = (_b2 = (_a2 = annotation == null ? void 0 : annotation.data) == null ? void 0 : _a2.contour) == null ? void 0 : _b2.polyline) == null ? void 0 : _c.length)) {
    return;
  }
  const { polyline } = annotation.data.contour;
  const { length } = polyline;
  let distance = Infinity;
  for (let i = 0; i < length; i++) {
    const canvasPoint = viewport.worldToCanvas(polyline[i]);
    const distanceToPoint5 = point_exports.distanceToPoint(canvasPoint, coords);
    distance = Math.min(distance, distanceToPoint5);
  }
  if (distance === Infinity || isNaN(distance)) {
    return;
  }
  return distance;
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool/CircleSculptCursor.js
var _CircleSculptCursor = class _CircleSculptCursor {
  constructor() {
    this.toolInfo = {
      toolSize: null,
      maxToolSize: null
    };
  }
  renderShape(svgDrawingHelper, canvasLocation, options) {
    const circleUID = "0";
    drawCircle_default(svgDrawingHelper, "SculptorTool", circleUID, canvasLocation, this.toolInfo.toolSize, options);
  }
  pushHandles(viewport, sculptData) {
    const { points, mouseCanvasPoint } = sculptData;
    const pushedHandles = { first: void 0, last: void 0 };
    for (let i = 0; i < points.length; i++) {
      const handleCanvasPoint = viewport.worldToCanvas(points[i]);
      const distanceToHandle = point_exports.distanceToPoint(handleCanvasPoint, mouseCanvasPoint);
      if (distanceToHandle > this.toolInfo.toolSize) {
        continue;
      }
      this.pushOneHandle(i, distanceToHandle, sculptData);
      if (pushedHandles.first === void 0) {
        pushedHandles.first = i;
        pushedHandles.last = i;
      } else {
        pushedHandles.last = i;
      }
    }
    return pushedHandles;
  }
  configureToolSize(evt) {
    const toolInfo = this.toolInfo;
    if (toolInfo.toolSize && toolInfo.maxToolSize) {
      return;
    }
    const eventData = evt.detail;
    const element = eventData.element;
    const minDim = Math.min(element.clientWidth, element.clientHeight);
    const maxRadius = minDim / 12;
    toolInfo.toolSize = maxRadius;
    toolInfo.maxToolSize = maxRadius;
  }
  updateToolSize(canvasCoords, viewport, activeAnnotation) {
    const toolInfo = this.toolInfo;
    const radius = distancePointToContour(viewport, activeAnnotation, canvasCoords);
    if (radius > 0) {
      toolInfo.toolSize = Math.min(toolInfo.maxToolSize, radius);
    }
  }
  getMaxSpacing(minSpacing) {
    return Math.max(this.toolInfo.toolSize / 4, minSpacing);
  }
  getInsertPosition(previousIndex, nextIndex, sculptData) {
    let insertPosition;
    const { points, element, mouseCanvasPoint } = sculptData;
    const toolSize = this.toolInfo.toolSize;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const previousCanvasPoint = viewport.worldToCanvas(points[previousIndex]);
    const nextCanvasPoint = viewport.worldToCanvas(points[nextIndex]);
    const midPoint3 = [
      (previousCanvasPoint[0] + nextCanvasPoint[0]) / 2,
      (previousCanvasPoint[1] + nextCanvasPoint[1]) / 2
    ];
    const distanceToMidPoint = point_exports.distanceToPoint(mouseCanvasPoint, midPoint3);
    if (distanceToMidPoint < toolSize) {
      const directionUnitVector = {
        x: (midPoint3[0] - mouseCanvasPoint[0]) / distanceToMidPoint,
        y: (midPoint3[1] - mouseCanvasPoint[1]) / distanceToMidPoint
      };
      insertPosition = [
        mouseCanvasPoint[0] + toolSize * directionUnitVector.x,
        mouseCanvasPoint[1] + toolSize * directionUnitVector.y
      ];
    } else {
      insertPosition = midPoint3;
    }
    const worldPosition = viewport.canvasToWorld(insertPosition);
    return worldPosition;
  }
  pushOneHandle(i, distanceToHandle, sculptData) {
    const { points, mousePoint } = sculptData;
    const toolSize = this.toolInfo.toolSize;
    const handle = points[i];
    const directionUnitVector = {
      x: (handle[0] - mousePoint[0]) / distanceToHandle,
      y: (handle[1] - mousePoint[1]) / distanceToHandle,
      z: (handle[2] - mousePoint[2]) / distanceToHandle
    };
    const position = {
      x: mousePoint[0] + toolSize * directionUnitVector.x,
      y: mousePoint[1] + toolSize * directionUnitVector.y,
      z: mousePoint[2] + toolSize * directionUnitVector.z
    };
    handle[0] = position.x;
    handle[1] = position.y;
    handle[2] = position.z;
  }
};
_CircleSculptCursor.shapeName = "Circle";
var CircleSculptCursor = _CircleSculptCursor;
var CircleSculptCursor_default = CircleSculptCursor;

// node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool.js
var SculptorTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      minSpacing: 1,
      referencedToolNames: [
        "PlanarFreehandROI",
        "PlanarFreehandContourSegmentationTool"
      ],
      toolShape: "circle",
      referencedToolName: "PlanarFreehandROI"
    }
  }) {
    super(toolProps, defaultToolProps);
    this.registeredShapes = /* @__PURE__ */ new Map();
    this.isActive = false;
    this.commonData = {
      activeAnnotationUID: null,
      viewportIdsToRender: [],
      isEditingOpenContour: false,
      canvasLocation: void 0
    };
    this.preMouseDownCallback = (evt) => {
      const eventData = evt.detail;
      const element = eventData.element;
      this.configureToolSize(evt);
      this.selectFreehandTool(eventData);
      if (this.commonData.activeAnnotationUID === null) {
        return;
      }
      this.isActive = true;
      hideElementCursor(element);
      this.activateModify(element);
      return true;
    };
    this.mouseMoveCallback = (evt) => {
      if (this.mode === ToolModes_default.Active) {
        this.configureToolSize(evt);
        this.updateCursor(evt);
      } else {
        this.commonData.canvasLocation = void 0;
      }
    };
    this.endCallback = (evt) => {
      const eventData = evt.detail;
      const { element } = eventData;
      const config = this.configuration;
      const enabledElement = getEnabledElement(element);
      this.isActive = false;
      this.deactivateModify(element);
      resetElementCursor(element);
      const { renderingEngineId, viewportId } = enabledElement;
      const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
      const toolInstance = toolGroup.getToolInstance(config.referencedToolName);
      const annotations = this.filterSculptableAnnotationsForElement(element);
      const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
      if (toolInstance.configuration.calculateStats) {
        activeAnnotation.invalidated = true;
      }
      triggerAnnotationModified(activeAnnotation, element);
    };
    this.dragCallback = (evt) => {
      const eventData = evt.detail;
      const element = eventData.element;
      this.updateCursor(evt);
      const annotations = this.filterSculptableAnnotationsForElement(element);
      const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
      if (!(annotations == null ? void 0 : annotations.length) || !this.isActive) {
        return;
      }
      const points = activeAnnotation.data.contour.polyline;
      this.sculpt(eventData, points);
    };
    this.registerShapes(CircleSculptCursor_default.shapeName, CircleSculptCursor_default);
    this.setToolShape(this.configuration.toolShape);
  }
  registerShapes(shapeName, shapeClass) {
    const shape = new shapeClass();
    this.registeredShapes.set(shapeName, shape);
  }
  sculpt(eventData, points) {
    const config = this.configuration;
    const element = eventData.element;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const cursorShape = this.registeredShapes.get(this.selectedShape);
    this.sculptData = {
      mousePoint: eventData.currentPoints.world,
      mouseCanvasPoint: eventData.currentPoints.canvas,
      points,
      maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),
      element
    };
    const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);
    if (pushedHandles.first !== void 0) {
      this.insertNewHandles(pushedHandles);
    }
  }
  interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing) {
    const { element } = this.sculptData;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const nextHandleIndex = contourIndex(i + 1, points.length);
    const currentCanvasPoint = viewport.worldToCanvas(points[i]);
    const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);
    const distanceToNextHandle = point_exports.distanceToPoint(currentCanvasPoint, nextCanvasPoint);
    if (distanceToNextHandle > maxSpacing) {
      indicesToInsertAfter.push(i);
    }
  }
  updateCursor(evt) {
    const eventData = evt.detail;
    const element = eventData.element;
    const enabledElement = getEnabledElement(element);
    const { renderingEngine, viewport } = enabledElement;
    this.commonData.viewportIdsToRender = [viewport.id];
    const annotations = this.filterSculptableAnnotationsForElement(element);
    if (!(annotations == null ? void 0 : annotations.length)) {
      return;
    }
    const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
    this.commonData.canvasLocation = eventData.currentPoints.canvas;
    if (this.isActive) {
      activeAnnotation.highlighted = true;
    } else {
      const cursorShape = this.registeredShapes.get(this.selectedShape);
      const canvasCoords = eventData.currentPoints.canvas;
      cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);
    }
    triggerAnnotationRenderForViewportIds(this.commonData.viewportIdsToRender);
  }
  filterSculptableAnnotationsForElement(element) {
    const config = this.configuration;
    const enabledElement = getEnabledElement(element);
    const { renderingEngineId, viewportId } = enabledElement;
    const sculptableAnnotations = [];
    const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
    const toolInstance = toolGroup.getToolInstance(config.referencedToolName);
    config.referencedToolNames.forEach((referencedToolName) => {
      const annotations = getAnnotations(referencedToolName, element);
      if (annotations) {
        sculptableAnnotations.push(...annotations);
      }
    });
    return toolInstance.filterInteractableAnnotationsForElement(element, sculptableAnnotations);
  }
  configureToolSize(evt) {
    const cursorShape = this.registeredShapes.get(this.selectedShape);
    cursorShape.configureToolSize(evt);
  }
  insertNewHandles(pushedHandles) {
    const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);
    let newIndexModifier = 0;
    for (let i = 0; i < (indicesToInsertAfter == null ? void 0 : indicesToInsertAfter.length); i++) {
      const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;
      this.insertHandleRadially(insertIndex);
      newIndexModifier++;
    }
  }
  findNewHandleIndices(pushedHandles) {
    const { points, maxSpacing } = this.sculptData;
    const indicesToInsertAfter = [];
    for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {
      this.interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing);
    }
    return indicesToInsertAfter;
  }
  insertHandleRadially(insertIndex) {
    const { points } = this.sculptData;
    if (insertIndex > points.length - 1 && this.commonData.isEditingOpenContour) {
      return;
    }
    const cursorShape = this.registeredShapes.get(this.selectedShape);
    const previousIndex = insertIndex - 1;
    const nextIndex = contourIndex(insertIndex, points.length);
    const insertPosition = cursorShape.getInsertPosition(previousIndex, nextIndex, this.sculptData);
    const handleData = insertPosition;
    points.splice(insertIndex, 0, handleData);
  }
  selectFreehandTool(eventData) {
    const closestAnnotationUID = this.getClosestFreehandToolOnElement(eventData);
    if (closestAnnotationUID === void 0) {
      return;
    }
    this.commonData.activeAnnotationUID = closestAnnotationUID;
  }
  getClosestFreehandToolOnElement(eventData) {
    const { element } = eventData;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const config = this.configuration;
    const annotations = this.filterSculptableAnnotationsForElement(element);
    if (!(annotations == null ? void 0 : annotations.length)) {
      return;
    }
    const canvasPoints = eventData.currentPoints.canvas;
    const closest = {
      distance: Infinity,
      toolIndex: void 0,
      annotationUID: void 0
    };
    for (let i = 0; i < (annotations == null ? void 0 : annotations.length); i++) {
      if (annotations[i].isLocked || !annotations[i].isVisible) {
        continue;
      }
      const distanceFromTool = distancePointToContour(viewport, annotations[i], canvasPoints);
      if (distanceFromTool === -1) {
        continue;
      }
      if (distanceFromTool < closest.distance) {
        closest.distance = distanceFromTool;
        closest.toolIndex = i;
        closest.annotationUID = annotations[i].annotationUID;
      }
    }
    this.commonData.isEditingOpenContour = !annotations[closest.toolIndex].data.contour.closed;
    config.referencedToolName = annotations[closest.toolIndex].metadata.toolName;
    return closest.annotationUID;
  }
  activateModify(element) {
    element.addEventListener(Events_default.MOUSE_UP, this.endCallback);
    element.addEventListener(Events_default.MOUSE_CLICK, this.endCallback);
    element.addEventListener(Events_default.MOUSE_DRAG, this.dragCallback);
    element.addEventListener(Events_default.TOUCH_TAP, this.endCallback);
    element.addEventListener(Events_default.TOUCH_END, this.endCallback);
    element.addEventListener(Events_default.TOUCH_DRAG, this.dragCallback);
  }
  deactivateModify(element) {
    element.removeEventListener(Events_default.MOUSE_UP, this.endCallback);
    element.removeEventListener(Events_default.MOUSE_CLICK, this.endCallback);
    element.removeEventListener(Events_default.MOUSE_DRAG, this.dragCallback);
    element.removeEventListener(Events_default.TOUCH_TAP, this.endCallback);
    element.removeEventListener(Events_default.TOUCH_END, this.endCallback);
    element.removeEventListener(Events_default.TOUCH_DRAG, this.dragCallback);
  }
  setToolShape(toolShape) {
    this.selectedShape = this.registeredShapes.get(toolShape) ?? CircleSculptCursor_default.shapeName;
  }
  renderAnnotation(enabledElement, svgDrawingHelper) {
    const { viewport } = enabledElement;
    const { element } = viewport;
    const viewportIdsToRender = this.commonData.viewportIdsToRender;
    if (!this.commonData.canvasLocation || this.mode !== ToolModes_default.Active || !viewportIdsToRender.includes(viewport.id)) {
      return;
    }
    const annotations = this.filterSculptableAnnotationsForElement(element);
    if (!(annotations == null ? void 0 : annotations.length)) {
      return;
    }
    const styleSpecifier = {
      toolGroupId: this.toolGroupId,
      toolName: this.getToolName(),
      viewportId: enabledElement.viewport.id
    };
    let color = getStyleProperty("color", styleSpecifier, AnnotationStyleStates_default.Default, this.mode);
    if (this.isActive) {
      color = getStyleProperty("color", styleSpecifier, AnnotationStyleStates_default.Highlighted, this.mode);
    }
    const cursorShape = this.registeredShapes.get(this.selectedShape);
    cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {
      color
    });
  }
};
var contourIndex = (i, length) => {
  return (i + length) % length;
};
SculptorTool.toolName = "SculptorTool";
var SculptorTool_default = SculptorTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js
var DIRECTIONS = {
  X: [1, 0, 0],
  Y: [0, 1, 0],
  Z: [0, 0, 1],
  CUSTOM: []
};
var VolumeRotateTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      direction: DIRECTIONS.Z,
      rotateIncrementDegrees: 30
    }
  }) {
    super(toolProps, defaultToolProps);
  }
  mouseWheelCallback(evt) {
    const { element, wheel } = evt.detail;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const { direction, rotateIncrementDegrees } = this.configuration;
    const camera = viewport.getCamera();
    const { viewUp, position, focalPoint } = camera;
    const { direction: deltaY } = wheel;
    const [cx, cy, cz] = focalPoint;
    const [ax, ay, az] = direction;
    const angle = deltaY * (rotateIncrementDegrees * Math.PI) / 180;
    const newPosition = [0, 0, 0];
    const newFocalPoint = [0, 0, 0];
    const newViewUp = [0, 0, 0];
    const transform = mat4_exports.identity(new Float32Array(16));
    mat4_exports.translate(transform, transform, [cx, cy, cz]);
    mat4_exports.rotate(transform, transform, angle, [ax, ay, az]);
    mat4_exports.translate(transform, transform, [-cx, -cy, -cz]);
    vec3_exports.transformMat4(newPosition, position, transform);
    vec3_exports.transformMat4(newFocalPoint, focalPoint, transform);
    mat4_exports.identity(transform);
    mat4_exports.rotate(transform, transform, angle, [ax, ay, az]);
    vec3_exports.transformMat4(newViewUp, viewUp, transform);
    viewport.setCamera({
      position: newPosition,
      viewUp: newViewUp,
      focalPoint: newFocalPoint
    });
    viewport.render();
  }
};
VolumeRotateTool.toolName = "VolumeRotateMouseWheel";
var VolumeRotateTool_default = VolumeRotateTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js
var { transformWorldToIndex: transformWorldToIndex11 } = utilities_exports;
var _LengthTool = class _LengthTool extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      preventHandleOutsideImage: false,
      getTextLines: defaultGetTextLines5,
      actions: {
        undo: {
          method: "undo",
          bindings: [{ key: "z" }]
        },
        redo: {
          method: "redo",
          bindings: [{ key: "y" }]
        }
      }
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      hideElementCursor(element);
      this.isDrawing = true;
      const { viewPlaneNormal, viewUp, position: cameraPosition } = viewport.getCamera();
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          ...viewport.getViewReference({ points: [worldPos] }),
          toolName: this.getToolName(),
          referencedImageId,
          viewUp,
          cameraPosition
        },
        data: {
          handles: {
            points: [[...worldPos], [...worldPos]],
            activeHandleIndex: null,
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            }
          },
          label: "",
          cachedStats: {}
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex: 1,
        movingTextBox: false,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const [point1, point2] = data.handles.points;
      const canvasPoint1 = viewport.worldToCanvas(point1);
      const canvasPoint2 = viewport.worldToCanvas(point2);
      const line = {
        start: {
          x: canvasPoint1[0],
          y: canvasPoint1[1]
        },
        end: {
          x: canvasPoint2[0],
          y: canvasPoint2[1]
        }
      };
      const distanceToPoint5 = distanceToPoint3([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
      if (distanceToPoint5 <= proximity) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        movingTextBox: false
      };
      this._activateModify(element);
      hideElementCursor(element);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      this.doneEditMemo();
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
      this.editData = null;
      this.isDrawing = false;
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation } = this.editData;
      const { data } = annotation;
      this.createMemo(element, annotation, { newAnnotation });
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const points = data.handles.points;
        points.forEach((point) => {
          point[0] += worldPosDelta[0];
          point[1] += worldPosDelta[1];
          point[2] += worldPosDelta[2];
        });
        annotation.invalidated = true;
      } else {
        const { currentPoints } = eventDetail;
        const worldPos = currentPoints.world;
        data.handles.points[handleIndex] = [...worldPos];
        annotation.invalidated = true;
      }
      this.editData.hasMoved = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.cancel = (element) => {
      if (this.isDrawing) {
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        resetElementCursor(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        const { data } = annotation;
        annotation.highlighted = false;
        data.handles.activeHandleIndex = null;
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        if (newAnnotation) {
          triggerAnnotationCompleted(annotation);
        }
        this.editData = null;
        return annotation.annotationUID;
      }
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const targetId = this.getTargetId(viewport);
      const renderingEngine = viewport.getRenderingEngine();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { points, activeHandleIndex } = data.handles;
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        if (!data.cachedStats[targetId] || data.cachedStats[targetId].unit == null) {
          data.cachedStats[targetId] = {
            length: null,
            unit: null
          };
          this._calculateCachedStats(annotation, renderingEngine, enabledElement);
        } else if (annotation.invalidated) {
          this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
        }
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        let activeHandleCanvasCoords;
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
            color,
            lineDash,
            lineWidth
          });
        }
        const dataId = `${annotationUID}-line`;
        const lineUID = "1";
        drawLine(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
          color,
          width: lineWidth,
          lineDash,
          shadow
        }, dataId);
        renderStatus = true;
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        if (!options.visibility) {
          data.handles.textBox = {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          };
          continue;
        }
        const textLines = this.configuration.getTextLines(data, targetId);
        if (!data.handles.textBox.hasMoved) {
          const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);
          data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
        }
        const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
        const textBoxUID = "1";
        const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
        const { x: left, y: top, width, height } = boundingBox;
        data.handles.textBox.worldBoundingBox = {
          topLeft: viewport.canvasToWorld([left, top]),
          topRight: viewport.canvasToWorld([left + width, top]),
          bottomLeft: viewport.canvasToWorld([left, top + height]),
          bottomRight: viewport.canvasToWorld([left + width, top + height])
        };
      }
      return renderStatus;
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
  handleSelectedCallback(evt, annotation, handle) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const { data } = annotation;
    annotation.highlighted = true;
    let movingTextBox = false;
    let handleIndex;
    if (handle.worldPosition) {
      movingTextBox = true;
    } else {
      handleIndex = data.handles.points.findIndex((p) => p === handle);
    }
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    this.editData = {
      annotation,
      viewportIdsToRender,
      handleIndex,
      movingTextBox
    };
    this._activateModify(element);
    hideElementCursor(element);
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    evt.preventDefault();
  }
  _calculateLength(pos1, pos2) {
    const dx = pos1[0] - pos2[0];
    const dy = pos1[1] - pos2[1];
    const dz = pos1[2] - pos2[2];
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }
  _calculateCachedStats(annotation, renderingEngine, enabledElement) {
    const data = annotation.data;
    const { element } = enabledElement.viewport;
    const worldPos1 = data.handles.points[0];
    const worldPos2 = data.handles.points[1];
    const { cachedStats } = data;
    const targetIds = Object.keys(cachedStats);
    for (let i = 0; i < targetIds.length; i++) {
      const targetId = targetIds[i];
      const image = this.getTargetImageData(targetId);
      if (!image) {
        continue;
      }
      const { imageData, dimensions } = image;
      const index1 = transformWorldToIndex11(imageData, worldPos1);
      const index2 = transformWorldToIndex11(imageData, worldPos2);
      const handles = [index1, index2];
      const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);
      const length = this._calculateLength(worldPos1, worldPos2) / scale;
      if (this._isInsideVolume(index1, index2, dimensions)) {
        this.isHandleOutsideImage = false;
      } else {
        this.isHandleOutsideImage = true;
      }
      cachedStats[targetId] = {
        length,
        unit
      };
    }
    annotation.invalidated = false;
    triggerAnnotationModified(annotation, element);
    return cachedStats;
  }
  _isInsideVolume(index1, index2, dimensions) {
    return utilities_exports.indexWithinDimensions(index1, dimensions) && utilities_exports.indexWithinDimensions(index2, dimensions);
  }
};
_LengthTool.hydrate = (viewportId, points, options) => {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
  const { viewPlaneNormal, viewUp } = viewport.getCamera();
  const instance = new _LengthTool();
  const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);
  const annotation = {
    annotationUID: (options == null ? void 0 : options.annotationUID) || utilities_exports.uuidv4(),
    data: {
      handles: {
        points
      }
    },
    highlighted: false,
    autoGenerated: false,
    invalidated: false,
    isLocked: false,
    isVisible: true,
    metadata: {
      toolName: instance.getToolName(),
      viewPlaneNormal,
      FrameOfReferenceUID,
      referencedImageId,
      ...options
    }
  };
  addAnnotation(annotation, viewport.element);
  triggerAnnotationRenderForViewportIds_default([viewport.id]);
};
var LengthTool = _LengthTool;
function defaultGetTextLines5(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { length, unit } = cachedVolumeStats;
  if (length === void 0 || length === null || isNaN(length)) {
    return;
  }
  const textLines = [`${utilities_exports.roundNumber(length)} ${unit}`];
  return textLines;
}
LengthTool.toolName = "Length";
var LengthTool_default = LengthTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js
var { transformWorldToIndex: transformWorldToIndex12 } = utilities_exports;
var HeightTool = class extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      preventHandleOutsideImage: false,
      getTextLines: defaultGetTextLines6
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      hideElementCursor(element);
      this.isDrawing = true;
      const { viewPlaneNormal, viewUp, position: cameraPosition } = viewport.getCamera();
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          ...viewport.getViewReference({ points: [worldPos] }),
          toolName: this.getToolName(),
          referencedImageId,
          viewUp,
          cameraPosition
        },
        data: {
          handles: {
            points: [[...worldPos], [...worldPos]],
            activeHandleIndex: null,
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            }
          },
          label: "",
          cachedStats: {}
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex: 1,
        movingTextBox: false,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const [point1, point2] = data.handles.points;
      const canvasPoint1 = viewport.worldToCanvas(point1);
      const canvasPoint2 = viewport.worldToCanvas(point2);
      const line = {
        start: {
          x: canvasPoint1[0],
          y: canvasPoint1[1]
        },
        end: {
          x: canvasPoint2[0],
          y: canvasPoint2[1]
        }
      };
      const distanceToPoint5 = distanceToPoint3([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
      if (distanceToPoint5 <= proximity) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        movingTextBox: false
      };
      this._activateModify(element);
      hideElementCursor(element);
      const enabledElement = getEnabledElement(element);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
      this.editData = null;
      this.isDrawing = false;
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
      const { data } = annotation;
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const points = data.handles.points;
        points.forEach((point) => {
          point[0] += worldPosDelta[0];
          point[1] += worldPosDelta[1];
          point[2] += worldPosDelta[2];
        });
        annotation.invalidated = true;
      } else {
        const { currentPoints } = eventDetail;
        const worldPos = currentPoints.world;
        data.handles.points[handleIndex] = [...worldPos];
        annotation.invalidated = true;
      }
      this.editData.hasMoved = true;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.cancel = (element) => {
      if (this.isDrawing) {
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        resetElementCursor(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        const { data } = annotation;
        annotation.highlighted = false;
        data.handles.activeHandleIndex = null;
        const enabledElement = getEnabledElement(element);
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        if (newAnnotation) {
          triggerAnnotationCompleted(annotation);
        }
        this.editData = null;
        return annotation.annotationUID;
      }
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const targetId = this.getTargetId(viewport);
      const renderingEngine = viewport.getRenderingEngine();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { points, activeHandleIndex } = data.handles;
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        let activeHandleCanvasCoords;
        if (!data.cachedStats[targetId] || data.cachedStats[targetId].unit == null) {
          data.cachedStats[targetId] = {
            length: null,
            unit: null
          };
          this._calculateCachedStats(annotation, renderingEngine, enabledElement);
        } else if (annotation.invalidated) {
          this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
        }
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
            color,
            lineDash,
            lineWidth
          });
        }
        const heightUID = "0";
        drawHeight(svgDrawingHelper, annotationUID, heightUID, canvasCoordinates[0], canvasCoordinates[1], {
          color,
          width: lineWidth,
          lineDash
        });
        renderStatus = true;
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        if (!options.visibility) {
          data.handles.textBox = {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          };
          continue;
        }
        const textLines = this.configuration.getTextLines(data, targetId);
        if (!data.handles.textBox.hasMoved) {
          const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);
          data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
        }
        const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
        const textBoxUID = "1";
        const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
        const { x: left, y: top, width, height } = boundingBox;
        data.handles.textBox.worldBoundingBox = {
          topLeft: viewport.canvasToWorld([left, top]),
          topRight: viewport.canvasToWorld([left + width, top]),
          bottomLeft: viewport.canvasToWorld([left, top + height]),
          bottomRight: viewport.canvasToWorld([left + width, top + height])
        };
      }
      return renderStatus;
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
  handleSelectedCallback(evt, annotation, handle) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const { data } = annotation;
    annotation.highlighted = true;
    let movingTextBox = false;
    let handleIndex;
    if (handle.worldPosition) {
      movingTextBox = true;
    } else {
      handleIndex = data.handles.points.findIndex((p) => p === handle);
    }
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    this.editData = {
      annotation,
      viewportIdsToRender,
      handleIndex,
      movingTextBox
    };
    this._activateModify(element);
    hideElementCursor(element);
    const enabledElement = getEnabledElement(element);
    const { renderingEngine } = enabledElement;
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    evt.preventDefault();
  }
  _calculateHeight(pos1, pos2) {
    const dx = pos2[0] - pos1[0];
    const dy = pos2[1] - pos1[1];
    const dz = pos2[2] - pos1[2];
    if (dx == 0) {
      if (dy != 0) {
        return Math.abs(dz);
      } else {
        return 0;
      }
    } else if (dy == 0) {
      return Math.abs(dz);
    } else if (dz == 0) {
      return Math.abs(dy);
    }
  }
  _calculateCachedStats(annotation, renderingEngine, enabledElement) {
    const data = annotation.data;
    const { element } = enabledElement.viewport;
    const worldPos1 = data.handles.points[0];
    const worldPos2 = data.handles.points[1];
    const { cachedStats } = data;
    const targetIds = Object.keys(cachedStats);
    for (let i = 0; i < targetIds.length; i++) {
      const targetId = targetIds[i];
      const image = this.getTargetImageData(targetId);
      if (!image) {
        continue;
      }
      const { imageData, dimensions } = image;
      const index1 = transformWorldToIndex12(imageData, worldPos1);
      const index2 = transformWorldToIndex12(imageData, worldPos2);
      const handles = [index1, index2];
      const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);
      const height = this._calculateHeight(worldPos1, worldPos2) / scale;
      const outside = this._isInsideVolume(index1, index2, dimensions);
      this.isHandleOutsideImage = outside;
      cachedStats[targetId] = {
        height,
        unit
      };
    }
    annotation.invalidated = false;
    triggerAnnotationModified(annotation, element);
    return cachedStats;
  }
  _isInsideVolume(index1, index2, dimensions) {
    return utilities_exports.indexWithinDimensions(index1, dimensions) && utilities_exports.indexWithinDimensions(index2, dimensions);
  }
};
function defaultGetTextLines6(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { height, unit } = cachedVolumeStats;
  if (height === void 0 || height === null || isNaN(height)) {
    return;
  }
  const textLines = [`${utilities_exports.roundNumber(height)} ${unit}`];
  return textLines;
}
HeightTool.toolName = "Height";
var HeightTool_default = HeightTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js
var { transformWorldToIndex: transformWorldToIndex13 } = utilities_exports;
var _ProbeTool = class _ProbeTool extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps) {
    super(toolProps, AnnotationTool_default.mergeDefaultProps(_ProbeTool.probeDefaults, defaultToolProps));
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        invalidated: true,
        highlighted: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId
        },
        data: {
          label: "",
          handles: { points: [[...worldPos]] },
          cachedStats: {}
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        newAnnotation: true,
        viewportIdsToRender
      };
      this._activateModify(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
      const { viewportId, renderingEngine } = getEnabledElement(element);
      this.eventDispatchDetail = {
        viewportId,
        renderingEngineId: renderingEngine.id
      };
      this._deactivateModify(element);
      resetElementCursor(element);
      if (newAnnotation) {
        this.createMemo(element, annotation, { newAnnotation });
      }
      this.editData = null;
      this.isDrawing = false;
      this.doneEditMemo();
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
      const { data } = annotation;
      this.createMemo(element, annotation, { newAnnotation });
      data.handles.points[0] = [...worldPos];
      annotation.invalidated = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.cancel = (element) => {
      if (this.isDrawing) {
        this.isDrawing = false;
        this._deactivateModify(element);
        resetElementCursor(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        const { data } = annotation;
        annotation.highlighted = false;
        data.handles.activeHandleIndex = null;
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        if (newAnnotation) {
          triggerAnnotationCompleted(annotation);
        }
        this.editData = null;
        return annotation.annotationUID;
      }
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const targetId = this.getTargetId(viewport);
      const renderingEngine = viewport.getRenderingEngine();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const annotationUID = annotation.annotationUID;
        const data = annotation.data;
        const point = data.handles.points[0];
        const canvasCoordinates = viewport.worldToCanvas(point);
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        if (!data.cachedStats) {
          data.cachedStats = {};
        }
        if (!data.cachedStats[targetId] || data.cachedStats[targetId].value === null) {
          data.cachedStats[targetId] = {
            Modality: null,
            index: null,
            value: null
          };
          this._calculateCachedStats(annotation, renderingEngine, enabledElement, ChangeTypes_default.StatsUpdated);
        } else if (annotation.invalidated) {
          this._calculateCachedStats(annotation, renderingEngine, enabledElement);
          if (viewport instanceof VolumeViewport_default) {
            const { referencedImageId } = annotation.metadata;
            for (const targetId2 in data.cachedStats) {
              if (targetId2.startsWith("imageId")) {
                const viewports = renderingEngine.getStackViewports();
                const invalidatedStack = viewports.find((vp) => {
                  const referencedImageURI = utilities_exports.imageIdToURI(referencedImageId);
                  const hasImageURI = vp.hasImageURI(referencedImageURI);
                  const currentImageURI = utilities_exports.imageIdToURI(vp.getCurrentImageId());
                  return hasImageURI && currentImageURI !== referencedImageURI;
                });
                if (invalidatedStack) {
                  delete data.cachedStats[targetId2];
                }
              }
            }
          }
        }
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        const handleGroupUID = "0";
        drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color, lineWidth });
        renderStatus = true;
        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        if (!options.visibility) {
          continue;
        }
        const textLines = this.configuration.getTextLines(data, targetId);
        if (textLines) {
          const textCanvasCoordinates = [
            canvasCoordinates[0] + 6,
            canvasCoordinates[1] - 6
          ];
          const textUID = "0";
          drawTextBox_default(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], options);
        }
      }
      return renderStatus;
    };
  }
  isPointNearTool(element, annotation, canvasCoords, proximity) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const { data } = annotation;
    const point = data.handles.points[0];
    const annotationCanvasCoordinate = viewport.worldToCanvas(point);
    return vec2_exports.distance(canvasCoords, annotationCanvasCoordinate) < proximity;
  }
  toolSelectedCallback() {
  }
  getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const { data } = annotation;
    const point = data.handles.points[0];
    const annotationCanvasCoordinate = viewport.worldToCanvas(point);
    const near = vec2_exports.distance(canvasCoords, annotationCanvasCoordinate) < proximity;
    if (near === true) {
      return point;
    }
  }
  handleSelectedCallback(evt, annotation) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    annotation.highlighted = true;
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    this.editData = {
      annotation,
      viewportIdsToRender
    };
    this._activateModify(element);
    hideElementCursor(element);
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    evt.preventDefault();
  }
  _calculateCachedStats(annotation, renderingEngine, enabledElement, changeType = ChangeTypes_default.StatsUpdated) {
    const data = annotation.data;
    const { renderingEngineId, viewport } = enabledElement;
    const { element } = viewport;
    const worldPos = data.handles.points[0];
    const { cachedStats } = data;
    const targetIds = Object.keys(cachedStats);
    for (let i = 0; i < targetIds.length; i++) {
      const targetId = targetIds[i];
      const pixelUnitsOptions = {
        isPreScaled: isViewportPreScaled(viewport, targetId),
        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId)
      };
      const image = this.getTargetImageData(targetId);
      if (!image) {
        continue;
      }
      const { dimensions, imageData, metadata, voxelManager } = image;
      const modality = metadata.Modality;
      let ijk = transformWorldToIndex13(imageData, worldPos);
      ijk = vec3_exports.round(ijk, ijk);
      if (utilities_exports.indexWithinDimensions(ijk, dimensions)) {
        this.isHandleOutsideImage = false;
        let value = voxelManager.getAtIJKPoint(ijk);
        if (targetId.startsWith("imageId:")) {
          const imageId = targetId.split("imageId:")[1];
          const imageURI = utilities_exports.imageIdToURI(imageId);
          const viewports = utilities_exports.getViewportsWithImageURI(imageURI);
          const viewport2 = viewports[0];
          ijk[2] = viewport2.getCurrentImageIdIndex();
        }
        let modalityUnit;
        if (modality === "US") {
          const calibratedResults = getCalibratedProbeUnitsAndValue(image, [
            ijk
          ]);
          const hasEnhancedRegionValues = calibratedResults.values.every((value2) => value2 !== null);
          value = hasEnhancedRegionValues ? calibratedResults.values : value;
          modalityUnit = hasEnhancedRegionValues ? calibratedResults.units : "raw";
        } else {
          modalityUnit = getPixelValueUnits(modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
        }
        cachedStats[targetId] = {
          index: ijk,
          value,
          Modality: modality,
          modalityUnit
        };
      } else {
        this.isHandleOutsideImage = true;
        cachedStats[targetId] = {
          index: ijk,
          Modality: modality
        };
      }
      annotation.invalidated = false;
      triggerAnnotationModified(annotation, element, changeType);
    }
    return cachedStats;
  }
};
_ProbeTool.probeDefaults = {
  supportedInteractionTypes: ["Mouse", "Touch"],
  configuration: {
    shadow: true,
    preventHandleOutsideImage: false,
    getTextLines: defaultGetTextLines7
  }
};
_ProbeTool.hydrate = (viewportId, points, options) => {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
  const { viewPlaneNormal, viewUp } = viewport.getCamera();
  const instance = new _ProbeTool();
  const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);
  const annotation = {
    annotationUID: (options == null ? void 0 : options.annotationUID) || utilities_exports.uuidv4(),
    data: {
      handles: {
        points
      }
    },
    highlighted: false,
    autoGenerated: false,
    invalidated: false,
    isLocked: false,
    isVisible: true,
    metadata: {
      toolName: instance.getToolName(),
      viewPlaneNormal,
      FrameOfReferenceUID,
      referencedImageId,
      ...options
    }
  };
  addAnnotation(annotation, viewport.element);
  triggerAnnotationRenderForViewportIds_default([viewport.id]);
};
var ProbeTool = _ProbeTool;
function defaultGetTextLines7(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { index, value, modalityUnit } = cachedVolumeStats;
  if (value === void 0 || !index) {
    return;
  }
  const textLines = [];
  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);
  if (value instanceof Array && modalityUnit instanceof Array) {
    for (let i = 0; i < value.length; i++) {
      textLines.push(`${utilities_exports.roundNumber(value[i])} ${modalityUnit[i]}`);
    }
  } else {
    textLines.push(`${utilities_exports.roundNumber(value)} ${modalityUnit}`);
  }
  return textLines;
}
ProbeTool.toolName = "Probe";
var ProbeTool_default = ProbeTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js
var DragProbeTool = class extends ProbeTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      shadow: true,
      preventHandleOutsideImage: false,
      getTextLines: defaultGetTextLines8
    }
  }) {
    super(toolProps, defaultToolProps);
    this.postMouseDownCallback = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const annotation = {
        invalidated: true,
        highlighted: true,
        isVisible: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
          referencedImageId
        },
        data: {
          label: "",
          handles: { points: [[...worldPos]] },
          cachedStats: {}
        }
      };
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        newAnnotation: true,
        viewportIdsToRender
      };
      this._activateModify(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.postTouchStartCallback = (evt) => {
      return this.postMouseDownCallback(evt);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      if (!this.editData) {
        return renderStatus;
      }
      const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const targetId = this.getTargetId(viewport);
      const renderingEngine = viewport.getRenderingEngine();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      const annotation = this.editData.annotation;
      const annotationUID = annotation.annotationUID;
      const data = annotation.data;
      const point = data.handles.points[0];
      const canvasCoordinates = viewport.worldToCanvas(point);
      styleSpecifier.annotationUID = annotationUID;
      const { color } = this.getAnnotationStyle({
        annotation,
        styleSpecifier
      });
      if (!data.cachedStats[targetId] || data.cachedStats[targetId].value === null) {
        data.cachedStats[targetId] = {
          Modality: null,
          index: null,
          value: null
        };
        this._calculateCachedStats(annotation, renderingEngine, enabledElement);
      } else if (annotation.invalidated) {
        this._calculateCachedStats(annotation, renderingEngine, enabledElement);
      }
      if (!viewport.getRenderingEngine()) {
        console.warn("Rendering Engine has been destroyed");
        return renderStatus;
      }
      const handleGroupUID = "0";
      drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });
      renderStatus = true;
      const textLines = this.configuration.getTextLines(data, targetId);
      if (textLines) {
        const textCanvasCoordinates = [
          canvasCoordinates[0] + 6,
          canvasCoordinates[1] - 6
        ];
        const textUID = "0";
        drawTextBox_default(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));
      }
      return renderStatus;
    };
  }
};
function defaultGetTextLines8(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { index, value, modalityUnit } = cachedVolumeStats;
  if (value === void 0) {
    return;
  }
  const textLines = [];
  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);
  textLines.push(`${value.toFixed(2)} ${modalityUnit}`);
  return textLines;
}
DragProbeTool.toolName = "DragProbe";
var DragProbeTool_default = DragProbeTool;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js
function getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2) {
  const viewRight = vec3_exports.create();
  vec3_exports.cross(viewRight, viewUp, viewPlaneNormal);
  const pos1 = vec3_exports.fromValues(...worldPos1);
  const pos2 = vec3_exports.fromValues(...worldPos2);
  const diagonal = vec3_exports.create();
  vec3_exports.subtract(diagonal, pos1, pos2);
  const diagonalLength = vec3_exports.length(diagonal);
  if (diagonalLength < 1e-4) {
    return { worldWidth: 0, worldHeight: 0 };
  }
  const cosTheta = vec3_exports.dot(diagonal, viewRight) / (diagonalLength * vec3_exports.length(viewRight));
  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
  const worldWidth = sinTheta * diagonalLength;
  const worldHeight = cosTheta * diagonalLength;
  return { worldWidth, worldHeight };
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js
var { transformWorldToIndex: transformWorldToIndex14 } = utilities_exports;
var _EllipticalROITool = class _EllipticalROITool extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      shadow: true,
      preventHandleOutsideImage: false,
      storePointData: false,
      centerPointRadius: 0,
      getTextLines: defaultGetTextLines9,
      statsCalculator: BasicStatsCalculator
    }
  }) {
    super(toolProps, defaultToolProps);
    this.isHandleOutsideImage = false;
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const canvasPos = currentPoints.canvas;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId,
          ...viewport.getViewReference({ points: [worldPos] })
        },
        data: {
          label: "",
          handles: {
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            },
            points: [
              [...worldPos],
              [...worldPos],
              [...worldPos],
              [...worldPos]
            ],
            activeHandleIndex: null
          },
          cachedStats: {},
          initialRotation: viewport.getRotation()
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        centerWorld: worldPos,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const { points } = data.handles;
      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
      const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);
      const [canvasPoint1, canvasPoint2] = canvasCorners;
      const minorEllipse = {
        left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,
        top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,
        width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,
        height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity
      };
      const majorEllipse = {
        left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,
        top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,
        width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,
        height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity
      };
      const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);
      const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);
      if (pointInMajorEllipse && !pointInMinorEllipse) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        movingTextBox: false
      };
      hideElementCursor(element);
      this._activateModify(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this.handleSelectedCallback = (evt, annotation, handle) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { data } = annotation;
      annotation.highlighted = true;
      let movingTextBox = false;
      let handleIndex;
      let centerCanvas;
      let centerWorld;
      let canvasWidth;
      let canvasHeight;
      let originalHandleCanvas;
      if (handle.worldPosition) {
        movingTextBox = true;
      } else {
        const { points } = data.handles;
        const { viewport } = getEnabledElement(element);
        const { worldToCanvas, canvasToWorld } = viewport;
        handleIndex = points.findIndex((p) => p === handle);
        const pointsCanvas = points.map(worldToCanvas);
        originalHandleCanvas = pointsCanvas[handleIndex];
        canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);
        canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);
        centerCanvas = [
          (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,
          (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2
        ];
        centerWorld = canvasToWorld(centerCanvas);
      }
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex,
        canvasWidth,
        canvasHeight,
        centerWorld,
        originalHandleCanvas,
        movingTextBox
      };
      this._activateModify(element);
      hideElementCursor(element);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      this.doneEditMemo();
      annotation.highlighted = false;
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      this.editData = null;
      this.isDrawing = false;
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
    };
    this._dragDrawCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { currentPoints } = eventDetail;
      const currentCanvasPoints = currentPoints.canvas;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { canvasToWorld } = viewport;
      const { annotation, viewportIdsToRender, centerWorld, newAnnotation } = this.editData;
      this.createMemo(element, annotation, { newAnnotation });
      const centerCanvas = viewport.worldToCanvas(centerWorld);
      const { data } = annotation;
      const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
      const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
      const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];
      const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];
      const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];
      const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];
      data.handles.points = [
        canvasToWorld(bottomCanvas),
        canvasToWorld(topCanvas),
        canvasToWorld(leftCanvas),
        canvasToWorld(rightCanvas)
      ];
      annotation.invalidated = true;
      this.editData.hasMoved = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._dragModifyCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation } = this.editData;
      this.createMemo(element, annotation, { newAnnotation });
      const { data } = annotation;
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const points = data.handles.points;
        points.forEach((point) => {
          point[0] += worldPosDelta[0];
          point[1] += worldPosDelta[1];
          point[2] += worldPosDelta[2];
        });
        annotation.invalidated = true;
      } else {
        this._dragHandle(evt);
        annotation.invalidated = true;
      }
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._dragHandle = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { viewport } = getEnabledElement(element);
      const { canvasToWorld, worldToCanvas } = viewport;
      const { annotation, canvasWidth, canvasHeight, handleIndex, centerWorld, originalHandleCanvas } = this.editData;
      const centerCanvas = viewport.worldToCanvas(centerWorld);
      const { data } = annotation;
      const { points } = data.handles;
      const { currentPoints } = eventDetail;
      const currentCanvasPoints = currentPoints.canvas;
      if (handleIndex === 0 || handleIndex === 1) {
        const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
        const canvasBottom = [
          centerCanvas[0],
          centerCanvas[1] - dYCanvas
        ];
        const canvasTop = [
          centerCanvas[0],
          centerCanvas[1] + dYCanvas
        ];
        points[0] = canvasToWorld(canvasBottom);
        points[1] = canvasToWorld(canvasTop);
        const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];
        const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;
        const canvasLeft = [
          centerCanvas[0] - newHalfCanvasWidth,
          centerCanvas[1]
        ];
        const canvasRight = [
          centerCanvas[0] + newHalfCanvasWidth,
          centerCanvas[1]
        ];
        points[2] = canvasToWorld(canvasLeft);
        points[3] = canvasToWorld(canvasRight);
      } else {
        const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
        const canvasLeft = [
          centerCanvas[0] - dXCanvas,
          centerCanvas[1]
        ];
        const canvasRight = [
          centerCanvas[0] + dXCanvas,
          centerCanvas[1]
        ];
        points[2] = canvasToWorld(canvasLeft);
        points[3] = canvasToWorld(canvasRight);
        const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];
        const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;
        const canvasBottom = [
          centerCanvas[0],
          centerCanvas[1] - newHalfCanvasHeight
        ];
        const canvasTop = [
          centerCanvas[0],
          centerCanvas[1] + newHalfCanvasHeight
        ];
        points[0] = canvasToWorld(canvasBottom);
        points[1] = canvasToWorld(canvasTop);
      }
    };
    this.cancel = (element) => {
      if (this.isDrawing) {
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        resetElementCursor(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        const { data } = annotation;
        annotation.highlighted = false;
        data.handles.activeHandleIndex = null;
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        if (newAnnotation) {
          triggerAnnotationCompleted(annotation);
        }
        this.editData = null;
        return annotation.annotationUID;
      }
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragModifyCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragModifyCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragModifyCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragModifyCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragDrawCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragDrawCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragDrawCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragDrawCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragDrawCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragDrawCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const targetId = this.getTargetId(viewport);
      const renderingEngine = viewport.getRenderingEngine();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { handles } = data;
        const { points, activeHandleIndex } = handles;
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth, lineDash } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);
        const { centerPointRadius } = this.configuration;
        if (!data.cachedStats[targetId] || data.cachedStats[targetId].areaUnit == null) {
          data.cachedStats[targetId] = {
            Modality: null,
            area: null,
            max: null,
            mean: null,
            stdDev: null,
            areaUnit: null
          };
          this._calculateCachedStats(annotation, viewport, renderingEngine);
        } else if (annotation.invalidated) {
          this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
          if (viewport instanceof VolumeViewport_default) {
            const { referencedImageId } = annotation.metadata;
            for (const targetId2 in data.cachedStats) {
              if (targetId2.startsWith("imageId")) {
                const viewports = renderingEngine.getStackViewports();
                const invalidatedStack = viewports.find((vp) => {
                  const referencedImageURI = utilities_exports.imageIdToURI(referencedImageId);
                  const hasImageURI = vp.hasImageURI(referencedImageURI);
                  const currentImageURI = utilities_exports.imageIdToURI(vp.getCurrentImageId());
                  return hasImageURI && currentImageURI !== referencedImageURI;
                });
                if (invalidatedStack) {
                  delete data.cachedStats[targetId2];
                }
              }
            }
          }
        }
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        let activeHandleCanvasCoords;
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
            color
          });
        }
        const dataId = `${annotationUID}-ellipse`;
        const ellipseUID = "0";
        drawEllipseByCoordinates_default(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, {
          color,
          lineDash,
          lineWidth
        }, dataId);
        if (centerPointRadius > 0) {
          const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);
          if (minRadius > 3 * centerPointRadius) {
            const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);
            drawCircle_default(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {
              color,
              lineDash,
              lineWidth
            });
          }
        }
        renderStatus = true;
        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        if (!options.visibility) {
          data.handles.textBox = {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          };
          continue;
        }
        const textLines = this.configuration.getTextLines(data, targetId);
        if (!textLines || textLines.length === 0) {
          continue;
        }
        let canvasTextBoxCoords;
        if (!data.handles.textBox.hasMoved) {
          canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);
          data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
        }
        const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
        const textBoxUID = "1";
        const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
        const { x: left, y: top, width, height } = boundingBox;
        data.handles.textBox.worldBoundingBox = {
          topLeft: viewport.canvasToWorld([left, top]),
          topRight: viewport.canvasToWorld([left + width, top]),
          bottomLeft: viewport.canvasToWorld([left, top + height]),
          bottomRight: viewport.canvasToWorld([left + width, top + height])
        };
      }
      return renderStatus;
    };
    this._calculateCachedStats = (annotation, viewport, renderingEngine) => {
      var _a2, _b2, _c;
      const data = annotation.data;
      const { element } = viewport;
      const { points } = data.handles;
      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
      const { viewPlaneNormal, viewUp } = viewport.getCamera();
      const [topLeftCanvas, bottomRightCanvas] = getCanvasEllipseCorners(canvasCoordinates);
      const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
      const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
      const { cachedStats } = data;
      const targetIds = Object.keys(cachedStats);
      const worldPos1 = topLeftWorld;
      const worldPos2 = bottomRightWorld;
      for (let i = 0; i < targetIds.length; i++) {
        const targetId = targetIds[i];
        const image = this.getTargetImageData(targetId);
        if (!image) {
          continue;
        }
        const { dimensions, imageData, metadata, voxelManager } = image;
        const pos1Index = transformWorldToIndex14(imageData, worldPos1);
        pos1Index[0] = Math.floor(pos1Index[0]);
        pos1Index[1] = Math.floor(pos1Index[1]);
        pos1Index[2] = Math.floor(pos1Index[2]);
        const post2Index = transformWorldToIndex14(imageData, worldPos2);
        post2Index[0] = Math.floor(post2Index[0]);
        post2Index[1] = Math.floor(post2Index[1]);
        post2Index[2] = Math.floor(post2Index[2]);
        this.isHandleOutsideImage = !this._isInsideVolume(pos1Index, post2Index, dimensions);
        const iMin = Math.min(pos1Index[0], post2Index[0]);
        const iMax = Math.max(pos1Index[0], post2Index[0]);
        const jMin = Math.min(pos1Index[1], post2Index[1]);
        const jMax = Math.max(pos1Index[1], post2Index[1]);
        const kMin = Math.min(pos1Index[2], post2Index[2]);
        const kMax = Math.max(pos1Index[2], post2Index[2]);
        const boundsIJK = [
          [iMin, iMax],
          [jMin, jMax],
          [kMin, kMax]
        ];
        const center = [
          (topLeftWorld[0] + bottomRightWorld[0]) / 2,
          (topLeftWorld[1] + bottomRightWorld[1]) / 2,
          (topLeftWorld[2] + bottomRightWorld[2]) / 2
        ];
        const ellipseObj = {
          center,
          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,
          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,
          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2
        };
        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);
        const isEmptyArea = worldWidth === 0 && worldHeight === 0;
        const handles = [pos1Index, post2Index];
        const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);
        const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) / scale / scale;
        const pixelUnitsOptions = {
          isPreScaled: isViewportPreScaled(viewport, targetId),
          isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId)
        };
        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
        const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
          boundsIJK,
          imageData,
          isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),
          returnPoints: this.configuration.storePointData
        });
        const stats = this.configuration.statsCalculator.getStatistics();
        cachedStats[targetId] = {
          Modality: metadata.Modality,
          area,
          mean: (_a2 = stats.mean) == null ? void 0 : _a2.value,
          max: (_b2 = stats.max) == null ? void 0 : _b2.value,
          stdDev: (_c = stats.stdDev) == null ? void 0 : _c.value,
          statsArray: stats.array,
          pointsInShape,
          isEmptyArea,
          areaUnit,
          modalityUnit
        };
      }
      annotation.invalidated = false;
      triggerAnnotationModified(annotation, element);
      return cachedStats;
    };
    this._isInsideVolume = (index1, index2, dimensions) => {
      return utilities_exports.indexWithinDimensions(index1, dimensions) && utilities_exports.indexWithinDimensions(index2, dimensions);
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
  _pointInEllipseCanvas(ellipse, location) {
    const xRadius = ellipse.width / 2;
    const yRadius = ellipse.height / 2;
    if (xRadius <= 0 || yRadius <= 0) {
      return false;
    }
    const center = [ellipse.left + xRadius, ellipse.top + yRadius];
    const normalized = [location[0] - center[0], location[1] - center[1]];
    const inEllipse = normalized[0] * normalized[0] / (xRadius * xRadius) + normalized[1] * normalized[1] / (yRadius * yRadius) <= 1;
    return inEllipse;
  }
  _getCanvasEllipseCenter(ellipseCanvasPoints) {
    const [bottom, top, left, right] = ellipseCanvasPoints;
    const topLeft = [left[0], top[1]];
    const bottomRight = [right[0], bottom[1]];
    return [
      (topLeft[0] + bottomRight[0]) / 2,
      (topLeft[1] + bottomRight[1]) / 2
    ];
  }
};
_EllipticalROITool.hydrate = (viewportId, points, options) => {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
  const { viewPlaneNormal, viewUp } = viewport.getCamera();
  const instance = new _EllipticalROITool();
  const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);
  const annotation = {
    annotationUID: (options == null ? void 0 : options.annotationUID) || utilities_exports.uuidv4(),
    data: {
      handles: {
        points,
        activeHandleIndex: null
      },
      label: "",
      cachedStats: {}
    },
    highlighted: false,
    autoGenerated: false,
    invalidated: false,
    isLocked: false,
    isVisible: true,
    metadata: {
      toolName: instance.getToolName(),
      viewPlaneNormal,
      FrameOfReferenceUID,
      referencedImageId,
      ...options
    }
  };
  addAnnotation(annotation, viewport.element);
  triggerAnnotationRenderForViewportIds_default([viewport.id]);
};
var EllipticalROITool = _EllipticalROITool;
function defaultGetTextLines9(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { area, mean, stdDev, max: max2, isEmptyArea, areaUnit, modalityUnit } = cachedVolumeStats;
  const textLines = [];
  if (area) {
    const areaLine = isEmptyArea ? `Area: Oblique not supported` : `Area: ${utilities_exports.roundNumber(area)} ${areaUnit}`;
    textLines.push(areaLine);
  }
  if (mean) {
    textLines.push(`Mean: ${utilities_exports.roundNumber(mean)} ${modalityUnit}`);
  }
  if (max2) {
    textLines.push(`Max: ${utilities_exports.roundNumber(max2)} ${modalityUnit}`);
  }
  if (stdDev) {
    textLines.push(`Std Dev: ${utilities_exports.roundNumber(stdDev)} ${modalityUnit}`);
  }
  return textLines;
}
EllipticalROITool.toolName = "EllipticalROI";
var EllipticalROITool_default = EllipticalROITool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js
var { transformWorldToIndex: transformWorldToIndex15 } = utilities_exports;
var _CircleROITool = class _CircleROITool extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      shadow: true,
      preventHandleOutsideImage: false,
      storePointData: false,
      centerPointRadius: 0,
      getTextLines: defaultGetTextLines10,
      statsCalculator: BasicStatsCalculator
    }
  }) {
    super(toolProps, defaultToolProps);
    this.isHandleOutsideImage = false;
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId,
          ...viewport.getViewReference({ points: [worldPos] })
        },
        data: {
          label: "",
          handles: {
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            },
            points: [[...worldPos], [...worldPos]],
            activeHandleIndex: null
          },
          cachedStats: {}
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const { points } = data.handles;
      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
      const radius = getCanvasCircleRadius(canvasCoordinates);
      const radiusPoint = getCanvasCircleRadius([
        canvasCoordinates[0],
        canvasCoords
      ]);
      if (Math.abs(radiusPoint - radius) < proximity / 2) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        movingTextBox: false
      };
      hideElementCursor(element);
      this._activateModify(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this.handleSelectedCallback = (evt, annotation, handle) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { data } = annotation;
      annotation.highlighted = true;
      let movingTextBox = false;
      let handleIndex;
      if (handle.worldPosition) {
        movingTextBox = true;
      } else {
        const { points } = data.handles;
        handleIndex = points.findIndex((p) => p === handle);
      }
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex,
        movingTextBox
      };
      this._activateModify(element);
      hideElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      this.doneEditMemo();
      annotation.highlighted = false;
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      const { renderingEngine } = getEnabledElement(element);
      this.editData = null;
      this.isDrawing = false;
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
    };
    this._dragDrawCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { currentPoints } = eventDetail;
      const currentCanvasPoints = currentPoints.canvas;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { canvasToWorld } = viewport;
      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
      this.createMemo(element, annotation, { newAnnotation });
      const { data } = annotation;
      data.handles.points = [
        data.handles.points[0],
        canvasToWorld(currentCanvasPoints)
      ];
      annotation.invalidated = true;
      this.editData.hasMoved = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._dragModifyCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation } = this.editData;
      this.createMemo(element, annotation, { newAnnotation });
      const { data } = annotation;
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const points = data.handles.points;
        points.forEach((point) => {
          point[0] += worldPosDelta[0];
          point[1] += worldPosDelta[1];
          point[2] += worldPosDelta[2];
        });
        annotation.invalidated = true;
      } else {
        this._dragHandle(evt);
        annotation.invalidated = true;
      }
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._dragHandle = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { canvasToWorld, worldToCanvas } = enabledElement.viewport;
      const { annotation, handleIndex } = this.editData;
      const { data } = annotation;
      const { points } = data.handles;
      const canvasCoordinates = points.map((p) => worldToCanvas(p));
      const { currentPoints } = eventDetail;
      const currentCanvasPoints = currentPoints.canvas;
      if (handleIndex === 0) {
        const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];
        const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];
        const canvasCenter = currentCanvasPoints;
        const canvasEnd = [
          canvasCoordinates[1][0] + dXCanvas,
          canvasCoordinates[1][1] + dYCanvas
        ];
        points[0] = canvasToWorld(canvasCenter);
        points[1] = canvasToWorld(canvasEnd);
      } else {
        points[1] = canvasToWorld(currentCanvasPoints);
      }
    };
    this.cancel = (element) => {
      if (this.isDrawing) {
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        resetElementCursor(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        const { data } = annotation;
        annotation.highlighted = false;
        data.handles.activeHandleIndex = null;
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        if (newAnnotation) {
          triggerAnnotationCompleted(annotation);
        }
        this.editData = null;
        return annotation.annotationUID;
      }
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragModifyCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragModifyCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragModifyCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragModifyCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragDrawCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragDrawCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragDrawCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragDrawCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragDrawCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragDrawCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const targetId = this.getTargetId(viewport);
      const renderingEngine = viewport.getRenderingEngine();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { handles } = data;
        const { points, activeHandleIndex } = handles;
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth, lineDash } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const center = canvasCoordinates[0];
        const radius = getCanvasCircleRadius(canvasCoordinates);
        const canvasCorners = getCanvasCircleCorners(canvasCoordinates);
        const { centerPointRadius } = this.configuration;
        if (!data.cachedStats[targetId] || data.cachedStats[targetId].areaUnit == null) {
          data.cachedStats[targetId] = {
            Modality: null,
            area: null,
            max: null,
            mean: null,
            stdDev: null,
            areaUnit: null,
            radius: null,
            radiusUnit: null,
            perimeter: null
          };
          this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
        } else if (annotation.invalidated) {
          this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
          if (viewport instanceof VolumeViewport_default) {
            const { referencedImageId } = annotation.metadata;
            for (const targetId2 in data.cachedStats) {
              if (targetId2.startsWith("imageId")) {
                const viewports = renderingEngine.getStackViewports();
                const invalidatedStack = viewports.find((vp) => {
                  const referencedImageURI = utilities_exports.imageIdToURI(referencedImageId);
                  const hasImageURI = vp.hasImageURI(referencedImageURI);
                  const currentImageURI = utilities_exports.imageIdToURI(vp.getCurrentImageId());
                  return hasImageURI && currentImageURI !== referencedImageURI;
                });
                if (invalidatedStack) {
                  delete data.cachedStats[targetId2];
                }
              }
            }
          }
        }
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        let activeHandleCanvasCoords;
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
            color
          });
        }
        const dataId = `${annotationUID}-circle`;
        const circleUID = "0";
        drawCircle_default(svgDrawingHelper, annotationUID, circleUID, center, radius, {
          color,
          lineDash,
          lineWidth
        }, dataId);
        if (centerPointRadius > 0) {
          if (radius > 3 * centerPointRadius) {
            drawCircle_default(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {
              color,
              lineDash,
              lineWidth
            });
          }
        }
        renderStatus = true;
        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        if (!options.visibility) {
          data.handles.textBox = {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          };
          continue;
        }
        const textLines = this.configuration.getTextLines(data, targetId);
        if (!textLines || textLines.length === 0) {
          continue;
        }
        let canvasTextBoxCoords;
        if (!data.handles.textBox.hasMoved) {
          canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);
          data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
        }
        const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
        const textBoxUID = "1";
        const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
        const { x: left, y: top, width, height } = boundingBox;
        data.handles.textBox.worldBoundingBox = {
          topLeft: viewport.canvasToWorld([left, top]),
          topRight: viewport.canvasToWorld([left + width, top]),
          bottomLeft: viewport.canvasToWorld([left, top + height]),
          bottomRight: viewport.canvasToWorld([left + width, top + height])
        };
      }
      return renderStatus;
    };
    this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {
      var _a2, _b2, _c;
      const data = annotation.data;
      const { element } = viewport;
      const { points } = data.handles;
      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
      const { viewPlaneNormal, viewUp } = viewport.getCamera();
      const [topLeftCanvas, bottomRightCanvas] = getCanvasCircleCorners(canvasCoordinates);
      const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
      const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
      const { cachedStats } = data;
      const targetIds = Object.keys(cachedStats);
      const worldPos1 = topLeftWorld;
      const worldPos2 = bottomRightWorld;
      for (let i = 0; i < targetIds.length; i++) {
        const targetId = targetIds[i];
        const image = this.getTargetImageData(targetId);
        if (!image) {
          continue;
        }
        const { dimensions, imageData, metadata, voxelManager } = image;
        const pos1Index = transformWorldToIndex15(imageData, worldPos1);
        pos1Index[0] = Math.floor(pos1Index[0]);
        pos1Index[1] = Math.floor(pos1Index[1]);
        pos1Index[2] = Math.floor(pos1Index[2]);
        const pos2Index = transformWorldToIndex15(imageData, worldPos2);
        pos2Index[0] = Math.floor(pos2Index[0]);
        pos2Index[1] = Math.floor(pos2Index[1]);
        pos2Index[2] = Math.floor(pos2Index[2]);
        if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {
          const iMin = Math.min(pos1Index[0], pos2Index[0]);
          const iMax = Math.max(pos1Index[0], pos2Index[0]);
          const jMin = Math.min(pos1Index[1], pos2Index[1]);
          const jMax = Math.max(pos1Index[1], pos2Index[1]);
          const kMin = Math.min(pos1Index[2], pos2Index[2]);
          const kMax = Math.max(pos1Index[2], pos2Index[2]);
          const boundsIJK = [
            [iMin, iMax],
            [jMin, jMax],
            [kMin, kMax]
          ];
          const center = [
            (topLeftWorld[0] + bottomRightWorld[0]) / 2,
            (topLeftWorld[1] + bottomRightWorld[1]) / 2,
            (topLeftWorld[2] + bottomRightWorld[2]) / 2
          ];
          const ellipseObj = {
            center,
            xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,
            yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,
            zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2
          };
          const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);
          const isEmptyArea = worldWidth === 0 && worldHeight === 0;
          const handles = [pos1Index, pos2Index];
          const { scale, unit, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);
          const aspect = getCalibratedAspect(image);
          const area = Math.abs(Math.PI * (worldWidth / scale / 2) * (worldHeight / aspect / scale / 2));
          const pixelUnitsOptions = {
            isPreScaled: isViewportPreScaled(viewport, targetId),
            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId)
          };
          const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
          const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
            isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),
            boundsIJK,
            imageData,
            returnPoints: this.configuration.storePointData
          });
          const stats = this.configuration.statsCalculator.getStatistics();
          cachedStats[targetId] = {
            Modality: metadata.Modality,
            area,
            mean: (_a2 = stats.mean) == null ? void 0 : _a2.value,
            max: (_b2 = stats.max) == null ? void 0 : _b2.value,
            pointsInShape,
            stdDev: (_c = stats.stdDev) == null ? void 0 : _c.value,
            statsArray: stats.array,
            isEmptyArea,
            areaUnit,
            radius: worldWidth / 2 / scale,
            radiusUnit: unit,
            perimeter: 2 * Math.PI * (worldWidth / 2) / scale,
            modalityUnit
          };
        } else {
          this.isHandleOutsideImage = true;
          cachedStats[targetId] = {
            Modality: metadata.Modality
          };
        }
      }
      annotation.invalidated = false;
      triggerAnnotationModified(annotation, element);
      return cachedStats;
    };
    this._isInsideVolume = (index1, index2, dimensions) => {
      return utilities_exports.indexWithinDimensions(index1, dimensions) && utilities_exports.indexWithinDimensions(index2, dimensions);
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
};
_CircleROITool.hydrate = (viewportId, points, options) => {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
  const { viewPlaneNormal, viewUp } = viewport.getCamera();
  const instance = new _CircleROITool();
  const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);
  const annotation = {
    annotationUID: (options == null ? void 0 : options.annotationUID) || utilities_exports.uuidv4(),
    data: {
      handles: {
        points,
        textBox: {
          hasMoved: false,
          worldPosition: [0, 0, 0],
          worldBoundingBox: {
            topLeft: [0, 0, 0],
            topRight: [0, 0, 0],
            bottomLeft: [0, 0, 0],
            bottomRight: [0, 0, 0]
          }
        },
        activeHandleIndex: null
      },
      label: "",
      cachedStats: {}
    },
    highlighted: false,
    autoGenerated: false,
    invalidated: false,
    isLocked: false,
    isVisible: true,
    metadata: {
      toolName: instance.getToolName(),
      viewPlaneNormal,
      FrameOfReferenceUID,
      referencedImageId,
      ...options
    }
  };
  addAnnotation(annotation, viewport.element);
  triggerAnnotationRenderForViewportIds_default([viewport.id]);
};
var CircleROITool = _CircleROITool;
function defaultGetTextLines10(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { radius, radiusUnit, area, mean, stdDev, max: max2, isEmptyArea, areaUnit, modalityUnit } = cachedVolumeStats;
  const textLines = [];
  if (radius) {
    const radiusLine = isEmptyArea ? `Radius: Oblique not supported` : `Radius: ${utilities_exports.roundNumber(radius)} ${radiusUnit}`;
    textLines.push(radiusLine);
  }
  if (area) {
    const areaLine = isEmptyArea ? `Area: Oblique not supported` : `Area: ${utilities_exports.roundNumber(area)} ${areaUnit}`;
    textLines.push(areaLine);
  }
  if (mean) {
    textLines.push(`Mean: ${utilities_exports.roundNumber(mean)} ${modalityUnit}`);
  }
  if (max2) {
    textLines.push(`Max: ${utilities_exports.roundNumber(max2)} ${modalityUnit}`);
  }
  if (stdDev) {
    textLines.push(`Std Dev: ${utilities_exports.roundNumber(stdDev)} ${modalityUnit}`);
  }
  return textLines;
}
CircleROITool.toolName = "CircleROI";
var CircleROITool_default = CircleROITool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js
var CROSSHAIR_SIZE = 5;
var ETDRSGridTool = class extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      shadow: true,
      preventHandleOutsideImage: false,
      degrees: [45, 135, 225, 315],
      diameters: [10, 30, 60]
    }
  }) {
    super(toolProps, defaultToolProps);
    this.isHandleOutsideImage = false;
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId,
          ...viewport.getViewReference({ points: [worldPos] })
        },
        data: {
          label: "",
          handles: {
            points: [[...worldPos]]
          }
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        newAnnotation: true
      };
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const { points } = data.handles;
      const center = viewport.worldToCanvas(points[0]);
      const radius = getCanvasCircleRadius([center, canvasCoords]);
      if (Math.abs(radius) < proximity) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender
      };
      hideElementCursor(element);
      this._activateModify(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this.handleSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender
      };
      this._activateModify(element);
      hideElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      annotation.highlighted = false;
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      const { renderingEngine } = getEnabledElement(element);
      this.editData = null;
      this.isDrawing = false;
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
    };
    this._dragDrawCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { currentPoints } = eventDetail;
      const currentCanvasPoints = currentPoints.canvas;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine, viewport } = enabledElement;
      const { canvasToWorld } = viewport;
      const { annotation, viewportIdsToRender } = this.editData;
      const { data } = annotation;
      data.handles.points = [
        canvasToWorld(currentCanvasPoints),
        canvasToWorld(currentCanvasPoints)
      ];
      annotation.invalidated = true;
      this.editData.hasMoved = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._dragModifyCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender } = this.editData;
      const { data } = annotation;
      const { deltaPoints } = eventDetail;
      const worldPosDelta = deltaPoints.world;
      const points = data.handles.points;
      points.forEach((point) => {
        point[0] += worldPosDelta[0];
        point[1] += worldPosDelta[1];
        point[2] += worldPosDelta[2];
      });
      annotation.invalidated = true;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._dragHandle = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { canvasToWorld, worldToCanvas } = enabledElement.viewport;
      const { annotation } = this.editData;
      const { data } = annotation;
      const { points } = data.handles;
      const canvasCoordinates = points.map((p) => worldToCanvas(p));
      const { currentPoints } = eventDetail;
      const currentCanvasPoints = currentPoints.canvas;
      const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];
      const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];
      const canvasCenter = currentCanvasPoints;
      const canvasEnd = [
        canvasCoordinates[1][0] + dXCanvas,
        canvasCoordinates[1][1] + dYCanvas
      ];
      points[0] = canvasToWorld(canvasCenter);
      points[1] = canvasToWorld(canvasEnd);
    };
    this.cancel = (element) => {
      if (this.isDrawing) {
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        resetElementCursor(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        const { data } = annotation;
        annotation.highlighted = false;
        data.handles.activeHandleIndex = null;
        const { renderingEngine } = getEnabledElement(element);
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        if (newAnnotation) {
          triggerAnnotationCompleted(annotation);
        }
        this.editData = null;
        return annotation.annotationUID;
      }
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragModifyCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragModifyCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragModifyCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragModifyCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragDrawCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragDrawCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragDrawCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragDrawCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragDrawCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragDrawCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { handles } = data;
        const { points } = handles;
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth, lineDash } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const center = canvasCoordinates[0];
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        let lineUID = `${annotationUID}-crosshair-vertical`;
        let start = [center[0], center[1] + CROSSHAIR_SIZE];
        let end = [center[0], center[1] - CROSSHAIR_SIZE];
        drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {
          color,
          lineDash,
          lineWidth
        });
        lineUID = `${annotationUID}-crosshair-horizontal`;
        start = [center[0] + CROSSHAIR_SIZE, center[1]];
        end = [center[0] - CROSSHAIR_SIZE, center[1]];
        drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {
          color,
          lineDash,
          lineWidth
        });
        const diametersCanvas = this.configuration.diameters.map((diameter) => this.worldMeasureToCanvas(diameter, viewport));
        for (let i2 = 0; i2 < diametersCanvas.length; i2++) {
          const dataId = `${annotationUID}-circle-${i2}`;
          const circleUID = `${annotationUID}-circle-${i2}`;
          drawCircle_default(svgDrawingHelper, annotationUID, circleUID, center, diametersCanvas[i2] / 2, {
            color,
            lineDash,
            lineWidth
          }, dataId);
        }
        const degreesRad = (x) => x * Math.PI / 180;
        const angleRadians = this.configuration.degrees.map((degree) => degreesRad(degree));
        for (let i2 = 0; i2 < angleRadians.length; i2++) {
          const lineUID2 = `${annotationUID}-line-${i2}`;
          const start2 = [
            Math.cos(angleRadians[i2]) * diametersCanvas[0] / 2 + center[0],
            Math.sin(angleRadians[i2]) * diametersCanvas[0] / 2 + center[1]
          ];
          const end2 = [
            Math.cos(angleRadians[i2]) * diametersCanvas[2] / 2 + center[0],
            Math.sin(angleRadians[i2]) * diametersCanvas[2] / 2 + center[1]
          ];
          drawLine(svgDrawingHelper, annotationUID, lineUID2, start2, end2, {
            color,
            lineDash,
            lineWidth
          });
        }
        renderStatus = true;
      }
      return renderStatus;
    };
  }
  worldMeasureToCanvas(measurement, viewport) {
    const p1 = viewport.canvasToWorld([
      viewport.canvas.width / 2,
      viewport.canvas.height / 2
    ]);
    const { viewUp } = viewport.getCamera();
    const p2 = vec3_exports.scaleAndAdd(vec3_exports.create(), p1, viewUp, measurement);
    const p1Canvas = viewport.worldToCanvas(p1);
    const p2Canvas = viewport.worldToCanvas(p2);
    const distance = Math.sqrt(Math.pow(p2Canvas[0] - p1Canvas[0], 2) + Math.pow(p2Canvas[1] - p1Canvas[1], 2));
    return distance;
  }
};
ETDRSGridTool.toolName = "ETDRSGrid";
var ETDRSGridTool_default = ETDRSGridTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js
var SPLINE_MIN_POINTS = 3;
var SPLINE_CLICK_CLOSE_CURVE_DIST = 10;
var DEFAULT_SPLINE_CONFIG = {
  resolution: 20,
  controlPointAdditionDistance: 6,
  controlPointDeletionDistance: 6,
  showControlPointsConnectors: false,
  controlPointAdditionEnabled: true,
  controlPointDeletionEnabled: true
};
var SplineTypesEnum;
(function(SplineTypesEnum2) {
  SplineTypesEnum2["Cardinal"] = "CARDINAL";
  SplineTypesEnum2["Linear"] = "LINEAR";
  SplineTypesEnum2["CatmullRom"] = "CATMULLROM";
  SplineTypesEnum2["BSpline"] = "BSPLINE";
})(SplineTypesEnum || (SplineTypesEnum = {}));
var SplineToolActions;
(function(SplineToolActions2) {
  SplineToolActions2["AddControlPoint"] = "addControlPoint";
  SplineToolActions2["DeleteControlPoint"] = "deleteControlPoint";
})(SplineToolActions || (SplineToolActions = {}));
var _SplineROITool = class _SplineROITool extends ContourSegmentationBaseTool {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      preventHandleOutsideImage: false,
      calculateStats: true,
      getTextLines: defaultGetTextLines11,
      contourHoleAdditionModifierKey: KeyboardBindings.Shift,
      decimate: {
        enabled: false,
        epsilon: 0.1
      },
      spline: {
        configuration: {
          [SplineTypesEnum.Cardinal]: {
            Class: CardinalSpline,
            scale: 0.5
          },
          [SplineTypesEnum.CatmullRom]: {
            Class: CatmullRomSpline
          },
          [SplineTypesEnum.Linear]: {
            Class: LinearSpline
          },
          [SplineTypesEnum.BSpline]: {
            Class: BSpline,
            controlPointAdditionEnabled: false,
            controlPointDeletionEnabled: false,
            showControlPointsConnectors: true
          }
        },
        type: SplineTypesEnum.CatmullRom,
        drawPreviewEnabled: true,
        lastControlPointDeletionKeys: ["Backspace", "Delete"]
      },
      actions: {
        [SplineToolActions.AddControlPoint]: {
          method: "addControlPointCallback",
          bindings: [
            {
              mouseButton: MouseBindings.Primary,
              modifierKey: KeyboardBindings.Shift
            }
          ]
        },
        [SplineToolActions.DeleteControlPoint]: {
          method: "deleteControlPointCallback",
          bindings: [
            {
              mouseButton: MouseBindings.Primary,
              modifierKey: KeyboardBindings.Ctrl
            }
          ]
        }
      }
    }
  }) {
    super(toolProps, defaultToolProps);
    this.isHandleOutsideImage = false;
    this.fireChangeOnUpdate = null;
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const { instance: spline } = annotation.data.spline;
      return spline.isPointNearCurve(canvasCoords, proximity);
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        movingTextBox: false
      };
      this._activateModify(element);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this.handleSelectedCallback = (evt, annotation, handle) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { data } = annotation;
      annotation.highlighted = true;
      let movingTextBox = false;
      let handleIndex;
      if (handle.worldPosition) {
        movingTextBox = true;
      } else {
        const { points } = data.handles;
        handleIndex = points.findIndex((p) => p === handle);
      }
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex,
        movingTextBox
      };
      this._activateModify(element);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled } = this.editData;
      const { data } = annotation;
      annotation.autoGenerated = false;
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const image = this.getTargetImageData(this.getTargetId(enabledElement.viewport));
      const { imageData, dimensions } = image;
      this.isHandleOutsideImage = data.handles.points.map((p) => utilities_exports.transformWorldToIndex(imageData, p)).some((index) => !utilities_exports.indexWithinDimensions(index, dimensions));
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      const changeType = newAnnotation ? ChangeTypes_default.Completed : ChangeTypes_default.HandlesUpdated;
      if (!this.fireChangeOnUpdate) {
        this.fireChangeOnUpdate = {
          annotationUID: annotation.annotationUID,
          changeType,
          contourHoleProcessingEnabled
        };
      } else {
        this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;
        this.fireChangeOnUpdate.changeType = changeType;
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      this.doneEditMemo();
      this.editData = null;
      this.isDrawing = false;
    };
    this._keyDownCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const key = eventDetail.key ?? "";
      const { lastControlPointDeletionKeys } = this.configuration.spline;
      const deleteLastPoint = lastControlPointDeletionKeys.includes(key);
      if (!deleteLastPoint) {
        return;
      }
      const { annotation } = this.editData;
      const { data } = annotation;
      if (data.handles.points.length === SPLINE_MIN_POINTS) {
        this.cancel(element);
        return;
      } else {
        const controlPointIndex = data.handles.points.length - 1;
        this._deleteControlPointByIndex(element, annotation, controlPointIndex);
      }
      evt.preventDefault();
    };
    this._mouseMoveCallback = (evt) => {
      const { drawPreviewEnabled } = this.configuration.spline;
      if (!drawPreviewEnabled) {
        return;
      }
      const { element } = evt.detail;
      const { renderingEngine } = getEnabledElement(element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._mouseDownCallback = (evt) => {
      const doubleClick = evt.type === Events_default.MOUSE_DOUBLE_CLICK;
      const { annotation, viewportIdsToRender } = this.editData;
      const { data } = annotation;
      if (data.contour.closed) {
        return;
      }
      this.doneEditMemo();
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const { canvas: canvasPoint, world: worldPoint } = currentPoints;
      let closeContour = data.handles.points.length >= 2 && doubleClick;
      let addNewPoint = true;
      if (data.handles.points.length) {
        this.createMemo(element, annotation, {
          newAnnotation: data.handles.points.length === 1
        });
      }
      if (data.handles.points.length >= 3) {
        this.createMemo(element, annotation);
        const { instance: spline } = data.spline;
        const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);
        if ((closestControlPoint == null ? void 0 : closestControlPoint.index) === 0) {
          addNewPoint = false;
          closeContour = true;
        }
      }
      if (addNewPoint) {
        data.handles.points.push(worldPoint);
      }
      data.contour.closed = data.contour.closed || closeContour;
      annotation.invalidated = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (data.contour.closed) {
        this._endCallback(evt);
      }
      evt.preventDefault();
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation } = this.editData;
      const { data } = annotation;
      this.createMemo(element, annotation, { newAnnotation });
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        this.moveAnnotation(annotation, worldPosDelta);
      } else {
        const { currentPoints } = eventDetail;
        const worldPos = currentPoints.world;
        data.handles.points[handleIndex] = [...worldPos];
        annotation.invalidated = true;
      }
      this.editData.hasMoved = true;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.triggerAnnotationCompleted = (annotation, contourHoleProcessingEnabled) => {
      const eventType = Events_default.ANNOTATION_COMPLETED;
      const eventDetail = {
        annotation,
        changeType: ChangeTypes_default.Completed,
        contourHoleProcessingEnabled
      };
      triggerEvent(eventTarget_default, eventType, eventDetail);
    };
    this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes_default.StatsUpdated) => {
      const { viewportId, renderingEngineId } = enabledElement;
      const eventType = Events_default.ANNOTATION_MODIFIED;
      const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId,
        changeType
      };
      triggerEvent(eventTarget_default, eventType, eventDetail);
    };
    this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes_default.StatsUpdated, contourHoleProcessingEnabled) => {
      if (changeType === ChangeTypes_default.Completed) {
        this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);
      } else {
        this.triggerAnnotationModified(annotation, enabledElement, changeType);
      }
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.KEY_DOWN, this._keyDownCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._mouseMoveCallback);
      element.addEventListener(Events_default.MOUSE_DOWN, this._mouseDownCallback);
      element.addEventListener(Events_default.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._mouseDownCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.KEY_DOWN, this._keyDownCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._mouseMoveCallback);
      element.removeEventListener(Events_default.MOUSE_DOWN, this._mouseDownCallback);
      element.removeEventListener(Events_default.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._mouseDownCallback);
    };
    this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {
      const data = annotation.data;
      const targetId = this.getTargetId(viewport);
      if (!data.spline.instance.closed || !textboxStyle.visibility) {
        return;
      }
      const textLines = this.configuration.getTextLines(data, targetId);
      if (!textLines || textLines.length === 0) {
        return;
      }
      const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
      if (!data.handles.textBox.hasMoved) {
        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);
        data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
      }
      const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
      const textBoxUID = "textBox";
      const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotation.annotationUID ?? "", textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);
      const { x: left, y: top, width, height } = boundingBox;
      data.handles.textBox.worldBoundingBox = {
        topLeft: viewport.canvasToWorld([left, top]),
        topRight: viewport.canvasToWorld([left + width, top]),
        bottomLeft: viewport.canvasToWorld([left, top + height]),
        bottomRight: viewport.canvasToWorld([left + width, top + height])
      };
    };
    this.addControlPointCallback = (evt, annotation) => {
      const { data } = annotation;
      const splineType = data.spline.type;
      const splineConfig = this._getSplineConfig(splineType);
      const maxDist = splineConfig.controlPointAdditionDistance;
      if (splineConfig.controlPointAdditionEnabled === false) {
        return;
      }
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine, viewport } = enabledElement;
      const { canvasToWorld } = viewport;
      const { instance: spline } = data.spline;
      const canvasPos = evt.detail.currentPoints.canvas;
      const closestPointInfo = spline.getClosestPoint(canvasPos);
      if (closestPointInfo.distance > maxDist) {
        return;
      }
      const { index, point: canvasPoint } = spline.addControlPointAtU(closestPointInfo.uValue);
      data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));
      annotation.invalidated = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.deleteControlPointCallback = (evt, annotation) => {
      const splineType = annotation.data.spline.type;
      const splineConfig = this._getSplineConfig(splineType);
      const maxDist = splineConfig.controlPointDeletionDistance;
      if (splineConfig.controlPointDeletionEnabled === false) {
        return;
      }
      const eventDetail = evt.detail;
      const { element, currentPoints } = eventDetail;
      const { canvas: canvasPos } = currentPoints;
      const { instance: spline } = annotation.data.spline;
      const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPos, maxDist);
      if (!closestControlPoint) {
        return;
      }
      this._deleteControlPointByIndex(element, annotation, closestControlPoint.index);
    };
    this._calculateCachedStats = (annotation, element) => {
      if (!this.configuration.calculateStats) {
        return;
      }
      const data = annotation.data;
      if (!data.contour.closed) {
        return;
      }
      const enabledElement = getEnabledElement(element);
      if (!enabledElement) {
        return;
      }
      const { viewport } = enabledElement;
      const { cachedStats } = data;
      const { polyline: points } = data.contour;
      const targetIds = Object.keys(cachedStats);
      for (let i = 0; i < targetIds.length; i++) {
        const targetId = targetIds[i];
        const image = this.getTargetImageData(targetId);
        if (!image) {
          continue;
        }
        const { metadata } = image;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const canvasPoint = canvasCoordinates[0];
        const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
        const deltaXPoint = viewport.canvasToWorld([
          canvasPoint[0] + 1,
          canvasPoint[1]
        ]);
        const deltaYPoint = viewport.canvasToWorld([
          canvasPoint[0],
          canvasPoint[1] + 1
        ]);
        const deltaInX = vec3_exports.distance(originalWorldPoint, deltaXPoint);
        const deltaInY = vec3_exports.distance(originalWorldPoint, deltaYPoint);
        const { imageData } = image;
        const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {
          const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY } = polyline_exports.getAABB(canvasCoordinates);
          const topLeftBBWorld = viewport.canvasToWorld([
            canvasMinX,
            canvasMinY
          ]);
          const topLeftBBIndex = utilities_exports.transformWorldToIndex(imageData, topLeftBBWorld);
          const bottomRightBBWorld = viewport.canvasToWorld([
            canvasMaxX,
            canvasMaxY
          ]);
          const bottomRightBBIndex = utilities_exports.transformWorldToIndex(imageData, bottomRightBBWorld);
          return [topLeftBBIndex, bottomRightBBIndex];
        });
        let area = polyline_exports.getArea(canvasCoordinates) / scale / scale;
        area *= deltaInX * deltaInY;
        cachedStats[targetId] = {
          Modality: metadata.Modality,
          area,
          areaUnit
        };
      }
      this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes_default.StatsUpdated);
      return cachedStats;
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
  addNewAnnotation(evt) {
    const eventDetail = evt.detail;
    const { currentPoints, element } = eventDetail;
    const { canvas: canvasPos } = currentPoints;
    const contourHoleProcessingEnabled = getMouseModifier_default(evt.detail.event) === this.configuration.contourHoleAdditionModifierKey;
    const enabledElement = getEnabledElement(element);
    const { renderingEngine } = enabledElement;
    const annotation = this.createAnnotation(evt);
    this.isDrawing = true;
    this.addAnnotation(annotation, element);
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    this.editData = {
      annotation,
      viewportIdsToRender,
      movingTextBox: false,
      newAnnotation: true,
      hasMoved: false,
      lastCanvasPoint: canvasPos,
      contourHoleProcessingEnabled
    };
    this._activateDraw(element);
    evt.preventDefault();
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    return annotation;
  }
  cancel(element) {
    if (!this.isDrawing) {
      return;
    }
    this.isDrawing = false;
    this._deactivateDraw(element);
    this._deactivateModify(element);
    resetElementCursor(element);
    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
    if (newAnnotation) {
      removeAnnotation(annotation.annotationUID);
    }
    super.cancelAnnotation(annotation);
    const enabledElement = getEnabledElement(element);
    const { renderingEngine } = enabledElement;
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    this.editData = null;
    return annotation.annotationUID;
  }
  isContourSegmentationTool() {
    return false;
  }
  renderAnnotationInstance(renderContext) {
    var _a2, _b2, _c;
    const { enabledElement, targetId, svgDrawingHelper, annotationStyle } = renderContext;
    const { viewport } = enabledElement;
    const { worldToCanvas } = viewport;
    const { element } = viewport;
    const annotation = renderContext.annotation;
    const { annotationUID, data, highlighted } = annotation;
    const { handles } = data;
    const { points: controlPoints, activeHandleIndex } = handles;
    const newAnnotation = (_a2 = this.editData) == null ? void 0 : _a2.newAnnotation;
    const { lineWidth, lineDash, color, locked: annotationLocked } = annotationStyle;
    const canvasCoordinates = controlPoints.map((p) => worldToCanvas(p));
    const { drawPreviewEnabled } = this.configuration.spline;
    const splineType = annotation.data.spline.type;
    const splineConfig = this._getSplineConfig(splineType);
    const spline = annotation.data.spline.instance;
    const childAnnotations = getChildAnnotations(annotation);
    const missingAnnotation = childAnnotations.findIndex((it) => !it);
    if (missingAnnotation !== -1) {
      throw new Error(`Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`);
    }
    const splineAnnotationsGroup = [annotation, ...childAnnotations].filter((annotation2) => this._isSplineROIAnnotation(annotation2));
    splineAnnotationsGroup.forEach((annotation2) => {
      const spline2 = this._updateSplineInstance(element, annotation2);
      const splinePolylineCanvas = spline2.getPolylinePoints();
      this.updateContourPolyline(annotation2, {
        points: splinePolylineCanvas,
        closed: data.contour.closed,
        targetWindingDirection: ContourWindingDirection.Clockwise
      }, viewport, { updateWindingDirection: data.contour.closed });
    });
    super.renderAnnotationInstance(renderContext);
    if (!data.cachedStats[targetId] || data.cachedStats[targetId].areaUnit == null) {
      data.cachedStats[targetId] = {
        Modality: null,
        area: null,
        areaUnit: null
      };
      this._calculateCachedStats(annotation, element);
    } else if (annotation.invalidated) {
      this._throttledCalculateCachedStats(annotation, element);
    }
    let activeHandleCanvasCoords;
    if (!annotationLocked && !this.editData && activeHandleIndex !== null) {
      activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
    }
    if (activeHandleCanvasCoords || newAnnotation || highlighted) {
      const handleGroupUID = "0";
      drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
        color,
        lineWidth,
        handleRadius: "3"
      });
    }
    if (drawPreviewEnabled && spline.numControlPoints > 1 && ((_b2 = this.editData) == null ? void 0 : _b2.lastCanvasPoint) && !spline.closed) {
      const { lastCanvasPoint } = this.editData;
      const previewPolylinePoints = spline.getPreviewPolylinePoints(lastCanvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);
      drawPolyline(svgDrawingHelper, annotationUID, "previewSplineChange", previewPolylinePoints, {
        color: "#9EA0CA",
        lineDash,
        lineWidth: 1
      });
    }
    if (splineConfig.showControlPointsConnectors) {
      const controlPointsConnectors = [...canvasCoordinates];
      if (spline.closed) {
        controlPointsConnectors.push(canvasCoordinates[0]);
      }
      drawPolyline(svgDrawingHelper, annotationUID, "controlPointsConnectors", controlPointsConnectors, {
        color: "rgba(255, 255, 255, 0.5)",
        lineWidth: 1
      });
    }
    this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);
    if (((_c = this.fireChangeOnUpdate) == null ? void 0 : _c.annotationUID) === annotationUID) {
      this.triggerChangeEvent(annotation, enabledElement, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled);
      this.fireChangeOnUpdate = null;
    }
    annotation.invalidated = false;
    return true;
  }
  createInterpolatedSplineControl(annotation) {
    var _a2;
    if ((_a2 = annotation.data.handles.points) == null ? void 0 : _a2.length) {
      return;
    }
    const { polyline } = annotation.data.contour;
    if (!polyline || !polyline.length) {
      return;
    }
    annotation.data.handles.points = [];
    const { points } = annotation.data.handles;
    const increment = Math.max(10, Math.floor(polyline.length / 20));
    for (let i = 0; i < polyline.length - increment; i += increment) {
      points.push(polyline[i]);
    }
    points.push(polyline[polyline.length - 1]);
  }
  createAnnotation(evt) {
    var _a2;
    const contourAnnotation = super.createAnnotation(evt);
    const { world: worldPos } = evt.detail.currentPoints;
    const { type: splineType } = this.configuration.spline;
    const splineConfig = this._getSplineConfig(splineType);
    const spline = new splineConfig.Class();
    const createSpline = () => ({
      type: splineConfig.type,
      instance: spline,
      resolution: splineConfig.resolution
    });
    let onInterpolationComplete;
    if ((_a2 = this.configuration.interpolation) == null ? void 0 : _a2.enabled) {
      onInterpolationComplete = (annotation) => {
        var _a3;
        (_a3 = annotation.data).spline || (_a3.spline = createSpline());
        this.createInterpolatedSplineControl(annotation);
      };
    }
    return utilities_exports.deepMerge(contourAnnotation, {
      data: {
        handles: {
          points: [[...worldPos]]
        },
        spline: createSpline(),
        cachedStats: {}
      },
      onInterpolationComplete
    });
  }
  _deleteControlPointByIndex(element, annotation, controlPointIndex) {
    const enabledElement = getEnabledElement(element);
    const { points: controlPoints } = annotation.data.handles;
    if (controlPoints.length === 3) {
      removeAnnotation(annotation.annotationUID);
    } else {
      controlPoints.splice(controlPointIndex, 1);
    }
    const { renderingEngine } = enabledElement;
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    annotation.invalidated = true;
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
  }
  _isSplineROIAnnotation(annotation) {
    var _a2;
    return !!((_a2 = annotation.data) == null ? void 0 : _a2.spline);
  }
  _getSplineConfig(type) {
    const { configuration: config } = this;
    const splineConfigs = config.spline.configuration;
    return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);
  }
  _updateSplineInstance(element, annotation) {
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    const { worldToCanvas } = viewport;
    const { data } = annotation;
    const { type: splineType, instance: spline } = annotation.data.spline;
    const splineConfig = this._getSplineConfig(splineType);
    const worldPoints = data.handles.points;
    const canvasPoints = worldPoints.map(worldToCanvas);
    const resolution = splineConfig.resolution !== void 0 ? parseInt(splineConfig.resolution) : void 0;
    const scale = splineConfig.scale !== void 0 ? parseFloat(splineConfig.scale) : void 0;
    spline.setControlPoints(canvasPoints);
    spline.closed = !!data.contour.closed;
    if (!spline.fixedResolution && resolution !== void 0 && spline.resolution !== resolution) {
      spline.resolution = resolution;
      annotation.invalidated = true;
    }
    if (spline instanceof CardinalSpline && !spline.fixedScale && scale !== void 0 && spline.scale !== scale) {
      spline.scale = scale;
      annotation.invalidated = true;
    }
    return spline;
  }
};
_SplineROITool.SplineTypes = SplineTypesEnum;
_SplineROITool.Actions = SplineToolActions;
_SplineROITool.hydrate = (viewportId, points, options) => {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  if (!enabledElement) {
    return;
  }
  if (points.length < SPLINE_MIN_POINTS) {
    console.warn("Spline requires at least 3 control points");
    return;
  }
  const { viewport } = enabledElement;
  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
  const { viewPlaneNormal, viewUp } = viewport.getCamera();
  const instance = new _SplineROITool();
  const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);
  const splineType = (options == null ? void 0 : options.splineType) || SplineTypesEnum.CatmullRom;
  const splineConfig = instance._getSplineConfig(splineType);
  const SplineClass = splineConfig.Class;
  const splineInstance = new SplineClass();
  const canvasPoints = points.map((point) => viewport.worldToCanvas(point));
  splineInstance.setControlPoints(canvasPoints);
  const splinePolylineCanvas = splineInstance.getPolylinePoints();
  const splinePolylineWorld = splinePolylineCanvas.map((point) => viewport.canvasToWorld(point));
  const annotation = {
    annotationUID: (options == null ? void 0 : options.annotationUID) || utilities_exports.uuidv4(),
    data: {
      handles: {
        points
      },
      label: "",
      cachedStats: {},
      spline: {
        type: splineType,
        instance: splineInstance
      },
      contour: {
        closed: true,
        polyline: splinePolylineWorld
      }
    },
    highlighted: false,
    autoGenerated: false,
    invalidated: true,
    isLocked: false,
    isVisible: true,
    metadata: {
      toolName: instance.getToolName(),
      viewPlaneNormal,
      FrameOfReferenceUID,
      referencedImageId,
      ...options
    }
  };
  addAnnotation(annotation, viewport.element);
  triggerAnnotationRenderForViewportIds_default([viewport.id]);
};
var SplineROITool = _SplineROITool;
function defaultGetTextLines11(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { area, isEmptyArea, areaUnit } = cachedVolumeStats;
  const textLines = [];
  if (area) {
    const areaLine = isEmptyArea ? `Area: Oblique not supported` : `Area: ${utilities_exports.roundNumber(area)} ${areaUnit}`;
    textLines.push(areaLine);
  }
  return textLines;
}
SplineROITool.toolName = "SplineROI";
var SplineROITool_default = SplineROITool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js
var SplineContourSegmentationTool = class extends SplineROITool_default {
  constructor(toolProps) {
    const initialProps = utilities_exports.deepMerge({
      configuration: {
        calculateStats: false
      }
    }, toolProps);
    super(initialProps);
  }
  isContourSegmentationTool() {
    return true;
  }
};
SplineContourSegmentationTool.toolName = "SplineContourSegmentationTool";
var SplineContourSegmentationTool_default = SplineContourSegmentationTool;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/BucketQueue.js
var BucketQueue = class {
  constructor({ numBits, getPriority, areEqual }) {
    this._bucketCount = 1 << numBits;
    this._mask = this._bucketCount - 1;
    this._size = 0;
    this._currentBucketIndex = 0;
    this._buckets = this._buildArray(this._bucketCount);
    this._getPriority = typeof getPriority !== "undefined" ? getPriority : (item) => item;
    this._areEqual = typeof areEqual === "function" ? areEqual : (itemA, itemB) => itemA === itemB;
  }
  push(item) {
    const bucketIndex = this._getBucketIndex(item);
    const oldHead = this._buckets[bucketIndex];
    const newHead = {
      value: item,
      next: oldHead
    };
    this._buckets[bucketIndex] = newHead;
    this._size++;
  }
  pop() {
    if (this._size === 0) {
      throw new Error("Cannot pop because the queue is empty.");
    }
    while (this._buckets[this._currentBucketIndex] === null) {
      this._currentBucketIndex = (this._currentBucketIndex + 1) % this._bucketCount;
    }
    const ret = this._buckets[this._currentBucketIndex];
    this._buckets[this._currentBucketIndex] = ret.next;
    this._size--;
    return ret.value;
  }
  remove(item) {
    if (!item) {
      return false;
    }
    const bucketIndex = this._getBucketIndex(item);
    const firstBucketNode = this._buckets[bucketIndex];
    let node = firstBucketNode;
    let prevNode;
    while (node !== null) {
      if (this._areEqual(item, node.value)) {
        break;
      }
      prevNode = node;
      node = node.next;
    }
    if (node === null) {
      return false;
    }
    if (node === firstBucketNode) {
      this._buckets[bucketIndex] = node.next;
    } else {
      prevNode.next = node.next;
    }
    this._size--;
    return true;
  }
  isEmpty() {
    return this._size === 0;
  }
  _getBucketIndex(item) {
    return this._getPriority(item) & this._mask;
  }
  _buildArray(size) {
    const buckets = new Array(size);
    buckets.fill(null);
    return buckets;
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LivewireScissors.js
var { isEqual: isEqual7 } = utilities_exports;
var MAX_UINT32 = 4294967295;
var TWO_THIRD_PI = 2 / (3 * Math.PI);
var LivewireScissors = class _LivewireScissors {
  constructor(grayscalePixelData, width, height) {
    this._getPointIndex = (row, col) => {
      const { width: width2 } = this;
      return row * width2 + col;
    };
    this._getPointCoordinate = (index) => {
      const x = index % this.width;
      const y = Math.floor(index / this.width);
      return [x, y];
    };
    this._getPointCost = (pointIndex) => {
      return Math.round(this.searchGranularity * this.costs[pointIndex]);
    };
    const numPixels = grayscalePixelData.length;
    this.searchGranularityBits = 8;
    this.searchGranularity = 1 << this.searchGranularityBits;
    this.width = width;
    this.height = height;
    this.grayscalePixelData = grayscalePixelData;
    this.laplace = null;
    this.gradXNew = null;
    this.gradYNew = null;
    this.laplace = this._computeLaplace();
    this.gradMagnitude = this._computeGradient();
    this.gradXNew = this._computeGradientX();
    this.gradYNew = this._computeGradientY();
    this.visited = new Array(numPixels);
    this.parents = new Uint32Array(numPixels);
    this.costs = new Float32Array(numPixels);
  }
  startSearch(startPoint) {
    const startPointIndex = this._getPointIndex(startPoint[1], startPoint[0]);
    this.startPoint = null;
    this.visited.fill(false);
    this.parents.fill(MAX_UINT32);
    this.costs.fill(Infinity);
    this.priorityQueueNew = new BucketQueue({
      numBits: this.searchGranularityBits,
      getPriority: this._getPointCost
    });
    this.startPoint = startPoint;
    this.costs[startPointIndex] = 0;
    this.priorityQueueNew.push(startPointIndex);
  }
  findMinNearby(testPoint, delta = 2) {
    const [x, y] = testPoint;
    const { costs } = this;
    const xRange = [
      Math.max(0, x - delta),
      Math.min(x + delta + 1, this.width)
    ];
    const yRange = [
      Math.max(0, y - delta),
      Math.min(y + delta + 1, this.height)
    ];
    let minValue = costs[this._getPointIndex(y, x)] * 0.8;
    let minPoint = testPoint;
    for (let xTest = xRange[0]; xTest < xRange[1]; xTest++) {
      for (let yTest = yRange[0]; yTest < yRange[1]; yTest++) {
        const distanceCost = 1 - (Math.abs(xTest - testPoint[0]) + Math.abs(yTest - testPoint[1])) / delta / 2;
        const weightCost = costs[this._getPointIndex(yTest, xTest)];
        const weight = weightCost * 0.8 + distanceCost * 0.2;
        if (weight < minValue) {
          minPoint = [xTest, yTest];
          minValue = weight;
        }
      }
    }
    return minPoint;
  }
  findPathToPoint(targetPoint) {
    if (!this.startPoint) {
      throw new Error("There is no search in progress");
    }
    const { startPoint, _getPointIndex: index, _getPointCoordinate: coord } = this;
    const startPointIndex = index(startPoint[1], startPoint[0]);
    const targetPointIndex = index(targetPoint[1], targetPoint[0]);
    const { visited, parents, costs: cost, priorityQueueNew: priorityQueue } = this;
    if (targetPointIndex === startPointIndex) {
      return [];
    }
    while (!priorityQueue.isEmpty() && parents[targetPointIndex] === MAX_UINT32) {
      const pointIndex = priorityQueue.pop();
      if (visited[pointIndex]) {
        continue;
      }
      const point = coord(pointIndex);
      const neighborsPoints = this._getNeighborPoints(point);
      visited[pointIndex] = true;
      for (let i = 0, len = neighborsPoints.length; i < len; i++) {
        const neighborPoint = neighborsPoints[i];
        const neighborPointIndex = index(neighborPoint[1], neighborPoint[0]);
        const dist = this._getWeightedDistance(point, neighborPoint);
        const neighborCost = cost[pointIndex] + dist;
        if (neighborCost < cost[neighborPointIndex]) {
          if (cost[neighborPointIndex] !== Infinity) {
            priorityQueue.remove(neighborPointIndex);
          }
          cost[neighborPointIndex] = neighborCost;
          parents[neighborPointIndex] = pointIndex;
          priorityQueue.push(neighborPointIndex);
        }
      }
    }
    const pathPoints = [];
    let pathPointIndex = targetPointIndex;
    while (pathPointIndex !== MAX_UINT32) {
      pathPoints.push(coord(pathPointIndex));
      pathPointIndex = parents[pathPointIndex];
    }
    return pathPoints.reverse();
  }
  _getDeltaX(x, y) {
    const { grayscalePixelData: data, width } = this;
    let index = this._getPointIndex(y, x);
    if (x + 1 === width) {
      index--;
    }
    return data[index + 1] - data[index];
  }
  _getDeltaY(x, y) {
    const { grayscalePixelData: data, width, height } = this;
    let index = this._getPointIndex(y, x);
    if (y + 1 === height) {
      index -= width;
    }
    return data[index] - data[index + width];
  }
  _getGradientMagnitude(x, y) {
    const dx = this._getDeltaX(x, y);
    const dy = this._getDeltaY(x, y);
    return Math.sqrt(dx * dx + dy * dy);
  }
  _getLaplace(x, y) {
    const { grayscalePixelData: data, _getPointIndex: index } = this;
    const p02 = data[index(y - 2, x)];
    const p11 = data[index(y - 1, x - 1)];
    const p12 = data[index(y - 1, x)];
    const p13 = data[index(y - 1, x + 1)];
    const p20 = data[index(y, x - 2)];
    const p21 = data[index(y, x - 1)];
    const p22 = data[index(y, x)];
    const p23 = data[index(y, x + 1)];
    const p24 = data[index(y, x + 2)];
    const p31 = data[index(y + 1, x - 1)];
    const p32 = data[index(y + 1, x)];
    const p33 = data[index(y + 1, x + 1)];
    const p42 = data[index(y + 2, x)];
    let lap = p02;
    lap += p11 + 2 * p12 + p13;
    lap += p20 + 2 * p21 - 16 * p22 + 2 * p23 + p24;
    lap += p31 + 2 * p32 + p33;
    lap += p42;
    return lap;
  }
  _computeGradient() {
    const { width, height } = this;
    const gradient = new Float32Array(width * height);
    let pixelIndex = 0;
    let max2 = 0;
    let x = 0;
    let y = 0;
    for (y = 0; y < height - 1; y++) {
      for (x = 0; x < width - 1; x++) {
        gradient[pixelIndex] = this._getGradientMagnitude(x, y);
        max2 = Math.max(gradient[pixelIndex], max2);
        pixelIndex++;
      }
      gradient[pixelIndex] = gradient[pixelIndex - 1];
      pixelIndex++;
    }
    for (let len = gradient.length; pixelIndex < len; pixelIndex++) {
      gradient[pixelIndex] = gradient[pixelIndex - width];
    }
    for (let i = 0, len = gradient.length; i < len; i++) {
      gradient[i] = 1 - gradient[i] / max2;
    }
    return gradient;
  }
  _computeLaplace() {
    const { width, height, _getPointIndex: index } = this;
    const laplace = new Float32Array(width * height);
    laplace.fill(1, 0, index(2, 0));
    for (let y = 2; y < height - 2; y++) {
      laplace[index(y, 0)] = 1;
      laplace[index(y, 1)] = 1;
      for (let x = 2; x < width - 2; x++) {
        laplace[index(y, x)] = this._getLaplace(x, y) > 0.33 ? 0 : 1;
      }
      laplace[index(y, width - 2)] = 1;
      laplace[index(y, width - 1)] = 1;
    }
    laplace.fill(1, index(height - 2, 0));
    return laplace;
  }
  _computeGradientX() {
    const { width, height } = this;
    const gradX = new Float32Array(width * height);
    let pixelIndex = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        gradX[pixelIndex++] = this._getDeltaX(x, y);
      }
    }
    return gradX;
  }
  _computeGradientY() {
    const { width, height } = this;
    const gradY = new Float32Array(width * height);
    let pixelIndex = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        gradY[pixelIndex++] = this._getDeltaY(x, y);
      }
    }
    return gradY;
  }
  _getGradientUnitVector(px, py) {
    const { gradXNew, gradYNew, _getPointIndex: index } = this;
    const pointGradX = gradXNew[index(py, px)];
    const pointGradY = gradYNew[index(py, px)];
    let gradVecLen = Math.sqrt(pointGradX * pointGradX + pointGradY * pointGradY);
    gradVecLen = Math.max(gradVecLen, 1e-100);
    return [pointGradX / gradVecLen, pointGradY / gradVecLen];
  }
  _getGradientDirection(px, py, qx, qy) {
    const dgpUnitVec = this._getGradientUnitVector(px, py);
    const gdqUnitVec = this._getGradientUnitVector(qx, qy);
    let dp = dgpUnitVec[1] * (qx - px) - dgpUnitVec[0] * (qy - py);
    let dq = gdqUnitVec[1] * (qx - px) - gdqUnitVec[0] * (qy - py);
    if (dp < 0) {
      dp = -dp;
      dq = -dq;
    }
    if (px !== qx && py !== qy) {
      dp *= Math.SQRT1_2;
      dq *= Math.SQRT1_2;
    }
    dq = Math.min(Math.max(dq, -1), 1);
    const direction = TWO_THIRD_PI * (Math.acos(Math.min(dp, 1)) + Math.acos(dq));
    if (isNaN(direction) || !isFinite(direction)) {
      console.warn("Found non-direction:", px, py, qx, qy, dp, dq, direction);
      return 1;
    }
    return direction;
  }
  getCost(pointA, pointB) {
    return this._getWeightedDistance(pointA, pointB);
  }
  _getWeightedDistance(pointA, pointB) {
    const { _getPointIndex: index, width, height } = this;
    const [aX, aY] = pointA;
    const [bX, bY] = pointB;
    if (bX < 0 || bX >= width || bY < 0 || bY >= height) {
      return 1;
    }
    if (aX < 0 || aY < 0 || aX >= width || aY >= height) {
      return 0;
    }
    const bIndex = index(bY, bX);
    let gradient = this.gradMagnitude[bIndex];
    if (aX === bX || aY === bY) {
      gradient *= Math.SQRT1_2;
    }
    const laplace = this.laplace[bIndex];
    const direction = this._getGradientDirection(aX, aY, bX, bY);
    return 0.43 * gradient + 0.43 * laplace + 0.11 * direction;
  }
  _getNeighborPoints(point) {
    const { width, height } = this;
    const list = [];
    const sx = Math.max(point[0] - 1, 0);
    const sy = Math.max(point[1] - 1, 0);
    const ex = Math.min(point[0] + 1, width - 1);
    const ey = Math.min(point[1] + 1, height - 1);
    for (let y = sy; y <= ey; y++) {
      for (let x = sx; x <= ex; x++) {
        if (x !== point[0] || y !== point[1]) {
          list.push([x, y]);
        }
      }
    }
    return list;
  }
  static createInstanceFromRawPixelData(pixelData, width, height, voiRange) {
    const numPixels = pixelData.length;
    const grayscalePixelData = new Float32Array(numPixels);
    const { lower: minPixelValue, upper: maxPixelValue } = voiRange;
    const pixelRange = maxPixelValue - minPixelValue;
    for (let i = 0, len = pixelData.length; i < len; i++) {
      grayscalePixelData[i] = Math.max(0, Math.min(1, (pixelData[i] - minPixelValue) / pixelRange));
    }
    return new _LivewireScissors(grayscalePixelData, width, height);
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LiveWirePath.js
var LivewirePath = class {
  constructor(inputPointArray, inputControlPointIndexArray) {
    this.pointArray = inputPointArray ? inputPointArray.slice() : [];
    this._controlPointIndexes = inputControlPointIndexArray ? inputControlPointIndexArray.slice() : [];
  }
  getPoint(index) {
    return this.pointArray[index];
  }
  getLastPoint() {
    return this.pointArray[this.pointArray.length - 1];
  }
  isControlPoint(point) {
    const index = this.pointArray.indexOf(point);
    if (index !== -1) {
      return this._controlPointIndexes.indexOf(index) !== -1;
    } else {
      throw new Error("Error: isControlPoint called with not in list point.");
    }
  }
  addPoint(point) {
    this.pointArray.push(point);
  }
  addControlPoint(point) {
    const index = this.pointArray.indexOf(point);
    if (index !== -1) {
      this._controlPointIndexes.push(index);
    } else {
      throw new Error("Cannot mark a non registered point as control point.");
    }
  }
  getControlPoints() {
    return this._controlPointIndexes.map((i) => this.pointArray[i]);
  }
  getNumControlPoints() {
    return this._controlPointIndexes.length;
  }
  removeLastControlPoint() {
    if (this._controlPointIndexes.length) {
      this._controlPointIndexes.pop();
    }
  }
  getLastControlPoint() {
    if (this._controlPointIndexes.length) {
      return this.pointArray[this._controlPointIndexes[this._controlPointIndexes.length - 1]];
    }
  }
  removeLastPoints(count) {
    this.pointArray.splice(this.pointArray.length - count, count);
  }
  addPoints(newPointArray) {
    this.pointArray = this.pointArray.concat(newPointArray);
  }
  prependPath(other) {
    const otherSize = other.pointArray.length;
    const shiftedIndexArray = [];
    this.pointArray = other.pointArray.concat(this.pointArray);
    for (let i = 0; i < this._controlPointIndexes.length; ++i) {
      shiftedIndexArray[i] = this._controlPointIndexes[i] + otherSize;
    }
    this._controlPointIndexes = other._controlPointIndexes.concat(shiftedIndexArray);
  }
  appendPath(other) {
    this.addPoints(other.pointArray);
    other._controlPointIndexes.forEach((point) => this._controlPointIndexes.push(point));
  }
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js
var CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;
var LivewireContourTool = class extends ContourSegmentationBaseTool {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      getTextLines: defaultGetTextLines12,
      calculateStats: true,
      preventHandleOutsideImage: false,
      contourHoleAdditionModifierKey: KeyboardBindings.Shift,
      snapHandleNearby: 2,
      interpolation: {
        enabled: false,
        nearestEdge: 2,
        showInterpolationPolyline: false
      },
      decimate: {
        enabled: false,
        epsilon: 0.1
      },
      actions: {
        cancelInProgress: {
          method: "cancelInProgress",
          bindings: [
            {
              key: "Escape"
            }
          ]
        }
      }
    }
  }) {
    super(toolProps, defaultToolProps);
    this.isHandleOutsideImage = false;
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const proximitySquared = proximity * proximity;
      const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));
      let startPoint = canvasPoints[canvasPoints.length - 1];
      for (let i = 0; i < canvasPoints.length; i++) {
        const endPoint = canvasPoints[i];
        const distanceToPointSquared4 = line_exports.distanceToPointSquared(startPoint, endPoint, canvasCoords);
        if (distanceToPointSquared4 <= proximitySquared) {
          return true;
        }
        startPoint = endPoint;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        movingTextBox: false
      };
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      this._activateModify(element);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this.handleSelectedCallback = (evt, annotation, handle) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { data } = annotation;
      annotation.highlighted = true;
      let movingTextBox = false;
      let handleIndex;
      if (handle.worldPosition) {
        movingTextBox = true;
      } else {
        const { points } = data.handles;
        handleIndex = points.findIndex((p) => p === handle);
      }
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex,
        movingTextBox
      };
      this._activateModify(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt, clearAnnotation = false) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled } = this.editData;
      const { data } = annotation;
      this.doneEditMemo();
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      const enabledElement = getEnabledElement(element);
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage || clearAnnotation) {
        removeAnnotation(annotation.annotationUID);
        this.clearEditData();
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        return;
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      const changeType = newAnnotation ? ChangeTypes_default.Completed : ChangeTypes_default.HandlesUpdated;
      this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);
      this.clearEditData();
    };
    this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes_default.StatsUpdated, contourHoleProcessingEnabled = false) => {
      if (changeType === ChangeTypes_default.Completed) {
        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);
      } else {
        triggerAnnotationModified(annotation, enabledElement.viewport.element, changeType);
      }
    };
    this._mouseDownCallback = (evt) => {
      const doubleClick = evt.type === Events_default.MOUSE_DOUBLE_CLICK;
      const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld, newAnnotation } = this.editData;
      if (this.editData.closed) {
        return;
      }
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { currentPoints } = eventDetail;
      const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;
      let worldPos = worldPosOriginal;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      const controlPoints = this.editData.currentPath.getControlPoints();
      let closePath = controlPoints.length >= 2 && doubleClick;
      this.doneEditMemo();
      this.createMemo(element, annotation, {
        newAnnotation: newAnnotation && controlPoints.length === 1
      });
      if (controlPoints.length >= 2) {
        const closestHandlePoint = {
          index: -1,
          distSquared: Infinity
        };
        for (let i = 0, len = controlPoints.length; i < len; i++) {
          const controlPoint = controlPoints[i];
          const worldControlPoint = sliceToWorld(controlPoint);
          const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);
          const distSquared = point_exports.distanceToPointSquared(canvasPos, canvasControlPoint);
          if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST && distSquared < closestHandlePoint.distSquared) {
            closestHandlePoint.distSquared = distSquared;
            closestHandlePoint.index = i;
          }
        }
        if (closestHandlePoint.index === 0) {
          closePath = true;
        }
      }
      const { snapHandleNearby } = this.configuration;
      if (snapHandleNearby && !this.editData.closed) {
        const currentPath = new LivewirePath();
        const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);
        const pathPoints = this.scissors.findPathToPoint(snapPoint);
        currentPath.addPoints(pathPoints);
        currentPath.prependPath(this.editData.confirmedPath);
        worldPos = sliceToWorld(snapPoint);
        this.editData.currentPath = currentPath;
      }
      this.editData.closed = this.editData.closed || closePath;
      this.editData.confirmedPath = this.editData.currentPath;
      const lastPoint = this.editData.currentPath.getLastPoint();
      this.editData.confirmedPath.addControlPoint(lastPoint);
      annotation.data.handles.points.push(sliceToWorld(lastPoint));
      this.scissors.startSearch(worldToSlice(worldPos));
      annotation.invalidated = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (this.editData.closed) {
        this.updateAnnotation(this.editData.confirmedPath);
        this._endCallback(evt);
      }
      evt.preventDefault();
    };
    this._mouseMoveCallback = (evt) => {
      const { element, currentPoints } = evt.detail;
      const { world: worldPos, canvas: canvasPos } = currentPoints;
      const { renderingEngine } = getEnabledElement(element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData.lastCanvasPoint = canvasPos;
      const { width: imgWidth, height: imgHeight } = this.scissors;
      const { worldToSlice } = this.editData;
      const slicePoint = worldToSlice(worldPos);
      if (slicePoint[0] < 0 || slicePoint[1] < 0 || slicePoint[0] >= imgWidth || slicePoint[1] >= imgHeight) {
        return;
      }
      const pathPoints = this.scissors.findPathToPoint(slicePoint);
      const currentPath = new LivewirePath();
      currentPath.addPoints(pathPoints);
      currentPath.prependPath(this.editData.confirmedPath);
      this.editData.currentPath = currentPath;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, movingTextBox, handleIndex, newAnnotation } = this.editData;
      this.createMemo(element, annotation, { newAnnotation });
      const { data } = annotation;
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0) {
        console.warn("Drag annotation not implemented");
      } else {
        const { currentPoints } = eventDetail;
        const worldPos = currentPoints.world;
        this.editHandle(worldPos, element, annotation, handleIndex);
      }
      this.editData.hasMoved = true;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.cancel = (element) => {
      if (!this.isDrawing) {
        return;
      }
      this.isDrawing = false;
      this._deactivateDraw(element);
      this._deactivateModify(element);
      resetElementCursor(element);
      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
      if (newAnnotation) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      this.doneEditMemo();
      this.scissors = null;
      return annotation.annotationUID;
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_MOVE, this._mouseMoveCallback);
      element.addEventListener(Events_default.MOUSE_DOWN, this._mouseDownCallback);
      element.addEventListener(Events_default.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._mouseDownCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_MOVE, this._mouseMoveCallback);
      element.removeEventListener(Events_default.MOUSE_DOWN, this._mouseDownCallback);
      element.removeEventListener(Events_default.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._mouseDownCallback);
    };
    this._calculateCachedStats = (annotation, element) => {
      if (!this.configuration.calculateStats) {
        return;
      }
      const data = annotation.data;
      if (!data.contour.closed) {
        return;
      }
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      const { cachedStats } = data;
      const { polyline: points } = data.contour;
      const targetIds = Object.keys(cachedStats);
      for (let i = 0; i < targetIds.length; i++) {
        const targetId = targetIds[i];
        const image = this.getTargetImageData(targetId);
        if (!image) {
          continue;
        }
        const { metadata } = image;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const canvasPoint = canvasCoordinates[0];
        const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
        const deltaXPoint = viewport.canvasToWorld([
          canvasPoint[0] + 1,
          canvasPoint[1]
        ]);
        const deltaYPoint = viewport.canvasToWorld([
          canvasPoint[0],
          canvasPoint[1] + 1
        ]);
        const deltaInX = vec3_exports.distance(originalWorldPoint, deltaXPoint);
        const deltaInY = vec3_exports.distance(originalWorldPoint, deltaYPoint);
        const { imageData } = image;
        const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {
          const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY } = polyline_exports.getAABB(canvasCoordinates);
          const topLeftBBWorld = viewport.canvasToWorld([
            canvasMinX,
            canvasMinY
          ]);
          const topLeftBBIndex = utilities_exports.transformWorldToIndex(imageData, topLeftBBWorld);
          const bottomRightBBWorld = viewport.canvasToWorld([
            canvasMaxX,
            canvasMaxY
          ]);
          const bottomRightBBIndex = utilities_exports.transformWorldToIndex(imageData, bottomRightBBWorld);
          return [topLeftBBIndex, bottomRightBBIndex];
        });
        let area = polyline_exports.getArea(canvasCoordinates) / scale / scale;
        area *= deltaInX * deltaInY;
        cachedStats[targetId] = {
          Modality: metadata.Modality,
          area,
          areaUnit
        };
      }
      this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes_default.StatsUpdated);
      return cachedStats;
    };
    this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {
      const data = annotation.data;
      const targetId = this.getTargetId(viewport);
      if (!data.contour.closed || !textboxStyle.visibility) {
        return;
      }
      const textLines = this.configuration.getTextLines(data, targetId);
      if (!textLines || textLines.length === 0) {
        return;
      }
      const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
      if (!data.handles.textBox.hasMoved) {
        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);
        data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
      }
      const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
      const textBoxUID = "textBox";
      const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotation.annotationUID ?? "", textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);
      const { x: left, y: top, width, height } = boundingBox;
      data.handles.textBox.worldBoundingBox = {
        topLeft: viewport.canvasToWorld([left, top]),
        topRight: viewport.canvasToWorld([left + width, top]),
        bottomLeft: viewport.canvasToWorld([left, top + height]),
        bottomRight: viewport.canvasToWorld([left + width, top + height])
      };
    };
    this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes_default.StatsUpdated) => {
      const { viewportId, renderingEngineId } = enabledElement;
      const eventType = Events_default.ANNOTATION_MODIFIED;
      const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId,
        changeType
      };
      triggerEvent(eventTarget_default, eventType, eventDetail);
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
  setupBaseEditData(worldPos, element, annotation, nextPos, contourHoleProcessingEnabled) {
    var _a2, _b2;
    const enabledElement = getEnabledElement(element);
    const { viewport } = enabledElement;
    this.isDrawing = true;
    const viewportImageData = viewport.getImageData();
    const { imageData: vtkImageData } = viewportImageData;
    let worldToSlice;
    let sliceToWorld;
    let width;
    let height;
    let scalarData;
    if (!(viewport instanceof VolumeViewport_default)) {
      width = viewportImageData.dimensions[0];
      height = viewportImageData.dimensions[1];
      worldToSlice = (point) => {
        const ijkPoint = utilities_exports.transformWorldToIndex(vtkImageData, point);
        return [ijkPoint[0], ijkPoint[1]];
      };
      sliceToWorld = (point) => utilities_exports.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);
      scalarData = viewportImageData.scalarData;
    } else if (viewport instanceof VolumeViewport_default) {
      const sliceImageData = utilities_exports.getCurrentVolumeViewportSlice(viewport);
      const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;
      worldToSlice = (point) => {
        const ijkPoint = utilities_exports.transformWorldToIndex(vtkImageData, point);
        const slicePoint = vec3_exports.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);
        return [slicePoint[0], slicePoint[1]];
      };
      sliceToWorld = (point) => {
        const ijkPoint = vec3_exports.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);
        return utilities_exports.transformIndexToWorld(vtkImageData, ijkPoint);
      };
      scalarData = sliceImageData.scalarData;
      width = sliceImageData.width;
      height = sliceImageData.height;
    } else {
      throw new Error("Viewport not supported");
    }
    scalarData = utilities_exports.convertToGrayscale(scalarData, width, height);
    const { voiRange } = viewport.getProperties();
    const startPos = worldToSlice(worldPos);
    this.scissors = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
    if (nextPos) {
      this.scissorsNext = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
      this.scissorsNext.startSearch(worldToSlice(nextPos));
    }
    this.scissors.startSearch(startPos);
    const newAnnotation = !nextPos;
    const confirmedPath = new LivewirePath();
    const currentPath = new LivewirePath();
    const currentPathNext = newAnnotation ? void 0 : new LivewirePath();
    confirmedPath.addPoint(startPos);
    confirmedPath.addControlPoint(startPos);
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    const lastCanvasPoint = viewport.worldToCanvas(worldPos);
    this.editData = {
      annotation,
      viewportIdsToRender,
      newAnnotation,
      hasMoved: false,
      lastCanvasPoint,
      confirmedPath,
      currentPath,
      confirmedPathNext: currentPathNext,
      closed: false,
      handleIndex: ((_a2 = this.editData) == null ? void 0 : _a2.handleIndex) ?? ((_b2 = annotation.handles) == null ? void 0 : _b2.activeHandleIndex),
      worldToSlice,
      sliceToWorld,
      contourHoleProcessingEnabled
    };
  }
  addNewAnnotation(evt) {
    const eventDetail = evt.detail;
    const { currentPoints, element } = eventDetail;
    const { world: worldPos } = currentPoints;
    const annotation = this.createAnnotation(evt);
    const contourHoleProcessingEnabled = getMouseModifier_default(evt.detail.event) === this.configuration.contourHoleAdditionModifierKey;
    this.setupBaseEditData(worldPos, element, annotation, void 0, contourHoleProcessingEnabled);
    this.addAnnotation(annotation, element);
    this._activateDraw(element);
    evt.preventDefault();
    triggerAnnotationRenderForViewportIds_default(this.editData.viewportIdsToRender);
    return annotation;
  }
  clearEditData() {
    this.editData = null;
    this.scissors = null;
    this.scissorsNext = null;
    this.isDrawing = false;
  }
  editHandle(worldPos, element, annotation, handleIndex) {
    var _a2;
    const { data } = annotation;
    const { points: handlePoints } = data.handles;
    const { length: numHandles } = handlePoints;
    const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];
    const nextHandle = handlePoints[(handleIndex + 1) % numHandles];
    if (!((_a2 = this.editData) == null ? void 0 : _a2.confirmedPathNext)) {
      this.setupBaseEditData(previousHandle, element, annotation, nextHandle);
      const { polyline } = data.contour;
      const confirmedPath = new LivewirePath();
      const confirmedPathNext = new LivewirePath();
      const { worldToSlice: worldToSlice2 } = this.editData;
      const previousIndex = findHandlePolylineIndex(annotation, handleIndex - 1);
      const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);
      if (nextIndex === -1 || previousIndex === -1) {
        throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);
      }
      if (handleIndex === 0) {
        confirmedPathNext.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice2));
      } else {
        confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice2));
        confirmedPathNext.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice2));
      }
      this.editData.confirmedPath = confirmedPath;
      this.editData.confirmedPathNext = confirmedPathNext;
    }
    const { editData, scissors } = this;
    const { worldToSlice, sliceToWorld } = editData;
    const { activeHandleIndex } = data.handles;
    if (activeHandleIndex === null || activeHandleIndex === void 0) {
      data.handles.activeHandleIndex = handleIndex;
    } else if (activeHandleIndex !== handleIndex) {
      throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);
    }
    const slicePos = worldToSlice(worldPos);
    if (slicePos[0] < 0 || slicePos[0] >= scissors.width || slicePos[1] < 0 || slicePos[1] >= scissors.height) {
      return;
    }
    handlePoints[handleIndex] = sliceToWorld(slicePos);
    const pathPointsLeft = scissors.findPathToPoint(slicePos);
    const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);
    const currentPath = new LivewirePath();
    currentPath.prependPath(editData.confirmedPath);
    if (handleIndex !== 0) {
      currentPath.addPoints(pathPointsLeft);
    }
    currentPath.addPoints(pathPointsRight.reverse());
    currentPath.appendPath(editData.confirmedPathNext);
    if (handleIndex === 0) {
      currentPath.addPoints(pathPointsLeft);
    }
    editData.currentPath = currentPath;
    annotation.invalidated = true;
    editData.hasMoved = true;
    editData.closed = true;
  }
  renderAnnotation(enabledElement, svgDrawingHelper) {
    var _a2;
    this.updateAnnotation((_a2 = this.editData) == null ? void 0 : _a2.currentPath);
    return super.renderAnnotation(enabledElement, svgDrawingHelper);
  }
  isContourSegmentationTool() {
    return false;
  }
  createAnnotation(evt) {
    const contourSegmentationAnnotation = super.createAnnotation(evt);
    const { world: worldPos } = evt.detail.currentPoints;
    const annotation = utilities_exports.deepMerge(contourSegmentationAnnotation, {
      data: {
        handles: {
          points: [[...worldPos]]
        }
      }
    });
    return annotation;
  }
  cancelInProgress(element, config, evt) {
    if (!this.editData) {
      this.undo();
      return;
    }
    this._endCallback(evt, true);
  }
  renderAnnotationInstance(renderContext) {
    var _a2, _b2, _c, _d;
    const { annotation, enabledElement, svgDrawingHelper, annotationStyle, targetId } = renderContext;
    const { viewport } = enabledElement;
    const { element } = viewport;
    const { worldToCanvas } = viewport;
    const { annotationUID, data, highlighted } = annotation;
    const { handles } = data;
    const newAnnotation = (_a2 = this.editData) == null ? void 0 : _a2.newAnnotation;
    const { lineWidth, lineDash, color } = annotationStyle;
    if (highlighted || newAnnotation && annotation.annotationUID === ((_c = (_b2 = this.editData) == null ? void 0 : _b2.annotation) == null ? void 0 : _c.annotationUID)) {
      const handleGroupUID = "0";
      const canvasHandles = handles.points.map(worldToCanvas);
      drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {
        color,
        lineDash,
        lineWidth
      });
    }
    super.renderAnnotationInstance(renderContext);
    if (!data.cachedStats[targetId] || ((_d = data.cachedStats[targetId]) == null ? void 0 : _d.areaUnit) === null) {
      data.cachedStats[targetId] = {
        Modality: null,
        area: null,
        areaUnit: null
      };
      this._calculateCachedStats(annotation, element);
    } else if (annotation.invalidated) {
      this._throttledCalculateCachedStats(annotation, element);
    }
    this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);
    return true;
  }
  updateAnnotation(livewirePath) {
    if (!this.editData || !livewirePath) {
      return;
    }
    const { annotation, sliceToWorld, worldToSlice, closed: closed2, newAnnotation } = this.editData;
    let { pointArray: imagePoints } = livewirePath;
    if (imagePoints.length > 1) {
      imagePoints = [...imagePoints, imagePoints[0]];
    }
    const targetWindingDirection = newAnnotation && closed2 ? ContourWindingDirection.Clockwise : void 0;
    this.updateContourPolyline(annotation, {
      points: imagePoints,
      closed: closed2,
      targetWindingDirection
    }, {
      canvasToWorld: sliceToWorld,
      worldToCanvas: worldToSlice
    });
  }
};
LivewireContourTool.toolName = "LivewireContour";
var LivewireContourTool_default = LivewireContourTool;
function defaultGetTextLines12(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { area, areaUnit } = cachedVolumeStats;
  const textLines = [];
  if (area) {
    const areaLine = `Area: ${utilities_exports.roundNumber(area)} ${areaUnit}`;
    textLines.push(areaLine);
  }
  return textLines;
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js
var LivewireContourSegmentationTool = class extends LivewireContourTool_default {
  updateInterpolatedAnnotation(annotation, enabledElement) {
    if (this.editData || !annotation.invalidated || !annotation.data.handles.interpolationSources) {
      return;
    }
    annotation.data.contour.originalPolyline = annotation.data.contour.polyline;
    queueMicrotask(() => {
      if (!annotation.data.handles.interpolationSources) {
        return;
      }
      const { points } = annotation.data.handles;
      const { element } = enabledElement.viewport;
      this.setupBaseEditData(points[0], element, annotation);
      const { length: count } = points;
      const { scissors } = this;
      const { nearestEdge, repeatInterpolation } = this.configuration.interpolation;
      annotation.data.handles.originalPoints = points;
      const { worldToSlice, sliceToWorld } = this.editData;
      const handleSmoothing = [];
      if (nearestEdge) {
        let lastPoint = worldToSlice(points[points.length - 1]);
        points.forEach((point, hIndex) => {
          const testPoint = worldToSlice(point);
          lastPoint = testPoint;
          handleSmoothing.push(testPoint);
          scissors.startSearch(lastPoint);
          scissors.findPathToPoint(testPoint);
          scissors.findPathToPoint(worldToSlice(points[(hIndex + 3) % points.length]));
          const minPoint = scissors.findMinNearby(testPoint, nearestEdge);
          if (!utilities_exports.isEqual(testPoint, minPoint)) {
            handleSmoothing[hIndex] = minPoint;
            lastPoint = minPoint;
            points[hIndex] = sliceToWorld(minPoint);
          }
        });
      }
      const acceptedPath = new LivewirePath();
      for (let i = 0; i < count; i++) {
        scissors.startSearch(worldToSlice(points[i]));
        const path = scissors.findPathToPoint(worldToSlice(points[(i + 1) % count]));
        acceptedPath.addPoints(path);
      }
      this.updateAnnotation(acceptedPath);
      this.scissors = null;
      this.scissorsNext = null;
      this.editData = null;
      annotation.data.handles.interpolationSources = null;
      if (repeatInterpolation) {
        triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes_default.InterpolationUpdated);
      }
    });
  }
  renderAnnotationInstance(renderContext) {
    var _a2;
    const { enabledElement, svgDrawingHelper } = renderContext;
    const annotation = renderContext.annotation;
    const { annotationUID } = annotation;
    const { viewport } = enabledElement;
    const { worldToCanvas } = viewport;
    const { showInterpolationPolyline } = this.configuration.interpolation || {};
    (_a2 = this.updateInterpolatedAnnotation) == null ? void 0 : _a2.call(this, annotation, enabledElement);
    const { originalPolyline } = annotation.data.contour;
    const rendered = super.renderAnnotationInstance(renderContext);
    if (showInterpolationPolyline && originalPolyline && annotation.autoGenerated) {
      const polylineCanvasPoints = originalPolyline.map(worldToCanvas);
      polylineCanvasPoints.push(polylineCanvasPoints[0]);
      drawPolyline(svgDrawingHelper, annotationUID, "interpolationContour-0", polylineCanvasPoints, {
        color: "#70ffff",
        lineWidth: 1,
        fillOpacity: 0
      });
    }
    return rendered;
  }
  isContourSegmentationTool() {
    return true;
  }
};
LivewireContourSegmentationTool.toolName = "LivewireContourSegmentationTool";
var LivewireContourSegmentationTool_default = LivewireContourSegmentationTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js
var _ArrowAnnotateTool = class _ArrowAnnotateTool extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      shadow: true,
      getTextCallback,
      changeTextCallback,
      preventHandleOutsideImage: false,
      arrowFirst: true
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      hideElementCursor(element);
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const { arrowFirst } = this.configuration;
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId,
          ...viewport.getViewReference({ points: [worldPos] })
        },
        data: {
          text: "",
          handles: {
            points: [[...worldPos], [...worldPos]],
            activeHandleIndex: null,
            arrowFirst,
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            }
          },
          label: ""
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex: 1,
        movingTextBox: false,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const [point1, point2] = data.handles.points;
      const canvasPoint1 = viewport.worldToCanvas(point1);
      const canvasPoint2 = viewport.worldToCanvas(point2);
      const line = {
        start: {
          x: canvasPoint1[0],
          y: canvasPoint1[1]
        },
        end: {
          x: canvasPoint2[0],
          y: canvasPoint2[1]
        }
      };
      const distanceToPoint5 = distanceToPoint3([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
      if (distanceToPoint5 <= proximity) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        movingTextBox: false
      };
      this._activateModify(element);
      hideElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      if (newAnnotation) {
        this.configuration.getTextCallback((text) => {
          if (!text) {
            removeAnnotation(annotation.annotationUID);
            triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
            this.editData = null;
            this.isDrawing = false;
            return;
          }
          annotation.data.text = text;
          triggerAnnotationCompleted(annotation);
          this.createMemo(element, annotation, { newAnnotation: !!this.memo });
          triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        });
      } else {
        triggerAnnotationModified(annotation, element);
      }
      this.doneEditMemo();
      this.editData = null;
      this.isDrawing = false;
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation } = this.editData;
      this.createMemo(element, annotation, { newAnnotation });
      const { data } = annotation;
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const points = data.handles.points;
        points.forEach((point) => {
          point[0] += worldPosDelta[0];
          point[1] += worldPosDelta[1];
          point[2] += worldPosDelta[2];
        });
        annotation.invalidated = true;
      } else {
        const { currentPoints } = eventDetail;
        const worldPos = currentPoints.world;
        data.handles.points[handleIndex] = [...worldPos];
        annotation.invalidated = true;
      }
      this.editData.hasMoved = true;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.touchTapCallback = (evt) => {
      if (evt.detail.taps == 2) {
        this.doubleClickCallback(evt);
      }
    };
    this.doubleClickCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      let annotations = getAnnotations(this.getToolName(), element);
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return;
      }
      const clickedAnnotation = annotations.find((annotation2) => this.isPointNearTool(element, annotation2, eventDetail.currentPoints.canvas, 6));
      if (!clickedAnnotation) {
        return;
      }
      const annotation = clickedAnnotation;
      this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));
      this.editData = null;
      this.isDrawing = false;
      evt.stopImmediatePropagation();
      evt.preventDefault();
    };
    this.cancel = (element) => {
      if (this.isDrawing) {
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        resetElementCursor(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        const { data } = annotation;
        annotation.highlighted = false;
        data.handles.activeHandleIndex = null;
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        if (newAnnotation) {
          triggerAnnotationCompleted(annotation);
        }
        this.editData = null;
        return annotation.annotationUID;
      }
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { handles, text } = data;
        const { points, activeHandleIndex } = handles;
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth, lineDash } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        let activeHandleCanvasCoords;
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
            color,
            lineWidth
          });
        }
        const arrowUID = "1";
        if (this.configuration.arrowFirst) {
          drawArrow(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {
            color,
            width: lineWidth,
            lineDash
          });
        } else {
          drawArrow(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {
            color,
            width: lineWidth,
            lineDash
          });
        }
        renderStatus = true;
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        if (!text) {
          continue;
        }
        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        if (!options.visibility) {
          data.handles.textBox = {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          };
          continue;
        }
        if (!data.handles.textBox.hasMoved) {
          const canvasTextBoxCoords = canvasCoordinates[1];
          data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
        }
        const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
        const textBoxUID = "1";
        const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, [text], textBoxPosition, canvasCoordinates, {}, options);
        const { x: left, y: top, width, height } = boundingBox;
        data.handles.textBox.worldBoundingBox = {
          topLeft: viewport.canvasToWorld([left, top]),
          topRight: viewport.canvasToWorld([left + width, top]),
          bottomLeft: viewport.canvasToWorld([left, top + height]),
          bottomRight: viewport.canvasToWorld([left + width, top + height])
        };
      }
      return renderStatus;
    };
  }
  handleSelectedCallback(evt, annotation, handle) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const { data } = annotation;
    annotation.highlighted = true;
    let movingTextBox = false;
    let handleIndex;
    if (handle.worldPosition) {
      movingTextBox = true;
    } else {
      handleIndex = data.handles.points.findIndex((p) => p === handle);
    }
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    this.editData = {
      annotation,
      viewportIdsToRender,
      handleIndex,
      movingTextBox
    };
    this._activateModify(element);
    hideElementCursor(element);
    const enabledElement = getEnabledElement(element);
    const { renderingEngine } = enabledElement;
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    evt.preventDefault();
  }
  _doneChangingTextCallback(element, annotation, updatedText) {
    annotation.data.text = updatedText;
    const enabledElement = getEnabledElement(element);
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    triggerAnnotationModified(annotation, element);
  }
  _isInsideVolume(index1, index2, dimensions) {
    return utilities_exports.indexWithinDimensions(index1, dimensions) && utilities_exports.indexWithinDimensions(index2, dimensions);
  }
};
_ArrowAnnotateTool.hydrate = (viewportId, points, text, options) => {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
  const { viewPlaneNormal, viewUp } = viewport.getCamera();
  const instance = new _ArrowAnnotateTool();
  const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);
  const annotation = {
    annotationUID: (options == null ? void 0 : options.annotationUID) || utilities_exports.uuidv4(),
    data: {
      text: text || "",
      handles: {
        points
      }
    },
    highlighted: false,
    autoGenerated: false,
    invalidated: false,
    isLocked: false,
    isVisible: true,
    metadata: {
      toolName: instance.getToolName(),
      viewPlaneNormal,
      FrameOfReferenceUID,
      referencedImageId,
      ...options
    }
  };
  addAnnotation(annotation, viewport.element);
  triggerAnnotationRenderForViewportIds_default([viewport.id]);
};
var ArrowAnnotateTool = _ArrowAnnotateTool;
function getTextCallback(doneChangingTextCallback) {
  return doneChangingTextCallback(prompt("Enter your annotation:"));
}
function changeTextCallback(data, eventData, doneChangingTextCallback) {
  return doneChangingTextCallback(prompt("Enter your annotation:"));
}
ArrowAnnotateTool.toolName = "ArrowAnnotate";
var ArrowAnnotateTool_default = ArrowAnnotateTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js
var _AngleTool = class _AngleTool extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      shadow: true,
      preventHandleOutsideImage: false,
      getTextLines: defaultGetTextLines13
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      if (this.angleStartedNotYetCompleted) {
        return;
      }
      this.angleStartedNotYetCompleted = true;
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      hideElementCursor(element);
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId,
          ...viewport.getViewReference({ points: [worldPos] })
        },
        data: {
          handles: {
            points: [[...worldPos], [...worldPos]],
            activeHandleIndex: null,
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            }
          },
          label: "",
          cachedStats: {}
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex: 1,
        movingTextBox: false,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const [point1, point2, point3] = data.handles.points;
      const canvasPoint1 = viewport.worldToCanvas(point1);
      const canvasPoint2 = viewport.worldToCanvas(point2);
      const line1 = {
        start: {
          x: canvasPoint1[0],
          y: canvasPoint1[1]
        },
        end: {
          x: canvasPoint2[0],
          y: canvasPoint2[1]
        }
      };
      const distanceToPoint5 = distanceToPoint3([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);
      if (distanceToPoint5 <= proximity) {
        return true;
      }
      if (!point3) {
        return false;
      }
      const canvasPoint3 = viewport.worldToCanvas(point3);
      const line2 = {
        start: {
          x: canvasPoint2[0],
          y: canvasPoint2[1]
        },
        end: {
          x: canvasPoint3[0],
          y: canvasPoint3[1]
        }
      };
      const distanceToPoint22 = distanceToPoint3([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);
      if (distanceToPoint22 <= proximity) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        movingTextBox: false
      };
      this._activateModify(element);
      hideElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {
        this.editData.handleIndex = 2;
        return;
      }
      this.angleStartedNotYetCompleted = false;
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
      this.editData = null;
      this.isDrawing = false;
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
      const { data } = annotation;
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const points = data.handles.points;
        points.forEach((point) => {
          point[0] += worldPosDelta[0];
          point[1] += worldPosDelta[1];
          point[2] += worldPosDelta[2];
        });
        annotation.invalidated = true;
      } else {
        const { currentPoints } = eventDetail;
        const worldPos = currentPoints.world;
        data.handles.points[handleIndex] = [...worldPos];
        annotation.invalidated = true;
      }
      this.editData.hasMoved = true;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.cancel = (element) => {
      if (this.isDrawing) {
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        resetElementCursor(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        const { data } = annotation;
        annotation.highlighted = false;
        data.handles.activeHandleIndex = null;
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        if (newAnnotation) {
          triggerAnnotationCompleted(annotation);
        }
        this.editData = null;
        this.angleStartedNotYetCompleted = false;
        return annotation.annotationUID;
      }
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      var _a2;
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const targetId = this.getTargetId(viewport);
      const renderingEngine = viewport.getRenderingEngine();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { points, activeHandleIndex } = data.handles;
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth, lineDash } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        if (!data.cachedStats[targetId] || data.cachedStats[targetId].angle == null) {
          data.cachedStats[targetId] = {
            angle: null
          };
          this._calculateCachedStats(annotation, renderingEngine, enabledElement);
        } else if (annotation.invalidated) {
          this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
        }
        let activeHandleCanvasCoords;
        if (!isAnnotationLocked(annotation.annotationUID) && !this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
            color,
            lineDash,
            lineWidth
          });
        }
        let lineUID = "1";
        drawLine(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
          color,
          width: lineWidth,
          lineDash
        });
        renderStatus = true;
        if (canvasCoordinates.length !== 3) {
          return renderStatus;
        }
        lineUID = "2";
        drawLine(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {
          color,
          width: lineWidth,
          lineDash
        });
        if (!((_a2 = data.cachedStats[targetId]) == null ? void 0 : _a2.angle)) {
          continue;
        }
        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        if (!options.visibility) {
          data.handles.textBox = {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          };
          continue;
        }
        const textLines = this.configuration.getTextLines(data, targetId);
        if (!data.handles.textBox.hasMoved) {
          const canvasTextBoxCoords = canvasCoordinates[1];
          data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
        }
        const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
        const textBoxUID = "1";
        const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
        const { x: left, y: top, width, height } = boundingBox;
        data.handles.textBox.worldBoundingBox = {
          topLeft: viewport.canvasToWorld([left, top]),
          topRight: viewport.canvasToWorld([left + width, top]),
          bottomLeft: viewport.canvasToWorld([left, top + height]),
          bottomRight: viewport.canvasToWorld([left + width, top + height])
        };
      }
      return renderStatus;
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
  handleSelectedCallback(evt, annotation, handle) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const { data } = annotation;
    annotation.highlighted = true;
    let movingTextBox = false;
    let handleIndex;
    if (handle.worldPosition) {
      movingTextBox = true;
    } else {
      handleIndex = data.handles.points.findIndex((p) => p === handle);
    }
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    this.editData = {
      annotation,
      viewportIdsToRender,
      handleIndex,
      movingTextBox
    };
    this._activateModify(element);
    hideElementCursor(element);
    const enabledElement = getEnabledElement(element);
    const { renderingEngine } = enabledElement;
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    evt.preventDefault();
  }
  _calculateCachedStats(annotation, renderingEngine, enabledElement) {
    const data = annotation.data;
    const { element } = enabledElement.viewport;
    if (data.handles.points.length !== 3) {
      return;
    }
    const worldPos1 = data.handles.points[0];
    const worldPos2 = data.handles.points[1];
    const worldPos3 = data.handles.points[2];
    const { cachedStats } = data;
    const targetIds = Object.keys(cachedStats);
    for (let i = 0; i < targetIds.length; i++) {
      const targetId = targetIds[i];
      const angle = angleBetweenLines([worldPos1, worldPos2], [worldPos2, worldPos3]);
      const { dimensions, imageData } = this.getTargetImageData(targetId);
      this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3].map((worldPos) => utilities_exports.transformWorldToIndex(imageData, worldPos)).some((index) => !utilities_exports.indexWithinDimensions(index, dimensions));
      cachedStats[targetId] = {
        angle: isNaN(angle) ? "Incomplete Angle" : angle
      };
    }
    annotation.invalidated = false;
    triggerAnnotationModified(annotation, element);
    return cachedStats;
  }
};
_AngleTool.hydrate = (viewportId, points, options) => {
  const enabledElement = getEnabledElementByViewportId(viewportId);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
  const { viewPlaneNormal, viewUp } = viewport.getCamera();
  const instance = new _AngleTool();
  const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);
  const annotation = {
    annotationUID: (options == null ? void 0 : options.annotationUID) || utilities_exports.uuidv4(),
    data: {
      handles: {
        points
      }
    },
    highlighted: false,
    autoGenerated: false,
    invalidated: false,
    isLocked: false,
    isVisible: true,
    metadata: {
      toolName: instance.getToolName(),
      viewPlaneNormal,
      FrameOfReferenceUID,
      referencedImageId,
      ...options
    }
  };
  addAnnotation(annotation, viewport.element);
  triggerAnnotationRenderForViewportIds_default([viewport.id]);
};
var AngleTool = _AngleTool;
function defaultGetTextLines13(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { angle } = cachedVolumeStats;
  if (angle === void 0) {
    return;
  }
  if (isNaN(angle)) {
    return [`${angle}`];
  }
  const textLines = [
    `${utilities_exports.roundNumber(angle)} ${String.fromCharCode(176)}`
  ];
  return textLines;
}
AngleTool.toolName = "Angle";
var AngleTool_default = AngleTool;

// node_modules/@cornerstonejs/tools/dist/esm/utilities/math/midPoint.js
var midPoint = (...args) => {
  const ret = args[0].length === 2 ? [0, 0] : [0, 0, 0];
  const len = args.length;
  for (const arg of args) {
    ret[0] += arg[0] / len;
    ret[1] += arg[1] / len;
    if (ret.length === 3) {
      ret[2] += arg[2] / len;
    }
  }
  return ret;
};
var midPoint2 = midPoint;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js
var CobbAngleTool = class extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      shadow: true,
      preventHandleOutsideImage: false,
      getTextLines: defaultGetTextLines14,
      showArcLines: false
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      if (this.angleStartedNotYetCompleted) {
        return;
      }
      this.angleStartedNotYetCompleted = true;
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      hideElementCursor(element);
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId,
          ...viewport.getViewReference({ points: [worldPos] })
        },
        data: {
          handles: {
            points: [[...worldPos], [...worldPos]],
            activeHandleIndex: null,
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            }
          },
          label: "",
          cachedStats: {}
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex: 1,
        movingTextBox: false,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const { distanceToPoint: distanceToPoint5, distanceToPoint2: distanceToPoint22 } = this.distanceToLines({
        viewport,
        points: data.handles.points,
        canvasCoords,
        proximity
      });
      if (distanceToPoint5 <= proximity || distanceToPoint22 <= proximity) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation, interactionType, canvasCoords, proximity = 6) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      annotation.highlighted = true;
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      const enabledElement = getEnabledElement(element);
      const { renderingEngine, viewport } = enabledElement;
      const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({
        viewport,
        points: annotation.data.handles.points,
        canvasCoords,
        proximity
      });
      this.editData = {
        annotation,
        viewportIdsToRender,
        movingTextBox: false,
        isNearFirstLine,
        isNearSecondLine
      };
      this._activateModify(element);
      hideElementCursor(element);
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      this.doneEditMemo();
      if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {
        resetElementCursor(element);
        this.editData.handleIndex = data.handles.points.length;
        return;
      }
      this.angleStartedNotYetCompleted = false;
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
      this.editData = null;
      this.isDrawing = false;
    };
    this._mouseDownCallback = (evt) => {
      const { annotation, handleIndex } = this.editData;
      const eventDetail = evt.detail;
      const { element, currentPoints } = eventDetail;
      const worldPos = currentPoints.world;
      const { data } = annotation;
      if (handleIndex === 1) {
        data.handles.points[1] = worldPos;
        this.editData.hasMoved = data.handles.points[1][0] !== data.handles.points[0][0] || data.handles.points[1][1] !== data.handles.points[0][0];
        return;
      }
      if (handleIndex === 3) {
        data.handles.points[3] = worldPos;
        this.editData.hasMoved = data.handles.points[3][0] !== data.handles.points[2][0] || data.handles.points[3][1] !== data.handles.points[2][0];
        this.angleStartedNotYetCompleted = false;
        return;
      }
      this.editData.hasMoved = false;
      hideElementCursor(element);
      data.handles.points[2] = data.handles.points[3] = worldPos;
      this.editData.handleIndex = data.handles.points.length - 1;
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex, movingTextBox, isNearFirstLine, isNearSecondLine, newAnnotation } = this.editData;
      this.createMemo(element, annotation, { newAnnotation });
      const { data } = annotation;
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0 && (isNearFirstLine || isNearSecondLine)) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const points = data.handles.points;
        if (isNearFirstLine) {
          const firstLinePoints = [points[0], points[1]];
          firstLinePoints.forEach((point) => {
            point[0] += worldPosDelta[0];
            point[1] += worldPosDelta[1];
            point[2] += worldPosDelta[2];
          });
        } else if (isNearSecondLine) {
          const secondLinePoints = [points[2], points[3]];
          secondLinePoints.forEach((point) => {
            point[0] += worldPosDelta[0];
            point[1] += worldPosDelta[1];
            point[2] += worldPosDelta[2];
          });
        }
        annotation.invalidated = true;
      } else {
        const { currentPoints } = eventDetail;
        const worldPos = currentPoints.world;
        data.handles.points[handleIndex] = [...worldPos];
        annotation.invalidated = true;
      }
      this.editData.hasMoved = true;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.cancel = (element) => {
      if (!this.isDrawing) {
        return;
      }
      this.isDrawing = false;
      this._deactivateDraw(element);
      this._deactivateModify(element);
      resetElementCursor(element);
      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
      const { data } = annotation;
      if (data.handles.points.length < 4) {
        removeAnnotation(annotation.annotationUID);
      }
      annotation.highlighted = false;
      data.handles.activeHandleIndex = null;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
      this.editData = null;
      this.angleStartedNotYetCompleted = false;
      return annotation.annotationUID;
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DOWN, this._mouseDownCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DOWN, this._mouseDownCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      var _a2;
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const targetId = this.getTargetId(viewport);
      const renderingEngine = viewport.getRenderingEngine();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { points, activeHandleIndex } = data.handles;
        styleSpecifier.annotationUID = annotationUID;
        const { color, lineWidth, lineDash } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        if (!data.cachedStats[targetId] || data.cachedStats[targetId].angle == null) {
          data.cachedStats[targetId] = {
            angle: null,
            arc1Angle: null,
            arc2Angle: null,
            points: {
              world: {
                arc1Start: null,
                arc1End: null,
                arc2Start: null,
                arc2End: null,
                arc1Angle: null,
                arc2Angle: null
              },
              canvas: {
                arc1Start: null,
                arc1End: null,
                arc2Start: null,
                arc2End: null,
                arc1Angle: null,
                arc2Angle: null
              }
            }
          };
          this._calculateCachedStats(annotation, renderingEngine, enabledElement);
        } else if (annotation.invalidated) {
          this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
        }
        let activeHandleCanvasCoords;
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
            color,
            lineDash,
            lineWidth
          });
        }
        const firstLine = [canvasCoordinates[0], canvasCoordinates[1]];
        const secondLine = [canvasCoordinates[2], canvasCoordinates[3]];
        let lineUID = "line1";
        drawLine(svgDrawingHelper, annotationUID, lineUID, firstLine[0], firstLine[1], {
          color,
          width: lineWidth,
          lineDash
        });
        renderStatus = true;
        if (canvasCoordinates.length < 4) {
          return renderStatus;
        }
        lineUID = "line2";
        drawLine(svgDrawingHelper, annotationUID, lineUID, secondLine[0], secondLine[1], {
          color,
          width: lineWidth,
          lineDash
        });
        lineUID = "linkLine";
        const mid1 = midPoint2(firstLine[0], firstLine[1]);
        const mid2 = midPoint2(secondLine[0], secondLine[1]);
        drawLine(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {
          color,
          lineWidth: "1",
          lineDash: "1,4"
        });
        const { arc1Start, arc1End, arc2End, arc2Start } = data.cachedStats[targetId].points.canvas;
        const { arc1Angle, arc2Angle } = data.cachedStats[targetId];
        if (this.configuration.showArcLines) {
          lineUID = "arc1";
          drawLine(svgDrawingHelper, annotationUID, lineUID, arc1Start, arc1End, {
            color,
            lineWidth: "1"
          });
          lineUID = "arc2";
          drawLine(svgDrawingHelper, annotationUID, lineUID, arc2Start, arc2End, {
            color,
            lineWidth: "1"
          });
        }
        if (!((_a2 = data.cachedStats[targetId]) == null ? void 0 : _a2.angle)) {
          continue;
        }
        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        if (!options.visibility) {
          data.handles.textBox = {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          };
          continue;
        }
        const textLines = this.configuration.getTextLines(data, targetId);
        if (!data.handles.textBox.hasMoved) {
          const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);
          data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
        }
        const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
        const textBoxUID = "cobbAngleText";
        const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
        const { x: left, y: top, width, height } = boundingBox;
        data.handles.textBox.worldBoundingBox = {
          topLeft: viewport.canvasToWorld([left, top]),
          topRight: viewport.canvasToWorld([left + width, top]),
          bottomLeft: viewport.canvasToWorld([left, top + height]),
          bottomRight: viewport.canvasToWorld([left + width, top + height])
        };
        if (this.configuration.showArcLines) {
          const arc1TextBoxUID = "arcAngle1";
          const arc1TextLine = [
            `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`
          ];
          const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);
          drawTextBox_default(svgDrawingHelper, annotationUID, arc1TextBoxUID, arc1TextLine, arch1TextPosCanvas, {
            ...options,
            padding: 3
          });
          const arc2TextBoxUID = "arcAngle2";
          const arc2TextLine = [
            `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`
          ];
          const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);
          drawTextBox_default(svgDrawingHelper, annotationUID, arc2TextBoxUID, arc2TextLine, arch2TextPosCanvas, {
            ...options,
            padding: 3
          });
        }
      }
      return renderStatus;
    };
    this.distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {
      const [point1, point2, point3, point4] = points;
      const canvasPoint1 = viewport.worldToCanvas(point1);
      const canvasPoint2 = viewport.worldToCanvas(point2);
      const canvasPoint3 = viewport.worldToCanvas(point3);
      const canvasPoint4 = viewport.worldToCanvas(point4);
      const line1 = {
        start: {
          x: canvasPoint1[0],
          y: canvasPoint1[1]
        },
        end: {
          x: canvasPoint2[0],
          y: canvasPoint2[1]
        }
      };
      const line2 = {
        start: {
          x: canvasPoint3[0],
          y: canvasPoint3[1]
        },
        end: {
          x: canvasPoint4[0],
          y: canvasPoint4[1]
        }
      };
      const distanceToPoint5 = distanceToPoint3([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);
      const distanceToPoint22 = distanceToPoint3([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);
      let isNearFirstLine = false;
      let isNearSecondLine = false;
      if (distanceToPoint5 <= proximity) {
        isNearFirstLine = true;
      } else if (distanceToPoint22 <= proximity) {
        isNearSecondLine = true;
      }
      return {
        distanceToPoint: distanceToPoint5,
        distanceToPoint2: distanceToPoint22,
        isNearFirstLine,
        isNearSecondLine
      };
    };
    this.getArcsStartEndPoints = ({ firstLine, secondLine, mid1, mid2 }) => {
      const linkLine = [mid1, mid2];
      const arc1Angle = angleBetweenLines(firstLine, linkLine);
      const arc2Angle = angleBetweenLines(secondLine, linkLine);
      const arc1Side = arc1Angle > 90 ? 1 : 0;
      const arc2Side = arc2Angle > 90 ? 0 : 1;
      const midLinkLine = midPoint2(linkLine[0], linkLine[1]);
      const linkLineLength = Math.sqrt((linkLine[1][0] - linkLine[0][0]) ** 2 + (linkLine[1][1] - linkLine[0][1]) ** 2);
      const ratio = 0.1;
      const midFirstLine = midPoint2(firstLine[0], firstLine[1]);
      const midSecondLine = midPoint2(secondLine[0], secondLine[1]);
      const directionVectorStartArc1 = [
        firstLine[arc1Side][0] - midFirstLine[0],
        firstLine[arc1Side][1] - midFirstLine[1]
      ];
      const magnitudeStartArc1 = Math.sqrt(directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2);
      const normalizedDirectionStartArc1 = [
        directionVectorStartArc1[0] / magnitudeStartArc1,
        directionVectorStartArc1[1] / magnitudeStartArc1
      ];
      const arc1Start = [
        midFirstLine[0] + normalizedDirectionStartArc1[0] * linkLineLength * ratio,
        midFirstLine[1] + normalizedDirectionStartArc1[1] * linkLineLength * ratio
      ];
      const directionVectorEndArc1 = [
        midLinkLine[0] - mid1[0],
        midLinkLine[1] - mid1[1]
      ];
      const magnitudeEndArc1 = Math.sqrt(directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2);
      const normalizedDirectionEndArc1 = [
        directionVectorEndArc1[0] / magnitudeEndArc1,
        directionVectorEndArc1[1] / magnitudeEndArc1
      ];
      const arc1End = [
        mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,
        mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio
      ];
      const directionVectorStartArc2 = [
        secondLine[arc2Side][0] - midSecondLine[0],
        secondLine[arc2Side][1] - midSecondLine[1]
      ];
      const magnitudeStartArc2 = Math.sqrt(directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2);
      const normalizedDirectionStartArc2 = [
        directionVectorStartArc2[0] / magnitudeStartArc2,
        directionVectorStartArc2[1] / magnitudeStartArc2
      ];
      const arc2Start = [
        midSecondLine[0] + normalizedDirectionStartArc2[0] * linkLineLength * ratio,
        midSecondLine[1] + normalizedDirectionStartArc2[1] * linkLineLength * ratio
      ];
      const directionVectorEndArc2 = [
        midLinkLine[0] - mid2[0],
        midLinkLine[1] - mid2[1]
      ];
      const magnitudeEndArc2 = Math.sqrt(directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2);
      const normalizedDirectionEndArc2 = [
        directionVectorEndArc2[0] / magnitudeEndArc2,
        directionVectorEndArc2[1] / magnitudeEndArc2
      ];
      const arc2End = [
        mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,
        mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio
      ];
      return {
        arc1Start,
        arc1End,
        arc2Start,
        arc2End,
        arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,
        arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle
      };
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 25, { trailing: true });
  }
  handleSelectedCallback(evt, annotation, handle, interactionType = "mouse") {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const { data } = annotation;
    annotation.highlighted = true;
    let movingTextBox = false;
    let handleIndex;
    if (handle.worldPosition) {
      movingTextBox = true;
    } else {
      handleIndex = data.handles.points.findIndex((p) => p === handle);
    }
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    this.editData = {
      annotation,
      viewportIdsToRender,
      handleIndex,
      movingTextBox
    };
    this._activateModify(element);
    hideElementCursor(element);
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    evt.preventDefault();
  }
  _calculateCachedStats(annotation, renderingEngine, enabledElement) {
    const data = annotation.data;
    if (data.handles.points.length !== 4) {
      return;
    }
    const seg1 = [null, null];
    const seg2 = [null, null];
    let minDist = Number.MAX_VALUE;
    for (let i = 0; i < 2; i += 1) {
      for (let j = 2; j < 4; j += 1) {
        const dist = vec3_exports.distance(data.handles.points[i], data.handles.points[j]);
        if (dist < minDist) {
          minDist = dist;
          seg1[1] = data.handles.points[i];
          seg1[0] = data.handles.points[(i + 1) % 2];
          seg2[0] = data.handles.points[j];
          seg2[1] = data.handles.points[2 + (j - 1) % 2];
        }
      }
    }
    const { viewport } = enabledElement;
    const { element } = viewport;
    const canvasPoints = data.handles.points.map((p) => viewport.worldToCanvas(p));
    const firstLine = [canvasPoints[0], canvasPoints[1]];
    const secondLine = [canvasPoints[2], canvasPoints[3]];
    const mid1 = midPoint2(firstLine[0], firstLine[1]);
    const mid2 = midPoint2(secondLine[0], secondLine[1]);
    const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } = this.getArcsStartEndPoints({
      firstLine,
      secondLine,
      mid1,
      mid2
    });
    const { cachedStats } = data;
    const targetIds = Object.keys(cachedStats);
    for (let i = 0; i < targetIds.length; i++) {
      const targetId = targetIds[i];
      cachedStats[targetId] = {
        angle: angleBetweenLines(seg1, seg2),
        arc1Angle,
        arc2Angle,
        points: {
          canvas: {
            arc1Start,
            arc1End,
            arc2End,
            arc2Start
          },
          world: {
            arc1Start: viewport.canvasToWorld(arc1Start),
            arc1End: viewport.canvasToWorld(arc1End),
            arc2End: viewport.canvasToWorld(arc2End),
            arc2Start: viewport.canvasToWorld(arc2Start)
          }
        }
      };
    }
    annotation.invalidated = false;
    triggerAnnotationModified(annotation, element);
    return cachedStats;
  }
};
function defaultGetTextLines14(data, targetId) {
  const cachedVolumeStats = data.cachedStats[targetId];
  const { angle } = cachedVolumeStats;
  if (angle === void 0) {
    return;
  }
  const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];
  return textLines;
}
CobbAngleTool.toolName = "CobbAngle";
var CobbAngleTool_default = CobbAngleTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js
var { transformWorldToIndex: transformWorldToIndex16 } = utilities_exports;
var UltrasoundDirectionalTool = class extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      shadow: true,
      preventHandleOutsideImage: false,
      getTextLines: defaultGetTextLines15,
      displayBothAxesDistances: false
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      if (this.startedDrawing) {
        return;
      }
      this.startedDrawing = true;
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      if (!(viewport instanceof StackViewport_default)) {
        throw new Error("UltrasoundDirectionalTool can only be used on a StackViewport");
      }
      hideElementCursor(element);
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId
        },
        data: {
          handles: {
            points: [[...worldPos], [...worldPos]],
            activeHandleIndex: null,
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            }
          },
          label: "",
          cachedStats: {}
        }
      };
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        handleIndex: 1,
        movingTextBox: false,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      return false;
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      if (this.startedDrawing && data.handles.points.length === 1) {
        this.editData.handleIndex = 1;
        return;
      }
      this.startedDrawing = false;
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
      this.editData = null;
      this.isDrawing = false;
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
      const { data } = annotation;
      if (movingTextBox) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const { textBox } = data.handles;
        const { worldPosition } = textBox;
        worldPosition[0] += worldPosDelta[0];
        worldPosition[1] += worldPosDelta[1];
        worldPosition[2] += worldPosDelta[2];
        textBox.hasMoved = true;
      } else if (handleIndex === void 0) {
        const { deltaPoints } = eventDetail;
        const worldPosDelta = deltaPoints.world;
        const points = data.handles.points;
        points.forEach((point) => {
          point[0] += worldPosDelta[0];
          point[1] += worldPosDelta[1];
          point[2] += worldPosDelta[2];
        });
        annotation.invalidated = true;
      } else {
        const { currentPoints } = eventDetail;
        const worldPos = currentPoints.world;
        data.handles.points[handleIndex] = [...worldPos];
        annotation.invalidated = true;
      }
      this.editData.hasMoved = true;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine } = enabledElement;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this.cancel = (element) => {
      if (this.isDrawing) {
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        resetElementCursor(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        const { data } = annotation;
        annotation.highlighted = false;
        data.handles.activeHandleIndex = null;
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
        if (newAnnotation) {
          triggerAnnotationCompleted(annotation);
        }
        this.editData = null;
        this.startedDrawing = false;
        return annotation.annotationUID;
      }
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const targetId = this.getTargetId(viewport);
      const renderingEngine = viewport.getRenderingEngine();
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data } = annotation;
        const { points } = data.handles;
        styleSpecifier.annotationUID = annotationUID;
        const color = this.getStyle("color", styleSpecifier, annotation);
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        if (!data.cachedStats[targetId] || data.cachedStats[targetId].xValues == null) {
          data.cachedStats[targetId] = {
            xValues: [0, 0],
            yValues: [0, 0],
            isHorizontal: false,
            units: [""],
            isUnitless: false
          };
          this._calculateCachedStats(annotation, renderingEngine, enabledElement);
        } else if (annotation.invalidated) {
          this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
        }
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        let handleGroupUID = "0";
        drawHandle_default(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[0], {
          color
        }, 0);
        renderStatus = true;
        if (canvasCoordinates.length !== 2) {
          return renderStatus;
        }
        handleGroupUID = "1";
        drawHandle_default(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[1], {
          color
        }, 1);
        const isUnitless = data.cachedStats[targetId].isUnitless;
        if (!isUnitless) {
          const canvasPoint1 = canvasCoordinates[0];
          const canvasPoint2 = canvasCoordinates[1];
          const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];
          const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];
          const isHorizontal = data.cachedStats[targetId].isHorizontal;
          let projectedPointCanvas = [0, 0];
          if (isHorizontal) {
            projectedPointCanvas = [
              canvasPoint1[0] + canvasDeltaX,
              canvasPoint1[1]
            ];
          } else {
            projectedPointCanvas = [
              canvasPoint1[0],
              canvasPoint1[1] + canvasDeltaY
            ];
          }
          let dataId = `${annotationUID}-line-1`;
          let lineUID = "1";
          drawLine(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], projectedPointCanvas, {
            color,
            width: 1,
            shadow: this.configuration.shadow
          }, dataId);
          dataId = `${annotationUID}-line-2`;
          lineUID = "2";
          drawLine(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], projectedPointCanvas, {
            color,
            width: 1,
            lineDash: [1, 1],
            shadow: this.configuration.shadow
          }, dataId);
        } else {
          const dataId = `${annotationUID}-line-1`;
          const lineUID = "1";
          drawLine(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
            color,
            width: 1,
            shadow: this.configuration.shadow
          }, dataId);
        }
        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
        if (!options.visibility) {
          data.handles.textBox = {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0],
              topRight: [0, 0, 0],
              bottomLeft: [0, 0, 0],
              bottomRight: [0, 0, 0]
            }
          };
          continue;
        }
        const textLines = this.configuration.getTextLines(data, targetId, this.configuration);
        if (!data.handles.textBox.hasMoved) {
          const canvasTextBoxCoords = canvasCoordinates[1];
          data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
        }
        const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
        const textBoxUID = "1";
        const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
        const { x: left, y: top, width, height } = boundingBox;
        data.handles.textBox.worldBoundingBox = {
          topLeft: viewport.canvasToWorld([left, top]),
          topRight: viewport.canvasToWorld([left + width, top]),
          bottomLeft: viewport.canvasToWorld([left, top + height]),
          bottomRight: viewport.canvasToWorld([left + width, top + height])
        };
      }
      return renderStatus;
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
  toolSelectedCallback(evt, annotation, interactionType, canvasCoords) {
    return;
  }
  handleSelectedCallback(evt, annotation, handle) {
    const eventDetail = evt.detail;
    const { element } = eventDetail;
    const { data } = annotation;
    annotation.highlighted = true;
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    let movingTextBox = false;
    let handleIndex;
    if (handle.worldPosition) {
      movingTextBox = true;
    } else {
      handleIndex = data.handles.points.findIndex((p) => p === handle);
    }
    this.editData = {
      handleIndex,
      annotation,
      viewportIdsToRender
    };
    this._activateModify(element);
    hideElementCursor(element);
    const enabledElement = getEnabledElement(element);
    const { renderingEngine } = enabledElement;
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    evt.preventDefault();
  }
  _calculateCachedStats(annotation, renderingEngine, enabledElement) {
    const data = annotation.data;
    const { element } = enabledElement.viewport;
    if (data.handles.points.length !== 2) {
      return;
    }
    const { cachedStats } = data;
    const targetIds = Object.keys(cachedStats);
    for (let i = 0; i < targetIds.length; i++) {
      const targetId = targetIds[i];
      const image = this.getTargetImageData(targetId);
      if (!image) {
        continue;
      }
      const { imageData } = image;
      const worldPos1 = data.handles.points[0];
      const worldPos2 = data.handles.points[1];
      const imageIndex1 = transformWorldToIndex16(imageData, worldPos1);
      const imageIndex2 = transformWorldToIndex16(imageData, worldPos2);
      const { values: values1, units: units1 } = getCalibratedProbeUnitsAndValue(image, [imageIndex1]);
      const { values: values2, units: units2 } = getCalibratedProbeUnitsAndValue(image, [imageIndex2]);
      let xValues, yValues, units, isHorizontal;
      let isUnitless = false;
      if (units1[0] !== units2[0] || units1[1] !== units2[1] || units1[0] === "raw" && units2[0] === "raw") {
        const value = distanceToPoint2(worldPos1, worldPos2);
        xValues = [value, 0];
        yValues = [value, 0];
        units = ["px"];
        isUnitless = true;
      } else {
        const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);
        const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);
        const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];
        const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];
        isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);
        xValues = [values1[0], values2[0]];
        yValues = [values1[1], values2[1]];
        units = [units1[0], units1[1]];
      }
      cachedStats[targetId] = {
        xValues,
        yValues,
        isHorizontal,
        units,
        isUnitless
      };
    }
    annotation.invalidated = false;
    triggerAnnotationModified(annotation, element);
    return cachedStats;
  }
};
function defaultGetTextLines15(data, targetId, configuration3) {
  const cachedStats = data.cachedStats[targetId];
  const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;
  if (isUnitless) {
    return [`${utilities_exports.roundNumber(xValues[0])} px`];
  }
  if (configuration3.displayBothAxesDistances) {
    const dist1 = Math.abs(xValues[1] - xValues[0]);
    const dist2 = Math.abs(yValues[1] - yValues[0]);
    return [
      `${utilities_exports.roundNumber(dist1)} ${units[0]}`,
      `${utilities_exports.roundNumber(dist2)} ${units[1]}`
    ];
  }
  if (isHorizontal) {
    const dist = Math.abs(xValues[1] - xValues[0]);
    return [`${utilities_exports.roundNumber(dist)} ${units[0]}`];
  } else {
    const dist = Math.abs(yValues[1] - yValues[0]);
    return [`${utilities_exports.roundNumber(dist)} ${units[1]}`];
  }
}
UltrasoundDirectionalTool.toolName = "UltrasoundDirectionalTool";
var UltrasoundDirectionalTool_default = UltrasoundDirectionalTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js
var KeyImageTool = class _KeyImageTool extends AnnotationTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      getTextCallback: getTextCallback2,
      changeTextCallback: changeTextCallback2,
      canvasPosition: [10, 10],
      canvasSize: 10
    }
  }) {
    super(toolProps, defaultToolProps);
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const annotation = _KeyImageTool.createAnnotation({
        metadata: { ...viewport.getViewReference(), referencedImageId }
      });
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      this.configuration.getTextCallback((text) => {
        if (!text) {
          removeAnnotation(annotation.annotationUID);
          triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
          this.isDrawing = false;
          return;
        }
        annotation.data.text = text;
        triggerAnnotationCompleted(annotation);
        triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      });
      this.createMemo(element, annotation, { newAnnotation: true });
      return annotation;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const { canvasPosition, canvasSize } = this.configuration;
      if (!(canvasPosition == null ? void 0 : canvasPosition.length)) {
        return false;
      }
      if (Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <= canvasSize / 2 && Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <= canvasSize / 2) {
        return true;
      }
      return false;
    };
    this.toolSelectedCallback = (evt, annotation) => {
      annotation.highlighted = true;
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      this.doneEditMemo();
      this._deactivateModify(element);
      resetElementCursor(element);
    };
    this.doubleClickCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      let annotations = getAnnotations(this.getToolName(), element);
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return;
      }
      const clickedAnnotation = annotations.find((annotation2) => this.isPointNearTool(element, annotation2, eventDetail.currentPoints.canvas, 6));
      if (!clickedAnnotation) {
        return;
      }
      const annotation = clickedAnnotation;
      this.createMemo(element, annotation);
      this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));
      this.isDrawing = false;
      this.doneEditMemo();
      evt.stopImmediatePropagation();
      evt.preventDefault();
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID } = annotation;
        styleSpecifier.annotationUID = annotationUID;
        const { color } = this.getAnnotationStyle({
          annotation,
          styleSpecifier
        });
        const { canvasPosition, canvasSize } = this.configuration;
        if (canvasPosition == null ? void 0 : canvasPosition.length) {
          const arrowUID = "1";
          drawArrow(svgDrawingHelper, annotationUID, arrowUID, canvasPosition.map((it) => it + canvasSize), canvasPosition, {
            color,
            width: 1
          });
        }
        renderStatus = true;
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
      }
      return renderStatus;
    };
  }
  cancel() {
  }
  handleSelectedCallback(evt, annotation, handle) {
  }
  _doneChangingTextCallback(element, annotation, updatedText) {
    annotation.data.text = updatedText;
    const enabledElement = getEnabledElement(element);
    const { renderingEngine } = enabledElement;
    const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
    triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    triggerAnnotationModified(annotation, element);
  }
  _isInsideVolume(index1, index2, dimensions) {
    return utilities_exports.indexWithinDimensions(index1, dimensions) && utilities_exports.indexWithinDimensions(index2, dimensions);
  }
};
function getTextCallback2(doneChangingTextCallback) {
  return doneChangingTextCallback(prompt("Enter your annotation:"));
}
function changeTextCallback2(data, eventData, doneChangingTextCallback) {
  return doneChangingTextCallback(prompt("Enter your annotation:"));
}
KeyImageTool.toolName = "KeyImage";
var KeyImageTool_default = KeyImageTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js
var AnnotationEraserTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"]
  }) {
    super(toolProps, defaultToolProps);
    this.preMouseDownCallback = (evt) => {
      return this._deleteNearbyAnnotations(evt, "mouse");
    };
    this.preTouchStartCallback = (evt) => {
      return this._deleteNearbyAnnotations(evt, "touch");
    };
  }
  _deleteNearbyAnnotations(evt, interactionType) {
    const { renderingEngineId, viewportId, element, currentPoints } = evt.detail;
    const toolGroup = getToolGroupForViewport_default(viewportId, renderingEngineId);
    if (!toolGroup) {
      return false;
    }
    const tools = toolGroup._toolInstances;
    const annotationsToRemove = [];
    for (const toolName in tools) {
      const toolInstance = tools[toolName];
      if (typeof toolInstance.isPointNearTool !== "function" || typeof toolInstance.filterInteractableAnnotationsForElement !== "function") {
        continue;
      }
      const annotations = getAnnotations(toolName, element);
      const interactableAnnotations = toolInstance.filterInteractableAnnotationsForElement(element, annotations);
      if (!interactableAnnotations) {
        continue;
      }
      for (const annotation of interactableAnnotations) {
        if (toolInstance.isPointNearTool(element, annotation, currentPoints.canvas, 10, interactionType)) {
          annotationsToRemove.push(annotation.annotationUID);
        }
      }
    }
    for (const annotationUID of annotationsToRemove) {
      setAnnotationSelected(annotationUID);
      const annotation = getAnnotation(annotationUID);
      AnnotationTool_default.createAnnotationMemo(element, annotation, {
        deleting: true
      });
      removeAnnotation(annotationUID);
    }
    evt.preventDefault();
    return true;
  }
};
AnnotationEraserTool.toolName = "Eraser";
var AnnotationEraserTool_default = AnnotationEraserTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/base/GrowCutBaseTool.js
var { transformWorldToIndex: transformWorldToIndex17, transformIndexToWorld: transformIndexToWorld2 } = utilities_exports;
var _GrowCutBaseTool = class _GrowCutBaseTool extends BaseTool_default {
  constructor(toolProps, defaultToolProps) {
    const baseToolProps = utilities_exports.deepMerge({
      configuration: {
        positiveSeedVariance: 0.1,
        negativeSeedVariance: 0.9,
        shrinkExpandIncrement: 0.05,
        islandRemoval: {
          enabled: false
        }
      }
    }, defaultToolProps);
    super(toolProps, baseToolProps);
  }
  async preMouseDownCallback(evt) {
    const eventData = evt.detail;
    const { element, currentPoints } = eventData;
    const { world: worldPoint } = currentPoints;
    const enabledElement = getEnabledElement(element);
    const { viewport, renderingEngine } = enabledElement;
    const { viewUp } = viewport.getCamera();
    const { segmentationId, segmentIndex, labelmapVolumeId, referencedVolumeId } = await this.getLabelmapSegmentationData(viewport);
    if (!this._isOrthogonalView(viewport, referencedVolumeId)) {
      throw new Error("Oblique view is not supported yet");
    }
    this.growCutData = {
      metadata: {
        ...viewport.getViewReference({ points: [worldPoint] }),
        viewUp
      },
      segmentation: {
        segmentationId,
        segmentIndex,
        labelmapVolumeId,
        referencedVolumeId
      },
      viewportId: viewport.id,
      renderingEngineId: renderingEngine.id
    };
    evt.preventDefault();
    return true;
  }
  shrink() {
    this._runLastCommand({
      shrinkExpandAmount: -this.configuration.shrinkExpandIncrement
    });
  }
  expand() {
    this._runLastCommand({
      shrinkExpandAmount: this.configuration.shrinkExpandIncrement
    });
  }
  refresh() {
    this._runLastCommand();
  }
  async getGrowCutLabelmap(_growCutData) {
    throw new Error("Not implemented");
  }
  async runGrowCut() {
    const { growCutData, configuration: config } = this;
    const { segmentation: { segmentationId, segmentIndex, labelmapVolumeId } } = growCutData;
    const hasSeedVarianceData = config.positiveSeedVariance !== void 0 && config.negativeSeedVariance !== void 0;
    const labelmap = cache_default.getVolume(labelmapVolumeId);
    let shrinkExpandValue = 0;
    const growCutCommand = async ({ shrinkExpandAmount = 0 } = {}) => {
      const { positiveSeedVariance, negativeSeedVariance } = config;
      let newPositiveSeedVariance = void 0;
      let newNegativeSeedVariance = void 0;
      shrinkExpandValue += shrinkExpandAmount;
      if (hasSeedVarianceData) {
        newPositiveSeedVariance = positiveSeedVariance + shrinkExpandValue;
        newNegativeSeedVariance = negativeSeedVariance + shrinkExpandValue;
      }
      const updatedGrowCutData = Object.assign({}, growCutData, {
        options: {
          positiveSeedValue: segmentIndex,
          negativeSeedValue: 255,
          positiveSeedVariance: newPositiveSeedVariance,
          negativeSeedVariance: newNegativeSeedVariance
        }
      });
      const growcutLabelmap = await this.getGrowCutLabelmap(updatedGrowCutData);
      this.applyGrowCutLabelmap(segmentationId, segmentIndex, labelmap, growcutLabelmap);
      this._removeIslands(growCutData);
    };
    await growCutCommand();
    if (hasSeedVarianceData) {
      _GrowCutBaseTool.lastGrowCutCommand = growCutCommand;
    }
    this.growCutData = null;
  }
  applyGrowCutLabelmap(segmentationId, segmentIndex, targetLabelmap, sourceLabelmap) {
    const srcLabelmapData = sourceLabelmap.voxelManager.getCompleteScalarDataArray();
    const tgtVoxelManager = targetLabelmap.voxelManager;
    const [srcColumns, srcRows, srcNumSlices] = sourceLabelmap.dimensions;
    const [tgtColumns, tgtRows] = targetLabelmap.dimensions;
    const srcPixelsPerSlice = srcColumns * srcRows;
    const tgtPixelsPerSlice = tgtColumns * tgtRows;
    for (let srcSlice = 0; srcSlice < srcNumSlices; srcSlice++) {
      for (let srcRow = 0; srcRow < srcRows; srcRow++) {
        const srcRowIJK = [0, srcRow, srcSlice];
        const rowVoxelWorld = transformIndexToWorld2(sourceLabelmap.imageData, srcRowIJK);
        const tgtRowIJK = transformWorldToIndex17(targetLabelmap.imageData, rowVoxelWorld);
        const [tgtColumn, tgtRow, tgtSlice] = tgtRowIJK;
        const srcOffset = srcRow * srcColumns + srcSlice * srcPixelsPerSlice;
        const tgtOffset = tgtColumn + tgtRow * tgtColumns + tgtSlice * tgtPixelsPerSlice;
        for (let column = 0; column < srcColumns; column++) {
          const labelmapValue = srcLabelmapData[srcOffset + column] === segmentIndex ? segmentIndex : 0;
          tgtVoxelManager.setAtIndex(tgtOffset + column, labelmapValue);
        }
      }
    }
    triggerSegmentationDataModified(segmentationId);
  }
  _runLastCommand({ shrinkExpandAmount = 0 } = {}) {
    const cmd = _GrowCutBaseTool.lastGrowCutCommand;
    if (cmd) {
      cmd({ shrinkExpandAmount });
    }
  }
  async getLabelmapSegmentationData(viewport) {
    const activeSeg = activeSegmentation_exports.getActiveSegmentation(viewport.id);
    if (!activeSeg) {
      throw new Error("No active segmentation found");
    }
    const { segmentationId } = activeSeg;
    const segmentIndex = segmentIndex_exports.getActiveSegmentIndex(segmentationId);
    const { representationData } = segmentationState_exports.getSegmentation(segmentationId);
    const labelmapData = representationData[SegmentationRepresentations_default.Labelmap];
    const { volumeId: labelmapVolumeId, referencedVolumeId } = labelmapData;
    if (!labelmapVolumeId) {
      throw new Error("Labelmap volume id not found - not implemented");
    }
    return {
      segmentationId,
      segmentIndex,
      labelmapVolumeId,
      referencedVolumeId
    };
  }
  _isOrthogonalView(viewport, referencedVolumeId) {
    const volume = cache_default.getVolume(referencedVolumeId);
    const volumeImageData = volume.imageData;
    const camera = viewport.getCamera();
    const { ijkVecColDir, ijkVecSliceDir } = utilities_exports.getVolumeDirectionVectors(volumeImageData, camera);
    return [ijkVecColDir, ijkVecSliceDir].every((vec) => utilities_exports.isEqual(Math.abs(vec[0]), 1) || utilities_exports.isEqual(Math.abs(vec[1]), 1) || utilities_exports.isEqual(Math.abs(vec[2]), 1));
  }
  getRemoveIslandData(_growCutData) {
    return;
  }
  _removeIslands(growCutData) {
    const { islandRemoval: config } = this.configuration;
    if (!config.enabled) {
      return;
    }
    const { segmentation: { segmentIndex, labelmapVolumeId }, renderingEngineId, viewportId } = growCutData;
    const labelmap = cache_default.getVolume(labelmapVolumeId);
    const removeIslandData = this.getRemoveIslandData(growCutData);
    if (!removeIslandData) {
      return;
    }
    const [width, height] = labelmap.dimensions;
    const numPixelsPerSlice = width * height;
    const { worldIslandPoints = [], islandPointIndexes = [] } = removeIslandData;
    let ijkIslandPoints = [...(removeIslandData == null ? void 0 : removeIslandData.ijkIslandPoints) ?? []];
    const renderingEngine = getRenderingEngine(renderingEngineId);
    const viewport = renderingEngine.getViewport(viewportId);
    const { voxelManager } = labelmap;
    const islandRemoval = new IslandRemoval();
    ijkIslandPoints = ijkIslandPoints.concat(worldIslandPoints.map((worldPoint) => transformWorldToIndex17(labelmap.imageData, worldPoint)));
    ijkIslandPoints = ijkIslandPoints.concat(islandPointIndexes.map((pointIndex) => {
      const x = pointIndex % width;
      const y = Math.floor(pointIndex / width) % height;
      const z = Math.floor(pointIndex / numPixelsPerSlice);
      return [x, y, z];
    }));
    islandRemoval.initialize(viewport, voxelManager, {
      points: ijkIslandPoints,
      previewSegmentIndex: segmentIndex,
      segmentIndex
    });
    islandRemoval.floodFillSegmentIsland();
    islandRemoval.removeExternalIslands();
    islandRemoval.removeInternalIslands();
  }
  getSegmentStyle({ segmentationId, viewportId, segmentIndex }) {
    return getSVGStyleForSegment({
      segmentationId,
      segmentIndex,
      viewportId
    });
  }
};
_GrowCutBaseTool.lastGrowCutCommand = null;
var GrowCutBaseTool = _GrowCutBaseTool;
GrowCutBaseTool.toolName = "GrowCutBaseTool";
var GrowCutBaseTool_default = GrowCutBaseTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentTool.js
var RegionSegmentTool = class extends GrowCutBaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      positiveSeedVariance: 0.5,
      negativeSeedVariance: 0.9
    }
  }) {
    super(toolProps, defaultToolProps);
    this._dragCallback = (evt) => {
      const eventData = evt.detail;
      const { element, currentPoints } = eventData;
      const { world: currentWorldPoint } = currentPoints;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      this.growCutData.circleBorderPoint = currentWorldPoint;
      triggerAnnotationRenderForViewportIds_default([viewport.id]);
    };
    this._endCallback = async (evt) => {
      const eventData = evt.detail;
      const { element } = eventData;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      this.runGrowCut();
      this._deactivateDraw(element);
      this.growCutData = null;
      resetElementCursor(element);
      triggerAnnotationRenderForViewportIds_default([viewport.id]);
    };
    this._deactivateDraw = (element) => {
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
    };
  }
  async preMouseDownCallback(evt) {
    const eventData = evt.detail;
    const { element, currentPoints } = eventData;
    const { world: worldPoint } = currentPoints;
    const enabledElement = getEnabledElement(element);
    const { viewport, renderingEngine } = enabledElement;
    await super.preMouseDownCallback(evt);
    Object.assign(this.growCutData, {
      circleCenterPoint: worldPoint,
      circleBorderPoint: worldPoint
    });
    this._activateDraw(element);
    hideElementCursor(element);
    triggerAnnotationRenderForViewportIds_default([viewport.id]);
    return true;
  }
  async getGrowCutLabelmap(growCutData) {
    const { segmentation: { referencedVolumeId }, renderingEngineId, viewportId, circleCenterPoint, circleBorderPoint, options } = growCutData;
    const renderingEngine = getRenderingEngine(renderingEngineId);
    const viewport = renderingEngine.getViewport(viewportId);
    const worldCircleRadius = vec3_exports.len(vec3_exports.sub(vec3_exports.create(), circleCenterPoint, circleBorderPoint));
    const sphereInfo = {
      center: circleCenterPoint,
      radius: worldCircleRadius
    };
    return growCut_exports.runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options);
  }
  _activateDraw(element) {
    element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
    element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
    element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
  }
  renderAnnotation(enabledElement, svgDrawingHelper) {
    if (!this.growCutData) {
      return;
    }
    const { viewport } = enabledElement;
    const { segmentation: segmentationData, circleCenterPoint, circleBorderPoint } = this.growCutData;
    const canvasCenterPoint = viewport.worldToCanvas(circleCenterPoint);
    const canvasBorderPoint = viewport.worldToCanvas(circleBorderPoint);
    const vecCenterToBorder = vec2_exports.sub(vec2_exports.create(), canvasBorderPoint, canvasCenterPoint);
    const circleRadius = vec2_exports.len(vecCenterToBorder);
    if (utilities_exports.isEqual(circleRadius, 0)) {
      return;
    }
    const annotationUID = "growcut";
    const circleUID = "0";
    const { color } = this.getSegmentStyle({
      segmentationId: segmentationData.segmentationId,
      segmentIndex: segmentationData.segmentIndex,
      viewportId: viewport.id
    });
    drawCircle_default(svgDrawingHelper, annotationUID, circleUID, canvasCenterPoint, circleRadius, {
      color
    });
  }
};
RegionSegmentTool.toolName = "RegionSegment";
var RegionSegmentTool_default = RegionSegmentTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentPlusTool.js
var RegionSegmentPlusTool = class extends GrowCutBaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      positiveSeedVariance: 0.4,
      negativeSeedVariance: 0.9,
      subVolumePaddingPercentage: 0.1,
      islandRemoval: {
        enabled: true
      }
    }
  }) {
    super(toolProps, defaultToolProps);
  }
  async preMouseDownCallback(evt) {
    const eventData = evt.detail;
    const { currentPoints } = eventData;
    const { world: worldPoint } = currentPoints;
    await super.preMouseDownCallback(evt);
    this.growCutData = utilities_exports.deepMerge(this.growCutData, {
      worldPoint,
      islandRemoval: {
        worldIslandPoints: [worldPoint]
      }
    });
    this.growCutData.worldPoint = worldPoint;
    this.growCutData.islandRemoval = {
      worldIslandPoints: [worldPoint]
    };
    this.runGrowCut();
    return true;
  }
  getRemoveIslandData(growCutData) {
    const { worldPoint } = growCutData;
    return {
      worldIslandPoints: [worldPoint]
    };
  }
  async getGrowCutLabelmap(growCutData) {
    const { segmentation: { referencedVolumeId }, renderingEngineId, viewportId, worldPoint, options } = growCutData;
    const renderingEngine = getRenderingEngine(renderingEngineId);
    const viewport = renderingEngine.getViewport(viewportId);
    const { subVolumePaddingPercentage } = this.configuration;
    const mergedOptions = {
      ...options,
      subVolumePaddingPercentage
    };
    return growCut_exports.runOneClickGrowCut(referencedVolumeId, worldPoint, viewport, mergedOptions);
  }
};
RegionSegmentPlusTool.toolName = "RegionSegmentPlus";
var RegionSegmentPlusTool_default = RegionSegmentPlusTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/WholeBodySegmentTool.js
var NEGATIVE_PIXEL_RANGE2 = [-Infinity, -995];
var POSITIVE_PIXEL_RANGE2 = [0, 1900];
var ISLAND_PIXEL_RANGE = [1e3, 1900];
var { transformWorldToIndex: transformWorldToIndex18, transformIndexToWorld: transformIndexToWorld3 } = utilities_exports;
var WholeBodySegmentTool = class extends GrowCutBaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      positivePixelRange: POSITIVE_PIXEL_RANGE2,
      negativePixelRange: NEGATIVE_PIXEL_RANGE2,
      islandRemoval: {
        enabled: true,
        islandPixelRange: ISLAND_PIXEL_RANGE
      }
    }
  }) {
    super(toolProps, defaultToolProps);
    this._dragCallback = (evt) => {
      const eventData = evt.detail;
      const { element, currentPoints } = eventData;
      const { world: currentWorldPoint } = currentPoints;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const linePoints = this._getHorizontalLineWorldPoints(enabledElement, currentWorldPoint);
      this.growCutData.horizontalLines[1] = linePoints;
      triggerAnnotationRenderForViewportIds_default([viewport.id]);
    };
    this._endCallback = async (evt) => {
      const eventData = evt.detail;
      const { element } = eventData;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      await this.runGrowCut();
      this._deactivateDraw(element);
      this.growCutData = null;
      resetElementCursor(element);
      triggerAnnotationRenderForViewportIds_default([viewport.id]);
    };
    this._deactivateDraw = (element) => {
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
    };
  }
  async preMouseDownCallback(evt) {
    const eventData = evt.detail;
    const { element, currentPoints } = eventData;
    const { world: worldPoint } = currentPoints;
    const enabledElement = getEnabledElement(element);
    const { viewport, renderingEngine } = enabledElement;
    const linePoints = this._getHorizontalLineWorldPoints(enabledElement, worldPoint);
    await super.preMouseDownCallback(evt);
    this.growCutData.horizontalLines = [linePoints, linePoints];
    this._activateDraw(element);
    hideElementCursor(element);
    triggerAnnotationRenderForViewportIds_default([viewport.id]);
    return true;
  }
  renderAnnotation(enabledElement, svgDrawingHelper) {
    if (!this.growCutData) {
      return;
    }
    const { segmentation: segmentationData, horizontalLines } = this.growCutData;
    if (horizontalLines.length !== 2) {
      return;
    }
    const { viewport } = enabledElement;
    const { segmentationId, segmentIndex } = segmentationData;
    const [line1, line2] = horizontalLines;
    const [worldLine1P1, worldLine1P2] = line1;
    const [worldLine2P1, worldLine2P2] = line2;
    const canvasPoints = [
      worldLine1P1,
      worldLine1P2,
      worldLine2P2,
      worldLine2P1
    ].map((worldPoint) => viewport.worldToCanvas(worldPoint));
    const annotationUID = "growCutRect";
    const squareGroupUID = "0";
    const { color, fillColor, lineWidth, fillOpacity, lineDash } = this.getSegmentStyle({
      segmentationId,
      segmentIndex,
      viewportId: viewport.id
    });
    drawPolyline(svgDrawingHelper, annotationUID, squareGroupUID, canvasPoints, {
      color,
      fillColor,
      fillOpacity,
      lineWidth,
      lineDash,
      closePath: true
    });
  }
  async getGrowCutLabelmap(growCutData) {
    const { segmentation: { segmentIndex, referencedVolumeId }, renderingEngineId, viewportId, horizontalLines } = growCutData;
    const renderingEngine = getRenderingEngine(renderingEngineId);
    const viewport = renderingEngine.getViewport(viewportId);
    const [line1, line2] = horizontalLines;
    const worldSquarePoints = [line1[0], line1[1], line2[1], line2[0]];
    const referencedVolume = cache_default.getVolume(referencedVolumeId);
    const { topLeft: worldTopLeft, bottomRight: worldBottomRight } = this._getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints);
    const ijkTopLeft = transformWorldToIndex18(referencedVolume.imageData, worldTopLeft);
    const ijkBottomRight = transformWorldToIndex18(referencedVolume.imageData, worldBottomRight);
    const boundingBoxInfo = {
      boundingBox: {
        ijkTopLeft,
        ijkBottomRight
      }
    };
    const config = this.configuration;
    const options = {
      positiveSeedValue: segmentIndex,
      negativeSeedValue: 255,
      negativePixelRange: config.negativePixelRange,
      positivePixelRange: config.positivePixelRange
    };
    return growCut_exports.runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options);
  }
  getRemoveIslandData() {
    const { segmentation: { segmentIndex, referencedVolumeId, labelmapVolumeId } } = this.growCutData;
    const referencedVolume = cache_default.getVolume(referencedVolumeId);
    const labelmapVolume = cache_default.getVolume(labelmapVolumeId);
    const referencedVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();
    const labelmapData = labelmapVolume.voxelManager.getCompleteScalarDataArray();
    const { islandPixelRange } = this.configuration.islandRemoval;
    const islandPointIndexes = [];
    for (let i = 0, len = labelmapData.length; i < len; i++) {
      if (labelmapData[i] !== segmentIndex) {
        continue;
      }
      const pixelValue = referencedVolumeData[i];
      if (pixelValue >= islandPixelRange[0] && pixelValue <= islandPixelRange[1]) {
        islandPointIndexes.push(i);
      }
    }
    return {
      islandPointIndexes
    };
  }
  _activateDraw(element) {
    element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
    element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
    element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
  }
  _projectWorldPointAcrossSlices(viewport, worldEdgePoint, vecDirection) {
    const volume = this._getViewportVolume(viewport);
    const { dimensions } = volume;
    const ijkPoint = transformWorldToIndex18(volume.imageData, worldEdgePoint);
    const axis = vecDirection.findIndex((n) => utilities_exports.isEqual(Math.abs(n), 1));
    if (axis === -1) {
      throw new Error("Non-orthogonal direction vector");
    }
    const ijkLineP1 = [...ijkPoint];
    const ijkLineP2 = [...ijkPoint];
    ijkLineP1[axis] = 0;
    ijkLineP2[axis] = dimensions[axis] - 1;
    return [ijkLineP1, ijkLineP2];
  }
  _getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldEdgePoint) {
    const { viewPlaneNormal } = viewport.getCamera();
    return this._projectWorldPointAcrossSlices(viewport, worldEdgePoint, viewPlaneNormal);
  }
  _getWorldCuboidCornerPoints(viewport, worldSquarePoints) {
    const cuboidPoints = [];
    const volume = this._getViewportVolume(viewport);
    worldSquarePoints.forEach((worldSquarePoint) => {
      const ijkEdgePoints = this._getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldSquarePoint);
      const worldEdgePoints = ijkEdgePoints.map((ijkPoint) => transformIndexToWorld3(volume.imageData, ijkPoint));
      cuboidPoints.push(...worldEdgePoints);
    });
    return cuboidPoints;
  }
  _getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints) {
    const worldCuboidPoints = this._getWorldCuboidCornerPoints(viewport, worldSquarePoints);
    const topLeft = [...worldCuboidPoints[0]];
    const bottomRight = [...worldCuboidPoints[0]];
    worldCuboidPoints.forEach((worldPoint) => {
      vec3_exports.min(topLeft, topLeft, worldPoint);
      vec3_exports.max(bottomRight, bottomRight, worldPoint);
    });
    return { topLeft, bottomRight };
  }
  _getViewportVolume(viewport) {
    if (!(viewport instanceof BaseVolumeViewport_default)) {
      throw new Error("Viewport is not a BaseVolumeViewport");
    }
    const volumeId = viewport.getAllVolumeIds()[0];
    return cache_default.getVolume(volumeId);
  }
  _getHorizontalLineIJKPoints(enabledElement, worldPoint) {
    const { viewport } = enabledElement;
    const volume = this._getViewportVolume(viewport);
    const { dimensions } = volume;
    const ijkPoint = transformWorldToIndex18(volume.imageData, worldPoint);
    const { viewUp, viewPlaneNormal } = viewport.getCamera();
    const vecRow = vec3_exports.cross(vec3_exports.create(), viewUp, viewPlaneNormal);
    const axis = vecRow.findIndex((n) => utilities_exports.isEqual(Math.abs(n), 1));
    const ijkLineP1 = [...ijkPoint];
    const ijkLineP2 = [...ijkPoint];
    ijkLineP1[axis] = 0;
    ijkLineP2[axis] = dimensions[axis] - 1;
    return [ijkLineP1, ijkLineP2];
  }
  _getHorizontalLineWorldPoints(enabledElement, worldPoint) {
    const { viewport } = enabledElement;
    const volume = this._getViewportVolume(viewport);
    const [ijkPoint1, ijkPoint2] = this._getHorizontalLineIJKPoints(enabledElement, worldPoint);
    const worldPoint1 = transformIndexToWorld3(volume.imageData, ijkPoint1);
    const worldPoint2 = transformIndexToWorld3(volume.imageData, ijkPoint2);
    return [worldPoint1, worldPoint2];
  }
};
WholeBodySegmentTool.toolName = "WholeBodySegment";
var WholeBodySegmentTool_default = WholeBodySegmentTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseRectangle.js
function eraseRectangle(enabledElement, operationData, inside = true) {
  const eraseOperationData = Object.assign({}, operationData, {
    segmentIndex: 0
  });
  fillInsideRectangle(enabledElement, eraseOperationData);
}
function eraseInsideRectangle(enabledElement, operationData) {
  eraseRectangle(enabledElement, operationData, true);
}

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js
var RectangleScissorsTool = class extends LabelmapBaseTool {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      strategies: {
        FILL_INSIDE: fillInsideRectangle,
        ERASE_INSIDE: eraseInsideRectangle
      },
      defaultStrategy: "FILL_INSIDE",
      activeStrategy: "FILL_INSIDE"
    }
  }) {
    super(toolProps, defaultToolProps);
    this.preMouseDownCallback = (evt) => {
      if (this.isDrawing === true) {
        return;
      }
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const activeLabelmapSegmentation = activeSegmentation_exports.getActiveSegmentation(viewport.id);
      if (!activeLabelmapSegmentation) {
        throw new Error("No active segmentation detected, create one before using scissors tool");
      }
      const { segmentationId } = activeLabelmapSegmentation;
      const segmentIndex = segmentIndex_exports.getActiveSegmentIndex(segmentationId);
      const segmentsLocked = segmentLocking_exports.getLockedSegmentIndices(segmentationId);
      const segmentColor = config_exports2.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
      const { representationData } = getSegmentation(segmentationId);
      const labelmapData = representationData[SegmentationRepresentations_default.Labelmap];
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
          referencedImageId: "",
          toolName: this.getToolName(),
          segmentColor
        },
        data: {
          handles: {
            points: [
              [...worldPos],
              [...worldPos],
              [...worldPos],
              [...worldPos]
            ],
            activeHandleIndex: null
          }
        }
      };
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        segmentIndex,
        segmentationId,
        segmentsLocked,
        segmentColor,
        viewportIdsToRender,
        handleIndex: 3,
        movingTextBox: false,
        newAnnotation: true,
        hasMoved: false,
        volumeId: null,
        referencedVolumeId: null,
        imageId: null
      };
      if (viewport instanceof BaseVolumeViewport_default) {
        const { volumeId } = labelmapData;
        const segmentation = cache_default.getVolume(volumeId);
        this.editData = {
          ...this.editData,
          volumeId,
          referencedVolumeId: segmentation.referencedVolumeId
        };
      } else {
        const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);
        this.editData = {
          ...this.editData,
          imageId: segmentationImageId
        };
      }
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return true;
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, handleIndex } = this.editData;
      const { data } = annotation;
      const { currentPoints } = eventDetail;
      const enabledElement = getEnabledElement(element);
      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
      const worldPos = currentPoints.world;
      const { points } = data.handles;
      points[handleIndex] = [...worldPos];
      let bottomLeftCanvas;
      let bottomRightCanvas;
      let topLeftCanvas;
      let topRightCanvas;
      let bottomLeftWorld;
      let bottomRightWorld;
      let topLeftWorld;
      let topRightWorld;
      switch (handleIndex) {
        case 0:
        case 3:
          bottomLeftCanvas = worldToCanvas(points[0]);
          topRightCanvas = worldToCanvas(points[3]);
          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
          bottomRightWorld = canvasToWorld(bottomRightCanvas);
          topLeftWorld = canvasToWorld(topLeftCanvas);
          points[1] = bottomRightWorld;
          points[2] = topLeftWorld;
          break;
        case 1:
        case 2:
          bottomRightCanvas = worldToCanvas(points[1]);
          topLeftCanvas = worldToCanvas(points[2]);
          bottomLeftCanvas = [
            topLeftCanvas[0],
            bottomRightCanvas[1]
          ];
          topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];
          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
          topRightWorld = canvasToWorld(topRightCanvas);
          points[0] = bottomLeftWorld;
          points[3] = topRightWorld;
          break;
      }
      annotation.invalidated = true;
      this.editData.hasMoved = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      data.handles.activeHandleIndex = null;
      this._deactivateDraw(element);
      resetElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const operationData = {
        ...this.editData,
        points: data.handles.points,
        strategySpecificConfiguration: {},
        createMemo: this.createMemo.bind(this)
      };
      this.editData = null;
      this.isDrawing = false;
      this.applyActiveStrategy(enabledElement, operationData);
      this.doneEditMemo();
    };
    this._activateDraw = (element) => {
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this._deactivateDraw = (element) => {
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      if (!this.editData) {
        return renderStatus;
      }
      const { viewport } = enabledElement;
      const { annotation } = this.editData;
      const toolMetadata = annotation.metadata;
      const annotationUID = annotation.annotationUID;
      const data = annotation.data;
      const { points } = data.handles;
      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
      const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
      if (!viewport.getRenderingEngine()) {
        console.warn("Rendering Engine has been destroyed");
        return renderStatus;
      }
      const rectangleUID = "0";
      drawRect(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
        color
      });
      renderStatus = true;
      return renderStatus;
    };
  }
};
RectangleScissorsTool.toolName = "RectangleScissor";
var RectangleScissorsTool_default = RectangleScissorsTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js
var CircleScissorsTool = class extends LabelmapBaseTool {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      strategies: {
        FILL_INSIDE: fillInsideCircle,
        ERASE_INSIDE: eraseInsideCircle
      },
      defaultStrategy: "FILL_INSIDE",
      activeStrategy: "FILL_INSIDE"
    }
  }) {
    super(toolProps, defaultToolProps);
    this.preMouseDownCallback = (evt) => {
      if (this.isDrawing === true) {
        return;
      }
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const canvasPos = currentPoints.canvas;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const activeLabelmapSegmentation = activeSegmentation_exports.getActiveSegmentation(viewport.id);
      if (!activeLabelmapSegmentation) {
        throw new Error("No active segmentation detected, create one before using scissors tool");
      }
      const { segmentationId } = activeLabelmapSegmentation;
      const segmentIndex = segmentIndex_exports.getActiveSegmentIndex(segmentationId);
      const segmentsLocked = segmentLocking_exports.getLockedSegmentIndices(segmentationId);
      const segmentColor = config_exports2.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
      const { representationData } = getSegmentation(segmentationId);
      const labelmapData = representationData.Labelmap;
      if (!labelmapData) {
        throw new Error("No labelmap data found for the active segmentation, create one before using scissors tool");
      }
      const annotation = {
        invalidated: true,
        highlighted: true,
        metadata: {
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
          referencedImageId: "",
          toolName: this.getToolName(),
          segmentColor
        },
        data: {
          handles: {
            points: [
              [...worldPos],
              [...worldPos],
              [...worldPos],
              [...worldPos]
            ],
            activeHandleIndex: null
          },
          isDrawing: true,
          cachedStats: {}
        }
      };
      const viewportIdsToRender = [viewport.id];
      this.editData = {
        annotation,
        centerCanvas: canvasPos,
        segmentIndex,
        segmentationId,
        segmentsLocked,
        segmentColor,
        viewportIdsToRender,
        handleIndex: 3,
        movingTextBox: false,
        newAnnotation: true,
        hasMoved: false,
        volumeId: null,
        referencedVolumeId: null,
        imageId: null
      };
      if (viewport instanceof BaseVolumeViewport_default) {
        const { volumeId } = labelmapData;
        const segmentation = cache_default.getVolume(volumeId);
        this.editData = {
          ...this.editData,
          volumeId,
          referencedVolumeId: segmentation.referencedVolumeId
        };
      } else {
        const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);
        this.editData = {
          ...this.editData,
          imageId: segmentationImageId
        };
      }
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return true;
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { currentPoints } = eventDetail;
      const currentCanvasPoints = currentPoints.canvas;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine, viewport } = enabledElement;
      const { canvasToWorld } = viewport;
      const { annotation, viewportIdsToRender, centerCanvas } = this.editData;
      const { data } = annotation;
      const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
      const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
      const radius = Math.sqrt(dX * dX + dY * dY);
      const bottomCanvas = [
        centerCanvas[0],
        centerCanvas[1] + radius
      ];
      const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];
      const leftCanvas = [
        centerCanvas[0] - radius,
        centerCanvas[1]
      ];
      const rightCanvas = [
        centerCanvas[0] + radius,
        centerCanvas[1]
      ];
      data.handles.points = [
        canvasToWorld(bottomCanvas),
        canvasToWorld(topCanvas),
        canvasToWorld(leftCanvas),
        canvasToWorld(rightCanvas)
      ];
      annotation.invalidated = true;
      this.editData.hasMoved = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      const { viewPlaneNormal, viewUp } = annotation.metadata;
      if (newAnnotation && !hasMoved) {
        return;
      }
      data.handles.activeHandleIndex = null;
      this._deactivateDraw(element);
      resetElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const operationData = {
        ...this.editData,
        points: data.handles.points,
        viewPlaneNormal,
        viewUp,
        strategySpecificConfiguration: {},
        createMemo: this.createMemo.bind(this)
      };
      this.editData = null;
      this.isDrawing = false;
      this.applyActiveStrategy(enabledElement, operationData);
      this.doneEditMemo();
    };
    this._activateDraw = (element) => {
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
    };
    this._deactivateDraw = (element) => {
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      if (!this.editData) {
        return renderStatus;
      }
      const { viewport } = enabledElement;
      const { viewportIdsToRender } = this.editData;
      if (!viewportIdsToRender.includes(viewport.id)) {
        return renderStatus;
      }
      const { annotation } = this.editData;
      const toolMetadata = annotation.metadata;
      const annotationUID = annotation.annotationUID;
      const data = annotation.data;
      const { points } = data.handles;
      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
      const bottom = canvasCoordinates[0];
      const top = canvasCoordinates[1];
      const center = [
        Math.floor((bottom[0] + top[0]) / 2),
        Math.floor((bottom[1] + top[1]) / 2)
      ];
      const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
      const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
      if (!viewport.getRenderingEngine()) {
        console.warn("Rendering Engine has been destroyed");
        return renderStatus;
      }
      const circleUID = "0";
      drawCircle_default(svgDrawingHelper, annotationUID, circleUID, center, radius, {
        color
      });
      renderStatus = true;
      return renderStatus;
    };
  }
};
CircleScissorsTool.toolName = "CircleScissor";
var CircleScissorsTool_default = CircleScissorsTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js
var SphereScissorsTool = class extends LabelmapBaseTool {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      strategies: {
        FILL_INSIDE: fillInsideSphere,
        ERASE_INSIDE: eraseInsideSphere
      },
      defaultStrategy: "FILL_INSIDE",
      activeStrategy: "FILL_INSIDE"
    }
  }) {
    super(toolProps, defaultToolProps);
    this.preMouseDownCallback = (evt) => {
      if (this.isDrawing === true) {
        return;
      }
      this.doneEditMemo();
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const canvasPos = currentPoints.canvas;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const activeSegmentationRepresentation = activeSegmentation_exports.getActiveSegmentation(viewport.id);
      if (!activeSegmentationRepresentation) {
        throw new Error("No active segmentation detected, create one before using scissors tool");
      }
      const { segmentationId } = activeSegmentationRepresentation;
      const segmentIndex = segmentIndex_exports.getActiveSegmentIndex(segmentationId);
      const segmentsLocked = segmentLocking_exports.getLockedSegmentIndices(segmentationId);
      const segmentColor = config_exports2.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
      this.isDrawing = true;
      const annotation = {
        metadata: {
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
          referencedImageId: "",
          toolName: this.getToolName(),
          segmentColor
        },
        data: {
          invalidated: true,
          handles: {
            points: [
              [...worldPos],
              [...worldPos],
              [...worldPos],
              [...worldPos]
            ],
            activeHandleIndex: null
          },
          cachedStats: {},
          highlighted: true
        }
      };
      const viewportIdsToRender = [viewport.id];
      this.editData = {
        annotation,
        centerCanvas: canvasPos,
        segmentIndex,
        segmentationId,
        segmentsLocked,
        segmentColor,
        toolGroupId: this.toolGroupId,
        viewportIdsToRender,
        handleIndex: 3,
        movingTextBox: false,
        newAnnotation: true,
        hasMoved: false,
        volumeId: null,
        referencedVolumeId: null,
        imageId: null
      };
      const { representationData } = getSegmentation(segmentationId);
      const labelmapData = representationData[SegmentationRepresentations_default.Labelmap];
      if (viewport instanceof BaseVolumeViewport_default) {
        const { volumeId } = labelmapData;
        const segmentation = cache_default.getVolume(volumeId);
        this.editData = {
          ...this.editData,
          volumeId,
          referencedVolumeId: segmentation.referencedVolumeId
        };
      } else {
        this.editData = {
          ...this.editData
        };
      }
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return true;
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { currentPoints } = eventDetail;
      const currentCanvasPoints = currentPoints.canvas;
      const enabledElement = getEnabledElement(element);
      const { renderingEngine, viewport } = enabledElement;
      const { canvasToWorld } = viewport;
      const { annotation, viewportIdsToRender, centerCanvas } = this.editData;
      const { data } = annotation;
      const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
      const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
      const radius = Math.sqrt(dX * dX + dY * dY);
      const bottomCanvas = [
        centerCanvas[0],
        centerCanvas[1] + radius
      ];
      const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];
      const leftCanvas = [
        centerCanvas[0] - radius,
        centerCanvas[1]
      ];
      const rightCanvas = [
        centerCanvas[0] + radius,
        centerCanvas[1]
      ];
      data.handles.points = [
        canvasToWorld(bottomCanvas),
        canvasToWorld(topCanvas),
        canvasToWorld(leftCanvas),
        canvasToWorld(rightCanvas)
      ];
      annotation.invalidated = true;
      this.editData.hasMoved = true;
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, newAnnotation, hasMoved, segmentIndex, segmentsLocked } = this.editData;
      const { data } = annotation;
      const { viewPlaneNormal, viewUp } = annotation.metadata;
      if (newAnnotation && !hasMoved) {
        return;
      }
      annotation.highlighted = false;
      data.handles.activeHandleIndex = null;
      this._deactivateDraw(element);
      resetElementCursor(element);
      const enabledElement = getEnabledElement(element);
      const operationData = {
        ...this.editData,
        points: data.handles.points,
        segmentIndex,
        segmentsLocked,
        viewPlaneNormal,
        viewUp,
        createMemo: this.createMemo.bind(this)
      };
      this.editData = null;
      this.isDrawing = false;
      this.applyActiveStrategy(enabledElement, operationData);
      this.doneEditMemo();
    };
    this._activateDraw = (element) => {
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_TAP, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._deactivateDraw = (element) => {
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.TOUCH_TAP, this._endCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      if (!this.editData) {
        return renderStatus;
      }
      const { viewport } = enabledElement;
      const { viewportIdsToRender } = this.editData;
      if (!viewportIdsToRender.includes(viewport.id)) {
        return renderStatus;
      }
      const { annotation } = this.editData;
      const toolMetadata = annotation.metadata;
      const annotationUID = annotation.annotationUID;
      const data = annotation.data;
      const { points } = data.handles;
      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
      const bottom = canvasCoordinates[0];
      const top = canvasCoordinates[1];
      const center = [
        Math.floor((bottom[0] + top[0]) / 2),
        Math.floor((bottom[1] + top[1]) / 2)
      ];
      const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
      const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
      if (!viewport.getRenderingEngine()) {
        console.warn("Rendering Engine has been destroyed");
        return renderStatus;
      }
      const circleUID = "0";
      drawCircle_default(svgDrawingHelper, annotationUID, circleUID, center, radius, {
        color
      });
      renderStatus = true;
      return renderStatus;
    };
  }
};
SphereScissorsTool.toolName = "SphereScissor";
var SphereScissorsTool_default = SphereScissorsTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js
var { transformWorldToIndex: transformWorldToIndex19 } = utilities_exports;
var CircleROIStartEndThresholdTool = class extends CircleROITool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      storePointData: false,
      numSlicesToPropagate: 10,
      calculatePointsInsideVolume: false,
      getTextLines: defaultGetTextLines16,
      statsCalculator: BasicStatsCalculator,
      showTextBox: false
    }
  }) {
    super(toolProps, defaultToolProps);
    this.isHandleOutsideImage = false;
    this.addNewAnnotation = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      let referencedImageId, imageVolume, volumeId;
      if (viewport instanceof StackViewport_default) {
        throw new Error("Stack Viewport Not implemented");
      } else {
        const targetId = this.getTargetId(viewport);
        volumeId = utilities_exports.getVolumeId(targetId);
        imageVolume = cache_default.getVolume(volumeId);
        referencedImageId = utilities_exports.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
      }
      const spacingInNormal = utilities_exports.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
      const startCoord = this._getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
      const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
      const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
      const annotation = {
        highlighted: true,
        invalidated: true,
        metadata: {
          toolName: this.getToolName(),
          viewPlaneNormal: [...viewPlaneNormal],
          viewUp: [...viewUp],
          FrameOfReferenceUID,
          referencedImageId,
          volumeId,
          spacingInNormal,
          enabledElement
        },
        data: {
          label: "",
          startCoordinate: startCoord,
          endCoordinate: endCoord,
          handles: {
            textBox: {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            },
            points: [[...worldPos], [...worldPos]],
            activeHandleIndex: null
          },
          cachedStats: {
            pointsInVolume: [],
            projectionPoints: [],
            statistics: []
          },
          labelmapUID: null
        }
      };
      this._computeProjectionPoints(annotation, imageVolume);
      addAnnotation(annotation, element);
      const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());
      this.editData = {
        annotation,
        viewportIdsToRender,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      return annotation;
    };
    this._endCallback = (evt) => {
      const eventDetail = evt.detail;
      const { element } = eventDetail;
      const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      annotation.highlighted = false;
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      const enabledElement = getEnabledElement(element);
      this.editData = null;
      this.isDrawing = false;
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      const targetId = this.getTargetId(enabledElement.viewport);
      const imageVolume = cache_default.getVolume(targetId.split(/volumeId:|\?/)[1]);
      if (this.configuration.calculatePointsInsideVolume) {
        this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);
      }
      triggerAnnotationRenderForViewportIds_default(viewportIdsToRender);
      if (newAnnotation) {
        triggerAnnotationCompleted(annotation);
      }
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      let renderStatus = false;
      const { viewport } = enabledElement;
      let annotations = getAnnotations(this.getToolName(), viewport.element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID, data, metadata } = annotation;
        const { startCoordinate, endCoordinate } = data;
        const { points, activeHandleIndex } = data.handles;
        styleSpecifier.annotationUID = annotationUID;
        const lineWidth = this.getStyle("lineWidth", styleSpecifier, annotation);
        const lineDash = this.getStyle("lineDash", styleSpecifier, annotation);
        const color = this.getStyle("color", styleSpecifier, annotation);
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const center = canvasCoordinates[0];
        const radius = getCanvasCircleRadius(canvasCoordinates);
        const { centerPointRadius } = this.configuration;
        const canvasCorners = getCanvasCircleCorners(canvasCoordinates);
        const focalPoint = viewport.getCamera().focalPoint;
        const viewplaneNormal = viewport.getCamera().viewPlaneNormal;
        let tempStartCoordinate = startCoordinate;
        let tempEndCoordinate = endCoordinate;
        if (Array.isArray(startCoordinate)) {
          tempStartCoordinate = this._getCoordinateForViewplaneNormal(tempStartCoordinate, viewplaneNormal);
          data.startCoordinate = tempStartCoordinate;
        }
        if (Array.isArray(endCoordinate)) {
          tempEndCoordinate = this._getCoordinateForViewplaneNormal(tempEndCoordinate, viewplaneNormal);
          data.endCoordinate = tempEndCoordinate;
        }
        const roundedStartCoordinate = utilities_exports.roundToPrecision(data.startCoordinate);
        const roundedEndCoordinate = utilities_exports.roundToPrecision(data.endCoordinate);
        const cameraCoordinate = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);
        const roundedCameraCoordinate = utilities_exports.roundToPrecision(cameraCoordinate);
        if (roundedCameraCoordinate < Math.min(roundedStartCoordinate, roundedEndCoordinate) || roundedCameraCoordinate > Math.max(roundedStartCoordinate, roundedEndCoordinate)) {
          continue;
        }
        const middleCoordinate = utilities_exports.roundToPrecision((data.startCoordinate + data.endCoordinate) / 2);
        let isMiddleSlice = false;
        if (roundedCameraCoordinate === middleCoordinate) {
          isMiddleSlice = true;
        }
        data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = middleCoordinate;
        if (annotation.invalidated) {
          this._throttledCalculateCachedStats(annotation, enabledElement);
        }
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return renderStatus;
        }
        let activeHandleCanvasCoords;
        if (!isAnnotationVisible(annotationUID)) {
          continue;
        }
        if (!isAnnotationLocked(annotationUID) && !this.editData && activeHandleIndex !== null && isMiddleSlice) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
            color
          });
        }
        let lineWidthToUse = lineWidth;
        let lineDashToUse = lineDash;
        if (isMiddleSlice) {
          lineWidthToUse = lineWidth;
          lineDashToUse = [];
        } else {
          lineDashToUse = [5, 5];
        }
        const circleUID = "0";
        drawCircle_default(svgDrawingHelper, annotationUID, circleUID, center, radius, {
          color,
          lineDash: lineDashToUse,
          lineWidth: lineWidthToUse
        });
        if (centerPointRadius > 0) {
          if (radius > 3 * centerPointRadius) {
            drawCircle_default(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {
              color,
              lineDash,
              lineWidth
            });
          }
        }
        renderStatus = true;
        if (this.configuration.showTextBox == true && this.configuration.calculatePointsInsideVolume == true) {
          const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
          if (!options.visibility) {
            data.handles.textBox = {
              hasMoved: false,
              worldPosition: [0, 0, 0],
              worldBoundingBox: {
                topLeft: [0, 0, 0],
                topRight: [0, 0, 0],
                bottomLeft: [0, 0, 0],
                bottomRight: [0, 0, 0]
              }
            };
            continue;
          }
          const textLines = this.configuration.getTextLines(data, { metadata });
          if (!textLines || textLines.length === 0) {
            continue;
          }
          let canvasTextBoxCoords;
          if (!data.handles.textBox.hasMoved) {
            canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);
            data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);
          }
          const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
          const textBoxUID = "1";
          const boundingBox = drawLinkedTextBox_default(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
          const { x: left, y: top, width, height } = boundingBox;
          data.handles.textBox.worldBoundingBox = {
            topLeft: viewport.canvasToWorld([left, top]),
            topRight: viewport.canvasToWorld([left + width, top]),
            bottomLeft: viewport.canvasToWorld([left, top + height]),
            bottomRight: viewport.canvasToWorld([left + width, top + height])
          };
        }
      }
      return renderStatus;
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStatsTool, 100, { trailing: true });
  }
  _computeProjectionPoints(annotation, imageVolume) {
    const { data, metadata } = annotation;
    const { viewPlaneNormal, spacingInNormal } = metadata;
    const { imageData } = imageVolume;
    const { startCoordinate, endCoordinate } = data;
    const { points } = data.handles;
    const startIJK = transformWorldToIndex19(imageData, points[0]);
    const endIJK = transformWorldToIndex19(imageData, points[0]);
    const handlesToStart = utilities_exports.deepClone(points);
    const startWorld = vec3_exports.create();
    imageData.indexToWorldVec3(startIJK, startWorld);
    const endWorld = vec3_exports.create();
    imageData.indexToWorldVec3(endIJK, endWorld);
    if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {
      startWorld[2] = startCoordinate;
      endWorld[2] = endCoordinate;
      handlesToStart[0][2] = startCoordinate;
      handlesToStart[1][2] = startCoordinate;
    } else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {
      startWorld[0] = startCoordinate;
      endWorld[0] = endCoordinate;
      handlesToStart[0][0] = startCoordinate;
      handlesToStart[1][0] = startCoordinate;
    } else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {
      startWorld[1] = startCoordinate;
      endWorld[1] = endCoordinate;
      handlesToStart[0][1] = startCoordinate;
      handlesToStart[1][1] = startCoordinate;
    }
    const distance = vec3_exports.distance(startWorld, endWorld);
    const newProjectionPoints = [];
    for (let dist = 0; dist < distance; dist += spacingInNormal) {
      newProjectionPoints.push(handlesToStart.map((point) => {
        const newPoint = vec3_exports.create();
        vec3_exports.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);
        return Array.from(newPoint);
      }));
    }
    data.cachedStats.projectionPoints = newProjectionPoints;
  }
  _computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement) {
    var _a2, _b2, _c;
    const { data, metadata } = annotation;
    const { viewPlaneNormal, viewUp } = metadata;
    const { viewport } = enabledElement;
    const projectionPoints = data.cachedStats.projectionPoints;
    const pointsInsideVolume = [[]];
    const image = this.getTargetImageData(targetId);
    const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
    const [topLeftCanvas, bottomRightCanvas] = getCanvasCircleCorners(canvasCoordinates);
    const pos1 = viewport.canvasToWorld(topLeftCanvas);
    const pos2 = viewport.canvasToWorld(bottomRightCanvas);
    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, pos1, pos2);
    const measureInfo = getCalibratedLengthUnitsAndScale(image, data.handles);
    const aspect = getCalibratedAspect(image);
    const area = Math.abs(Math.PI * (worldWidth / measureInfo.scale / 2) * (worldHeight / aspect / measureInfo.scale / 2));
    const modalityUnitOptions = {
      isPreScaled: isViewportPreScaled(viewport, targetId),
      isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId)
    };
    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
    for (let i = 0; i < projectionPoints.length; i++) {
      if (!imageVolume) {
        continue;
      }
      const centerWorld = projectionPoints[i][0];
      const canvasCoordinates2 = projectionPoints[i].map((p) => viewport.worldToCanvas(p));
      const [topLeftCanvas2, bottomRightCanvas2] = getCanvasCircleCorners(canvasCoordinates2);
      const topLeftWorld = viewport.canvasToWorld(topLeftCanvas2);
      const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas2);
      const worldPos1 = topLeftWorld;
      const worldPos2 = bottomRightWorld;
      const { dimensions, imageData, voxelManager } = imageVolume;
      const worldPos1Index = transformWorldToIndex19(imageData, worldPos1);
      const worldProjectionPointIndex = transformWorldToIndex19(imageData, centerWorld);
      const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
      worldPos1Index[0] = Math.floor(worldPos1Index[0]);
      worldPos1Index[1] = Math.floor(worldPos1Index[1]);
      worldPos1Index[2] = Math.floor(worldPos1Index[2]);
      worldPos1Index[indexOfProjection] = worldProjectionPointIndex[indexOfProjection];
      const worldPos2Index = transformWorldToIndex19(imageData, worldPos2);
      worldPos2Index[0] = Math.floor(worldPos2Index[0]);
      worldPos2Index[1] = Math.floor(worldPos2Index[1]);
      worldPos2Index[2] = Math.floor(worldPos2Index[2]);
      worldPos2Index[indexOfProjection] = worldProjectionPointIndex[indexOfProjection];
      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
        const boundsIJK = [
          [iMin, iMax],
          [jMin, jMax],
          [kMin, kMax]
        ];
        const center = centerWorld;
        const ellipseObj = {
          center,
          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,
          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,
          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2
        };
        const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
          isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS),
          boundsIJK,
          imageData,
          returnPoints: this.configuration.storePointData
        });
        pointsInsideVolume.push(pointsInShape);
      }
    }
    const stats = this.configuration.statsCalculator.getStatistics();
    data.cachedStats.pointsInVolume = pointsInsideVolume;
    data.cachedStats.statistics = {
      Modality: metadata.Modality,
      area,
      mean: (_a2 = stats.mean) == null ? void 0 : _a2.value,
      stdDev: (_b2 = stats.stdDev) == null ? void 0 : _b2.value,
      max: (_c = stats.max) == null ? void 0 : _c.value,
      statsArray: stats.array,
      areaUnit: measureInfo.areaUnit,
      modalityUnit
    };
  }
  _calculateCachedStatsTool(annotation, enabledElement) {
    const data = annotation.data;
    const { viewport } = enabledElement;
    const { cachedStats } = data;
    const targetId = this.getTargetId(viewport);
    const imageVolume = cache_default.getVolume(targetId.split(/volumeId:|\?/)[1]);
    this._computeProjectionPoints(annotation, imageVolume);
    if (this.configuration.calculatePointsInsideVolume) {
      this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);
    }
    annotation.invalidated = false;
    triggerAnnotationModified(annotation, viewport.element);
    return cachedStats;
  }
  _getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
    const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);
    const startPos = vec3_exports.create();
    vec3_exports.scaleAndAdd(startPos, worldPos, viewPlaneNormal, numSlicesToPropagateFromStart * -spacingInNormal);
    const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);
    return startCoord;
  }
  _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
    const numSlicesToPropagateToEnd = numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);
    const endPos = vec3_exports.create();
    vec3_exports.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagateToEnd * spacingInNormal);
    const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);
    return endCoord;
  }
  _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {
    const viewplaneNormalAbs = [
      Math.abs(viewPlaneNormal[0]),
      Math.abs(viewPlaneNormal[1]),
      Math.abs(viewPlaneNormal[2])
    ];
    const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));
    return indexOfDirection;
  }
  _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {
    const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
    return pos[indexOfDirection];
  }
};
function defaultGetTextLines16(data, _context = {}) {
  const cachedVolumeStats = data.cachedStats.statistics;
  const { area, mean, max: max2, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
  if (mean === void 0) {
    return;
  }
  const textLines = [];
  textLines.push(`Area: ${utilities_exports.roundNumber(area)} ${areaUnit}`);
  textLines.push(`Mean: ${utilities_exports.roundNumber(mean)} ${modalityUnit}`);
  textLines.push(`Max: ${utilities_exports.roundNumber(max2)} ${modalityUnit}`);
  textLines.push(`Std Dev: ${utilities_exports.roundNumber(stdDev)} ${modalityUnit}`);
  return textLines;
}
CircleROIStartEndThresholdTool.toolName = "CircleROIStartEndThreshold";
var CircleROIStartEndThresholdTool_default = CircleROIStartEndThresholdTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js
var { transformWorldToIndex: transformWorldToIndex20, isEqual: isEqual8 } = utilities_exports;
var PaintFillTool = class extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"]
  }) {
    super(toolProps, defaultToolProps);
    this.preMouseDownCallback = (evt) => {
      const eventDetail = evt.detail;
      const { currentPoints, element } = eventDetail;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const camera = viewport.getCamera();
      const { viewPlaneNormal } = camera;
      const activeSegmentationRepresentation = activeSegmentation_exports.getActiveSegmentation(viewport.id);
      if (!activeSegmentationRepresentation) {
        throw new Error("No active segmentation detected, create one before using scissors tool");
      }
      const { segmentationId } = activeSegmentationRepresentation;
      const segmentIndex = segmentIndex_exports.getActiveSegmentIndex(segmentationId);
      const segmentsLocked = segmentLocking_exports.getLockedSegmentIndices(segmentationId);
      const { representationData } = getSegmentation(segmentationId);
      let dimensions;
      let direction;
      let index;
      let voxelManager;
      this.doneEditMemo();
      if (viewport instanceof BaseVolumeViewport_default) {
        const { volumeId } = representationData[SegmentationRepresentations_default.Labelmap];
        const segmentation = cache_default.getVolume(volumeId);
        ({ dimensions, direction } = segmentation);
        voxelManager = segmentation.voxelManager;
        index = transformWorldToIndex20(segmentation.imageData, worldPos);
      } else {
        const currentSegmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);
        if (!currentSegmentationImageId) {
          throw new Error("No active segmentation imageId detected, create one before using scissors tool");
        }
        const { imageData } = viewport.getImageData();
        dimensions = imageData.getDimensions();
        direction = imageData.getDirection();
        const image = cache_default.getImage(currentSegmentationImageId);
        voxelManager = image.voxelManager;
        index = transformWorldToIndex20(imageData, worldPos);
      }
      const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);
      if (fixedDimension === void 0) {
        console.warn("Oblique paint fill not yet supported");
        return;
      }
      const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue } = this.generateHelpers(voxelManager, dimensions, index, fixedDimension);
      if (index[0] < 0 || index[0] >= dimensions[0] || index[1] < 0 || index[1] >= dimensions[1] || index[2] < 0 || index[2] >= dimensions[2]) {
        return;
      }
      const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);
      if (segmentsLocked.includes(clickedLabelValue)) {
        return;
      }
      const floodFillResult = floodFill_default(floodFillGetter, inPlaneSeedPoint);
      const { flooded } = floodFillResult;
      flooded.forEach((index2) => {
        const scalarDataIndex = getScalarDataPositionFromPlane(index2[0], index2[1]);
        voxelManager.setAtIndex(scalarDataIndex, segmentIndex);
      });
      const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);
      triggerSegmentationDataModified(segmentationId, framesModified);
      return true;
    };
    this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {
      const { flooded: boundaries } = floodFillResult;
      if (fixedDimension === 2) {
        return [fixedDimensionValue];
      }
      let minJ = Infinity;
      let maxJ = -Infinity;
      for (let b = 0; b < boundaries.length; b++) {
        const j = boundaries[b][1];
        if (j < minJ) {
          minJ = j;
        }
        if (j > maxJ) {
          maxJ = j;
        }
      }
      const framesModified = [];
      for (let frame = minJ; frame <= maxJ; frame++) {
        framesModified.push(frame);
      }
      return framesModified;
    };
    this.generateHelpers = (voxelManager, dimensions, seedIndex3D, fixedDimension = 2) => {
      let fixedDimensionValue;
      let inPlaneSeedPoint;
      switch (fixedDimension) {
        case 0:
          fixedDimensionValue = seedIndex3D[0];
          inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];
          break;
        case 1:
          fixedDimensionValue = seedIndex3D[1];
          inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];
          break;
        case 2:
          fixedDimensionValue = seedIndex3D[2];
          inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];
          break;
        default:
          throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
      }
      const getScalarDataPosition = (x, y, z) => {
        return voxelManager.toIndex([x, y, z]);
      };
      const getLabelValue = (x, y, z) => {
        return voxelManager.getAtIJK(x, y, z);
      };
      const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);
      const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);
      return {
        getScalarDataPositionFromPlane,
        getLabelValue,
        floodFillGetter,
        inPlaneSeedPoint,
        fixedDimensionValue
      };
    };
    this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {
      let floodFillGetter;
      switch (fixedDimension) {
        case 0:
          floodFillGetter = (y, z) => {
            if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {
              return;
            }
            return getLabelValue(fixedDimensionValue, y, z);
          };
          break;
        case 1:
          floodFillGetter = (x, z) => {
            if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {
              return;
            }
            return getLabelValue(x, fixedDimensionValue, z);
          };
          break;
        case 2:
          floodFillGetter = (x, y) => {
            if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {
              return;
            }
            return getLabelValue(x, y, fixedDimensionValue);
          };
          break;
        default:
          throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
      }
      return floodFillGetter;
    };
    this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {
      let getScalarDataPositionFromPlane;
      switch (fixedDimension) {
        case 0:
          getScalarDataPositionFromPlane = (y, z) => {
            return getScalarDataPosition(fixedDimensionValue, y, z);
          };
          break;
        case 1:
          getScalarDataPositionFromPlane = (x, z) => {
            return getScalarDataPosition(x, fixedDimensionValue, z);
          };
          break;
        case 2:
          getScalarDataPositionFromPlane = (x, y) => {
            return getScalarDataPosition(x, y, fixedDimensionValue);
          };
          break;
        default:
          throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
      }
      return getScalarDataPositionFromPlane;
    };
  }
  getFixedDimension(viewPlaneNormal, direction) {
    const xDirection = direction.slice(0, 3);
    const yDirection = direction.slice(3, 6);
    const zDirection = direction.slice(6, 9);
    const absoluteOfViewPlaneNormal = [
      Math.abs(viewPlaneNormal[0]),
      Math.abs(viewPlaneNormal[1]),
      Math.abs(viewPlaneNormal[2])
    ];
    const absoluteOfXDirection = [
      Math.abs(xDirection[0]),
      Math.abs(xDirection[1]),
      Math.abs(xDirection[2])
    ];
    if (isEqual8(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {
      return 0;
    }
    const absoluteOfYDirection = [
      Math.abs(yDirection[0]),
      Math.abs(yDirection[1]),
      Math.abs(yDirection[2])
    ];
    if (isEqual8(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {
      return 1;
    }
    const absoluteOfZDirection = [
      Math.abs(zDirection[0]),
      Math.abs(zDirection[1]),
      Math.abs(zDirection[2])
    ];
    if (isEqual8(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {
      return 2;
    }
  }
};
PaintFillTool.toolName = "PaintFill";
var PaintFillTool_default = PaintFillTool;

// node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget/Constants.js
var Corners = {
  TOP_LEFT: "TOP_LEFT",
  TOP_RIGHT: "TOP_RIGHT",
  BOTTOM_LEFT: "BOTTOM_LEFT",
  BOTTOM_RIGHT: "BOTTOM_RIGHT"
};
var Constants = {
  Corners
};

// node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget.js
var {
  vtkErrorMacro: vtkErrorMacro2
} = macro;
var {
  Corners: Corners2
} = Constants;
function vtkOrientationMarkerWidget(publicAPI, model) {
  model.classHierarchy.push("vtkOrientationMarkerWidget");
  const superClass = {
    ...publicAPI
  };
  const previousCameraInput = [];
  const selfRenderer = vtkRenderer$1.newInstance();
  const resizeObserver = new ResizeObserver((entries) => {
    publicAPI.updateViewport();
  });
  let onCameraChangedSub = null;
  let onCameraModifiedSub = null;
  let onAnimationSub = null;
  let onEndAnimationSub = null;
  let selfSubscription = null;
  function onCameraModified2() {
    if (!model._interactor.isAnimating()) {
      publicAPI.updateMarkerOrientation();
    }
  }
  model._onParentRendererChanged = () => publicAPI.updateViewport();
  publicAPI.computeViewport = () => {
    const parentRen = model.parentRenderer || model._interactor.getCurrentRenderer();
    const [xMin, yMin, xMax, yMax] = parentRen.getViewport();
    const view = model._interactor.getView();
    const canvasSize = view.getSize();
    const [viewXSize, viewYSize] = view.getViewportSize(parentRen);
    const minViewSize = Math.min(viewXSize, viewYSize);
    let pixelSize = model.viewportSize * minViewSize;
    pixelSize = Math.max(Math.min(model.minPixelSize, minViewSize), Math.min(model.maxPixelSize, pixelSize));
    const xFrac = pixelSize / canvasSize[0];
    const yFrac = pixelSize / canvasSize[1];
    switch (model.viewportCorner) {
      case Corners2.TOP_LEFT:
        return [xMin, yMax - yFrac, xMin + xFrac, yMax];
      case Corners2.TOP_RIGHT:
        return [xMax - xFrac, yMax - yFrac, xMax, yMax];
      case Corners2.BOTTOM_LEFT:
        return [xMin, yMin, xMin + xFrac, yMin + yFrac];
      case Corners2.BOTTOM_RIGHT:
        return [xMax - xFrac, yMin, xMax, yMin + yFrac];
      default:
        vtkErrorMacro2("Invalid widget corner");
        return null;
    }
  };
  publicAPI.updateViewport = () => {
    if (model.enabled) {
      selfRenderer.setViewport(...publicAPI.computeViewport());
      model._interactor.render();
    }
  };
  publicAPI.updateMarkerOrientation = () => {
    const ren = model.parentRenderer || model._interactor.getCurrentRenderer();
    const currentCamera = ren.getActiveCamera();
    if (!currentCamera) {
      return;
    }
    const position = currentCamera.getReferenceByName("position");
    const focalPoint = currentCamera.getReferenceByName("focalPoint");
    const viewUp = currentCamera.getReferenceByName("viewUp");
    if (previousCameraInput[0] !== position[0] || previousCameraInput[1] !== position[1] || previousCameraInput[2] !== position[2] || previousCameraInput[3] !== focalPoint[0] || previousCameraInput[4] !== focalPoint[1] || previousCameraInput[5] !== focalPoint[2] || previousCameraInput[6] !== viewUp[0] || previousCameraInput[7] !== viewUp[1] || previousCameraInput[8] !== viewUp[2]) {
      previousCameraInput[0] = position[0];
      previousCameraInput[1] = position[1];
      previousCameraInput[2] = position[2];
      previousCameraInput[3] = focalPoint[0];
      previousCameraInput[4] = focalPoint[1];
      previousCameraInput[5] = focalPoint[2];
      previousCameraInput[6] = viewUp[0];
      previousCameraInput[7] = viewUp[1];
      previousCameraInput[8] = viewUp[2];
      const activeCamera = selfRenderer.getActiveCamera();
      activeCamera.setPosition(position[0], position[1], position[2]);
      activeCamera.setFocalPoint(focalPoint[0], focalPoint[1], focalPoint[2]);
      activeCamera.setViewUp(viewUp[0], viewUp[1], viewUp[2]);
      selfRenderer.resetCamera();
    }
  };
  publicAPI.setEnabled = (enabling) => {
    var _a2, _b2;
    if (enabling) {
      if (model.enabled) {
        return;
      }
      if (!model.actor) {
        vtkErrorMacro2("Must set actor before enabling orientation marker.");
        return;
      }
      if (!model._interactor) {
        vtkErrorMacro2("Must set interactor before enabling orientation marker.");
        return;
      }
      const ren = model.parentRenderer || model._interactor.getCurrentRenderer();
      const renderWindow = ren.getRenderWindow();
      renderWindow.addRenderer(selfRenderer);
      if (renderWindow.getNumberOfLayers() < 2) {
        renderWindow.setNumberOfLayers(2);
      }
      selfRenderer.setLayer(renderWindow.getNumberOfLayers() - 1);
      selfRenderer.setInteractive(model.interactiveRenderer);
      selfRenderer.addViewProp(model.actor);
      model.actor.setVisibility(true);
      onCameraChangedSub = ren.onEvent((event) => {
        if (event.type === "ActiveCameraEvent") {
          if (onCameraModifiedSub) {
            onCameraModifiedSub.unsubscribe();
          }
          onCameraModifiedSub = event.camera.onModified(onCameraModified2);
        }
      });
      onCameraModifiedSub = ren.getActiveCamera().onModified(onCameraModified2);
      onAnimationSub = model._interactor.onAnimation(publicAPI.updateMarkerOrientation);
      onEndAnimationSub = model._interactor.onEndAnimation(publicAPI.updateMarkerOrientation);
      resizeObserver.observe(model._interactor.getView().getCanvas());
      publicAPI.updateViewport();
      publicAPI.updateMarkerOrientation();
      model.enabled = true;
    } else {
      if (!model.enabled) {
        return;
      }
      model.enabled = false;
      resizeObserver.disconnect();
      onCameraChangedSub.unsubscribe();
      onCameraChangedSub = null;
      onCameraModifiedSub.unsubscribe();
      onCameraModifiedSub = null;
      onAnimationSub.unsubscribe();
      onAnimationSub = null;
      onEndAnimationSub.unsubscribe();
      onEndAnimationSub = null;
      model.actor.setVisibility(false);
      selfRenderer.removeViewProp(model.actor);
      const renderWindow = (_b2 = (_a2 = model._interactor) == null ? void 0 : _a2.findPokedRenderer()) == null ? void 0 : _b2.getRenderWindow();
      if (renderWindow) {
        renderWindow.removeRenderer(selfRenderer);
      }
    }
    publicAPI.modified();
  };
  publicAPI.setViewportCorner = (corner) => {
    if (corner === model.viewportCorner) {
      return;
    }
    model.viewportCorner = corner;
    publicAPI.updateViewport();
  };
  publicAPI.setViewportSize = (sizeFactor) => {
    const viewportSize = Math.min(1, Math.max(0, sizeFactor));
    if (viewportSize === model.viewportSize) {
      return;
    }
    model.viewportSize = viewportSize;
    publicAPI.updateViewport();
  };
  publicAPI.setActor = (actor) => {
    const previousState = model.enabled;
    publicAPI.setEnabled(false);
    model.actor = actor;
    publicAPI.setEnabled(previousState);
  };
  publicAPI.getRenderer = () => selfRenderer;
  publicAPI.delete = () => {
    superClass.delete();
    if (selfSubscription) {
      selfSubscription.unsubscribe();
      selfSubscription = null;
    }
    if (onCameraChangedSub) {
      onCameraChangedSub.unsubscribe();
      onCameraChangedSub = null;
    }
    if (onCameraModifiedSub) {
      onCameraModifiedSub.unsubscribe();
      onCameraModifiedSub = null;
    }
    if (onAnimationSub) {
      onAnimationSub.unsubscribe();
      onAnimationSub = null;
    }
    if (onEndAnimationSub) {
      onEndAnimationSub.unsubscribe();
      onEndAnimationSub = null;
    }
    resizeObserver.disconnect();
  };
  selfSubscription = publicAPI.onModified(publicAPI.updateViewport);
}
var DEFAULT_VALUES2 = {
  // actor: null,
  // _interactor: null,
  viewportCorner: Constants.Corners.BOTTOM_LEFT,
  viewportSize: 0.2,
  minPixelSize: 50,
  maxPixelSize: 200,
  parentRenderer: null,
  interactiveRenderer: false
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["enabled", "viewportCorner", "viewportSize", "interactiveRenderer"]);
  macro.setGet(publicAPI, model, ["_interactor", "minPixelSize", "maxPixelSize", "parentRenderer"]);
  macro.get(publicAPI, model, ["actor"]);
  macro.moveToProtected(publicAPI, model, ["interactor"]);
  vtkOrientationMarkerWidget(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend3, "vtkOrientationMarkerWidget");
var vtkOrientationMarkerWidget$1 = {
  newInstance: newInstance3,
  extend: extend3,
  ...Constants
};

// node_modules/@kitware/vtk.js/Common/Core/ImageHelper.js
function canvasToImageData(canvas) {
  let boundingBox = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0, 0];
  const [top, left, width, height] = boundingBox;
  const ctxt = canvas.getContext("2d");
  const idata = ctxt.getImageData(top, left, width || canvas.width, height || canvas.height);
  const imageData = vtkImageData$1.newInstance({
    type: "vtkImageData"
  });
  imageData.setOrigin(0, 0, 0);
  imageData.setSpacing(1, 1, 1);
  imageData.setExtent(0, (width || canvas.width) - 1, 0, (height || canvas.height) - 1, 0, 0);
  const scalars = vtkDataArray$1.newInstance({
    numberOfComponents: 4,
    values: new Uint8Array(idata.data.buffer)
  });
  scalars.setName("scalars");
  imageData.getPointData().setScalars(scalars);
  return imageData;
}
function imageToImageData(image) {
  let transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    flipX: false,
    flipY: false,
    rotate: 0
  };
  const canvas = document.createElement("canvas");
  canvas.width = image.width;
  canvas.height = image.height;
  const ctx = canvas.getContext("2d");
  const {
    flipX,
    flipY,
    rotate: rotate2
  } = transform;
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.scale(flipX ? -1 : 1, flipY ? -1 : 1);
  ctx.rotate(rotate2 * Math.PI / 180);
  ctx.drawImage(image, -image.width / 2, -image.height / 2);
  return canvasToImageData(canvas);
}
var ImageHelper = {
  canvasToImageData,
  imageToImageData
};

// node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor/Presets.js
var STYLES = {
  default: {
    defaultStyle: {
      fontStyle: "bold",
      fontFamily: "Arial",
      fontColor: "black",
      fontSizeScale: (res) => res / 2,
      faceColor: "white",
      edgeThickness: 0.1,
      edgeColor: "black",
      resolution: 400
    },
    xMinusFaceProperty: {
      text: "X-",
      faceColor: "yellow"
    },
    xPlusFaceProperty: {
      text: "X+",
      faceColor: "yellow"
    },
    yMinusFaceProperty: {
      text: "Y-",
      faceColor: "red"
    },
    yPlusFaceProperty: {
      text: "Y+",
      faceColor: "red"
    },
    zMinusFaceProperty: {
      text: "Z-",
      faceColor: "#008000"
    },
    zPlusFaceProperty: {
      text: "Z+",
      faceColor: "#008000"
    }
  },
  lps: {
    xMinusFaceProperty: {
      text: "R",
      faceRotation: -90
    },
    xPlusFaceProperty: {
      text: "L",
      faceRotation: 90
    },
    yMinusFaceProperty: {
      text: "A",
      faceRotation: 0
    },
    yPlusFaceProperty: {
      text: "P",
      faceRotation: 180
    },
    zMinusFaceProperty: {
      text: "I",
      faceRotation: 180
    },
    zPlusFaceProperty: {
      text: "S",
      faceRotation: 0
    }
  }
};
function applyDefinitions(definitions, cubeActor) {
  cubeActor.set(definitions);
}
function applyPreset(name, cubeActor) {
  return applyDefinitions(STYLES[name], cubeActor);
}
function registerStylePreset(name, definitions) {
  STYLES[name] = definitions;
}
var AnnotatedCubePresets = {
  applyDefinitions,
  applyPreset,
  registerStylePreset
};

// node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor.js
var FACE_TO_INDEX = {
  xPlus: 0,
  xMinus: 1,
  yPlus: 2,
  yMinus: 3,
  zPlus: 4,
  zMinus: 5
};
function vtkAnnotatedCubeActor(publicAPI, model) {
  model.classHierarchy.push("vtkAnnotatedCubeActor");
  model.xPlusFaceProperty = {
    ...model.xPlusFaceProperty
  };
  model.xMinusFaceProperty = {
    ...model.xMinusFaceProperty
  };
  model.yPlusFaceProperty = {
    ...model.yPlusFaceProperty
  };
  model.yMinusFaceProperty = {
    ...model.yMinusFaceProperty
  };
  model.zPlusFaceProperty = {
    ...model.zPlusFaceProperty
  };
  model.zMinusFaceProperty = {
    ...model.zMinusFaceProperty
  };
  let cubeSource = null;
  const canvas = document.createElement("canvas");
  const mapper = vtkMapper$1.newInstance();
  const texture = vtkTexture$1.newInstance();
  texture.setInterpolate(true);
  function updateFaceTexture(faceName) {
    let newProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (newProp) {
      Object.assign(model[`${faceName}FaceProperty`], newProp);
    }
    const prop = {
      ...model.defaultStyle,
      ...model[`${faceName}FaceProperty`]
    };
    canvas.width = prop.resolution;
    canvas.height = prop.resolution;
    const ctxt = canvas.getContext("2d");
    ctxt.fillStyle = prop.faceColor;
    ctxt.fillRect(0, 0, canvas.width, canvas.height);
    if (prop.edgeThickness > 0) {
      ctxt.strokeStyle = prop.edgeColor;
      ctxt.lineWidth = prop.edgeThickness * canvas.width;
      ctxt.strokeRect(0, 0, canvas.width, canvas.height);
    }
    ctxt.save();
    ctxt.translate(0, canvas.height);
    ctxt.scale(1, -1);
    ctxt.translate(canvas.width / 2, canvas.height / 2);
    ctxt.rotate(-Math.PI * (prop.faceRotation / 180));
    const textSize = prop.fontSizeScale(prop.resolution);
    ctxt.fillStyle = prop.fontColor;
    ctxt.textAlign = "center";
    ctxt.textBaseline = "middle";
    ctxt.font = `${prop.fontStyle} ${textSize}px "${prop.fontFamily}"`;
    ctxt.fillText(prop.text, 0, 0);
    ctxt.restore();
    const vtkImage = ImageHelper.canvasToImageData(canvas);
    texture.setInputData(vtkImage, FACE_TO_INDEX[faceName]);
    publicAPI.modified();
  }
  function updateAllFaceTextures() {
    cubeSource = vtkCubeSource$1.newInstance({
      generate3DTextureCoordinates: true
    });
    mapper.setInputConnection(cubeSource.getOutputPort());
    updateFaceTexture("xPlus");
    updateFaceTexture("xMinus");
    updateFaceTexture("yPlus");
    updateFaceTexture("yMinus");
    updateFaceTexture("zPlus");
    updateFaceTexture("zMinus");
  }
  publicAPI.setDefaultStyle = (style) => {
    model.defaultStyle = {
      ...model.defaultStyle,
      ...style
    };
    updateAllFaceTextures();
  };
  publicAPI.setXPlusFaceProperty = (prop) => updateFaceTexture("xPlus", prop);
  publicAPI.setXMinusFaceProperty = (prop) => updateFaceTexture("xMinus", prop);
  publicAPI.setYPlusFaceProperty = (prop) => updateFaceTexture("yPlus", prop);
  publicAPI.setYMinusFaceProperty = (prop) => updateFaceTexture("yMinus", prop);
  publicAPI.setZPlusFaceProperty = (prop) => updateFaceTexture("zPlus", prop);
  publicAPI.setZMinusFaceProperty = (prop) => updateFaceTexture("zMinus", prop);
  updateAllFaceTextures();
  mapper.setInputConnection(cubeSource.getOutputPort());
  publicAPI.setMapper(mapper);
  publicAPI.addTexture(texture);
}
var DEFAULT_VALUES3 = {
  defaultStyle: {
    text: "",
    faceColor: "white",
    faceRotation: 0,
    fontFamily: "Arial",
    fontColor: "black",
    fontStyle: "normal",
    fontSizeScale: (resolution) => resolution / 1.8,
    edgeThickness: 0.1,
    edgeColor: "black",
    resolution: 200
  }
  // xPlusFaceProperty: null,
  // xMinusFaceProperty: null,
  // yPlusFaceProperty: null,
  // yMinusFaceProperty: null,
  // zPlusFaceProperty: null,
  // zMinusFaceProperty: null,
};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkActor$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["defaultStyle", "xPlusFaceProperty", "xMinusFaceProperty", "yPlusFaceProperty", "yMinusFaceProperty", "zPlusFaceProperty", "zMinusFaceProperty"]);
  vtkAnnotatedCubeActor(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend4, "vtkAnnotatedCubeActor");
var vtkAnnotatedCubeActor$1 = {
  newInstance: newInstance4,
  extend: extend4,
  Presets: AnnotatedCubePresets
};

// node_modules/@kitware/vtk.js/Filters/General/AppendPolyData.js
var {
  vtkErrorMacro: vtkErrorMacro3
} = macro;
function offsetCellArray(typedArray, offset) {
  let currentIdx = 0;
  return typedArray.map((value, index) => {
    if (index === currentIdx) {
      currentIdx += value + 1;
      return value;
    }
    return value + offset;
  });
}
function appendCellData(dest, src, ptOffset, cellOffset) {
  dest.set(offsetCellArray(src, ptOffset), cellOffset);
}
function vtkAppendPolyData(publicAPI, model) {
  model.classHierarchy.push("vtkAppendPolyData");
  publicAPI.requestData = (inData, outData) => {
    const numberOfInputs = publicAPI.getNumberOfInputPorts();
    if (!numberOfInputs) {
      vtkErrorMacro3("No input specified.");
      return;
    }
    if (numberOfInputs === 1) {
      outData[0] = inData[0];
      return;
    }
    const output = vtkPolyData$1.newInstance();
    let numPts = 0;
    let pointType = 0;
    let ttype = 1;
    let firstType = 1;
    let numVerts = 0;
    let numLines = 0;
    let numStrips = 0;
    let numPolys = 0;
    let hasPtNormals = true;
    let hasPtTCoords = true;
    let hasPtScalars = true;
    for (let i = 0; i < numberOfInputs; i++) {
      const ds = inData[i];
      if (!ds) {
        continue;
      }
      const dsNumPts = ds.getPoints().getNumberOfPoints();
      numPts += dsNumPts;
      numVerts += ds.getVerts().getNumberOfValues();
      numLines += ds.getLines().getNumberOfValues();
      numStrips += ds.getStrips().getNumberOfValues();
      numPolys += ds.getPolys().getNumberOfValues();
      if (dsNumPts) {
        if (firstType) {
          firstType = 0;
          pointType = ds.getPoints().getDataType();
        }
        ttype = ds.getPoints().getDataType();
        pointType = pointType > ttype ? pointType : ttype;
      }
      const ptD = ds.getPointData();
      if (ptD) {
        hasPtNormals = hasPtNormals && ptD.getNormals() !== null;
        hasPtTCoords = hasPtTCoords && ptD.getTCoords() !== null;
        hasPtScalars = hasPtScalars && ptD.getScalars() !== null;
      } else {
        hasPtNormals = false;
        hasPtTCoords = false;
        hasPtScalars = false;
      }
    }
    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {
      pointType = VtkDataTypes.FLOAT;
    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {
      pointType = VtkDataTypes.DOUBLE;
    }
    const points = vtkPoints$1.newInstance({
      dataType: pointType
    });
    points.setNumberOfPoints(numPts);
    const pointData = points.getData();
    const vertData = new Uint32Array(numVerts);
    const lineData = new Uint32Array(numLines);
    const stripData = new Uint32Array(numStrips);
    const polyData = new Uint32Array(numPolys);
    let newPtNormals = null;
    let newPtTCoords = null;
    let newPtScalars = null;
    const lds = inData[numberOfInputs - 1];
    if (hasPtNormals) {
      const dsNormals = lds.getPointData().getNormals();
      newPtNormals = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        numberOfTuples: numPts,
        size: 3 * numPts,
        dataType: dsNormals.getDataType(),
        name: dsNormals.getName()
      });
    }
    if (hasPtTCoords) {
      const dsTCoords = lds.getPointData().getTCoords();
      newPtTCoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        numberOfTuples: numPts,
        size: 2 * numPts,
        dataType: dsTCoords.getDataType(),
        name: dsTCoords.getName()
      });
    }
    if (hasPtScalars) {
      const dsScalars = lds.getPointData().getScalars();
      newPtScalars = vtkDataArray$1.newInstance({
        numberOfComponents: dsScalars.getNumberOfComponents(),
        numberOfTuples: numPts,
        size: numPts * dsScalars.getNumberOfComponents(),
        dataType: dsScalars.getDataType(),
        name: dsScalars.getName()
      });
    }
    numPts = 0;
    numVerts = 0;
    numLines = 0;
    numStrips = 0;
    numPolys = 0;
    for (let i = 0; i < numberOfInputs; i++) {
      const ds = inData[i];
      pointData.set(ds.getPoints().getData(), numPts * 3);
      appendCellData(vertData, ds.getVerts().getData(), numPts, numVerts);
      numVerts += ds.getVerts().getNumberOfValues();
      appendCellData(lineData, ds.getLines().getData(), numPts, numLines);
      numLines += ds.getLines().getNumberOfValues();
      appendCellData(stripData, ds.getStrips().getData(), numPts, numStrips);
      numStrips += ds.getStrips().getNumberOfValues();
      appendCellData(polyData, ds.getPolys().getData(), numPts, numPolys);
      numPolys += ds.getPolys().getNumberOfValues();
      const dsPD = ds.getPointData();
      if (hasPtNormals) {
        const ptNorms = dsPD.getNormals();
        newPtNormals.getData().set(ptNorms.getData(), numPts * 3);
      }
      if (hasPtTCoords) {
        const ptTCoords = dsPD.getTCoords();
        newPtTCoords.getData().set(ptTCoords.getData(), numPts * 2);
      }
      if (hasPtScalars) {
        const ptScalars = dsPD.getScalars();
        newPtScalars.getData().set(ptScalars.getData(), numPts * newPtScalars.getNumberOfComponents());
      }
      numPts += ds.getPoints().getNumberOfPoints();
    }
    output.setPoints(points);
    output.getVerts().setData(vertData);
    output.getLines().setData(lineData);
    output.getStrips().setData(stripData);
    output.getPolys().setData(polyData);
    if (newPtNormals) {
      output.getPointData().setNormals(newPtNormals);
    }
    if (newPtTCoords) {
      output.getPointData().setTCoords(newPtTCoords);
    }
    if (newPtScalars) {
      output.getPointData().setScalars(newPtScalars);
    }
    outData[0] = output;
  };
}
var DEFAULT_VALUES4 = {
  outputPointsPrecision: DesiredOutputPrecision.DEFAULT
};
function extend5(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  macro.setGet(publicAPI, model, ["outputPointsPrecision"]);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  vtkAppendPolyData(publicAPI, model);
}
var newInstance5 = macro.newInstance(extend5, "vtkAppendPolyData");
var vtkAppendPolyData$1 = {
  newInstance: newInstance5,
  extend: extend5
};

// node_modules/@kitware/vtk.js/Filters/Sources/ConeSource.js
function vtkConeSource(publicAPI, model) {
  model.classHierarchy.push("vtkConeSource");
  function requestData(inData, outData) {
    if (model.deleted) {
      return;
    }
    let dataset = outData[0];
    const angle = 2 * Math.PI / model.resolution;
    const xbot = -model.height / 2;
    const numberOfPoints = model.resolution + 1;
    const cellArraySize = 4 * model.resolution + 1 + model.resolution;
    let pointIdx = 0;
    const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    let cellLocation = 0;
    const polys = new Uint32Array(cellArraySize);
    points[0] = model.height / 2;
    points[1] = 0;
    points[2] = 0;
    if (model.capping) {
      polys[cellLocation++] = model.resolution;
    }
    for (let i = 0; i < model.resolution; i++) {
      pointIdx++;
      points[pointIdx * 3 + 0] = xbot;
      points[pointIdx * 3 + 1] = model.radius * Math.cos(i * angle);
      points[pointIdx * 3 + 2] = model.radius * Math.sin(i * angle);
      if (model.capping) {
        polys[model.resolution - cellLocation++ + 1] = pointIdx;
      }
    }
    for (let i = 0; i < model.resolution; i++) {
      polys[cellLocation++] = 3;
      polys[cellLocation++] = 0;
      polys[cellLocation++] = i + 1;
      polys[cellLocation++] = i + 2 > model.resolution ? 1 : i + 2;
    }
    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([1, 0, 0], model.direction).apply(points);
    dataset = vtkPolyData$1.newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1);
    outData[0] = dataset;
  }
  publicAPI.requestData = requestData;
}
var DEFAULT_VALUES5 = {
  height: 1,
  radius: 0.5,
  resolution: 6,
  center: [0, 0, 0],
  direction: [1, 0, 0],
  capping: true,
  pointType: "Float64Array"
};
function extend6(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["height", "radius", "resolution", "capping"]);
  macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkConeSource(publicAPI, model);
}
var newInstance6 = macro.newInstance(extend6, "vtkConeSource");
var vtkConeSource$1 = {
  newInstance: newInstance6,
  extend: extend6
};

// node_modules/@kitware/vtk.js/Filters/Sources/CylinderSource.js
function vtkCylinderSource(publicAPI, model) {
  model.classHierarchy.push("vtkCylinderSource");
  function requestData(inData, outData) {
    if (model.deleted) {
      return;
    }
    let dataset = outData[0];
    const angle = 2 * Math.PI / model.resolution;
    let numberOfPoints = 2 * model.resolution;
    let numberOfPolys = 5 * model.resolution;
    if (model.capping) {
      numberOfPoints = 4 * model.resolution;
      numberOfPolys = 7 * model.resolution + 2;
    }
    const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    let cellLocation = 0;
    const polys = new Uint32Array(numberOfPolys);
    const normalsData = new Float32Array(numberOfPoints * 3);
    const normals = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: normalsData,
      name: "Normals"
    });
    const tcData = new Float32Array(numberOfPoints * 2);
    const tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcData,
      name: "TCoords"
    });
    const nbot = [0, 0, 0];
    const ntop = [0, 0, 0];
    const xbot = [0, 0, 0];
    const xtop = [0, 0, 0];
    const tcbot = [0, 0];
    const tctop = [0, 0];
    const otherRadius = model.otherRadius == null ? model.radius : model.otherRadius;
    for (let i = 0; i < model.resolution; i++) {
      nbot[0] = Math.cos(i * angle + model.initAngle);
      ntop[0] = nbot[0];
      xbot[0] = model.radius * nbot[0] + model.center[0];
      xtop[0] = xbot[0];
      tcbot[0] = Math.abs(2 * i / model.resolution - 1);
      tctop[0] = tcbot[0];
      xbot[1] = 0.5 * model.height + model.center[1];
      xtop[1] = -0.5 * model.height + model.center[1];
      tcbot[1] = 0;
      tctop[1] = 1;
      nbot[2] = -Math.sin(i * angle + model.initAngle);
      ntop[2] = nbot[2];
      xbot[2] = otherRadius * nbot[2] + model.center[2];
      xtop[2] = xbot[2];
      const pointIdx = 2 * i;
      for (let j = 0; j < 3; j++) {
        normalsData[pointIdx * 3 + j] = nbot[j];
        normalsData[(pointIdx + 1) * 3 + j] = ntop[j];
        points[pointIdx * 3 + j] = xbot[j];
        points[(pointIdx + 1) * 3 + j] = xtop[j];
        if (j < 2) {
          tcData[pointIdx * 2 + j] = tcbot[j];
          tcData[(pointIdx + 1) * 2 + j] = tctop[j];
        }
      }
    }
    for (let i = 0; i < model.resolution; i++) {
      polys[cellLocation++] = 4;
      polys[cellLocation++] = 2 * i;
      polys[cellLocation++] = 2 * i + 1;
      const pt = (2 * i + 3) % (2 * model.resolution);
      polys[cellLocation++] = pt;
      polys[cellLocation++] = pt - 1;
    }
    if (model.capping) {
      for (let i = 0; i < model.resolution; i++) {
        xbot[0] = model.radius * Math.cos(i * angle + model.initAngle);
        xtop[0] = xbot[0];
        tcbot[0] = xbot[0];
        tctop[0] = xbot[0];
        xbot[0] += model.center[0];
        xtop[0] += model.center[0];
        nbot[1] = 1;
        ntop[1] = -1;
        xbot[1] = 0.5 * model.height + model.center[1];
        xtop[1] = -0.5 * model.height + model.center[1];
        xbot[2] = -otherRadius * Math.sin(i * angle + model.initAngle);
        xtop[2] = xbot[2];
        tcbot[1] = xbot[2];
        tctop[1] = xbot[2];
        xbot[2] += model.center[2];
        xtop[2] += model.center[2];
        const botIdx = 2 * model.resolution + i;
        const topIdx = 3 * model.resolution + model.resolution - i - 1;
        for (let j = 0; j < 3; j++) {
          normalsData[3 * botIdx + j] = nbot[j];
          normalsData[3 * topIdx + j] = ntop[j];
          points[3 * botIdx + j] = xbot[j];
          points[3 * topIdx + j] = xtop[j];
          if (j < 2) {
            tcData[2 * botIdx + j] = tcbot[j];
            tcData[2 * topIdx + j] = tctop[j];
          }
        }
      }
      polys[cellLocation++] = model.resolution;
      for (let i = 0; i < model.resolution; i++) {
        polys[cellLocation++] = 2 * model.resolution + i;
      }
      polys[cellLocation++] = model.resolution;
      for (let i = 0; i < model.resolution; i++) {
        polys[cellLocation++] = 3 * model.resolution + i;
      }
    }
    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([0, 1, 0], model.direction).translate(...model.center.map((c) => c * -1)).apply(points);
    dataset = vtkPolyData$1.newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1);
    dataset.getPointData().setNormals(normals);
    dataset.getPointData().setTCoords(tcoords);
    outData[0] = dataset;
  }
  publicAPI.requestData = requestData;
}
var DEFAULT_VALUES6 = {
  height: 1,
  initAngle: 0,
  radius: 1,
  resolution: 6,
  center: [0, 0, 0],
  direction: [0, 1, 0],
  capping: true,
  pointType: "Float64Array"
};
function extend7(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["height", "initAngle", "otherRadius", "radius", "resolution", "capping"]);
  macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkCylinderSource(publicAPI, model);
}
var newInstance7 = macro.newInstance(extend7, "vtkCylinderSource");
var vtkCylinderSource$1 = {
  newInstance: newInstance7,
  extend: extend7
};

// node_modules/@kitware/vtk.js/Filters/Sources/ArrowSource.js
function vtkArrowSource(publicAPI, model) {
  model.classHierarchy.push("vtkArrowSource");
  function requestData(inData, outData) {
    if (model.deleted) {
      return;
    }
    const cylinder = vtkCylinderSource$1.newInstance({
      capping: true
    });
    cylinder.setResolution(model.shaftResolution);
    cylinder.setRadius(model.shaftRadius);
    cylinder.setHeight(1 - model.tipLength);
    cylinder.setCenter(0, (1 - model.tipLength) * 0.5, 0);
    const cylinderPD = cylinder.getOutputData();
    const cylinderPts = cylinderPD.getPoints().getData();
    const cylinderNormals = cylinderPD.getPointData().getNormals().getData();
    vtkMatrixBuilder.buildFromDegree().rotateZ(-90).apply(cylinderPts).apply(cylinderNormals);
    const cone = vtkConeSource$1.newInstance();
    cone.setResolution(model.tipResolution);
    cone.setHeight(model.tipLength);
    cone.setRadius(model.tipRadius);
    const conePD = cone.getOutputData();
    const conePts = conePD.getPoints().getData();
    vtkMatrixBuilder.buildFromRadian().translate(1 - model.tipLength * 0.5, 0, 0).apply(conePts);
    const append = vtkAppendPolyData$1.newInstance();
    append.setInputData(cylinderPD);
    append.addInputData(conePD);
    const appendPD = append.getOutputData();
    const appendPts = appendPD.getPoints().getData();
    vtkMatrixBuilder.buildFromRadian().translate(-0.5 + model.tipLength * 0.5, 0, 0).apply(appendPts);
    if (model.invert) {
      vtkMatrixBuilder.buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(-1, -1, -1).apply(appendPts);
      outData[0] = appendPD;
    } else {
      vtkMatrixBuilder.buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(1, 1, 1).apply(appendPts);
      outData[0] = append.getOutputData();
    }
  }
  publicAPI.requestData = requestData;
}
var DEFAULT_VALUES7 = {
  tipResolution: 6,
  tipRadius: 0.1,
  tipLength: 0.35,
  shaftResolution: 6,
  shaftRadius: 0.03,
  invert: false,
  direction: [1, 0, 0],
  pointType: "Float64Array"
};
function extend8(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["tipResolution", "tipRadius", "tipLength", "shaftResolution", "shaftRadius", "invert"]);
  macro.setGetArray(publicAPI, model, ["direction"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkArrowSource(publicAPI, model);
}
var newInstance8 = macro.newInstance(extend8, "vtkArrowSource");
var vtkArrowSource$1 = {
  newInstance: newInstance8,
  extend: extend8
};

// node_modules/@kitware/vtk.js/Rendering/Core/AxesActor.js
function centerDataSet(ds) {
  const bounds = ds.getPoints().getBounds();
  const center = [-(bounds[0] + bounds[1]) * 0.5, -(bounds[2] + bounds[3]) * 0.5, -(bounds[4] + bounds[5]) * 0.5];
  vtkMatrixBuilder.buildFromDegree().translate(...center).apply(ds.getPoints().getData());
}
function shiftDataset(ds, axis) {
  let invert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const bounds = ds.getPoints().getBounds();
  const center = [0, 0, 0];
  if (invert) {
    center[axis] = -bounds[axis * 2 + 1];
  } else {
    center[axis] = -bounds[axis * 2];
  }
  vtkMatrixBuilder.buildFromDegree().translate(...center).apply(ds.getPoints().getData());
}
function addColor(ds, r, g, b) {
  const size = ds.getPoints().getData().length;
  const rgbArray = new Uint8ClampedArray(size);
  let offset = 0;
  while (offset < size) {
    rgbArray[offset++] = r;
    rgbArray[offset++] = g;
    rgbArray[offset++] = b;
  }
  ds.getPointData().setScalars(vtkDataArray$1.newInstance({
    name: "color",
    numberOfComponents: 3,
    values: rgbArray
  }));
}
function vtkAxesActor(publicAPI, model) {
  model.classHierarchy.push("vtkAxesActor");
  const _mapper = vtkMapper$1.newInstance();
  publicAPI.setMapper(_mapper);
  publicAPI.update = () => {
    let currentConfig = {
      ...model.config,
      ...model.xConfig
    };
    const xAxis = vtkArrowSource$1.newInstance({
      direction: [1, 0, 0],
      ...currentConfig
    }).getOutputData();
    if (model.config.recenter) {
      centerDataSet(xAxis);
    } else {
      shiftDataset(xAxis, 0, currentConfig.invert);
    }
    addColor(xAxis, ...currentConfig.color);
    currentConfig = {
      ...model.config,
      ...model.yConfig
    };
    const yAxis = vtkArrowSource$1.newInstance({
      direction: [0, 1, 0],
      ...currentConfig
    }).getOutputData();
    if (model.config.recenter) {
      centerDataSet(yAxis);
    } else {
      shiftDataset(yAxis, 1, currentConfig.invert);
    }
    addColor(yAxis, ...currentConfig.color);
    currentConfig = {
      ...model.config,
      ...model.zConfig
    };
    const zAxis = vtkArrowSource$1.newInstance({
      direction: [0, 0, 1],
      ...currentConfig
    }).getOutputData();
    if (model.config.recenter) {
      centerDataSet(zAxis);
    } else {
      shiftDataset(zAxis, 2, currentConfig.invert);
    }
    addColor(zAxis, ...currentConfig.color);
    const source = vtkAppendPolyData$1.newInstance();
    source.setInputData(xAxis);
    source.addInputData(yAxis);
    source.addInputData(zAxis);
    _mapper.setInputConnection(source.getOutputPort());
  };
  publicAPI.update();
  const _debouncedUpdate = macro.debounce(publicAPI.update, 0);
  publicAPI.setXAxisColor = (color) => publicAPI.setXConfig({
    ...publicAPI.getXConfig(),
    color
  });
  publicAPI.setYAxisColor = (color) => publicAPI.setYConfig({
    ...publicAPI.getYConfig(),
    color
  });
  publicAPI.setZAxisColor = (color) => publicAPI.setZConfig({
    ...publicAPI.getZConfig(),
    color
  });
  publicAPI.getXAxisColor = () => model.getXConfig().color;
  publicAPI.getYAxisColor = () => model.getYConfig().color;
  publicAPI.getZAxisColor = () => model.getZConfig().color;
  model._onConfigChanged = _debouncedUpdate;
  model._onXConfigChanged = _debouncedUpdate;
  model._onYConfigChanged = _debouncedUpdate;
  model._onZConfigChanged = _debouncedUpdate;
}
function defaultValues(initialValues) {
  return {
    config: {
      recenter: true,
      tipResolution: 60,
      tipRadius: 0.1,
      tipLength: 0.2,
      shaftResolution: 60,
      shaftRadius: 0.03,
      invert: false,
      ...initialValues == null ? void 0 : initialValues.config
    },
    xConfig: {
      color: [255, 0, 0],
      invert: false,
      ...initialValues == null ? void 0 : initialValues.xConfig
    },
    yConfig: {
      color: [255, 255, 0],
      invert: false,
      ...initialValues == null ? void 0 : initialValues.yConfig
    },
    zConfig: {
      color: [0, 128, 0],
      invert: false,
      ...initialValues == null ? void 0 : initialValues.zConfig
    }
  };
}
function extend9(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkActor$1.extend(publicAPI, model, defaultValues(initialValues));
  macro.setGet(publicAPI, model, ["config", "xConfig", "yConfig", "zConfig"]);
  vtkAxesActor(publicAPI, model);
}
var newInstance9 = macro.newInstance(extend9, "vtkAxesActor");
var vtkAxesActor$1 = {
  newInstance: newInstance9,
  extend: extend9
};

// node_modules/@kitware/vtk.js/IO/XML/XMLReader.js
var import_xmlbuilder2 = __toESM(require_xmlbuilder2_min());

// node_modules/fflate/esm/browser.js
var ch2 = {};
var wk = function(c, id, msg, transfer, cb) {
  var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
    c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
  ], { type: "text/javascript" }))));
  w.onmessage = function(e) {
    var d = e.data, ed = d.$e$;
    if (ed) {
      var err2 = new Error(ed[0]);
      err2["code"] = ed[1];
      err2.stack = ed[2];
      cb(err2, null);
    } else
      cb(null, d);
  };
  w.postMessage(msg, transfer);
  return w;
};
var u8 = Uint8Array;
var u16 = Uint16Array;
var u32 = Uint32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new u32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return [b, r];
};
var _a = freb(fleb, 2);
var fl = _a[0];
var revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b[0];
var revfd = _b[1];
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >>> 1 | (i & 21845) << 1;
  x = (x & 52428) >>> 2 | (x & 13107) << 2;
  x = (x & 61680) >>> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >>> 8 | (x & 255) << 8) >>> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 0; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flm = hMap(flt, 9, 0);
var flrm = hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
var fdrm = hMap(fdt, 5, 1);
var max = function(a) {
  var m = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);
  n.set(v.subarray(s, e));
  return n;
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, buf, st) {
  var sl = dat.length;
  if (!sl || st && st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf || st;
  var noSt = !st || st.i;
  if (!st)
    st = {};
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (noBuf)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >>> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (noBuf)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (noBuf)
          cbuf(bt + 131072);
        var end = bt + add;
        for (; bt < end; bt += 4) {
          buf[bt] = buf[bt - dt];
          buf[bt + 1] = buf[bt + 1 - dt];
          buf[bt + 2] = buf[bt + 2 - dt];
          buf[bt + 3] = buf[bt + 3 - dt];
        }
        bt = end;
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt == buf.length ? buf : slc(buf, 0, bt);
};
var wbits = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
};
var wbits16 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
  d[o + 2] |= v >>> 16;
};
var hTree = function(d, mb) {
  var t = [];
  for (var i = 0; i < d.length; ++i) {
    if (d[i])
      t.push({ s: i, f: d[i] });
  }
  var s = t.length;
  var t2 = t.slice();
  if (!s)
    return [et, 0];
  if (s == 1) {
    var v = new u8(t[0].s + 1);
    v[t[0].s] = 1;
    return [v, 1];
  }
  t.sort(function(a, b) {
    return a.f - b.f;
  });
  t.push({ s: -1, f: 25001 });
  var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
  t[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t[t[i0].f < t[i2].f ? i0++ : i2++];
    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
    t[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t2[0].s;
  for (var i = 1; i < s; ++i) {
    if (t2[i].s > maxSym)
      maxSym = t2[i].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t2.sort(function(a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });
    for (; i < s; ++i) {
      var i2_1 = t2[i].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>>= lft;
    while (dt > 0) {
      var i2_2 = t2[i].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i;
    }
    for (; i >= 0 && dt; --i) {
      var i2_3 = t2[i].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return [new u8(tr), mbt];
};
var ln = function(n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
var lc = function(c) {
  var s = c.length;
  while (s && !c[--s])
    ;
  var cl = new u16(++s);
  var cli = 0, cln = c[0], cls = 1;
  var w = function(v) {
    cl[cli++] = v;
  };
  for (var i = 1; i <= s; ++i) {
    if (c[i] == cln && i != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c[i];
    }
  }
  return [cl.subarray(0, cli), s];
};
var clen = function(cf, cl) {
  var l = 0;
  for (var i = 0; i < cl.length; ++i)
    l += cf[i] * cl[i];
  return l;
};
var wfblk = function(out, pos, dat) {
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >>> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i = 0; i < s; ++i)
    out[o + i + 4] = dat[i];
  return (o + 4 + s) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];
  var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u16(19);
  for (var i = 0; i < lclt.length; ++i)
    lcfreq[lclt[i] & 31]++;
  for (var i = 0; i < lcdt.length; ++i)
    lcfreq[lcdt[i] & 31]++;
  var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i = 0; i < nlcc; ++i)
      wbits(out, p + 3 * i, lct[clim[i]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i = 0; i < clct.length; ++i) {
        var len = clct[i] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i = 0; i < li; ++i) {
    if (syms[i] > 255) {
      var len = syms[i] >>> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];
      var dst = syms[i] & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, lst) {
  var s = dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
  var w = o.subarray(pre, o.length - post);
  var pos = 0;
  if (!lvl || s < 8) {
    for (var i = 0; i <= s; i += 65535) {
      var e = i + 65535;
      if (e >= s) {
        w[pos >> 3] = lst;
      }
      pos = wfblk(w, pos + 1, dat.subarray(i, e));
    }
  } else {
    var opt = deo[lvl - 1];
    var n = opt >>> 13, c = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = new u16(32768), head = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i2) {
      return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
    };
    var syms = new u32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;
    for (; i < s; ++i) {
      var hv = hsh(i);
      var imod = i & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i) {
        var rem = s - i;
        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
          li = lc_1 = eb = 0, bs = i;
          for (var j = 0; j < 286; ++j)
            lf[j] = 0;
          for (var j = 0; j < 30; ++j)
            df[j] = 0;
        }
        var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i + l] == dat[i + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0; j < mmd; ++j) {
                  var ti = i - dif + j + 32768 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
      }
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
    if (!lst && pos & 7)
      pos = wfblk(w, pos + 1, et);
  }
  return slc(o, 0, pre + shft(pos) + post);
};
var crct = function() {
  var t = new Int32Array(256);
  for (var i = 0; i < 256; ++i) {
    var c = i, k = 9;
    while (--k)
      c = (c & 1 && -306674912) ^ c >>> 1;
    t[i] = c;
  }
  return t;
}();
var crc = function() {
  var c = -1;
  return {
    p: function(d) {
      var cr = c;
      for (var i = 0; i < d.length; ++i)
        cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
      c = cr;
    },
    d: function() {
      return ~c;
    }
  };
};
var adler = function() {
  var a = 1, b = 0;
  return {
    p: function(d) {
      var n = a, m = b;
      var l = d.length | 0;
      for (var i = 0; i != l; ) {
        var e = Math.min(i + 2655, l);
        for (; i < e; ++i)
          m += n += d[i];
        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
      }
      a = n, b = m;
    },
    d: function() {
      a %= 65521, b %= 65521;
      return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post, st) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);
};
var mrg = function(a, b) {
  var o = {};
  for (var k in a)
    o[k] = a[k];
  for (var k in b)
    o[k] = b[k];
  return o;
};
var wcln = function(fn, fnStr, td2) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
  for (var i = 0; i < dt.length; ++i) {
    var v = dt[i], k = ks[i];
    if (typeof v == "function") {
      fnStr += ";" + k + "=";
      var st_1 = v.toString();
      if (v.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t in v.prototype)
            fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
        }
      } else
        fnStr += st_1;
    } else
      td2[k] = v;
  }
  return [fnStr, td2];
};
var ch = [];
var cbfs = function(v) {
  var tl = [];
  for (var k in v) {
    if (v[k].buffer) {
      tl.push((v[k] = new v[k].constructor(v[k])).buffer);
    }
  }
  return tl;
};
var wrkr = function(fns, init2, id, cb) {
  var _a2;
  if (!ch[id]) {
    var fnStr = "", td_1 = {}, m = fns.length - 1;
    for (var i = 0; i < m; ++i)
      _a2 = wcln(fns[i], fnStr, td_1), fnStr = _a2[0], td_1 = _a2[1];
    ch[id] = wcln(fns[m], fnStr, td_1);
  }
  var td2 = mrg({}, ch[id][1]);
  return wk(ch[id][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init2.toString() + "}", id, td2, cbfs(td2), cb);
};
var bInflt = function() {
  return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8];
};
var bDflt = function() {
  return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
};
var guze = function() {
  return [gzs, gzl];
};
var zule = function() {
  return [zlv];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gu8 = function(o) {
  return o && o.size && new u8(o.size);
};
var astrm = function(strm) {
  strm.ondata = function(dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };
  return function(ev) {
    return strm.push(ev.data[0], ev.data[1]);
  };
};
var astrmify = function(fns, strm, opts, init2, id) {
  var t;
  var w = wrkr(fns, init2, id, function(err2, dat) {
    if (err2)
      w.terminate(), strm.ondata.call(strm, err2);
    else {
      if (dat[1])
        w.terminate();
      strm.ondata.call(strm, err2, dat[0], dat[1]);
    }
  });
  w.postMessage(opts);
  strm.push = function(d, f) {
    if (!strm.ondata)
      err(5);
    if (t)
      strm.ondata(err(4, 0, 1), null, !!f);
    w.postMessage([d, t = f], [d.buffer]);
  };
  strm.terminate = function() {
    w.terminate();
  };
};
var b2 = function(d, b) {
  return d[b] | d[b + 1] << 8;
};
var b4 = function(d, b) {
  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function(d, b) {
  return b4(d, b) + b4(d, b + 4) * 4294967296;
};
var wbytes = function(d, b, v) {
  for (; v; ++b)
    d[b] = v, v >>>= 8;
};
var gzh = function(c, o) {
  var fn = o.filename;
  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
  if (o.mtime != 0)
    wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
  if (fn) {
    c[3] = 8;
    for (var i = 0; i <= fn.length; ++i)
      c[i + 10] = fn.charCodeAt(i);
  }
};
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += d[10] | (d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var gzhl = function(o) {
  return 10 + (o.filename && o.filename.length + 1 || 0);
};
var zlh = function(c, o) {
  var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c[0] = 120, c[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
};
var zlv = function(d) {
  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if (d[1] & 32)
    err(6, "invalid zlib data: preset dictionaries not supported");
};
function AsyncCmpStrm(opts, cb) {
  if (!cb && typeof opts == "function")
    cb = opts, opts = {};
  this.ondata = cb;
  return opts;
}
var Deflate = function() {
  function Deflate2(opts, cb) {
    if (!cb && typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    this.o = opts || {};
  }
  Deflate2.prototype.p = function(c, f) {
    this.ondata(dopt(c, this.o, 0, 0, !f), f);
  };
  Deflate2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    this.d = final;
    this.p(chunk, final || false);
  };
  return Deflate2;
}();
var AsyncDeflate = /* @__PURE__ */ function() {
  function AsyncDeflate2(opts, cb) {
    astrmify([
      bDflt,
      function() {
        return [astrm, Deflate];
      }
    ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6);
  }
  return AsyncDeflate2;
}();
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
var Inflate = function() {
  function Inflate2(cb) {
    this.s = {};
    this.p = new u8(0);
    this.ondata = cb;
  }
  Inflate2.prototype.e = function(c) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    var l = this.p.length;
    var n = new u8(l + c.length);
    n.set(this.p), n.set(c, l), this.p = n;
  };
  Inflate2.prototype.c = function(final) {
    this.d = this.s.i = final || false;
    var bts = this.s.b;
    var dt = inflt(this.p, this.o, this.s);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate2;
}();
var AsyncInflate = /* @__PURE__ */ function() {
  function AsyncInflate2(cb) {
    this.ondata = cb;
    astrmify([
      bInflt,
      function() {
        return [astrm, Inflate];
      }
    ], this, 0, function() {
      var strm = new Inflate();
      onmessage = astrm(strm);
    }, 7);
  }
  return AsyncInflate2;
}();
function inflateSync(data, out) {
  return inflt(data, out);
}
var Gzip = function() {
  function Gzip2(opts, cb) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Gzip2.prototype.push = function(chunk, final) {
    Deflate.prototype.push.call(this, chunk, final);
  };
  Gzip2.prototype.p = function(c, f) {
    this.c.p(c);
    this.l += c.length;
    var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);
    if (this.v)
      gzh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f);
  };
  return Gzip2;
}();
var Gunzip = function() {
  function Gunzip2(cb) {
    this.v = 1;
    Inflate.call(this, cb);
  }
  Gunzip2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    if (this.v) {
      var s = this.p.length > 3 ? gzs(this.p) : 4;
      if (s >= this.p.length && !final)
        return;
      this.p = this.p.subarray(s), this.v = 0;
    }
    if (final) {
      if (this.p.length < 8)
        err(6, "invalid gzip data");
      this.p = this.p.subarray(0, -8);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Gunzip2;
}();
var AsyncGunzip = /* @__PURE__ */ function() {
  function AsyncGunzip2(cb) {
    this.ondata = cb;
    astrmify([
      bInflt,
      guze,
      function() {
        return [astrm, Inflate, Gunzip];
      }
    ], this, 0, function() {
      var strm = new Gunzip();
      onmessage = astrm(strm);
    }, 9);
  }
  return AsyncGunzip2;
}();
function gunzipSync(data, out) {
  return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));
}
var Zlib = function() {
  function Zlib2(opts, cb) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Zlib2.prototype.push = function(chunk, final) {
    Deflate.prototype.push.call(this, chunk, final);
  };
  Zlib2.prototype.p = function(c, f) {
    this.c.p(c);
    var raw = dopt(c, this.o, this.v && 2, f && 4, !f);
    if (this.v)
      zlh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f);
  };
  return Zlib2;
}();
var Unzlib = function() {
  function Unzlib2(cb) {
    this.v = 1;
    Inflate.call(this, cb);
  }
  Unzlib2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    if (this.v) {
      if (this.p.length < 2 && !final)
        return;
      this.p = this.p.subarray(2), this.v = 0;
    }
    if (final) {
      if (this.p.length < 4)
        err(6, "invalid zlib data");
      this.p = this.p.subarray(0, -4);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Unzlib2;
}();
var AsyncUnzlib = /* @__PURE__ */ function() {
  function AsyncUnzlib2(cb) {
    this.ondata = cb;
    astrmify([
      bInflt,
      zule,
      function() {
        return [astrm, Inflate, Unzlib];
      }
    ], this, 0, function() {
      var strm = new Unzlib();
      onmessage = astrm(strm);
    }, 11);
  }
  return AsyncUnzlib2;
}();
function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
}
var Decompress = function() {
  function Decompress2(cb) {
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
    this.ondata = cb;
  }
  Decompress2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (!this.s) {
      if (this.p && this.p.length) {
        var n = new u8(this.p.length + chunk.length);
        n.set(this.p), n.set(chunk, this.p.length);
      } else
        this.p = chunk;
      if (this.p.length > 2) {
        var _this_1 = this;
        var cb = function() {
          _this_1.ondata.apply(_this_1, arguments);
        };
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);
        this.s.push(this.p, final);
        this.p = null;
      }
    } else
      this.s.push(chunk, final);
  };
  return Decompress2;
}();
var AsyncDecompress = function() {
  function AsyncDecompress2(cb) {
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
    this.ondata = cb;
  }
  AsyncDecompress2.prototype.push = function(chunk, final) {
    Decompress.prototype.push.call(this, chunk, final);
  };
  return AsyncDecompress2;
}();
function decompressSync(data, out) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);
}
var te = typeof TextEncoder != "undefined" && new TextEncoder();
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
var dutf8 = function(d) {
  for (var r = "", i = 0; ; ) {
    var c = d[i++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i + eb > d.length)
      return [r, slc(d, i - 1)];
    if (!eb)
      r += String.fromCharCode(c);
    else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
    else
      r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
  }
};
var DecodeUTF8 = function() {
  function DecodeUTF82(cb) {
    this.ondata = cb;
    if (tds)
      this.t = new TextDecoder();
    else
      this.p = et;
  }
  DecodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    final = !!final;
    if (this.t) {
      this.ondata(this.t.decode(chunk, { stream: true }), final);
      if (final) {
        if (this.t.decode().length)
          err(8);
        this.t = null;
      }
      return;
    }
    if (!this.p)
      err(4);
    var dat = new u8(this.p.length + chunk.length);
    dat.set(this.p);
    dat.set(chunk, this.p.length);
    var _a2 = dutf8(dat), ch3 = _a2[0], np = _a2[1];
    if (final) {
      if (np.length)
        err(8);
      this.p = null;
    } else
      this.p = np;
    this.ondata(ch3, final);
  };
  return DecodeUTF82;
}();
var EncodeUTF8 = function() {
  function EncodeUTF82(cb) {
    this.ondata = cb;
  }
  EncodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    this.ondata(strToU8(chunk), this.d = final || false);
  };
  return EncodeUTF82;
}();
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i = 0; i < str.length; ++i)
      ar_1[i] = str.charCodeAt(i);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v) {
    ar[ai++] = v;
  };
  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i << 1));
      n.set(ar);
      ar = n;
    }
    var c = str.charCodeAt(i);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i = 0; i < dat.length; i += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
    return r;
  } else if (td)
    return td.decode(dat);
  else {
    var _a2 = dutf8(dat), out = _a2[0], ext = _a2[1];
    if (ext.length)
      err(8);
    return out;
  }
}
var dbf = function(l) {
  return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
var z64e = function(d, b) {
  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
    ;
  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
};
var exfl = function(ex) {
  var le = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535)
        err(9);
      le += l + 4;
    }
  }
  return le;
};
var wzh = function(d, b, f, fn, u, c, ce, co) {
  var fl2 = fn.length, ex = f.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
  if (ce != null)
    d[b++] = 20, d[b++] = f.os;
  d[b] = 20, b += 2;
  d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;
  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119)
    err(10);
  wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;
  if (c != null) {
    wbytes(d, b, f.crc);
    wbytes(d, b + 4, c);
    wbytes(d, b + 8, f.size);
  }
  wbytes(d, b + 12, fl2);
  wbytes(d, b + 14, exl), b += 16;
  if (ce != null) {
    wbytes(d, b, col);
    wbytes(d, b + 6, f.attrs);
    wbytes(d, b + 10, ce), b += 14;
  }
  d.set(fn, b);
  b += fl2;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes(d, b, +k);
      wbytes(d, b + 2, l);
      d.set(exf, b + 4), b += 4 + l;
    }
  }
  if (col)
    d.set(co, b), b += col;
  return b;
};
var wzf = function(o, b, c, d, e) {
  wbytes(o, b, 101010256);
  wbytes(o, b + 8, c);
  wbytes(o, b + 10, c);
  wbytes(o, b + 12, d);
  wbytes(o, b + 16, e);
};
var ZipPassThrough = function() {
  function ZipPassThrough2(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  ZipPassThrough2.prototype.process = function(chunk, final) {
    this.ondata(null, chunk, final);
  };
  ZipPassThrough2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    this.c.p(chunk);
    this.size += chunk.length;
    if (final)
      this.crc = this.c.d();
    this.process(chunk, final || false);
  };
  return ZipPassThrough2;
}();
var ZipDeflate = function() {
  function ZipDeflate2(filename, opts) {
    var _this_1 = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function(dat, final) {
      _this_1.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }
  ZipDeflate2.prototype.process = function(chunk, final) {
    try {
      this.d.push(chunk, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  ZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return ZipDeflate2;
}();
var AsyncZipDeflate = function() {
  function AsyncZipDeflate2(filename, opts) {
    var _this_1 = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function(err2, dat, final) {
      _this_1.ondata(err2, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }
  AsyncZipDeflate2.prototype.process = function(chunk, final) {
    this.d.push(chunk, final);
  };
  AsyncZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return AsyncZipDeflate2;
}();
var Zip = function() {
  function Zip2(cb) {
    this.ondata = cb;
    this.u = [];
    this.d = 1;
  }
  Zip2.prototype.add = function(file) {
    var _this_1 = this;
    if (!this.ondata)
      err(5);
    if (this.d & 2)
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
    else {
      var f = strToU8(file.filename), fl_1 = f.length;
      var com = file.comment, o = com && strToU8(com);
      var u = fl_1 != file.filename.length || o && com.length != o.length;
      var hl_1 = fl_1 + exfl(file.extra) + 30;
      if (fl_1 > 65535)
        this.ondata(err(11, 0, 1), null, false);
      var header = new u8(hl_1);
      wzh(header, 0, file, f, u);
      var chks_1 = [header];
      var pAll_1 = function() {
        for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
          var chk = chks_2[_i];
          _this_1.ondata(null, chk, false);
        }
        chks_1 = [];
      };
      var tr_1 = this.d;
      this.d = 0;
      var ind_1 = this.u.length;
      var uf_1 = mrg(file, {
        f,
        u,
        o,
        t: function() {
          if (file.terminate)
            file.terminate();
        },
        r: function() {
          pAll_1();
          if (tr_1) {
            var nxt = _this_1.u[ind_1 + 1];
            if (nxt)
              nxt.r();
            else
              _this_1.d = 1;
          }
          tr_1 = 1;
        }
      });
      var cl_1 = 0;
      file.ondata = function(err2, dat, final) {
        if (err2) {
          _this_1.ondata(err2, dat, final);
          _this_1.terminate();
        } else {
          cl_1 += dat.length;
          chks_1.push(dat);
          if (final) {
            var dd = new u8(16);
            wbytes(dd, 0, 134695760);
            wbytes(dd, 4, file.crc);
            wbytes(dd, 8, cl_1);
            wbytes(dd, 12, file.size);
            chks_1.push(dd);
            uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
            if (tr_1)
              uf_1.r();
            tr_1 = 1;
          } else if (tr_1)
            pAll_1();
        }
      };
      this.u.push(uf_1);
    }
  };
  Zip2.prototype.end = function() {
    var _this_1 = this;
    if (this.d & 2) {
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
      return;
    }
    if (this.d)
      this.e();
    else
      this.u.push({
        r: function() {
          if (!(_this_1.d & 1))
            return;
          _this_1.u.splice(-1, 1);
          _this_1.e();
        },
        t: function() {
        }
      });
    this.d = 3;
  };
  Zip2.prototype.e = function() {
    var bt = 0, l = 0, tl = 0;
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f = _a2[_i];
      tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
    }
    var out = new u8(tl + 22);
    for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
      var f = _c[_b2];
      wzh(out, bt, f, f.f, f.u, f.c, l, f.o);
      bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
    }
    wzf(out, bt, this.u.length, tl, l);
    this.ondata(null, out, true);
    this.d = 2;
  };
  Zip2.prototype.terminate = function() {
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f = _a2[_i];
      f.t();
    }
    this.d = 2;
  };
  return Zip2;
}();
var UnzipPassThrough = function() {
  function UnzipPassThrough2() {
  }
  UnzipPassThrough2.prototype.push = function(data, final) {
    this.ondata(null, data, final);
  };
  UnzipPassThrough2.compression = 0;
  return UnzipPassThrough2;
}();
var UnzipInflate = function() {
  function UnzipInflate2() {
    var _this_1 = this;
    this.i = new Inflate(function(dat, final) {
      _this_1.ondata(null, dat, final);
    });
  }
  UnzipInflate2.prototype.push = function(data, final) {
    try {
      this.i.push(data, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  UnzipInflate2.compression = 8;
  return UnzipInflate2;
}();
var AsyncUnzipInflate = function() {
  function AsyncUnzipInflate2(_, sz) {
    var _this_1 = this;
    if (sz < 32e4) {
      this.i = new Inflate(function(dat, final) {
        _this_1.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function(err2, dat, final) {
        _this_1.ondata(err2, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }
  AsyncUnzipInflate2.prototype.push = function(data, final) {
    if (this.i.terminate)
      data = slc(data, 0);
    this.i.push(data, final);
  };
  AsyncUnzipInflate2.compression = 8;
  return AsyncUnzipInflate2;
}();
var Unzip = function() {
  function Unzip2(cb) {
    this.onfile = cb;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  Unzip2.prototype.push = function(chunk, final) {
    var _this_1 = this;
    if (!this.onfile)
      err(5);
    if (!this.p)
      err(4);
    if (this.c > 0) {
      var len = Math.min(this.c, chunk.length);
      var toAdd = chunk.subarray(0, len);
      this.c -= len;
      if (this.d)
        this.d.push(toAdd, !this.c);
      else
        this.k[0].push(toAdd);
      chunk = chunk.subarray(len);
      if (chunk.length)
        return this.push(chunk, final);
    } else {
      var f = 0, i = 0, is = void 0, buf = void 0;
      if (!this.p.length)
        buf = chunk;
      else if (!chunk.length)
        buf = this.p;
      else {
        buf = new u8(this.p.length + chunk.length);
        buf.set(this.p), buf.set(chunk, this.p.length);
      }
      var l = buf.length, oc = this.c, add = oc && this.d;
      var _loop_2 = function() {
        var _a2;
        var sig = b4(buf, i);
        if (sig == 67324752) {
          f = 1, is = i;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
          if (l > i + 30 + fnl + es) {
            var chks_3 = [];
            this_1.k.unshift(chks_3);
            f = 2;
            var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
            var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
            if (sc_1 == 4294967295) {
              _a2 = dd ? [-2] : z64e(buf, i), sc_1 = _a2[0], su_1 = _a2[1];
            } else if (dd)
              sc_1 = -1;
            i += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function() {
                if (!file_1.ondata)
                  err(5);
                if (!sc_1)
                  file_1.ondata(null, et, true);
                else {
                  var ctr = _this_1.o[cmp_1];
                  if (!ctr)
                    file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                  d_1.ondata = function(err2, dat3, final2) {
                    file_1.ondata(err2, dat3, final2);
                  };
                  for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                    var dat2 = chks_4[_i];
                    d_1.push(dat2, false);
                  }
                  if (_this_1.k[0] == chks_3 && _this_1.c)
                    _this_1.d = d_1;
                  else
                    d_1.push(et, true);
                }
              },
              terminate: function() {
                if (d_1 && d_1.terminate)
                  d_1.terminate();
              }
            };
            if (sc_1 >= 0)
              file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }
          return "break";
        } else if (oc) {
          if (sig == 134695760) {
            is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
            return "break";
          } else if (sig == 33639248) {
            is = i -= 4, f = 3, this_1.c = 0;
            return "break";
          }
        }
      };
      var this_1 = this;
      for (; i < l - 4; ++i) {
        var state_1 = _loop_2();
        if (state_1 === "break")
          break;
      }
      this.p = et;
      if (oc < 0) {
        var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i);
        if (add)
          add.push(dat, !!f);
        else
          this.k[+(f == 2)].push(dat);
      }
      if (f & 2)
        return this.push(buf.subarray(i), final);
      this.p = buf.subarray(i);
    }
    if (final) {
      if (this.c)
        err(13);
      this.p = null;
    }
  };
  Unzip2.prototype.register = function(decoder) {
    this.o[decoder.compression] = decoder;
  };
  return Unzip2;
}();

// node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper.js
var TYPE_MAPPING = {};
function has(type) {
  return !!TYPE_MAPPING[type];
}
function get2() {
  let type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "http";
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return TYPE_MAPPING[type](options);
}
function registerType(type, fn) {
  TYPE_MAPPING[type] = fn;
}
var DataAccessHelper = {
  get: get2,
  has,
  registerType
};

// node_modules/@kitware/vtk.js/Common/Core/Base64.js
var REVERSE_LOOKUP = [];
REVERSE_LOOKUP["-".charCodeAt(0)] = 62;
REVERSE_LOOKUP["_".charCodeAt(0)] = 63;
var BASE64_CODE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (let i = 0; i < BASE64_CODE.length; i++) {
  REVERSE_LOOKUP[BASE64_CODE.charCodeAt(i)] = i;
}
function isValidChar(c) {
  return REVERSE_LOOKUP[c.charCodeAt(0)] !== void 0;
}
function extractChunks(b64Str) {
  const strSize = b64Str.length;
  const chunks = [];
  let currentChunk = null;
  for (let i = 0; i < strSize; i++) {
    if (isValidChar(b64Str[i])) {
      if (!currentChunk) {
        currentChunk = {
          start: i,
          count: 0
        };
      }
      currentChunk.count++;
      currentChunk.end = i;
    } else if (b64Str[i] === "=" && currentChunk) {
      chunks.push(currentChunk);
      currentChunk = null;
    }
  }
  if (currentChunk) {
    chunks.push(currentChunk);
  }
  return chunks;
}
function writeChunk(b64Str, chunk, dstOffset, uint8) {
  const {
    start,
    count
  } = chunk;
  const remain = count % 4;
  const fourCharProcessCount = Math.floor(count / 4);
  let charIdx = start;
  let tmp = null;
  let offset = dstOffset;
  for (let i = 0; i < fourCharProcessCount; i++) {
    while (!isValidChar(b64Str[charIdx])) {
      charIdx++;
    }
    tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 18;
    while (!isValidChar(b64Str[charIdx])) {
      charIdx++;
    }
    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 12;
    while (!isValidChar(b64Str[charIdx])) {
      charIdx++;
    }
    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 6;
    while (!isValidChar(b64Str[charIdx])) {
      charIdx++;
    }
    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)];
    uint8[offset++] = tmp >> 16 & 255;
    uint8[offset++] = tmp >> 8 & 255;
    uint8[offset++] = tmp & 255;
  }
  switch (remain) {
    case 3:
      while (!isValidChar(b64Str[charIdx])) {
        charIdx++;
      }
      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 10;
      while (!isValidChar(b64Str[charIdx])) {
        charIdx++;
      }
      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 4;
      while (!isValidChar(b64Str[charIdx])) {
        charIdx++;
      }
      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 2;
      uint8[offset++] = tmp >> 8 & 255;
      uint8[offset++] = tmp & 255;
      break;
    case 2:
      while (!isValidChar(b64Str[charIdx])) {
        charIdx++;
      }
      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 2;
      while (!isValidChar(b64Str[charIdx])) {
        charIdx++;
      }
      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 4;
      uint8[offset++] = tmp & 255;
      break;
    case 1:
      throw new Error("BASE64: remain 1 should not happen");
  }
  return offset;
}
function toArrayBuffer(b64Str) {
  const chunks = extractChunks(b64Str);
  const totalEncodedLength = chunks[chunks.length - 1].end + 1;
  const padding = (4 - totalEncodedLength % 4) % 4;
  const totalSize = (totalEncodedLength + padding) * 3 / 4 - padding;
  const arrayBuffer = new ArrayBuffer(totalSize);
  const view = new Uint8Array(arrayBuffer);
  let dstOffset = 0;
  for (let i = 0; i < chunks.length; i++) {
    dstOffset += writeChunk(b64Str, chunks[i], dstOffset, view);
    dstOffset += (4 - chunks[i].count % 4) % 4;
  }
  return arrayBuffer;
}
function encodeTriplet(v1, v2, v3) {
  const triplet = (v1 << 16) + (v2 << 8) + v3;
  return BASE64_CODE[triplet >> 18] + BASE64_CODE[triplet >> 12 & 63] + BASE64_CODE[triplet >> 6 & 63] + BASE64_CODE[triplet & 63];
}
function fromArrayBuffer(ab) {
  const uint8 = new Uint8Array(ab);
  const leftoverLength = ab.byteLength % 3;
  const maxTripletIndex = ab.byteLength - leftoverLength;
  const segments = Array(maxTripletIndex / 3);
  for (let i = 0; i < segments.length; i++) {
    const bufOffset = i * 3;
    segments[i] = encodeTriplet(uint8[bufOffset], uint8[bufOffset + 1], uint8[bufOffset + 2]);
  }
  if (leftoverLength > 0) {
    const segment = encodeTriplet(uint8[maxTripletIndex], uint8[maxTripletIndex + 1] || 0, uint8[maxTripletIndex + 2] || 0);
    if (leftoverLength === 1) {
      segments.push(`${segment.substr(0, 2)}==`);
    } else if (leftoverLength === 2) {
      segments.push(`${segment.substr(0, 3)}=`);
    }
  }
  return segments.join("");
}
var Base64 = {
  toArrayBuffer,
  fromArrayBuffer
};

// node_modules/@kitware/vtk.js/Common/Core/StringArray.js
function vtkStringArray(publicAPI, model) {
  model.classHierarchy.push("vtkStringArray");
  publicAPI.getComponent = function(tupleIdx) {
    let compIdx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return model.values[tupleIdx * model.numberOfComponents + compIdx];
  };
  publicAPI.setComponent = (tupleIdx, compIdx, value) => {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      publicAPI.modified();
    }
  };
  publicAPI.getData = () => model.values;
  publicAPI.getTuple = function(idx) {
    let tupleToFill = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const numberOfComponents = model.numberOfComponents || 1;
    if (tupleToFill.length) {
      tupleToFill.length = numberOfComponents;
    }
    const offset = idx * numberOfComponents;
    for (let i = 0; i < numberOfComponents; i++) {
      tupleToFill[i] = model.values[offset + i];
    }
    return tupleToFill;
  };
  publicAPI.getTupleLocation = function() {
    let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    return idx * model.numberOfComponents;
  };
  publicAPI.getNumberOfComponents = () => model.numberOfComponents;
  publicAPI.getNumberOfValues = () => model.values.length;
  publicAPI.getNumberOfTuples = () => model.values.length / model.numberOfComponents;
  publicAPI.getDataType = () => model.dataType;
  publicAPI.newClone = () => newInstance10({
    name: model.name,
    numberOfComponents: model.numberOfComponents,
    empty: true
  });
  publicAPI.getName = () => {
    if (!model.name) {
      publicAPI.setName(`vtkStringArray${publicAPI.getMTime()}`);
    }
    return model.name;
  };
  publicAPI.setData = (array, numberOfComponents) => {
    model.values = array;
    model.size = array.length;
    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }
    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }
    publicAPI.modified();
  };
}
var DEFAULT_VALUES8 = {
  name: "",
  numberOfComponents: 1,
  size: 0,
  // values: null,
  dataType: "string"
};
function extend10(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  if (!model.empty && !model.values && !model.size) {
    throw new TypeError("Cannot create vtkStringArray object without: size > 0, values");
  }
  if (!model.values) {
    model.values = [];
  } else if (Array.isArray(model.values)) {
    model.values = [...model.values];
  }
  if (model.values) {
    model.size = model.values.length;
  }
  macro.obj(publicAPI, model);
  macro.set(publicAPI, model, ["name"]);
  vtkStringArray(publicAPI, model);
}
var newInstance10 = macro.newInstance(extend10, "vtkStringArray");
var vtkStringArray$1 = {
  newInstance: newInstance10,
  extend: extend10
};

// node_modules/@kitware/vtk.js/IO/Core/BinaryHelper.js
function arrayBufferToString(arrayBuffer) {
  const decoder = new TextDecoder("latin1");
  return decoder.decode(arrayBuffer);
}
function extractBinary(arrayBuffer, prefixRegex) {
  let suffixRegex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  const str = arrayBufferToString(arrayBuffer);
  const prefixMatch = prefixRegex.exec(str);
  if (!prefixMatch) {
    return {
      text: str
    };
  }
  const dataStartIndex = prefixMatch.index + prefixMatch[0].length;
  const strFirstHalf = str.substring(0, dataStartIndex);
  let retVal = null;
  const suffixMatch = suffixRegex ? suffixRegex.exec(str) : null;
  if (suffixMatch) {
    const strSecondHalf = str.substr(suffixMatch.index);
    retVal = {
      text: strFirstHalf + strSecondHalf,
      binaryBuffer: arrayBuffer.slice(dataStartIndex, suffixMatch.index)
    };
  } else {
    retVal = {
      text: strFirstHalf,
      binaryBuffer: arrayBuffer.slice(dataStartIndex)
    };
  }
  return retVal;
}
var BinaryHelper = {
  arrayBufferToString,
  extractBinary
};

// node_modules/@kitware/vtk.js/Common/Core/Endian.js
function getEndianness() {
  const a = new ArrayBuffer(4);
  const b = new Uint8Array(a);
  const c = new Uint32Array(a);
  b[0] = 161;
  b[1] = 178;
  b[2] = 195;
  b[3] = 212;
  if (c[0] === 3569595041) return "LittleEndian";
  if (c[0] === 2712847316) return "BigEndian";
  return null;
}
var ENDIANNESS = getEndianness();
function swapBytes(buffer, wordSize) {
  if (wordSize < 2) {
    return;
  }
  const bytes = new Int8Array(buffer);
  const size = bytes.length;
  const tempBuffer = [];
  for (let i = 0; i < size; i += wordSize) {
    for (let j = 0; j < wordSize; j++) {
      tempBuffer.push(bytes[i + j]);
    }
    for (let j = 0; j < wordSize; j++) {
      bytes[i + j] = tempBuffer.pop();
    }
  }
}
var Endian = {
  ENDIANNESS,
  getEndianness,
  swapBytes
};

// node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper/LiteHttpDataAccessHelper.js
var {
  vtkErrorMacro: vtkErrorMacro4,
  vtkDebugMacro: vtkDebugMacro2
} = macro;
var REJECT_COMPRESSION = () => {
  vtkErrorMacro4("LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead.");
  return Promise.reject(new Error("LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead."));
};
var requestCount = 0;
function openAsyncXHR(method, url) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const xhr = new XMLHttpRequest();
  xhr.open(method, url, true);
  if (options.headers) {
    Object.entries(options.headers).forEach((_ref) => {
      let [key, value] = _ref;
      return xhr.setRequestHeader(key, value);
    });
  }
  if (options.progressCallback) {
    xhr.addEventListener("progress", options.progressCallback);
  }
  return xhr;
}
function fetchBinary(url) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((resolve, reject) => {
    const xhr = openAsyncXHR("GET", url, options);
    xhr.onreadystatechange = (e) => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200 || xhr.status === 0) {
          resolve(xhr.response);
        } else {
          reject({
            xhr,
            e
          });
        }
      }
    };
    xhr.responseType = "arraybuffer";
    xhr.send();
  });
}
function fetchArray(instance, baseURL, array) {
  let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  if (options && options.compression) {
    return REJECT_COMPRESSION();
  }
  if (array.ref && !array.ref.pending) {
    return new Promise((resolve, reject) => {
      const url = [baseURL, array.ref.basepath, array.ref.id].join("/");
      const xhr = openAsyncXHR("GET", url, options);
      xhr.onreadystatechange = (e) => {
        if (xhr.readyState === 1) {
          array.ref.pending = true;
          if (++requestCount === 1 && (instance == null ? void 0 : instance.invokeBusy)) {
            instance.invokeBusy(true);
          }
        }
        if (xhr.readyState === 4) {
          array.ref.pending = false;
          if (xhr.status === 200 || xhr.status === 0) {
            array.buffer = xhr.response;
            if (array.ref.encode === "JSON") {
              array.values = JSON.parse(array.buffer);
            } else {
              if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {
                vtkDebugMacro2(`Swap bytes of ${array.name}`);
                Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);
              }
              array.values = macro.newTypedArray(array.dataType, array.buffer);
            }
            if (array.values.length !== array.size) {
              vtkErrorMacro4(`Error in FetchArray: ${array.name}, does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`);
            }
            delete array.ref;
            if (--requestCount === 0 && (instance == null ? void 0 : instance.invokeBusy)) {
              instance.invokeBusy(false);
            }
            if (instance == null ? void 0 : instance.modified) {
              instance.modified();
            }
            resolve(array);
          } else {
            reject({
              xhr,
              e
            });
          }
        }
      };
      xhr.responseType = array.dataType !== "string" ? "arraybuffer" : "text";
      xhr.send();
    });
  }
  return Promise.resolve(array);
}
function fetchJSON(instance, url) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (options && options.compression) {
    return REJECT_COMPRESSION();
  }
  return new Promise((resolve, reject) => {
    const xhr = openAsyncXHR("GET", url, options);
    xhr.onreadystatechange = (e) => {
      if (xhr.readyState === 1) {
        if (++requestCount === 1 && (instance == null ? void 0 : instance.invokeBusy)) {
          instance.invokeBusy(true);
        }
      }
      if (xhr.readyState === 4) {
        if (--requestCount === 0 && (instance == null ? void 0 : instance.invokeBusy)) {
          instance.invokeBusy(false);
        }
        if (xhr.status === 200 || xhr.status === 0) {
          resolve(JSON.parse(xhr.responseText));
        } else {
          reject({
            xhr,
            e
          });
        }
      }
    };
    xhr.responseType = "text";
    xhr.send();
  });
}
function fetchText(instance, url) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (options && options.compression) {
    return REJECT_COMPRESSION();
  }
  return new Promise((resolve, reject) => {
    const xhr = openAsyncXHR("GET", url, options);
    xhr.onreadystatechange = (e) => {
      if (xhr.readyState === 1) {
        if (++requestCount === 1 && (instance == null ? void 0 : instance.invokeBusy)) {
          instance.invokeBusy(true);
        }
      }
      if (xhr.readyState === 4) {
        if (--requestCount === 0 && (instance == null ? void 0 : instance.invokeBusy)) {
          instance.invokeBusy(false);
        }
        if (xhr.status === 200 || xhr.status === 0) {
          resolve(xhr.responseText);
        } else {
          reject({
            xhr,
            e
          });
        }
      }
    };
    xhr.responseType = "text";
    xhr.send();
  });
}
function fetchImage(instance, url) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return new Promise((resolve, reject) => {
    const img = new Image();
    if (options.crossOrigin) {
      img.crossOrigin = options.crossOrigin;
    }
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}
var LiteHttpDataAccessHelper = {
  fetchArray,
  fetchJSON,
  fetchText,
  fetchBinary,
  // Only for HTTP
  fetchImage
};
if (!has("http")) {
  registerType("http", (options) => LiteHttpDataAccessHelper);
}

// node_modules/@kitware/vtk.js/IO/XML/XMLReader.js
function findAllTags(node, tagName) {
  return [...node.getElementsByTagName(tagName)];
}
function findFirstTag(node, tagName) {
  return findAllTags(node, tagName)[0];
}
function parseXML(xmlStr) {
  return (0, import_xmlbuilder2.create)(xmlStr);
}
function extractAppendedData(buffer) {
  const prefixRegex = /^\s*<AppendedData\s+encoding="raw">\s*_/m;
  const suffixRegex = /\n\s*<\/AppendedData>/m;
  return BinaryHelper.extractBinary(buffer, prefixRegex, suffixRegex);
}
var TYPED_ARRAY = {
  Int8: Int8Array,
  UInt8: Uint8Array,
  Int16: Int16Array,
  UInt16: Uint16Array,
  Int32: Int32Array,
  UInt32: Uint32Array,
  Int64: Int32Array,
  // Not supported with JavaScript will cause error in binary
  UInt64: Uint32Array,
  // Not supported with JavaScript will cause error in binary
  Float32: Float32Array,
  Float64: Float64Array
};
var TYPED_ARRAY_BYTES = {
  Int8: 1,
  UInt8: 1,
  Int16: 2,
  UInt16: 2,
  Int32: 4,
  UInt32: 4,
  Int64: 8,
  // Not supported with JavaScript will cause error in binary
  UInt64: 8,
  // Not supported with JavaScript will cause error in binary
  Float32: 4,
  Float64: 8
};
function integer64to32(array) {
  const maxIdx = array.length - 1;
  return array.filter((v, i) => i < maxIdx && i % 2 === 0);
}
function readLengthPrefixedData(uint8, dataType, headerType) {
  if (!["UInt64", "UInt32"].includes(headerType)) {
    throw new Error(`Cannot handle a header type of ${headerType}`);
  }
  let HeaderTypedArray = TYPED_ARRAY[headerType];
  let DataTypedArray = TYPED_ARRAY[dataType];
  let dataFallbackTo32 = false;
  if (headerType === "UInt64") {
    HeaderTypedArray = TYPED_ARRAY.UInt32;
  }
  if (/^U?Int64$/.test(dataType)) {
    dataFallbackTo32 = true;
    DataTypedArray = TYPED_ARRAY[dataType.replace("64", "32")];
  }
  const {
    byteOffset
  } = uint8;
  const dataWordSize = TYPED_ARRAY_BYTES[dataType];
  const headerWordSize = TYPED_ARRAY_BYTES[headerType];
  let header;
  if (byteOffset % headerWordSize === 0) {
    header = new HeaderTypedArray(uint8.buffer, byteOffset, 1);
  } else {
    header = new HeaderTypedArray(uint8.buffer.slice(byteOffset, byteOffset + headerWordSize));
  }
  const dataByteLength = Number(header[0]);
  let values;
  let arraySize = dataByteLength / dataWordSize;
  if (dataFallbackTo32) {
    arraySize *= 2;
  }
  const dataOffset = byteOffset + headerWordSize;
  if (dataOffset % dataWordSize === 0) {
    values = new DataTypedArray(uint8.buffer, dataOffset, arraySize);
  } else {
    values = new DataTypedArray(uint8.buffer.slice(dataOffset, dataOffset + dataByteLength));
  }
  if (dataFallbackTo32) {
    values = integer64to32(values);
  }
  return values;
}
function readerHeader(uint8, headerType) {
  if (headerType === "UInt64") {
    const offset2 = 8;
    let uint322 = new Uint32Array(uint8.buffer, 0, 6);
    const nbBlocks2 = uint322[0];
    const s12 = uint322[2];
    const s22 = uint322[4];
    const resultArray2 = [offset2, nbBlocks2, s12, s22];
    uint322 = new Uint32Array(uint8.buffer, 3 * 8, nbBlocks2 * 2);
    for (let i = 0; i < nbBlocks2; i++) {
      resultArray2.push(uint322[i * 2]);
    }
    return resultArray2;
  }
  let uint32 = new Uint32Array(uint8.buffer, 0, 3);
  const offset = 4;
  const nbBlocks = uint32[0];
  const s1 = uint32[1];
  const s2 = uint32[2];
  const resultArray = [offset, nbBlocks, s1, s2];
  uint32 = new Uint32Array(uint8.buffer, 3 * 4, nbBlocks);
  for (let i = 0; i < nbBlocks; i++) {
    resultArray.push(uint32[i]);
  }
  return resultArray;
}
function getHeaderByteLength(header, headerType) {
  const [headerWordSize] = header;
  return (header.length - 1) * headerWordSize;
}
function uncompressBlock(compressedUint8, output) {
  const uncompressedBlock = decompressSync(compressedUint8);
  output.uint8.set(uncompressedBlock, output.offset);
  output.offset += uncompressedBlock.length;
}
function decompressZLib(bytes, headerType) {
  const header = readerHeader(bytes, headerType);
  const nbBlocks = header[1];
  const s1 = header[2];
  const s2 = header[3];
  let dataByteLength = 0;
  if (nbBlocks > 0) {
    if (s2 === 0) {
      dataByteLength = nbBlocks * s1;
    } else {
      dataByteLength = (nbBlocks - 1) * s1 + s2;
    }
  }
  const buffer = new ArrayBuffer(dataByteLength);
  const output = {
    offset: 0,
    uint8: new Uint8Array(buffer)
  };
  let offset = getHeaderByteLength(header);
  while (offset < bytes.length && bytes[offset] !== 120) {
    offset++;
  }
  for (let i = 0; i < nbBlocks; i++) {
    const blockSize = header[4 + i];
    const compressedBlock = new Uint8Array(bytes.buffer, offset, blockSize);
    uncompressBlock(compressedBlock, output);
    offset += blockSize;
  }
  return output.uint8;
}
function processDataArray(size, dataArrayElem, compressor, byteOrder, headerType, binaryBuffer) {
  const dataType = dataArrayElem.getAttribute("type");
  const name = dataArrayElem.getAttribute("Name");
  const format2 = dataArrayElem.getAttribute("format");
  const numberOfComponents = Number(dataArrayElem.getAttribute("NumberOfComponents") || "1");
  let values = null;
  if (format2 === "ascii") {
    values = new TYPED_ARRAY[dataType](size * numberOfComponents);
    let offset = 0;
    dataArrayElem.firstChild.nodeValue.split(/[\\t \\n]+/).forEach((token) => {
      if (token.trim().length) {
        values[offset++] = Number(token);
      }
    });
  } else if (format2 === "binary") {
    const uint8 = new Uint8Array(Base64.toArrayBuffer(dataArrayElem.firstChild.nodeValue.trim()));
    if (compressor === "vtkZLibDataCompressor") {
      const data = decompressZLib(uint8, headerType);
      values = new TYPED_ARRAY[dataType](data.buffer);
      if (/^U?Int64$/.test(dataType)) {
        values = integer64to32(values);
      }
    } else {
      values = new TYPED_ARRAY[dataType](uint8.buffer, TYPED_ARRAY_BYTES[headerType]);
      if (dataType.indexOf("Int64") !== -1) {
        values = integer64to32(values);
      }
    }
  } else if (format2 === "appended") {
    const offset = Number(dataArrayElem.getAttribute("offset"));
    values = readLengthPrefixedData(new Uint8Array(binaryBuffer, offset), dataType, headerType);
  } else {
    console.error("Format not supported", format2);
  }
  return {
    name,
    values,
    numberOfComponents
  };
}
function decodeStringArrayFromBytes(bytes) {
  const decoder = new TextDecoder();
  const decoded = decoder.decode(bytes);
  return decoded.split("\0").slice(0, -1);
}
function processStringArray(stringArrayElem, compressor, byteOrder, headerType, binaryBuffer) {
  const name = stringArrayElem.getAttribute("Name");
  const format2 = stringArrayElem.getAttribute("format");
  const numberOfComponents = Number(stringArrayElem.getAttribute("NumberOfComponents") || "1");
  const numberOfTuples = Number(stringArrayElem.getAttribute("NumberOfTuples") || "1");
  const nbStrings = numberOfTuples * numberOfComponents;
  const strings = [];
  if (format2 === "ascii") {
    const tokens = stringArrayElem.firstChild.nodeValue.trim().split(/\s+/);
    let tokIdx = 0;
    const strChars = [];
    while (strings.length < nbStrings) {
      const token = Number(tokens[tokIdx++]);
      if (token === 0) {
        strings.push(strChars.join(""));
        strChars.length = 0;
      } else {
        strChars.push(String.fromCharCode(token));
      }
    }
  } else if (format2 === "binary") {
    const uint8 = new Uint8Array(Base64.toArrayBuffer(stringArrayElem.firstChild.nodeValue.trim()));
    if (compressor === "vtkZLibDataCompressor") {
      const decompressed = decompressZLib(uint8, headerType);
      strings.push(...decodeStringArrayFromBytes(decompressed));
    } else {
      const strData = readLengthPrefixedData(uint8, "UInt8", headerType);
      strings.push(...decodeStringArrayFromBytes(strData));
    }
  } else if (format2 === "appended") {
    const offset = Number(stringArrayElem.getAttribute("offset"));
    const values = readLengthPrefixedData(new Uint8Array(binaryBuffer, offset), "UInt8", headerType);
    strings.push(...decodeStringArrayFromBytes(values));
  } else {
    macro.vtkErrorMacro(`Format not supported: ${format2}`);
  }
  return {
    name,
    values: strings,
    numberOfComponents
  };
}
function processCells(size, containerElem, compressor, byteOrder, headerType, binaryBuffer) {
  const arrayElems = {};
  const dataArrayElems = containerElem.getElementsByTagName("DataArray");
  for (let elIdx = 0; elIdx < dataArrayElems.length; elIdx++) {
    const el = dataArrayElems[elIdx];
    arrayElems[el.getAttribute("Name")] = el;
  }
  const offsets = processDataArray(size, arrayElems.offsets, compressor, byteOrder, headerType, binaryBuffer).values;
  const connectivitySize = offsets[offsets.length - 1];
  const connectivity = processDataArray(connectivitySize, arrayElems.connectivity, compressor, byteOrder, headerType, binaryBuffer).values;
  const values = new Uint32Array(size + connectivitySize);
  let writeOffset = 0;
  let previousOffset = 0;
  offsets.forEach((v) => {
    const cellSize = v - previousOffset;
    values[writeOffset++] = cellSize;
    for (let i = 0; i < cellSize; i++) {
      values[writeOffset++] = connectivity[previousOffset + i];
    }
    previousOffset = v;
  });
  return values;
}
function processFieldData(size, fieldElem, fieldContainer, compressor, byteOrder, headerType, binaryBuffer) {
  if (fieldElem) {
    const attributes = ["Scalars", "Vectors", "Normals", "Tensors", "TCoords"];
    const nameBinding = {};
    attributes.forEach((attrName) => {
      const arrayName = fieldElem.getAttribute(attrName);
      if (arrayName) {
        nameBinding[arrayName] = fieldContainer[`set${attrName}`];
      }
    });
    const dataArrayElems = fieldElem.getElementsByTagName("DataArray");
    const nbArrays = dataArrayElems.length;
    for (let idx = 0; idx < nbArrays; idx++) {
      const array = dataArrayElems[idx];
      const dataArray = vtkDataArray$1.newInstance(processDataArray(size, array, compressor, byteOrder, headerType, binaryBuffer));
      const name = dataArray.getName();
      (nameBinding[name] || fieldContainer.addArray)(dataArray);
    }
  }
}
function handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, binaryBuffer) {
  const dataArrays = [...fieldDataElem.getElementsByTagName("DataArray")].map((daElem) => vtkDataArray$1.newInstance(processDataArray(Number(daElem.getAttribute("NumberOfTuples")), daElem, compressor, byteOrder, headerType, binaryBuffer)));
  const stringArrays = [...fieldDataElem.getElementsByTagName("Array")].filter((elem) => elem.getAttribute("type") === "String").map((arrElem) => {
    const sa = vtkStringArray$1.newInstance(processStringArray(arrElem, compressor, byteOrder, headerType, binaryBuffer));
    return sa;
  });
  return [...dataArrays, ...stringArrays];
}
function vtkXMLReader(publicAPI, model) {
  model.classHierarchy.push("vtkXMLReader");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return model.dataAccessHelper.fetchBinary(url, option);
  }
  publicAPI.setUrl = function(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    model.url = url;
    const path = url.split("/");
    path.pop();
    model.baseURL = path.join("/");
    return publicAPI.loadData(option);
  };
  publicAPI.loadData = function() {
    let option = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return fetchData(model.url, option).then(publicAPI.parseAsArrayBuffer);
  };
  publicAPI.parseAsArrayBuffer = (arrayBuffer) => {
    if (!arrayBuffer) {
      return false;
    }
    if (arrayBuffer !== model.rawDataBuffer) {
      publicAPI.modified();
    } else {
      return true;
    }
    const {
      text: content,
      binaryBuffer
    } = extractAppendedData(arrayBuffer);
    model.rawDataBuffer = arrayBuffer;
    model.binaryBuffer = binaryBuffer;
    const doc = parseXML(content);
    const root = doc.root();
    const rootElem = root.node;
    const type = rootElem.getAttribute("type");
    const compressor = rootElem.getAttribute("compressor");
    const byteOrder = rootElem.getAttribute("byte_order");
    const headerType = rootElem.getAttribute("header_type") || "UInt32";
    if (compressor && compressor !== "vtkZLibDataCompressor") {
      console.error("Invalid compressor", compressor);
      return false;
    }
    if (byteOrder && byteOrder !== "LittleEndian") {
      console.error("Only LittleEndian encoding is supported");
      return false;
    }
    if (type !== model.dataType) {
      console.error("Invalid data type", type, "expecting", model.dataType);
      return false;
    }
    if (findFirstTag(rootElem, "AppendedData")) {
      const appendedDataElem = findFirstTag(rootElem, "AppendedData");
      const encoding = appendedDataElem.getAttribute("encoding");
      const arrays = root.filter((xmlNode) => {
        const {
          node
        } = xmlNode;
        return node.nodeType === Node.ELEMENT_NODE && node.getAttribute("format") === "appended" && node.hasAttribute("offset");
      }, false, true).map((xmlNode) => ({
        node: xmlNode.node,
        offset: Number(xmlNode.node.getAttribute("offset"))
      }));
      arrays.sort((a, b) => a.offset - b.offset);
      let appendedBuffer = model.binaryBuffer;
      if (encoding === "base64") {
        appendedBuffer = appendedDataElem.textContent.trim().substr(1);
      }
      const dataArrays = [];
      for (let i = 0; i < arrays.length; ++i) {
        const offset = arrays[i].offset;
        let nextOffset = 0;
        if (i === arrays.length - 1) {
          nextOffset = appendedBuffer.length || appendedBuffer.byteLength;
        } else {
          nextOffset = arrays[i + 1].offset;
        }
        if (encoding === "base64") {
          dataArrays.push(new Uint8Array(Base64.toArrayBuffer(appendedBuffer.substring(offset, nextOffset))));
        } else {
          dataArrays.push(new Uint8Array(appendedBuffer.slice(offset, nextOffset)));
        }
      }
      if (compressor === "vtkZLibDataCompressor") {
        for (let arrayidx = 0; arrayidx < dataArrays.length; ++arrayidx) {
          const dataArray = dataArrays[arrayidx];
          const uncompressed = decompressZLib(dataArray, headerType);
          const data = new Uint8Array(uncompressed.length + TYPED_ARRAY_BYTES[headerType]);
          new TYPED_ARRAY[headerType](data.buffer, 0, 1)[0] = uncompressed.length;
          data.set(uncompressed, TYPED_ARRAY_BYTES[headerType]);
          dataArrays[arrayidx] = data;
        }
      }
      const bufferLength = dataArrays.reduce((acc, arr) => acc + arr.length, 0);
      const buffer = new ArrayBuffer(bufferLength);
      const view = new Uint8Array(buffer);
      for (let i = 0, offset = 0; i < dataArrays.length; ++i) {
        arrays[i].node.setAttribute("offset", offset);
        view.set(dataArrays[i], offset);
        offset += dataArrays[i].length;
      }
      model.binaryBuffer = buffer;
      if (!model.binaryBuffer) {
        console.error("Processing appended data format: requires binaryBuffer to parse");
        return false;
      }
    }
    publicAPI.parseXML(rootElem, type, compressor, byteOrder, headerType);
    const datasetElem = rootElem.getElementsByTagName(type)[0];
    const fieldDataElem = datasetElem.getElementsByTagName("FieldData")[0];
    if (fieldDataElem) {
      const fieldDataArrays = handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, model.binaryBuffer);
      for (let i = 0; i < model.output.length; i++) {
        const fieldData = model.output[i].getFieldData();
        for (let j = 0; j < fieldDataArrays.length; j++) {
          fieldData.addArray(fieldDataArrays[j]);
        }
      }
    }
    return true;
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parseAsArrayBuffer(model.rawDataBuffer);
  };
}
var DEFAULT_VALUES9 = {
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};
function extend11(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES9, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkXMLReader(publicAPI, model);
}
var vtkXMLReader$1 = {
  extend: extend11,
  processDataArray,
  processFieldData,
  processCells
};

// node_modules/@kitware/vtk.js/IO/XML/XMLPolyDataReader.js
function handleArray(polydata, cellType, piece, compressor, byteOrder, headerType, binaryBuffer) {
  const size = Number(piece.getAttribute(`NumberOf${cellType}`));
  if (size > 0) {
    const dataArrayElem = piece.getElementsByTagName(cellType)[0].getElementsByTagName("DataArray")[0];
    const {
      values,
      numberOfComponents
    } = vtkXMLReader$1.processDataArray(size, dataArrayElem, compressor, byteOrder, headerType, binaryBuffer);
    polydata[`get${cellType}`]().setData(values, numberOfComponents);
  }
  return size;
}
function handleCells(polydata, cellType, piece, compressor, byteOrder, headerType, binaryBuffer) {
  const size = Number(piece.getAttribute(`NumberOf${cellType}`));
  if (size > 0) {
    const values = vtkXMLReader$1.processCells(size, piece.getElementsByTagName(cellType)[0], compressor, byteOrder, headerType, binaryBuffer);
    polydata[`get${cellType}`]().setData(values);
  }
  return size;
}
function vtkXMLPolyDataReader(publicAPI, model) {
  model.classHierarchy.push("vtkXMLPolyDataReader");
  publicAPI.parseXML = (rootElem, type, compressor, byteOrder, headerType) => {
    const datasetElem = rootElem.getElementsByTagName(model.dataType)[0];
    const pieces = datasetElem.getElementsByTagName("Piece");
    const nbPieces = pieces.length;
    for (let outputIndex = 0; outputIndex < nbPieces; outputIndex++) {
      const polydata = vtkPolyData$1.newInstance();
      const piece = pieces[outputIndex];
      const nbPoints = handleArray(polydata, "Points", piece, compressor, byteOrder, headerType, model.binaryBuffer);
      let nbCells = 0;
      ["Verts", "Lines", "Strips", "Polys"].forEach((cellType) => {
        nbCells += handleCells(polydata, cellType, piece, compressor, byteOrder, headerType, model.binaryBuffer);
      });
      vtkXMLReader$1.processFieldData(nbPoints, piece.getElementsByTagName("PointData")[0], polydata.getPointData(), compressor, byteOrder, headerType, model.binaryBuffer);
      vtkXMLReader$1.processFieldData(nbCells, piece.getElementsByTagName("CellData")[0], polydata.getCellData(), compressor, byteOrder, headerType, model.binaryBuffer);
      model.output[outputIndex] = polydata;
    }
  };
}
var DEFAULT_VALUES10 = {
  dataType: "PolyData"
};
function extend12(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES10, initialValues);
  vtkXMLReader$1.extend(publicAPI, model, initialValues);
  vtkXMLPolyDataReader(publicAPI, model);
}
var newInstance11 = macro.newInstance(extend12, "vtkXMLPolyDataReader");
var vtkXMLPolyDataReader$1 = {
  newInstance: newInstance11,
  extend: extend12
};

// node_modules/@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js
var OverlayMarkerType;
(function(OverlayMarkerType2) {
  OverlayMarkerType2[OverlayMarkerType2["ANNOTATED_CUBE"] = 1] = "ANNOTATED_CUBE";
  OverlayMarkerType2[OverlayMarkerType2["AXES"] = 2] = "AXES";
  OverlayMarkerType2[OverlayMarkerType2["CUSTOM"] = 3] = "CUSTOM";
})(OverlayMarkerType || (OverlayMarkerType = {}));
var _OrientationMarkerTool = class _OrientationMarkerTool extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    configuration: {
      orientationWidget: {
        enabled: true,
        viewportCorner: vtkOrientationMarkerWidget$1.Corners.BOTTOM_RIGHT,
        viewportSize: 0.15,
        minPixelSize: 100,
        maxPixelSize: 300
      },
      overlayMarkerType: _OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,
      overlayConfiguration: {
        [_OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {
          faceProperties: {
            xPlus: { text: "L", faceColor: "#ffff00", faceRotation: 90 },
            xMinus: { text: "R", faceColor: "#ffff00", faceRotation: 270 },
            yPlus: {
              text: "P",
              faceColor: "#00ffff",
              fontColor: "white",
              faceRotation: 180
            },
            yMinus: { text: "A", faceColor: "#00ffff", fontColor: "white" },
            zPlus: { text: "S" },
            zMinus: { text: "I" }
          },
          defaultStyle: {
            fontStyle: "bold",
            fontFamily: "Arial",
            fontColor: "black",
            fontSizeScale: (res) => res / 2,
            faceColor: "#0000ff",
            edgeThickness: 0.1,
            edgeColor: "black",
            resolution: 400
          }
        },
        [_OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},
        [_OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {
          polyDataURL: "https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp"
        }
      }
    }
  }) {
    super(toolProps, defaultToolProps);
    this._resizeObservers = /* @__PURE__ */ new Map();
    this.onSetToolEnabled = () => {
      this.initViewports();
      this._subscribeToViewportEvents();
    };
    this.onSetToolActive = () => {
      this.initViewports();
      this._subscribeToViewportEvents();
    };
    this.onSetToolDisabled = () => {
      this.cleanUpData();
      this._unsubscribeToViewportNewVolumeSet();
    };
    this._getViewportsInfo = () => {
      const viewports = getToolGroup_default(this.toolGroupId).viewportsInfo;
      return viewports;
    };
    this.resize = (viewportId) => {
      const orientationMarker = this.orientationMarkers[viewportId];
      if (!orientationMarker) {
        return;
      }
      const { orientationWidget } = orientationMarker;
      orientationWidget.updateViewport();
    };
    this.orientationMarkers = {};
    this.updatingOrientationMarker = {};
  }
  _unsubscribeToViewportNewVolumeSet() {
    const unsubscribe = () => {
      const viewportsInfo = this._getViewportsInfo();
      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);
        const { element } = viewport;
        element.removeEventListener(enums_exports.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));
        const resizeObserver = this._resizeObservers.get(viewportId);
        resizeObserver.unobserve(element);
      });
    };
    eventTarget_default.removeEventListener(Events_default.TOOLGROUP_VIEWPORT_ADDED, (evt) => {
      if (evt.detail.toolGroupId !== this.toolGroupId) {
        return;
      }
      unsubscribe();
      this.initViewports();
    });
  }
  _subscribeToViewportEvents() {
    const subscribeToElementResize = () => {
      const viewportsInfo = this._getViewportsInfo();
      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);
        const { element } = viewport;
        this.initViewports();
        element.addEventListener(enums_exports.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));
        const resizeObserver = new ResizeObserver(() => {
          setTimeout(() => {
            const element2 = getEnabledElementByIds(viewportId, renderingEngineId);
            if (!element2) {
              return;
            }
            const { viewport: viewport2 } = element2;
            this.resize(viewportId);
            viewport2.render();
          }, 100);
        });
        resizeObserver.observe(element);
        this._resizeObservers.set(viewportId, resizeObserver);
      });
    };
    subscribeToElementResize();
    eventTarget_default.addEventListener(Events_default.TOOLGROUP_VIEWPORT_ADDED, (evt) => {
      if (evt.detail.toolGroupId !== this.toolGroupId) {
        return;
      }
      subscribeToElementResize();
      this.initViewports();
    });
  }
  cleanUpData() {
    const renderingEngines = getRenderingEngines();
    const renderingEngine = renderingEngines[0];
    const viewports = renderingEngine.getViewports();
    viewports.forEach((viewport) => {
      const orientationMarker = this.orientationMarkers[viewport.id];
      if (!orientationMarker) {
        return;
      }
      const { actor, orientationWidget } = orientationMarker;
      orientationWidget == null ? void 0 : orientationWidget.setEnabled(false);
      orientationWidget == null ? void 0 : orientationWidget.delete();
      actor == null ? void 0 : actor.delete();
      const renderWindow = viewport.getRenderingEngine().offscreenMultiRenderWindow.getRenderWindow();
      renderWindow.render();
      viewport.getRenderingEngine().render();
      delete this.orientationMarkers[viewport.id];
    });
  }
  initViewports() {
    const renderingEngines = getRenderingEngines();
    const renderingEngine = renderingEngines[0];
    if (!renderingEngine) {
      return;
    }
    let viewports = renderingEngine.getViewports();
    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());
    viewports.forEach((viewport) => {
      const widget = viewport.getWidget(this.getToolName());
      if (!widget || widget.isDeleted()) {
        this.addAxisActorInViewport(viewport);
      }
    });
  }
  async addAxisActorInViewport(viewport) {
    const viewportId = viewport.id;
    if (!this.updatingOrientationMarker[viewportId]) {
      this.updatingOrientationMarker[viewportId] = true;
      const type = this.configuration.overlayMarkerType;
      const overlayConfiguration = this.configuration.overlayConfiguration[type];
      if (this.orientationMarkers[viewportId]) {
        const { actor: actor2, orientationWidget: orientationWidget2 } = this.orientationMarkers[viewportId];
        viewport.getRenderer().removeActor(actor2);
        orientationWidget2.setEnabled(false);
      }
      let actor;
      if (type === 1) {
        actor = this.createAnnotationCube(overlayConfiguration);
      } else if (type === 2) {
        actor = vtkAxesActor$1.newInstance();
      } else if (type === 3) {
        actor = await this.createCustomActor();
      }
      const renderer = viewport.getRenderer();
      const renderWindow = viewport.getRenderingEngine().offscreenMultiRenderWindow.getRenderWindow();
      const { enabled, viewportCorner, viewportSize, minPixelSize, maxPixelSize } = this.configuration.orientationWidget;
      const orientationWidget = vtkOrientationMarkerWidget$1.newInstance({
        actor,
        interactor: renderWindow.getInteractor(),
        parentRenderer: renderer
      });
      orientationWidget.setEnabled(enabled);
      orientationWidget.setViewportCorner(viewportCorner);
      orientationWidget.setViewportSize(viewportSize);
      orientationWidget.setMinPixelSize(minPixelSize);
      orientationWidget.setMaxPixelSize(maxPixelSize);
      orientationWidget.updateMarkerOrientation();
      this.orientationMarkers[viewportId] = {
        orientationWidget,
        actor
      };
      viewport.addWidget(this.getToolName(), orientationWidget);
      renderWindow.render();
      viewport.getRenderingEngine().render();
      this.updatingOrientationMarker[viewportId] = false;
    }
  }
  async createCustomActor() {
    const url = this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM].polyDataURL;
    const response = await fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const vtpReader = vtkXMLPolyDataReader$1.newInstance();
    vtpReader.parseAsArrayBuffer(arrayBuffer);
    vtpReader.update();
    const polyData = vtkPolyData$1.newInstance();
    polyData.shallowCopy(vtpReader.getOutputData());
    polyData.getPointData().setActiveScalars("Color");
    const mapper = vtkMapper$1.newInstance();
    mapper.setInputData(polyData);
    mapper.setColorModeToDirectScalars();
    const actor = vtkActor$1.newInstance();
    actor.setMapper(mapper);
    actor.rotateZ(180);
    return actor;
  }
  createAnnotationCube(overlayConfiguration) {
    const actor = vtkAnnotatedCubeActor$1.newInstance();
    actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });
    actor.setXPlusFaceProperty({
      ...overlayConfiguration.faceProperties.xPlus
    });
    actor.setXMinusFaceProperty({
      ...overlayConfiguration.faceProperties.xMinus
    });
    actor.setYPlusFaceProperty({
      ...overlayConfiguration.faceProperties.yPlus
    });
    actor.setYMinusFaceProperty({
      ...overlayConfiguration.faceProperties.yMinus
    });
    actor.setZPlusFaceProperty({
      ...overlayConfiguration.faceProperties.zPlus
    });
    actor.setZMinusFaceProperty({
      ...overlayConfiguration.faceProperties.zMinus
    });
    return actor;
  }
  async createAnnotatedCubeActor() {
    const axes = vtkAnnotatedCubeActor$1.newInstance();
    const { faceProperties, defaultStyle } = this.configuration.annotatedCube;
    axes.setDefaultStyle(defaultStyle);
    Object.keys(faceProperties).forEach((key) => {
      const methodName = `set${key.charAt(0).toUpperCase() + key.slice(1)}FaceProperty`;
      axes[methodName](faceProperties[key]);
    });
    return axes;
  }
};
_OrientationMarkerTool.CUBE = 1;
_OrientationMarkerTool.AXIS = 2;
_OrientationMarkerTool.VTPFILE = 3;
_OrientationMarkerTool.OVERLAY_MARKER_TYPES = OverlayMarkerType;
var OrientationMarkerTool = _OrientationMarkerTool;
OrientationMarkerTool.toolName = "OrientationMarker";
var OrientationMarkerTool_default = OrientationMarkerTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js
var _SegmentSelectTool = class _SegmentSelectTool extends BaseTool_default {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ["Mouse", "Touch"],
    configuration: {
      hoverTimeout: 100,
      mode: _SegmentSelectTool.SelectMode.Border,
      searchRadius: 6
    }
  }) {
    super(toolProps, defaultToolProps);
    this.mouseMoveCallback = (evt) => {
      if (this.hoverTimer) {
        clearTimeout(this.hoverTimer);
      }
      this.hoverTimer = setTimeout(() => {
        this._setActiveSegment(evt);
        this.hoverTimer = null;
      }, this.configuration.hoverTimeout);
      return true;
    };
    this.onSetToolEnabled = () => {
      this.onSetToolActive();
    };
    this.onSetToolActive = () => {
      this.hoverTimer = null;
    };
    this.onSetToolDisabled = () => {
      this.hoverTimer = null;
    };
    this.hoverTimer = null;
  }
  _setActiveSegment(evt = {}) {
    if (state.isInteractingWithTool) {
      return;
    }
    const { element, currentPoints } = evt.detail;
    const worldPoint = currentPoints.world;
    const enabledElement = getEnabledElement(element);
    if (!enabledElement) {
      return;
    }
    const { viewport } = enabledElement;
    const activeSegmentation = getActiveSegmentation2(viewport.id);
    if (!activeSegmentation) {
      return;
    }
    this._setActiveSegmentForType(activeSegmentation, worldPoint, viewport);
  }
  _setActiveSegmentForType(activeSegmentation, worldPoint, viewport) {
    const imageDataInfo = viewport.getImageData();
    if (!imageDataInfo) {
      return;
    }
    const { segmentationId, representationData } = activeSegmentation;
    let hoveredSegmentIndex;
    if (this.configuration.mode === _SegmentSelectTool.SelectMode.Inside) {
      hoveredSegmentIndex = getSegmentIndexAtWorldPoint(segmentationId, worldPoint, {
        viewport
      });
    } else {
      if (representationData.Labelmap) {
        hoveredSegmentIndex = getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, {
          viewport,
          searchRadius: this.configuration.searchRadius
        });
      } else if (representationData.Contour) {
        hoveredSegmentIndex = getHoveredContourSegmentationAnnotation(segmentationId);
      } else if (representationData.Surface) {
      }
    }
    if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {
      return;
    }
    setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);
    const renderingEngine = viewport.getRenderingEngine();
    const viewportIds = renderingEngine.getViewports().map((v) => v.id);
    triggerSegmentationModified(segmentationId);
    triggerAnnotationRenderForViewportIds_default(viewportIds);
  }
};
_SegmentSelectTool.SelectMode = {
  Inside: "Inside",
  Border: "Border"
};
var SegmentSelectTool = _SegmentSelectTool;
SegmentSelectTool.toolName = "SegmentSelectTool";
var SegmentSelectTool_default = SegmentSelectTool;

// node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js
var VideoRedactionTool = class extends AnnotationTool_default {
  constructor(toolConfiguration = {}) {
    super(toolConfiguration, {
      supportedInteractionTypes: ["Mouse", "Touch"],
      configuration: { shadow: true, preventHandleOutsideImage: false }
    });
    this.addNewAnnotation = (evt) => {
      const eventData = evt.detail;
      const { currentPoints, element } = eventData;
      const worldPos = currentPoints.world;
      const enabledElement = getEnabledElement(element);
      const { viewport, renderingEngine } = enabledElement;
      this.isDrawing = true;
      const camera = viewport.getCamera();
      const { viewPlaneNormal, viewUp } = camera;
      const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
      const annotation = {
        metadata: {
          viewPlaneNormal: [0, 0, 1],
          viewUp: [0, 1, 0],
          FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
          referencedImageId,
          toolName: this.getToolName()
        },
        data: {
          invalidated: true,
          handles: {
            points: [
              [...worldPos],
              [...worldPos],
              [...worldPos],
              [...worldPos]
            ],
            activeHandleIndex: null
          },
          cachedStats: {},
          active: true
        }
      };
      addAnnotation(annotation, element);
      const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);
      this.editData = {
        annotation,
        viewportUIDsToRender,
        handleIndex: 3,
        newAnnotation: true,
        hasMoved: false
      };
      this._activateDraw(element);
      hideElementCursor(element);
      evt.preventDefault();
      triggerAnnotationRenderForViewportIds_default(viewportUIDsToRender);
      return annotation;
    };
    this.getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const { points } = data.handles;
      for (let i = 0; i < points.length; i++) {
        const point = points[i];
        const toolDataCanvasCoordinate = viewport.worldToCanvas(point);
        const near = vec2_exports.distance(canvasCoords, toolDataCanvasCoordinate) < proximity;
        if (near === true) {
          data.handles.activeHandleIndex = i;
          return point;
        }
      }
      data.handles.activeHandleIndex = null;
    };
    this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
      const enabledElement = getEnabledElement(element);
      const { viewport } = enabledElement;
      const { data } = annotation;
      const { points } = data.handles;
      const canvasPoint1 = viewport.worldToCanvas(points[0]);
      const canvasPoint2 = viewport.worldToCanvas(points[3]);
      const rect = this._getRectangleImageCoordinates([
        canvasPoint1,
        canvasPoint2
      ]);
      const point = [canvasCoords[0], canvasCoords[1]];
      const { left, top, width, height } = rect;
      const distanceToPoint5 = distanceToPoint4([left, top, width, height], point);
      if (distanceToPoint5 <= proximity) {
        return true;
      }
    };
    this.toolSelectedCallback = (evt, annotation, interactionType = "mouse") => {
      const eventData = evt.detail;
      const { element } = eventData;
      const { data } = annotation;
      data.active = true;
      const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);
      this.editData = {
        annotation,
        viewportUIDsToRender
      };
      this._activateModify(element);
      hideElementCursor(element);
      triggerAnnotationRenderForViewportIds_default(viewportUIDsToRender);
      evt.preventDefault();
    };
    this.handleSelectedCallback = (evt, annotation, handle, interactionType = "mouse") => {
      const eventData = evt.detail;
      const { element } = eventData;
      const { data } = annotation;
      data.active = true;
      let movingTextBox = false;
      let handleIndex;
      if (handle.worldPosition) {
        movingTextBox = true;
      } else {
        handleIndex = data.handles.points.findIndex((p) => p === handle);
      }
      const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);
      this.editData = {
        annotation,
        viewportUIDsToRender,
        handleIndex
      };
      this._activateModify(element);
      hideElementCursor(element);
      triggerAnnotationRenderForViewportIds_default(viewportUIDsToRender);
      evt.preventDefault();
    };
    this._endCallback = (evt) => {
      const eventData = evt.detail;
      const { element } = eventData;
      const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } = this.editData;
      const { data } = annotation;
      if (newAnnotation && !hasMoved) {
        return;
      }
      this.doneEditMemo();
      data.active = false;
      data.handles.activeHandleIndex = null;
      this._deactivateModify(element);
      this._deactivateDraw(element);
      resetElementCursor(element);
      this.editData = null;
      this.isDrawing = false;
      if (this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage) {
        removeAnnotation(annotation.annotationUID);
      }
      triggerAnnotationRenderForViewportIds_default(viewportUIDsToRender);
    };
    this._dragCallback = (evt) => {
      this.isDrawing = true;
      const eventData = evt.detail;
      const { element } = eventData;
      const { annotation, viewportUIDsToRender, handleIndex, newAnnotation } = this.editData;
      this.createMemo(element, annotation, { newAnnotation });
      const { data } = annotation;
      if (handleIndex === void 0) {
        const { deltaPoints } = eventData;
        const worldPosDelta = deltaPoints.world;
        const { points } = data.handles;
        points.forEach((point) => {
          point[0] += worldPosDelta[0];
          point[1] += worldPosDelta[1];
          point[2] += worldPosDelta[2];
        });
        data.invalidated = true;
      } else {
        const { currentPoints } = eventData;
        const enabledElement2 = getEnabledElement(element);
        const { worldToCanvas, canvasToWorld } = enabledElement2.viewport;
        const worldPos = currentPoints.world;
        const { points } = data.handles;
        points[handleIndex] = [...worldPos];
        let bottomLeftCanvas;
        let bottomRightCanvas;
        let topLeftCanvas;
        let topRightCanvas;
        let bottomLeftWorld;
        let bottomRightWorld;
        let topLeftWorld;
        let topRightWorld;
        switch (handleIndex) {
          case 0:
          case 3:
            bottomLeftCanvas = worldToCanvas(points[0]);
            topRightCanvas = worldToCanvas(points[3]);
            bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
            topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
            bottomRightWorld = canvasToWorld(bottomRightCanvas);
            topLeftWorld = canvasToWorld(topLeftCanvas);
            points[1] = bottomRightWorld;
            points[2] = topLeftWorld;
            break;
          case 1:
          case 2:
            bottomRightCanvas = worldToCanvas(points[1]);
            topLeftCanvas = worldToCanvas(points[2]);
            bottomLeftCanvas = [
              topLeftCanvas[0],
              bottomRightCanvas[1]
            ];
            topRightCanvas = [
              bottomRightCanvas[0],
              topLeftCanvas[1]
            ];
            bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
            topRightWorld = canvasToWorld(topRightCanvas);
            points[0] = bottomLeftWorld;
            points[3] = topRightWorld;
            break;
        }
        data.invalidated = true;
      }
      this.editData.hasMoved = true;
      const enabledElement = getEnabledElement(element);
      triggerAnnotationRenderForViewportIds_default(viewportUIDsToRender);
    };
    this._activateDraw = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._deactivateDraw = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_MOVE, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._activateModify = (element) => {
      state.isInteractingWithTool = true;
      element.addEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.addEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.addEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.addEventListener(Events_default.TOUCH_END, this._endCallback);
      element.addEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this._deactivateModify = (element) => {
      state.isInteractingWithTool = false;
      element.removeEventListener(Events_default.MOUSE_UP, this._endCallback);
      element.removeEventListener(Events_default.MOUSE_DRAG, this._dragCallback);
      element.removeEventListener(Events_default.MOUSE_CLICK, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_END, this._endCallback);
      element.removeEventListener(Events_default.TOUCH_DRAG, this._dragCallback);
    };
    this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
      const renderStatus = false;
      const { viewport } = enabledElement;
      const { element } = viewport;
      let annotations = getAnnotations(this.getToolName(), element);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      annotations = this.filterInteractableAnnotationsForElement(element, annotations);
      if (!(annotations == null ? void 0 : annotations.length)) {
        return renderStatus;
      }
      const styleSpecifier = {
        toolGroupId: this.toolGroupId,
        toolName: this.getToolName(),
        viewportId: enabledElement.viewport.id
      };
      for (let i = 0; i < annotations.length; i++) {
        const annotation = annotations[i];
        const { annotationUID } = annotation;
        const data = annotation.data;
        const { points, activeHandleIndex } = data.handles;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const lineWidth = this.getStyle("lineWidth", styleSpecifier, annotation);
        const lineDash = this.getStyle("lineDash", styleSpecifier, annotation);
        const color = this.getStyle("color", styleSpecifier, annotation);
        if (!viewport.getRenderingEngine()) {
          console.warn("Rendering Engine has been destroyed");
          return;
        }
        let activeHandleCanvasCoords;
        if (!this.editData && activeHandleIndex !== null) {
          activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords) {
          const handleGroupUID = "0";
          drawHandles_default(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
            color
          });
        }
        const rectangleUID = "0";
        drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
          color: "black",
          lineDash,
          lineWidth
        });
      }
    };
    this._getRectangleImageCoordinates = (points) => {
      const [point0, point1] = points;
      return {
        left: Math.min(point0[0], point1[0]),
        top: Math.min(point0[1], point1[1]),
        width: Math.abs(point0[0] - point1[0]),
        height: Math.abs(point0[1] - point1[1])
      };
    };
    this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {
      const { data } = annotation;
      const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;
      const worldPos1 = data.handles.points[0];
      const worldPos2 = data.handles.points[3];
      const { cachedStats } = data;
      const targetUIDs = Object.keys(cachedStats);
      for (let i = 0; i < targetUIDs.length; i++) {
        const targetUID = targetUIDs[i];
        const { imageVolume } = this._getImageVolumeFromTargetUID(targetUID, renderingEngine);
        const { dimensions, scalarData, vtkImageData: imageData, metadata } = imageVolume;
        const worldPos1Index = vec3_exports.fromValues(0, 0, 0);
        const worldPos2Index = vec3_exports.fromValues(0, 0, 0);
        imageData.worldToIndexVec3(worldPos1, worldPos1Index);
        worldPos1Index[0] = Math.floor(worldPos1Index[0]);
        worldPos1Index[1] = Math.floor(worldPos1Index[1]);
        worldPos1Index[2] = Math.floor(worldPos1Index[2]);
        imageData.worldToIndexVec3(worldPos2, worldPos2Index);
        worldPos2Index[0] = Math.floor(worldPos2Index[0]);
        worldPos2Index[1] = Math.floor(worldPos2Index[1]);
        worldPos2Index[2] = Math.floor(worldPos2Index[2]);
        if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
          this.isHandleOutsideImage = false;
          const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
          const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
          const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
          const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
          const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
          const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
          const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);
          const area = worldWidth * worldHeight;
          let count = 0;
          let mean = 0;
          let stdDev = 0;
          const yMultiple = dimensions[0];
          const zMultiple = dimensions[0] * dimensions[1];
          for (let k = kMin; k <= kMax; k++) {
            for (let j = jMin; j <= jMax; j++) {
              for (let i2 = iMin; i2 <= iMax; i2++) {
                const value = scalarData[k * zMultiple + j * yMultiple + i2];
                count++;
                mean += value;
              }
            }
          }
          mean /= count;
          for (let k = kMin; k <= kMax; k++) {
            for (let j = jMin; j <= jMax; j++) {
              for (let i2 = iMin; i2 <= iMax; i2++) {
                const value = scalarData[k * zMultiple + j * yMultiple + i2];
                const valueMinusMean = value - mean;
                stdDev += valueMinusMean * valueMinusMean;
              }
            }
          }
          stdDev /= count;
          stdDev = Math.sqrt(stdDev);
          cachedStats[targetUID] = {
            Modality: metadata.Modality,
            area,
            mean,
            stdDev
          };
        } else {
          this.isHandleOutsideImage = true;
          cachedStats[targetUID] = {
            Modality: metadata.Modality
          };
        }
      }
      data.invalidated = false;
      const eventType = Events_default.ANNOTATION_MODIFIED;
      const eventDetail = {
        annotation,
        viewportUID,
        renderingEngineUID,
        sceneUID
      };
      triggerEvent(eventTarget_default, eventType, eventDetail);
      return cachedStats;
    };
    this._isInsideVolume = (index1, index2, dimensions) => {
      return utilities_exports.indexWithinDimensions(index1, dimensions) && utilities_exports.indexWithinDimensions(index2, dimensions);
    };
    this._getTargetVolumeUID = (scene) => {
      if (this.configuration.volumeUID) {
        return this.configuration.volumeUID;
      }
      const volumeActors = scene.getVolumeActors();
      if (!volumeActors && !volumeActors.length) {
        return;
      }
      return volumeActors[0].uid;
    };
    this._throttledCalculateCachedStats = throttle_default(this._calculateCachedStats, 100, { trailing: true });
  }
  cancel(element) {
    if (!this.isDrawing) {
      return;
    }
    this.isDrawing = false;
    this._deactivateDraw(element);
    this._deactivateModify(element);
    resetElementCursor(element);
    const { annotation, viewportUIDsToRender } = this.editData;
    const { data } = annotation;
    data.active = false;
    data.handles.activeHandleIndex = null;
    triggerAnnotationRenderForViewportIds_default(viewportUIDsToRender);
    this.editData = null;
    return annotation.metadata.annotationUID;
  }
  _getImageVolumeFromTargetUID(targetUID, renderingEngine) {
    let imageVolume, viewport;
    if (targetUID.startsWith("stackTarget")) {
      const coloneIndex = targetUID.indexOf(":");
      const viewportUID = targetUID.substring(coloneIndex + 1);
      const viewport2 = renderingEngine.getViewport(viewportUID);
      imageVolume = viewport2.getImageData();
    } else {
      imageVolume = cache_default.getVolume(targetUID);
    }
    return { imageVolume, viewport };
  }
  _getTargetStackUID(viewport) {
    return `stackTarget:${viewport.uid}`;
  }
};
VideoRedactionTool.toolName = "VideoRedaction";
var VideoRedactionTool_default = VideoRedactionTool;
export {
  AdvancedMagnifyTool,
  AngleTool_default as AngleTool,
  AnnotationDisplayTool_default as AnnotationDisplayTool,
  AnnotationTool_default as AnnotationTool,
  ArrowAnnotateTool_default as ArrowAnnotateTool,
  BaseTool_default as BaseTool,
  BidirectionalTool_default as BidirectionalTool,
  BrushTool_default as BrushTool,
  constants_exports2 as CONSTANTS,
  CircleROIStartEndThresholdTool_default as CircleROIStartEndThresholdTool,
  CircleROITool_default as CircleROITool,
  CircleScissorsTool_default as CircleScissorsTool,
  CobbAngleTool_default as CobbAngleTool,
  CrosshairsTool_default as CrosshairsTool,
  DragProbeTool_default as DragProbeTool,
  ETDRSGridTool_default as ETDRSGridTool,
  EllipticalROITool_default as EllipticalROITool,
  enums_exports2 as Enums,
  AnnotationEraserTool_default as EraserTool,
  HeightTool_default as HeightTool,
  KeyImageTool_default as KeyImageTool,
  LabelmapBaseTool,
  LengthTool_default as LengthTool,
  LivewireContourSegmentationTool_default as LivewireContourSegmentationTool,
  LivewireContourTool_default as LivewireContourTool,
  MIPJumpToClickTool_default as MIPJumpToClickTool,
  MagnifyTool_default as MagnifyTool,
  OrientationMarkerTool_default as OrientationMarkerTool,
  OverlayGridTool_default as OverlayGridTool,
  PaintFillTool_default as PaintFillTool,
  PanTool_default as PanTool,
  PlanarFreehandContourSegmentationTool_default as PlanarFreehandContourSegmentationTool,
  PlanarFreehandROITool_default as PlanarFreehandROITool,
  PlanarRotateTool_default as PlanarRotateTool,
  ProbeTool_default as ProbeTool,
  RectangleROIStartEndThresholdTool_default as RectangleROIStartEndThresholdTool,
  RectangleROIThresholdTool_default as RectangleROIThresholdTool,
  RectangleROITool_default as RectangleROITool,
  RectangleScissorsTool_default as RectangleScissorsTool,
  ReferenceCursors_default as ReferenceCursors,
  ReferenceLinesTool_default as ReferenceLinesTool,
  RegionSegmentPlusTool_default as RegionSegmentPlusTool,
  RegionSegmentTool_default as RegionSegmentTool,
  ScaleOverlayTool_default as ScaleOverlayTool,
  SculptorTool_default as SculptorTool,
  SegmentSelectTool_default as SegmentSelectTool,
  SegmentationIntersectionTool_default as SegmentationIntersectionTool,
  SphereScissorsTool_default as SphereScissorsTool,
  SplineContourSegmentationTool_default as SplineContourSegmentationTool,
  SplineROITool_default as SplineROITool,
  StackScrollTool_default as StackScrollTool,
  Synchronizer_default as Synchronizer,
  SynchronizerManager_exports as SynchronizerManager,
  ToolGroupManager_exports as ToolGroupManager,
  TrackballRotateTool_default as TrackballRotateTool,
  Types,
  UltrasoundDirectionalTool_default as UltrasoundDirectionalTool,
  VideoRedactionTool_default as VideoRedactionTool,
  VolumeRotateTool_default as VolumeRotateTool,
  WholeBodySegmentTool_default as WholeBodySegmentTool,
  WindowLevelRegionTool_default as WindowLevelRegionTool,
  WindowLevelTool_default as WindowLevelTool,
  ZoomTool_default as ZoomTool,
  addTool,
  annotation_exports as annotation,
  cancelActiveManipulations,
  cursors_exports as cursors,
  destroy4 as destroy,
  drawingSvg_exports as drawing,
  init,
  removeTool,
  segmentation_exports2 as segmentation,
  splines_exports as splines,
  state,
  synchronizers_exports as synchronizers,
  utilities_exports2 as utilities
};
/*! Bundled license information:

xmlbuilder2/lib/xmlbuilder2.min.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <http://feross.org>
   * @license  MIT
   *)
  (*! https://mths.be/punycode v1.4.1 by @mathias *)
*/
//# sourceMappingURL=@cornerstonejs_tools.js.map
