import StrategyCallbacks from '../../../../enums/StrategyCallbacks';
import VolumetricCalculator from '../../../../utilities/segmentation/VolumetricCalculator';
import { getActiveSegmentIndex } from '../../../../stateManagement/segmentation/getActiveSegmentIndex';
import { getStrategyData } from '../utils/getStrategyData';
import { utilities } from '@cornerstonejs/core';
import { getPixelValueUnits } from '../../../../utilities/getPixelValueUnits';
import { AnnotationTool } from '../../../base';
import { isViewportPreScaled } from '../../../../utilities/viewport/isViewportPreScaled';
const radiusForVol1 = Math.pow((3 * 1000) / (4 * Math.PI), 1 / 3);
export default {
    [StrategyCallbacks.GetStatistics]: function (enabledElement, operationData, options) {
        const { viewport } = enabledElement;
        let { indices } = options;
        const { segmentationId } = operationData;
        if (!indices) {
            indices = [getActiveSegmentIndex(segmentationId)];
        }
        else if (!Array.isArray(indices)) {
            indices = [indices, 255];
        }
        const indicesArr = indices;
        const { segmentationVoxelManager, imageVoxelManager, segmentationImageData, } = getStrategyData({
            operationData,
            viewport,
        });
        const spacing = segmentationImageData.getSpacing();
        const { boundsIJK: boundsOrig } = segmentationVoxelManager;
        if (!boundsOrig) {
            return VolumetricCalculator.getStatistics({ spacing });
        }
        segmentationVoxelManager.forEach((voxel) => {
            const { value, pointIJK } = voxel;
            if (indicesArr.indexOf(value) === -1) {
                return;
            }
            const imageValue = imageVoxelManager.getAtIJKPoint(pointIJK);
            VolumetricCalculator.statsCallback({ value: imageValue, pointIJK });
        });
        const targetId = viewport.getReferenceId();
        const modalityUnitOptions = {
            isPreScaled: isViewportPreScaled(viewport, targetId),
            isSuvScaled: AnnotationTool.isSuvScaled(viewport, targetId, viewport.getCurrentImageId()),
        };
        const imageData = viewport.getImageData();
        const unit = getPixelValueUnits(imageData.metadata.Modality, viewport.getCurrentImageId(), modalityUnitOptions);
        const stats = VolumetricCalculator.getStatistics({ spacing, unit });
        const { maxIJKs } = stats;
        if (!maxIJKs?.length) {
            return stats;
        }
        stats.mean.unit = unit;
        stats.max.unit = unit;
        stats.min.unit = unit;
        if (unit !== 'SUV') {
            return;
        }
        const radiusIJK = spacing.map((s) => Math.max(1, Math.round((1.1 * radiusForVol1) / s)));
        for (const testMax of maxIJKs) {
            const testStats = getSphereStats(testMax, radiusIJK, segmentationImageData, imageVoxelManager, spacing);
            if (!testStats) {
                continue;
            }
            const { mean } = testStats;
            if (!stats.peakValue || stats.peakValue.value <= mean.value) {
                stats.peakValue = {
                    name: 'peakValue',
                    label: 'Peak Value',
                    value: mean.value,
                    unit,
                };
            }
        }
        return stats;
    },
};
function getSphereStats(testMax, radiusIJK, segData, imageVoxels, spacing) {
    const { pointIJK: centerIJK } = testMax;
    const boundsIJK = centerIJK.map((ijk, idx) => [
        ijk - radiusIJK[idx],
        ijk + radiusIJK[idx],
    ]);
    const testFunction = (_pointLPS, pointIJK) => {
        const i = (pointIJK[0] - centerIJK[0]) / radiusIJK[0];
        const j = (pointIJK[1] - centerIJK[1]) / radiusIJK[1];
        const k = (pointIJK[2] - centerIJK[2]) / radiusIJK[2];
        const radius = i * i + j * j + k * k;
        return radius <= 1;
    };
    const statsFunction = ({ pointIJK, pointLPS }) => {
        const value = imageVoxels.getAtIJKPoint(pointIJK);
        if (value === undefined) {
            return;
        }
        VolumetricCalculator.statsCallback({ value, pointLPS, pointIJK });
    };
    VolumetricCalculator.statsInit({ storePointData: false });
    utilities.pointInShapeCallback(segData, {
        pointInShapeFn: testFunction,
        callback: statsFunction,
        boundsIJK,
    });
    return VolumetricCalculator.getStatistics({ spacing });
}
