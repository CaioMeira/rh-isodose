import type { IDynamicImageVolume, ImageVolumeProps, IStreamingVolumeProperties } from '../../types';
import BaseStreamingImageVolume from './BaseStreamingImageVolume';
export default class StreamingDynamicImageVolume extends BaseStreamingImageVolume implements IDynamicImageVolume {
    private _timePointIndex;
    private _splittingTag;
    private _imageIdGroups;
    private _loadedTimePoints;
    numTimePoints: number;
    constructor(imageVolumeProperties: ImageVolumeProps & {
        splittingTag: string;
        imageIdGroups: string[][];
    }, streamingProperties: IStreamingVolumeProperties);
    private _getImageIdsToLoad;
    private _getImageIdRequests;
    getImageIdsToLoad(): string[];
    get timePointIndex(): number;
    set timePointIndex(index: number);
    scroll(delta: number): void;
    getCurrentTimePointImageIds(): string[];
    flatImageIdIndexToTimePointIndex(flatImageIdIndex: number): number;
    flatImageIdIndexToImageIdIndex(flatImageIdIndex: number): number;
    get splittingTag(): string;
    getImageLoadRequests: (priority: number) => {
        callLoadImage: (imageId: any, imageIdIndex: any, options: any) => any;
        imageId: string;
        imageIdIndex: number;
        options: {
            targetBuffer: {
                type: import("../../types").PixelDataTypedArrayString;
                rows: any;
                columns: any;
            };
            allowFloatRendering: boolean;
            preScale: {
                enabled: boolean;
                scalingParameters: import("../../types").ScalingParameters;
            };
            transferPixelData: boolean;
            requestType: import("../../enums").RequestType;
            transferSyntaxUID: any;
            additionalDetails: {
                imageId: string;
                imageIdIndex: number;
                volumeId: string;
            };
        };
        priority: number;
        requestType: import("../../enums").RequestType;
        additionalDetails: {
            volumeId: string;
        };
    }[];
    isTimePointLoaded(timePointIndex: number): boolean;
    private markTimePointAsLoaded;
    protected checkTimePointCompletion(imageIdIndex: number): void;
}
